language: scala
name: HumanEval_72_will_it_fly
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        var halfValue = 0L\n        for (i <- q.indices)\
    \ {\n            if (i == q.length / 2) halfValue = q(i)\n            else if\
    \ (q(i) != q(q.length - 1 - i)) return false\n        }\n        q.sum - halfValue\
    \ <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821195
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        var flag = false\n        if (q.sum <= w) {\n\
    \            if (q.reverse == q) flag = true\n        }\n        flag\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821194
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        if(q.length == 1) return true\n        if(q.length\
    \ == 2) return q(0) == q(1)\n        if(q.length > 1) {\n            var m = Map[Long,\
    \ Long]()\n            for(x <- q) {\n                if(m.contains(x)) m(x) +=\
    \ 1\n                else m(x) = 1\n            }\n            var b = m.map(x\
    \ => x._2).toList.sorted\n            if(b.length == 1) return true\n        \
    \    else if(b.length == 2) {\n                if(b(0) == 1 && b(1) == 2) return\
    \ true\n                else return false\n            }\n            else return\
    \ false\n        }\n        else return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdib2kyiw.scala:38)\n\tat Problem.main(tmpdib2kyiw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821195
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        def isBalanced(q : List[Long]) : Boolean =\
    \ {\n            def helper(q : List[Long], acc : List[Long]) : Boolean = {\n\
    \                if (q.isEmpty) acc.isEmpty\n                else if (q.head !=\
    \ acc.head) false\n                else helper(q.tail, acc.tail)\n           \
    \ }\n            helper(q, q.reverse)\n        }\n        q.sum <= w && isBalanced(q)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821194
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        if (q.length <= 1) return true\n        if\
    \ (q.sum <= w) {\n            var first = q.head\n            var last = q.last\n\
    \            for (i <- 0 until q.length/2) {\n                if (first != last)\
    \ return false\n                first = q(i + 1)\n                last = q(q.length\
    \ - i - 2)\n            }\n            return true\n        }\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821195
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        q.sum <= w && q == q.reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821194
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        def isPalindrome(q : List[Long]) : Boolean\
    \ = q == q.reverse\n        if (q.sum <= w && isPalindrome(q)) true else false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821194
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val sum = q.sum\n        val rev = q.reverse\n\
    \        sum <= w && q == rev\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821195
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        var b = true\n        if (q.sum > w) b = false\n\
    \        else {\n            var list = q.sortWith(_ < _)\n            var reversed\
    \ = list.reverse\n            if (list != reversed) b = false\n        }\n   \
    \     b\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr_hxu9vt.scala:26)\n\tat Problem.main(tmpr_hxu9vt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821194
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        return q.sum <= w && q == q.reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821194
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val sum = q.sum\n        val palindrome = q.reverse\
    \ == q\n        palindrome && sum <= w\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821194
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        if (q.length % 2 == 0) return false\n     \
    \   var l = q.length\n        for (i <- 0 until l / 2) {\n            if (q(i)\
    \ != q(l - i - 1)) return false\n        }\n        if (q.sum <= w) return true\n\
    \        false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821195
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val sum = q.sum\n        if (sum > w) return\
    \ false\n        val m = q.max\n        if (m * 2 > w) return false\n        val\
    \ list = Array.fill(2 * m.toInt + 1)(false)\n        q.foreach(e => list(e.toInt)\
    \ = true)\n        for (i <- q.indices) {\n            val e = q(i)\n        \
    \    if (list(w.toInt - e.toInt)) return true\n        }\n        false\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 7 out of bounds for length\
    \ 7\n\tat Problem$.willItFly$$anonfun$2(tmpqdgdn04d.scala:24)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.willItFly(tmpqdgdn04d.scala:25)\n\
    \tat Problem$.main(tmpqdgdn04d.scala:29)\n\tat Problem.main(tmpqdgdn04d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821195
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        var sum = 0L\n        for (i <- q) sum += i\n\
    \        if (sum > w) return false\n        if (q.isEmpty) return true\n     \
    \   return q == q.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821194
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        def isBalanced(q : List[Long]) : Boolean =\
    \ {\n            def recurse(q : List[Long], front : List[Long]) : Boolean = {\n\
    \                if (q.length == 0) true\n                else if (q.head == front.head)\
    \ recurse(q.tail, front.tail)\n                else false\n            }\n   \
    \         recurse(q, q.reverse)\n        }\n        if (q.length == 0) true\n\
    \        else if (q.sum <= w && isBalanced(q)) true\n        else false\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821194
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        q == q.reverse && q.reduce(_ + _) <= w\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821194
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val sum = q.sum\n        val limit = w - sum\n\
    \        q.size match {\n            case 1 => true\n            case 2 => q(0)\
    \ == q(1)\n            case _ => {\n                val half = q.size / 2\n  \
    \              val lower = q.slice(0, half)\n                val upper = if (q.size\
    \ % 2 == 0) q.slice(half, q.size) else q.slice(half + 1, q.size)\n           \
    \     val lowerSum = lower.sum\n                val upperSum = upper.sum\n   \
    \             val lowerUpperSum = lowerSum + upperSum\n                val lowerUpperLimit\
    \ = limit - lowerSum\n                val lowerUpperLimitNonZero = lowerUpperLimit\
    \ != 0\n                val rightUpperSum = lowerUpperSum + lowerUpperLimit\n\
    \                if (rightUpperSum > upperSum) false\n                else if\
    \ (rightUpperSum == upperSum) lowerUpperLimitNonZero\n                else if\
    \ (rightUpperSum + lowerUpperLimit == upperSum) lowerUpperLimitNonZero\n     \
    \           else if (rightUpperSum + 2 * lowerUpperLimit == upperSum) lowerUpperLimitNonZero\n\
    \                else true\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu2z05bgv.scala:40)\n\tat Problem.main(tmpu2z05bgv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821194
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n    \tvar temp = true\n    \tvar sum = 0L\n    \tfor\
    \ (i <- q) {\n    \t\tsum += i\n    \t}\n    \tif (sum > w) temp = false\n   \
    \ \tif (q.length == 1) return temp\n    \tfor (i <- 0 until q.length / 2) {\n\
    \    \t\tif (q(i) != q(q.length - 1 - i)) temp = false\n    \t}\n    \treturn\
    \ temp\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821194
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val s = q.sum\n        val isBalanced = q ==\
    \ q.reverse\n        s <= w && isBalanced\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821194
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        if (q.length <= 1) return true\n        var\
    \ flag = false\n        for (i <- 0 until q.length / 2) if (q(i) != q(q.length\
    \ - 1 - i)) flag = true\n        if (flag) return false\n        var sum = 0L\n\
    \        for (i <- q) sum += i\n        return sum <= w\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821195
