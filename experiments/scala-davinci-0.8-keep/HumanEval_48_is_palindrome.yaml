name: HumanEval_48_is_palindrome
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Checks if given string is a palindrome\n    // >>> is_palindrome('')\n \
  \   // True\n    // >>> is_palindrome('aba')\n    // True\n    // >>> is_palindrome('aaaaa')\n\
  \    // True\n    // >>> is_palindrome('zbcd')\n    // False\n    def isPalindrome(text\
  \ : String) : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(isPalindrome((\"\"\
  )) == (true));\n    assert(isPalindrome((\"aba\")) == (true));\n    assert(isPalindrome((\"\
  aaaaa\")) == (true));\n    assert(isPalindrome((\"zbcd\")) == (false));\n    assert(isPalindrome((\"\
  xywyx\")) == (true));\n    assert(isPalindrome((\"xywyz\")) == (false));\n    assert(isPalindrome((\"\
  xywzx\")) == (false));\n    }\n\n}\n"
completions: ["        if (text.size == 0) return true\n        val size = text.size\n\
    \        for (i <- 0 until size/2) {\n            if (text(i) != text(size - i\
    \ - 1)) return false\n        }\n        return true", '        return text ==
    text.reverse', "        val reversed = text.reverse\n        return text == reversed",
  '        return text == text.reverse', "        if (text.length == 0) return true\n\
    \        val mid = text.length / 2\n        for (i <- 0 until mid) {\n       \
    \     if (text(i) != text(text.length - i - 1)) return false\n        }\n    \
    \    return true", "        val length = text.length\n        val half = length\
    \ / 2\n        for (i <- 0 until half) {\n            if (text(i) != text(length\
    \ - i - 1)) {\n                return false\n            }\n        }\n      \
    \  return true", "        val center = (text.length / 2) - 1\n        (0 to center).forall(i\
    \ => text(i) == text(text.length - i - 1))", "        if (text.length <= 1)\n\
    \            return true\n        val front = text.substring(0, 1)\n        val\
    \ back = text.substring(text.length - 1, text.length)\n        if (front != back)\n\
    \            return false\n        isPalindrome(text.substring(1, text.length\
    \ - 1))", "        var low = 0\n        var high = text.length - 1\n        while\
    \ (low < high) {\n            if (text(low) != text(high)) return false\n    \
    \        low += 1\n            high -= 1\n        }\n        return true", '        text
    == text.reverse', "        if (text.length == 0)\n            return true\n  \
    \      var i = 0\n        var j = text.length - 1\n        while (i < j) {\n \
    \           if (text(i) != text(j))\n                return false\n          \
    \  i += 1\n            j -= 1\n        }\n        return true", "        val firstHalf\
    \ = text.slice(0, ceil(text.length / 2.0).toInt)\n        val secondHalf = text.slice(floor(text.length\
    \ / 2.0).toInt, text.length)\n        return firstHalf == secondHalf.reverse",
  "        if (text.length() < 2) return true\n        else if (text.charAt(0) !=\
    \ text.charAt(text.length() - 1)) return false\n        else return isPalindrome(text.substring(1,\
    \ text.length() - 1))", '        text == text.reverse', "        for (i <- 0 until\
    \ text.length / 2) {\n            if (text(i) != text(text.length - i - 1)) return\
    \ false\n        }\n        return true", "        if (text.length <= 1) {\n \
    \           return true\n        }\n        return text(0) == text(text.length\
    \ - 1) && isPalindrome(text.substring(1, text.length - 1))", "        if (text.length\
    \ == 0)\n            return true\n        var i = 0\n        var j = text.length\
    \ - 1\n        while (i < j) {\n            if (text(i) != text(j))\n        \
    \        return false\n            i += 1\n            j -= 1\n        }\n   \
    \     return true", "        val length = text.length\n        if (length <= 1)\
    \ return true\n        val first = text.charAt(0)\n        val last = text.charAt(length\
    \ - 1)\n        if (first != last) return false\n        return isPalindrome(text.substring(1,\
    \ length - 1))", "        val len = text.length\n        val half = len / 2\n\
    \        var i = 0\n        while (i < half) {\n            if (text(i) != text(len\
    \ - i - 1)) return false\n            i += 1\n        }\n        return true",
  "        val reversed = text.reverse\n        return text == reversed"]
stop_tokens:
- "\n    }\n"
