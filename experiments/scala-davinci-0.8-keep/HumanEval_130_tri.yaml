name: HumanEval_130_tri
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
  \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
  \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    // tri(1)\
  \ = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n - 1) + tri(n\
  \ - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2) = 1 + (2 /\
  \ 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n    // =\
  \ 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n, you have\
  \ to a return a list of the \n    // first n + 1 numbers of the Tribonacci sequence.\n\
  \    // Examples:\n    // tri(3) = [1, 3, 2, 8]\n    def tri(n : Long) : List[Long]\
  \ = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
  \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
  \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
  \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
  \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n    assert(tri((7l)).equals((List[Long](1l.toLong,\
  \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n\
  \    assert(tri((8l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
  \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong,\
  \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
  \ 5l.toLong, 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong,\
  \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
  \ 5l.toLong, 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong,\
  \ 80l.toLong, 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n\
  \    assert(tri((0l)).equals((List[Long](1l.toLong))));\n    assert(tri((1l)).equals((List[Long](1l.toLong,\
  \ 3l.toLong))));\n    }\n\n}\n"
completions: ["        def tri_help(n : Long, result : List[Long]) : List[Long] =\
    \ {\n            if (n == 1) result\n            else {\n                val l\
    \ = result.length\n                tri_help(n - 1, result :+ (if (n % 2 == 0)\
    \ n / 2 else result(l - 1) + result(l - 2) + result(l - 3)))\n            }\n\
    \        }\n        tri_help(n, List(1))", "        val buffer = new ArrayBuffer[Long]\n\
    \        buffer += 1\n        buffer += 3\n        buffer += 2\n        var i\
    \ = 0\n        while (i < n) {\n            val num = buffer(i)\n            if\
    \ (num % 2 == 0) {\n                buffer += (1 + num / 2)\n            } else\
    \ {\n                buffer += (buffer(i - 1) + buffer(i - 2) + buffer(i + 1))\n\
    \            }\n            i += 1\n        }\n        buffer.toList", "     \
    \   if (n == 0) return List(1)\n        val t = new Array[Long](n.toInt + 1)\n\
    \        t(0) = 1\n        t(1) = 3\n        t(2) = 2\n        for (i <- 3 to\
    \ n.toInt) {\n            if (i % 2 == 0) t(i) = 1 + i / 2\n            else t(i)\
    \ = t(i - 1) + t(i - 2) + t(i + 1)\n        }\n        t.toList", "        def\
    \ solve(n : Long, cache : List[Long]) : List[Long] = {\n            if (n == 0)\
    \ {\n                cache\n            } else {\n                val t = if (n\
    \ % 2 == 0) (1 + n / 2) else (cache(0) + cache(1) + cache(2))\n              \
    \  solve(n - 1, t :: cache)\n            }\n        }\n        solve(n, List(3,\
    \ 1, 2)).reverse", "        // tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1),\
    \ if n is odd.\n        // tri(n - 1) = tri(n - 2) + tri(n - 3) + tri(n)\n   \
    \     // tri(n) = tri(n - 1) + tri(n - 2) + tri(n - 3) + tri(n - 2) + tri(n -\
    \ 3) + tri(n - 1)\n        // = 2 * tri(n - 1) + tri(n - 3)\n        val m = n\
    \ + 1\n        val a = Array.fill(m.toInt)(0L)\n        a(0) = 1\n        a(1)\
    \ = 3\n        a(2) = 2\n        for (i <- 3 to m.toInt - 1) {\n            a(i)\
    \ = 2 * a(i - 1) + a(i - 3)\n        }\n        a.toList", "        def triImpl(i\
    \ : Long, a : Long, b : Long, c : Long) : List[Long] = {\n            if (i ==\
    \ n) List(a, b, c)\n            else if (i % 2 == 0) triImpl(i + 1, b, c, 1 +\
    \ i / 2)\n            else triImpl(i + 1, b, c, a + b + c)\n        }\n      \
    \  triImpl(1, 1, 3, 2)", "        val a : Array[Long] = Array(1, 3, 2)\n     \
    \   def f(n : Long) : List[Long] = {\n            if (n == 1) return List(a(0))\n\
    \            else if (n == 2) return List(a(0), a(1))\n            else if (n\
    \ == 3) return List(a(0), a(1), a(2))\n            else {\n                for\
    \ (i <- 4 to n.toInt) {\n                    if (i % 2 == 0) a(2) = 1 + i / 2\n\
    \                    else a(2) = a(0) + a(1) + a(2)\n                    a(0)\
    \ = a(1)\n                    a(1) = a(2)\n                }\n               \
    \ return a.toList\n            }\n        }\n        return f(n)", "    \tif (n\
    \ == 0) List(1)\n    \telse {\n    \t\tval result = new ListBuffer[Long]\n   \
    \ \t\tresult += 1\n    \t\tresult += 3\n    \t\tresult += 2\n    \t\tvar i = 2\n\
    \    \t\twhile (i < n) {\n    \t\t\tval k = result(i)\n    \t\t\tval j = result(i\
    \ - 1)\n    \t\t\tval l = result(i - 2)\n    \t\t\tresult += (k + j + l)\n   \
    \ \t\t\ti += 1\n    \t\t}\n    \t\tresult.toList\n    \t}", "        val cache\
    \ = new HashMap[Long, Long]()\n        def tri(n : Long) : Long = {\n        \
    \    if (n == 1) 3\n            else if (n == 2) 2\n            else if (n ==\
    \ 3) 8\n            else if (cache.contains(n)) cache(n)\n            else {\n\
    \                val result = if (n % 2 == 0) 1 + n / 2 else tri(n - 1) + tri(n\
    \ - 2) + tri(n + 1)\n                cache(n) = result\n                result\n\
    \            }\n        }\n        (1 to n + 1).map(tri).toList", "    \tval s\
    \ = new Queue[Long]\n    \ts += 1\n    \tif (n > 0) s += 3\n    \tif (n > 1) s\
    \ += 2\n    \tif (n > 2) for (i <- 3 to n) s += s(i - 3) + s(i - 2) + s(i - 1)\n\
    \    \ts.toList", "        val memo = new HashMap[Long, Long]\n        memo(1)\
    \ = 3\n        memo(2) = 2\n        memo(3) = 8\n        def compute(n : Long)\
    \ : Long = {\n            if (memo.contains(n)) memo(n)\n            else {\n\
    \                val result = if (n % 2 == 0) (1 + n / 2) else (compute(n - 1)\
    \ + compute(n - 2) + compute(n + 1))\n                memo(n) = result\n     \
    \           result\n            }\n        }\n        List.range(1, n + 2).map(compute(_))",
  "        val a = Array.fill(n.toInt + 1)(0)\n        a(0) = 1\n        a(1) = 3\n\
    \        a(2) = 2\n        for (i <- 3 to n.toInt) {\n            a(i) = if (i\
    \ % 2 == 0) a(i - 1) + a(i - 2) + a(i + 1) else (1 + i / 2)\n        }\n     \
    \   a.toList", "    \tif (n == 0) return List(1)\n    \tif (n == 1) return List(1,\
    \ 3)\n    \tif (n == 2) return List(1, 3, 2)\n    \tvar res = List(1, 3, 2)\n\
    \    \tvar i = 3\n    \twhile (i <= n) {\n    \t\tif (i % 2 == 0) res = res :+\
    \ (1 + i / 2)\n    \t\telse res = res :+ (res(i - 1) + res(i - 2) + res(i + 1))\n\
    \    \t\ti += 1\n    \t}\n    \tres", "        if (n == 0) return List(1)\n  \
    \      val cache = new Array[Long](n.toInt + 1)\n        cache(0) = 1\n      \
    \  cache(1) = 3\n        cache(2) = 2\n        for (i <- 3 to n.toInt) {\n   \
    \         if (i % 2 == 0) cache(i) = 1 + i / 2\n            else cache(i) = cache(i\
    \ - 1) + cache(i - 2) + cache(i + 1)\n        }\n        return cache.toList",
  "        var map = Map[Long, Long]()\n        map(1) = 3\n        def loop(i : Long)\
    \ : Long = {\n            if (map.contains(i)) map(i)\n            else {\n  \
    \              val result = if (i % 2 == 0) 1 + i / 2 else loop(i - 1) + loop(i\
    \ - 2) + loop(i + 1)\n                map(i) = result\n                result\n\
    \            }\n        }\n        List.range(1, n + 2).map(loop(_))", "     \
    \   var memo = new HashMap[Long, Long]\n        memo(1) = 3\n        memo(2) =\
    \ 2\n        for (i <- 3 to n) {\n            if (i % 2 == 0) memo(i) = 1 + i\
    \ / 2\n            else memo(i) = memo(i - 1) + memo(i - 2) + memo(i + 1)\n  \
    \      }\n        List(1) ++ (for (i <- 0 to n.toInt) yield memo(i)).toList",
  "        val cache = new HashMap[Long, Long]\n        cache += 1 -> 3\n        def\
    \ triHelper(index : Long) : Long = cache.get(index) match {\n            case\
    \ Some(value) => value\n            case None => {\n                val value\
    \ = if (index % 2 == 0) index / 2 + 1 else triHelper(index - 1) + triHelper(index\
    \ - 2) + triHelper(index + 1)\n                cache += index -> value\n     \
    \           value\n            }\n        }\n        (1 to n + 1).map(x => triHelper(x)).toList",
  "        var result = List[Long]()\n        var a = 1\n        var b = 3\n     \
    \   var c = 2\n        result = result :+ 1\n        if (n > 0) {\n          \
    \  result = result :+ 3\n            if (n > 1) {\n                result = result\
    \ :+ 2\n                if (n > 2) {\n                    for (i <- 3 to n.toInt)\
    \ {\n                        if (i % 2 == 0) {\n                            var\
    \ d = a + 1 + i / 2\n                            result = result :+ d\n      \
    \                      a = b\n                            b = c\n            \
    \                c = d\n                        } else {\n                   \
    \         var d = a + b + c\n                            result = result :+ d\n\
    \                            a = b\n                            b = c\n      \
    \                      c = d\n                        }\n                    }\n\
    \                }\n            }\n        }\n        return result", "      \
    \  var result = ListBuffer[Long]()\n        if (n <= 1) {\n            result\
    \ += 1\n            result += 2\n            result += 3\n        } else {\n \
    \           var a = 1L\n            var b = 2L\n            var c = 3L\n     \
    \       result += a\n            result += b\n            result += c\n      \
    \      for (i <- 3L to n) {\n                val newnum = if (i % 2 == 0) 1 +\
    \ i / 2 else a + b + c\n                result += newnum\n                a =\
    \ b\n                b = c\n                c = newnum\n            }\n      \
    \  }\n        result.toList", "        val a = Array.fill(n.toInt + 1)(0L)\n \
    \       a(0) = 1\n        a(1) = 3\n        for (i <- 2 to n.toInt) {\n      \
    \      a(i) = if (i % 2 == 0) 1 + i / 2\n            else a(i - 1) + a(i - 2)\
    \ + a(i + 1)\n        }\n        a.toList"]
stop_tokens:
- "\n    }\n"
