name: HumanEval_149_sorted_list_sum
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function that accepts a list of strings as a parameter,\n    //\
  \ deletes the strings that have odd lengths from it,\n    // and returns the resulted\
  \ list with a sorted order,\n    // The list is always a list of strings and never\
  \ an array of numbers,\n    // and it may contain duplicates.\n    // The order\
  \ of the list should be ascending by length of each word, and you\n    // should\
  \ return the list sorted by that rule.\n    // If two words have the same length,\
  \ sort the list alphabetically.\n    // The function should return a list of strings\
  \ in sorted order.\n    // You may assume that all words will have the same length.\n\
  \    // For example:\n    // assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"\
  ]\n    // assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"\
  ]\n    def sortedListSum(lst : List[String]) : List[String] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(sortedListSum((List[String](\"\
  aa\", \"a\", \"aaa\"))).equals((List[String](\"aa\"))));\n    assert(sortedListSum((List[String](\"\
  school\", \"AI\", \"asdf\", \"b\"))).equals((List[String](\"AI\", \"asdf\", \"school\"\
  ))));\n    assert(sortedListSum((List[String](\"d\", \"b\", \"c\", \"a\"))).equals((List[String]())));\n\
  \    assert(sortedListSum((List[String](\"d\", \"dcba\", \"abcd\", \"a\"))).equals((List[String](\"\
  abcd\", \"dcba\"))));\n    assert(sortedListSum((List[String](\"AI\", \"ai\", \"\
  au\"))).equals((List[String](\"AI\", \"ai\", \"au\"))));\n    assert(sortedListSum((List[String](\"\
  a\", \"b\", \"b\", \"c\", \"c\", \"a\"))).equals((List[String]())));\n    assert(sortedListSum((List[String](\"\
  aaaa\", \"bbbb\", \"dd\", \"cc\"))).equals((List[String](\"cc\", \"dd\", \"aaaa\"\
  , \"bbbb\"))));\n    }\n\n}\n"
completions: ["        val lst2 = lst.toSet\n        def fn(s : String) : Boolean\
    \ = {\n            if (s.length % 2 == 0) {\n                true\n          \
    \  } else {\n                false\n            }\n        }\n        val lst3\
    \ = lst2.filter(fn).toList\n        val lst4 = lst3.sortWith(_.length < _.length)\n\
    \        lst4", "        val l = new ListBuffer[String]\n        val s = new ListBuffer[String]\n\
    \        var pre = \"\"\n        for (i <- lst) {\n            if (i.length %\
    \ 2 == 0) l += i\n            else s += i\n        }\n        for (j <- l) {\n\
    \            for (k <- s) {\n                if (j.length == k.length) pre = j\n\
    \            }\n        }\n        l.distinct.sorted.filter(_ != pre)", "    \
    \    val map = HashMap[Int, List[String]]()\n        for (str <- lst) {\n    \
    \        if (map.contains(str.length)) {\n                map(str.length) = str\
    \ :: map(str.length)\n            } else {\n                map(str.length) =\
    \ List(str)\n            }\n        }\n        val keys = map.keys.toList.sorted\n\
    \        var result = List[String]()\n        for (key <- keys) {\n          \
    \  for (str <- map(key).sorted) {\n                result = str :: result\n  \
    \          }\n        }\n        result", "    \tvar s = Set[String]()\n    \t\
    for (i <- lst) {\n    \t\tval len = i.length\n    \t\tif (len % 2 == 0) s += i\n\
    \    \t}\n    \ts.toList.sortWith((x, y) => x.length <= y.length && x < y)", " \
    \       var lst_length = lst.length\n        for (i <- 0 until lst_length) {\n\
    \            for (j <- i + 1 until lst_length) {\n                if (lst(i).length\
    \ > lst(j).length) {\n                    val temp = lst(i)\n                \
    \    lst(i) = lst(j)\n                    lst(j) = temp\n                }\n \
    \           }\n        }\n        lst", "        val dict = HashMap[Int, List[String]]()\n\
    \        lst.foreach(\n            (word : String) => {\n                val len\
    \ = word.length\n                val curr = dict.getOrElse(len, List())\n    \
    \            dict.put(len, curr :+ word)\n            }\n        )\n        dict.keySet.toList.sorted.flatMap(\n\
    \            (k : Int) => {\n                dict(k).sorted\n            }\n \
    \       )", "        val res : ListBuffer[String] = new ListBuffer[String]\n \
    \       var sorted = lst.sortWith(_ < _)\n        sorted.foreach(x => if (x.length\
    \ % 2 == 0) res += x)\n        res.toList", "        val evenLenList = for(s <-\
    \ lst if s.length % 2 == 0) yield s\n        evenLenList.sorted", '        return
    lst.filter(_.length % 2 == 0).sorted', "    \t//val rst = \n    \tlst.filter(s\
    \ => s.length % 2 == 0).sorted", "        var sum = 0\n        for (s <- lst)\
    \ sum += s.length\n        List(sum.toString)", "        val lst2 = lst.groupBy(s\
    \ => s.length).map(l => l._2.sorted).toList.sortBy(l => l.head.length)\n     \
    \   lst2.flatMap(l => l)", "        var keys : List[Int] = lst.map(x => x.length).distinct.sorted\n\
    \        var m : Map[Int, List[String]] = Map()\n        for (k <- keys) m(k)\
    \ = lst.filter(x => x.length == k).sorted\n        keys.map(x => m(x).head)",
  "        def isEven(n : Int) : Boolean = n % 2 == 0\n        return lst.filter(isEven(_)).sortWith(_.length\
    \ < _.length)", '        lst.distinct.sortWith((a, b) => a.length < b.length)',
  '        lst.sortWith((x, y) => x.length < y.length)', '        lst.filter(x =>
    x.length % 2 == 0).sortWith((x, y) => if (x.length == y.length) x < y else x.length
    < y.length)', '        lst.toSet.toList.sorted', "        var hash = HashMap[Int,\
    \ List[String]]()\n        for (s <- lst) {\n            val len = s.length\n\
    \            if (hash.contains(len)) {\n                val l = hash(len)\n  \
    \              hash(len) = s :: l\n            } else {\n                hash(len)\
    \ = List(s)\n            }\n        }\n        var result = List[String]()\n \
    \       for (k <- hash.keys.toList.sorted) {\n            val l = hash(k)\n  \
    \          val sl = l.sorted\n            result = result ::: sl\n        }\n\
    \        result", "        def sum(s1 : String, s2 : String) : String = {\n  \
    \          s1 + s2\n        }\n        lst.sortWith(_.length < _.length).foldLeft(List.empty[String])((acc,\
    \ str) => sum(acc.headOption.getOrElse(\"\"), str) :: acc).reverse"]
stop_tokens:
- "\n    }\n"
