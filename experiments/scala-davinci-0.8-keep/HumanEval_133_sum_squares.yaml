name: HumanEval_133_sum_squares
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a list of numbers.\n    // You need to return the sum of squared\
  \ numbers in the given list,\n    // round each element in the list to the upper\
  \ int(Ceiling) first.\n    // Examples:\n    // For lst = [1,2,3] the output should\
  \ be 14\n    // For lst = [1,4,9] the output should be 98\n    // For lst = [1,3,5,7]\
  \ the output should be 84\n    // For lst = [1.4,4.2,0] the output should be 29\n\
  \    // For lst = [-2.4,1,1] the output should be 6\n    def sumSquares(lst : List[Float])\
  \ : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(sumSquares((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat))) == (14l));\n    assert(sumSquares((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat))) == (14l));\n    assert(sumSquares((List[Float](1.0f.toFloat,\
  \ 3.0f.toFloat, 5.0f.toFloat, 7.0f.toFloat))) == (84l));\n    assert(sumSquares((List[Float](1.4f.toFloat,\
  \ 4.2f.toFloat, 0.0f.toFloat))) == (29l));\n    assert(sumSquares((List[Float](-2.4f.toFloat,\
  \ 1.0f.toFloat, 1.0f.toFloat))) == (6l));\n    assert(sumSquares((List[Float](100.0f.toFloat,\
  \ 1.0f.toFloat, 15.0f.toFloat, 2.0f.toFloat))) == (10230l));\n    assert(sumSquares((List[Float](10000.0f.toFloat,\
  \ 10000.0f.toFloat))) == (200000000l));\n    assert(sumSquares((List[Float](-1.4f.toFloat,\
  \ 4.6f.toFloat, 6.3f.toFloat))) == (75l));\n    assert(sumSquares((List[Float](-1.4f.toFloat,\
  \ 17.9f.toFloat, 18.9f.toFloat, 19.9f.toFloat))) == (1086l));\n    assert(sumSquares((List[Float](0.0f.toFloat)))\
  \ == (0l));\n    assert(sumSquares((List[Float](-1.0f.toFloat))) == (1l));\n   \
  \ assert(sumSquares((List[Float](-1.0f.toFloat, 1.0f.toFloat, 0.0f.toFloat))) ==\
  \ (2l));\n    }\n\n}\n"
completions: ['        lst.map(i => math.ceil(i).toLong).map(i => i * i).sum', '        return
    lst.map(Math.ceil(_).toInt).map(x => x * x).sum.toLong', '        return lst.map(ceil(_).toLong).map(x
    => x * x).sum', '      lst.map(ceil(_).toLong).map(x => x * x).sum', '        lst.map(x
    => ceil(x).toLong).map(x => x * x).sum', '        return lst.map(ceil(_).toLong).map(x
    => x * x).sum', '        lst.map(x => math.ceil(x).toLong).map(x => x * x).sum',
  "        var result : Long = 0\n        for (n <- lst) {\n            val r = ceil(n).toInt\n\
    \            val r2 = r * r\n            result += r2\n        }\n        return\
    \ result", '        lst.map(x => pow(ceil(x).toLong, 2).toLong).sum', '        return
    lst.map(e => ceil(e).toLong).map(e => e * e).sum', '        return lst.map(x =>
    ceil(x).toLong).map(x => x * x).sum', "        var sum = 0.0\n        for (num\
    \ <- lst) {\n            sum += pow(ceil(num).toInt, 2)\n        }\n        sum.toLong",
  '        lst.map(f => ceil(f).toLong).map(f => f * f).sum', "        val result\
    \ = for (x <- lst) yield {\n            ceil(x).toLong * ceil(x).toLong\n    \
    \    }\n        result.sum", "        // your code here\n        val lst2 = lst.map(p\
    \ => ceil(p).toInt)\n        lst2.map(p => p * p).sum", "    \t// Fill up this\
    \ function body\n        // You can add another function as well, if required\n\
    \    \t// Make sure to round the number (Ceiling) before summing up\n    \tval\
    \ squareList = lst.map((x) => (math.ceil(x)).toInt).map((x) => x*x)\n    \tsquareList.sum",
  '        return 0', '        return lst.map((x) => ceil(x).toLong * ceil(x).toLong).sum',
  '      lst.map(x => ceil(x).toLong).map(x => x * x).sum', '        return 0']
stop_tokens:
- "\n    }\n"
