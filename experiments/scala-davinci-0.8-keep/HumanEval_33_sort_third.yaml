name: HumanEval_33_sort_third
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // This function takes a list l and returns a list l' such that\n    // l'\
  \ is identical to l in the indicies that are not divisible by three, while its values\
  \ at the indicies that are divisible by three are equal\n    // to the values of\
  \ the corresponding indicies of l, but sorted.\n    // >>> sort_third([1, 2, 3])\n\
  \    // [1, 2, 3]\n    // >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    // [2, 6, 3,\
  \ 4, 8, 9, 5]\n    def sortThird(l : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(sortThird((List[Long](5l.toLong,\
  \ 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong))).equals((List[Long](2l.toLong,\
  \ 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong))));\n    assert(sortThird((List[Long](5l.toLong,\
  \ 8l.toLong, 3l.toLong, 4l.toLong, 6l.toLong, 9l.toLong, 2l.toLong))).equals((List[Long](2l.toLong,\
  \ 8l.toLong, 3l.toLong, 4l.toLong, 6l.toLong, 9l.toLong, 5l.toLong))));\n    assert(sortThird((List[Long](5l.toLong,\
  \ 6l.toLong, 9l.toLong, 4l.toLong, 8l.toLong, 3l.toLong, 2l.toLong))).equals((List[Long](2l.toLong,\
  \ 6l.toLong, 9l.toLong, 4l.toLong, 8l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortThird((List[Long](5l.toLong,\
  \ 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](2l.toLong,\
  \ 6l.toLong, 3l.toLong, 4l.toLong, 8l.toLong, 9l.toLong, 5l.toLong, 1l.toLong))));\n\
  \    }\n\n}\n"
completions: ["        def sortThirdRec(remaining : List[Long], acc : List[Long])\
    \ : List[Long] = {\n            if (remaining.length == 0) acc\n            else\
    \ {\n                if (remaining.length % 3 == 0) sortThirdRec(remaining.tail,\
    \ acc ++ List(remaining.tail.take(2).sorted.head))\n                else sortThirdRec(remaining.tail,\
    \ acc ++ List(remaining.head))\n            }\n        }\n        sortThirdRec(l,\
    \ List())", "        var result = l\n        for (i <- l.indices.filter(_ % 3\
    \ == 0)) {\n            val temp = l(i)\n            result = result.updated(i,\
    \ l.slice(i, i + 3).sorted.head)\n        }\n        result", "        if (l.length\
    \ < 2) return l\n        val (a, b) = l.splitAt(l.length / 3)\n        val sorted\
    \ = b.sortWith(_ < _)\n        (a ::: sorted) ::: sortThird(l.drop(l.length /\
    \ 3 + l.length % 3))", "        val l1 = l.zipWithIndex.filter(t => t._2 % 3 ==\
    \ 0).map(t => t._1).sorted\n        l.zipWithIndex.map(t => if (t._2 % 3 == 0)\
    \ l1(t._2 / 3) else t._1)", "      for(i <- 0 until l.length by 3) {\n       \
    \ val subList = l.slice(i, i + 3)\n        l.insertAll(i, subList.sorted)\n  \
    \      l.take(i + 3)\n        l.drop(i + 3)\n      }\n      l", "        var lNew\
    \ = new ListBuffer[Long]()\n        for (i <- 0 until l.length) {\n          \
    \  if (i % 3 == 0) {\n                val list = l.drop(i).take(3).sortWith(_\
    \ < _)\n                lNew += list(0)\n                lNew += list(1)\n   \
    \             lNew += list(2)\n            } else {\n                lNew += l(i)\n\
    \            }\n        }\n        lNew.toList", "    \tval (head, tail) = l.splitAt(3)\n\
    \    \tval tailSorted = sortThird(tail)\n    \thead match {\n    \t\tcase x ::\
    \ y :: z :: Nil => (List(x, y, z).sorted ::: tailSorted)\n    \t\tcase _ => head\
    \ ::: tailSorted\n    \t}", "        val n = l.length;\n        if (n == 0) return\
    \ l;\n        val m = n % 3;\n        val k = n / 3;\n        val a = l.slice(0,\
    \ m);\n        val b = l.slice(m, m + k).sortWith(_ < _);\n        val c = l.slice(m\
    \ + k, n).sortWith(_ < _);\n        val d = b ++ c;\n        return a ++ d;",
  "        var newl = new ListBuffer[Long]\n        var i = 0\n        while (i <\
    \ l.length) {\n            if (i % 3 == 0) {\n                newl += l.slice(i,\
    \ i + 3).sortWith(_ < _)(1)\n                i += 3\n            } else {\n  \
    \              newl += l(i)\n                i += 1\n            }\n        }\n\
    \        newl.toList", "        val (sorted, unsorted) = l.zipWithIndex.filter(_._2\
    \ % 3 == 0).map(_._1).sorted.zipWithIndex.partition(_._2 % 3 == 0)\n        val\
    \ s = scala.collection.mutable.Map[Int, Long]()\n        sorted.foreach(x => s(x._2)\
    \ = x._1)\n        l.zipWithIndex.map(x => if (x._2 % 3 == 0) s(x._2) else x._1)",
  "        if (l.length == 0) return l\n        var result = new ListBuffer[Long]\n\
    \        var count = 0\n        for (e <- l) {\n            if (count % 3 == 0)\
    \ {\n                var temp = (result.takeRight(3) :+ e).sorted\n          \
    \      result = result.dropRight(3) ++ temp\n            } else {\n          \
    \      result += e\n            }\n            count += 1\n        }\n       \
    \ result.toList", "        var l1 = new ListBuffer[Long]()\n        l1 += l(0)\n\
    \        l1 += l(1)\n        var l2 = l(2) to l(2)\n        l1 ++= l2.sorted\n\
    \        l1 ++= l.slice(3, l.length)\n        return l1.toList", "        var\
    \ sorted = l.filter(n => n % 3 == 0).sorted\n        var i = 0\n        return\
    \ l.map(n => if (n % 3 == 0) sorted(i) else { i += 1; n })", "        var l_prime\
    \ = List[Long]()\n        for (i <- 0 until l.length) {\n            if (i % 3\
    \ == 0) {\n                val sublist = l.slice(i, i + 3)\n                val\
    \ sublist_sorted = sublist.sorted\n                l_prime = l_prime ::: sublist_sorted\n\
    \            } else {\n                l_prime = l_prime :+ l(i)\n           \
    \ }\n        }\n        return l_prime", "        var ls = l.toBuffer\n      \
    \  var s = 0\n        while (s < ls.length) {\n            if (s % 3 == 0) {\n\
    \                val arr = ls.slice(s, s + 3).sorted\n                for (i <-\
    \ 0 until 3) {\n                    ls(s + i) = arr(i)\n                }\n  \
    \          }\n            s += 1\n        }\n        ls.toList", "        var\
    \ li = new ListBuffer[Long]()\n        var i = 0\n        for (e <- l) {\n   \
    \         if (i % 3 == 0) {\n                li += l.slice(i, i + 3).sorted.reverse(0)\n\
    \                i += 3\n            } else {\n                li += e\n     \
    \           i += 1\n            }\n        }\n        return li.toList", "   \
    \     def helper(m : List[Long], n : List[Long], cnt : Int) : List[Long] = {\n\
    \            if (m.length < cnt) n else {\n                if (cnt % 3 == 0) helper(m.tail,\
    \ n :+ m.head, cnt + 1) else helper(m.tail, n :+ m.head, cnt + 1)\n          \
    \  }\n        }\n        val sorted = l.sorted\n        def helper2(n : List[Long],\
    \ k : List[Long], cnt : Int) : List[Long] = {\n            if (n.length < cnt)\
    \ k else {\n                if (cnt % 3 == 0) helper2(n.tail, k :+ sorted(cnt\
    \ - 1), cnt + 1) else helper2(n.tail, k :+ n.head, cnt + 1)\n            }\n \
    \       }\n        helper2(helper(l, List(), 1), List(), 1)", "        var ln\
    \ = ListBuffer[Long]()\n        for (i <- 0 until l.length) {\n            if\
    \ (i % 3 == 0) {\n                val lx = l.slice(i, i + 3).sorted\n        \
    \        ln += lx(0)\n                ln += lx(1)\n                ln += lx(2)\n\
    \            } else {\n                ln += l(i)\n            }\n        }\n\
    \        ln.toList", "        def sortThird(l : List[Long], s : Long) : List[Long]\
    \ = l match {\n            case List() => Nil\n            case List(a) => List(a)\n\
    \            case List(a, b) => List(a, b)\n            case h1 :: h2 :: h3 ::\
    \ tail => sortThird(tail, s + 1) ::: List(List(h1, h2, h3).sorted.head)\n    \
    \    }\n        sortThird(l, 0)", "        def get(l : List[Long], n : Int) :\
    \ Long = {\n            if (n >= l.length)\n                0\n            else\n\
    \                l(n)\n        }\n        def sortSub(l : List[Long], n : Int)\
    \ : List[Long] = {\n            var start = n\n            var end = n + 2\n \
    \           var sub : List[Long] = Nil\n            var i = start\n          \
    \  while (i <= end) {\n                sub = get(l, i) :: sub\n              \
    \  i += 1\n            }\n            sub.sorted\n        }\n        def go(l\
    \ : List[Long], n : Int, acc : List[Long]) : List[Long] = {\n            if (n\
    \ >= l.length)\n                acc\n            else {\n                if (n\
    \ % 3 == 0) {\n                    go(l, n + 1, acc ::: sortSub(l, n))\n     \
    \           } else {\n                    go(l, n + 1, acc ::: List(get(l, n)))\n\
    \                }\n            }\n        }\n        go(l, 0, Nil)"]
stop_tokens:
- "\n    }\n"
