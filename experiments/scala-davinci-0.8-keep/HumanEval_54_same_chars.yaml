name: HumanEval_54_same_chars
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Check if two words have the same characters.\n    // >>> same_chars('eabcdzzzz',\
  \ 'dddzzzzzzzddeddabc')\n    // True\n    // >>> same_chars('abcd', 'dddddddabc')\n\
  \    // True\n    // >>> same_chars('dddddddabc', 'abcd')\n    // True\n    // >>>\
  \ same_chars('eabcd', 'dddddddabc')\n    // False\n    // >>> same_chars('abcd',\
  \ 'dddddddabce')\n    // False\n    // >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n\
  \    // False\n    def sameChars(s0 : String, s1 : String) : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(sameChars((\"eabcdzzzz\"\
  ), (\"dddzzzzzzzddeddabc\")) == (true));\n    assert(sameChars((\"abcd\"), (\"dddddddabc\"\
  )) == (true));\n    assert(sameChars((\"dddddddabc\"), (\"abcd\")) == (true));\n\
  \    assert(sameChars((\"eabcd\"), (\"dddddddabc\")) == (false));\n    assert(sameChars((\"\
  abcd\"), (\"dddddddabcf\")) == (false));\n    assert(sameChars((\"eabcdzzzz\"),\
  \ (\"dddzzzzzzzddddabc\")) == (false));\n    assert(sameChars((\"aabb\"), (\"aaccc\"\
  )) == (false));\n    }\n\n}\n"
completions: ["        var h0 = HashMap[Char, Int]()\n        for (c <- s0) h0(c)\
    \ = h0.getOrElse(c, 0) + 1\n        var h1 = HashMap[Char, Int]()\n        for\
    \ (c <- s1) h1(c) = h1.getOrElse(c, 0) + 1\n        h0 == h1", "        val l0\
    \ = s0.length\n        val l1 = s1.length\n        if (l0 > l1) return false\n\
    \        val m0 = new Array[Int](26)\n        val m1 = new Array[Int](26)\n  \
    \      for (i <- 0 until l0) {\n            m0(s0(i) - 'a') += 1\n           \
    \ m1(s1(i) - 'a') += 1\n        }\n        for (i <- 0 until 26) {\n         \
    \   if (m0(i) > m1(i)) return false\n        }\n        for (i <- 0 until l1 -\
    \ l0) {\n            m1(s1(i) - 'a') -= 1\n            m1(s1(i + l0) - 'a') +=\
    \ 1\n            var isPossible = true\n            for (j <- 0 until 26) {\n\
    \                if (m0(j) > m1(j)) {\n                    isPossible = false\n\
    \                    break\n                }\n            }\n            if (isPossible)\
    \ return true\n        }\n        false", "        var d = HashMap[Char, Int]()\n\
    \        for (c <- s0) {\n            if (d.contains(c)) d(c) += 1 else d(c) =\
    \ 1\n        }\n        for (c <- s1) {\n            if (d.contains(c)) d(c) -=\
    \ 1 else return false\n            if (d(c) < 0) return false\n        }\n   \
    \     for (v <- d.values) {\n            if (v != 0) return false\n        }\n\
    \        return true", "        val c = new Array[Int](26)\n        for (i <-\
    \ 0 until s0.length) c(s0(i) - 'a') += 1\n        for (i <- 0 until s1.length)\
    \ c(s1(i) - 'a') -= 1\n        for (i <- 0 until 26) if (c(i) != 0) return false\n\
    \        return true", "        val map = new HashMap[Char, Int]\n        for\
    \ (c <- s0) map(c) = map.getOrElse(c, 0) + 1\n        for (c <- s1) map(c) = map.getOrElse(c,\
    \ 0) - 1\n        map.values.forall(_ == 0)", "        val c0 = Array.fill(26)(0)\n\
    \        val c1 = Array.fill(26)(0)\n        s0.foreach(c => c0(c - 'a') += 1)\n\
    \        s1.foreach(c => c1(c - 'a') += 1)\n        c0.zip(c1).forall(p => p._1\
    \ == p._2)", "        val m0 = s0.groupBy(x => x).map(x => (x._1, x._2.length)).toList.sortBy(x\
    \ => x._1)\n        val m1 = s1.groupBy(x => x).map(x => (x._1, x._2.length)).toList.sortBy(x\
    \ => x._1)\n        m0 == m1", "        val m0 = s0.groupBy(x => x).map(x => (x._1,\
    \ x._2.length)).toMap\n        val m1 = s1.groupBy(x => x).map(x => (x._1, x._2.length)).toMap\n\
    \        m0.forall(x => m1.getOrElse(x._1, 0) >= x._2) && m1.forall(x => m0.getOrElse(x._1,\
    \ 0) >= x._2)", "        val counts0 = new Array[Int](26)\n        val counts1\
    \ = new Array[Int](26)\n        for (c <- s0) {\n            val n = c - 'a'\n\
    \            counts0(n) += 1\n        }\n        for (c <- s1) {\n           \
    \ val n = c - 'a'\n            counts1(n) += 1\n        }\n        for (i <- 0\
    \ until 26) {\n            if (counts0(i) != counts1(i)) return false\n      \
    \  }\n        return true", "        val m0 = s0.groupBy(identity).mapValues(_.length)\n\
    \        val m1 = s1.groupBy(identity).mapValues(_.length)\n        for ((key,\
    \ value) <- m0) {\n            if (!m1.contains(key) || m1(key) < value) return\
    \ false\n        }\n        return true", "      if (s0.length != s1.length) return\
    \ false\n      val s0s = s0.toList.sortWith(_<_)\n      val s1s = s1.toList.sortWith(_<_)\n\
    \      var same = true\n      for (i <- 0 until s0.length) {\n        if (s0s(i)\
    \ != s1s(i)) same = false\n      }\n      same", "      if (s0.length != s1.length)\
    \ false\n      else {\n        var count0 = new Array[Int](256)\n        var count1\
    \ = new Array[Int](256)\n        for (i <- 0 until s0.length) {\n          count0(s0(i))\
    \ += 1\n          count1(s1(i)) += 1\n        }\n        count0.deep == count1.deep\n\
    \      }", "        val a0 = s0.toCharArray\n        val a1 = s1.toCharArray\n\
    \        val c0 = Array.fill(26)(0)\n        val c1 = Array.fill(26)(0)\n    \
    \    for (i <- 0 until a0.length) c0(a0(i) - 'a') += 1\n        for (i <- 0 until\
    \ a1.length) c1(a1(i) - 'a') += 1\n        c0.toList == c1.toList", "        val\
    \ a0 = s0.toArray.sorted\n        val a1 = s1.toArray.sorted\n        val n0 =\
    \ a0.length\n        val n1 = a1.length\n        if (n0 != n1) return false\n\
    \        var i = 0\n        while (i < n0) {\n            if (a0(i) != a1(i))\
    \ return false\n            i += 1\n        }\n        return true", "       \
    \ val arr0 = s0.toCharArray.sorted\n        val arr1 = s1.toCharArray.sorted\n\
    \        if (arr0.length > arr1.length) false\n        else {\n            var\
    \ i = 0\n            var j = 0\n            while (i < arr0.length && j < arr1.length)\
    \ {\n                if (arr0(i) == arr1(j)) {\n                    i += 1\n \
    \                   j += 1\n                }\n                else j += 1\n \
    \           }\n            if (i == arr0.length) true\n            else false\n\
    \        }", "        val counts0 = Array.fill(26)(0)\n        val counts1 = Array.fill(26)(0)\n\
    \        for (c <- s0) counts0(c - 'a') += 1\n        for (c <- s1) counts1(c\
    \ - 'a') += 1\n        for (i <- 0 until 26) if (counts0(i) != counts1(i)) return\
    \ false\n        return true", "        val m0 = Map[Char, Int]()\n        val\
    \ m1 = Map[Char, Int]()\n        for (c <- s0) {\n            if (m0.contains(c))\
    \ {\n                m0(c) += 1\n            } else {\n                m0(c) =\
    \ 1\n            }\n        }\n        for (c <- s1) {\n            if (m1.contains(c))\
    \ {\n                m1(c) += 1\n            } else {\n                m1(c) =\
    \ 1\n            }\n        }\n        for (c <- m0.keys) {\n            if (!m1.contains(c)\
    \ || m0(c) != m1(c)) return false\n        }\n        for (c <- m1.keys) {\n \
    \           if (!m0.contains(c) || m0(c) != m1(c)) return false\n        }\n \
    \       return true", "        var h0 = new HashMap[Char, Int]\n        var h1\
    \ = new HashMap[Char, Int]\n        for (c <- s0) {\n            if (h0.contains(c))\
    \ {\n                h0(c) += 1\n            } else {\n                h0(c) =\
    \ 1\n            }\n        }\n        for (c <- s1) {\n            if (h1.contains(c))\
    \ {\n                h1(c) += 1\n            } else {\n                h1(c) =\
    \ 1\n            }\n        }\n        for (c <- h0.keys) {\n            if (!h1.contains(c)\
    \ || h1(c) < h0(c)) return false\n        }\n        for (c <- h1.keys) {\n  \
    \          if (!h0.contains(c) || h0(c) < h1(c)) return false\n        }\n   \
    \     return true", "        def f(s : String) : Map[Char, Int] = {\n        \
    \    val d = new HashMap[Char, Int]\n            for (c <- s) d(c) = d.getOrElse(c,\
    \ 0) + 1\n            d\n        }\n        val d0 = f(s0)\n        val d1 = f(s1)\n\
    \        d0.keys.forall(c => d0(c) == d1.getOrElse(c, 0))", "        def sameChars(s0\
    \ : List[Char], s1 : List[Char]) : Boolean = {\n            if (s0.isEmpty) s1.isEmpty\n\
    \            else if (s1.isEmpty) false\n            else if (s0.head == s1.head)\
    \ sameChars(s0.tail, s1.tail)\n            else sameChars(s0, s1.tail)\n     \
    \   }\n        sameChars(s0.toList, s1.toList)"]
stop_tokens:
- "\n    }\n"
