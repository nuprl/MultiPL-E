name: HumanEval_151_double_the_difference
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a list of numbers, return the sum of squares of the numbers\n    //\
  \ in the list that are odd. Ignore numbers that are negative or not integers.\n\
  \    // double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    // double_the_difference([-1,\
  \ -2, 0]) == 0\n    // double_the_difference([9, -2]) == 81\n    // double_the_difference([0])\
  \ == 0  \n    // If the input list is empty, return 0.\n    def doubleTheDifference(lst\
  \ : List[Float]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(doubleTheDifference((List[Float]()))\
  \ == (0l));\n    assert(doubleTheDifference((List[Float](5.0f.toFloat, 4.0f.toFloat)))\
  \ == (25l));\n    assert(doubleTheDifference((List[Float](0.1f.toFloat, 0.2f.toFloat,\
  \ 0.3f.toFloat))) == (0l));\n    assert(doubleTheDifference((List[Float](-10.0f.toFloat,\
  \ -20.0f.toFloat, -30.0f.toFloat))) == (0l));\n    assert(doubleTheDifference((List[Float](-1.0f.toFloat,\
  \ -2.0f.toFloat, 8.0f.toFloat))) == (0l));\n    assert(doubleTheDifference((List[Float](0.2f.toFloat,\
  \ 3.0f.toFloat, 5.0f.toFloat))) == (34l));\n    assert(doubleTheDifference((List[Float](-9.0f.toFloat,\
  \ -7.0f.toFloat, -5.0f.toFloat, -3.0f.toFloat, -1.0f.toFloat, 1.0f.toFloat, 3.0f.toFloat,\
  \ 5.0f.toFloat, 7.0f.toFloat, 9.0f.toFloat))) == (165l));\n    }\n\n}\n"
completions: ['      lst.filter(x => (x % 2 == 1) && x >= 0 && x % 1 == 0).map(x =>
    Math.pow(x, 2).toLong).sum', "        // Fill Up this function body\n        //\
    \ `0L` indicates that the return type is Long\n        lst.map(i => i * i).sum.toLong",
  "        var sum : Long = 0\n        for (i <- lst) {\n            if (i % 2 ==\
    \ 1) {\n                sum += (i * i).toLong\n            }\n        }\n    \
    \    sum", "        def helper(lst : List[Float], a : Long, b : Long) : Long =\
    \ {\n            if (lst.length == 0) a * 2 - b * 2\n            else if (lst.head\
    \ % 2 == 0) helper(lst.tail, a, b + lst.head)\n            else helper(lst.tail,\
    \ a + lst.head, b)\n        }\n        helper(lst, 0, 0)", "        var sum1 =\
    \ 0.0\n        var sum2 = 0.0\n        for (x <- lst) {\n            if (x % 2\
    \ == 0) sum1 += x * x\n            else sum2 += x * x\n        }\n        (sum1\
    \ - sum2) * 2", "        // we can do this in 2 passes:\n        // one to find\
    \ the sum of the squares of the odd numbers\n        // the other to find the\
    \ difference (the sum of the squares of the even numbers)\n        var odds =\
    \ 0\n        var evens = 0\n        for (i <- lst if (i.isValidInt)) {\n     \
    \       if (i % 2 == 0) evens += i * i\n            else odds += i * i\n     \
    \   }\n        2 * (odds - evens)", "        def isOdd(n : Float) : Boolean =\
    \ n % 2 == 1\n        def isInteger(n : Float) : Boolean = n.isValidInt\n    \
    \    def isValid(n : Float) : Boolean = n >= 0 && isInteger(n)\n        def square(n\
    \ : Float) : Long = pow(n, 2).toLong\n        val squares = lst.filter(isValid(_)).filter(isOdd(_)).map(square(_))\n\
    \        if (squares.isEmpty) return 0\n        else squares.reduceLeft(_ + _)\
    \ * 2", "    \tvar sum = 0L\n    \tfor (i <- lst) {\n    \t\tif (i % 2 == 1 &&\
    \ i > 0) sum += (i * i)\n    \t}\n    \tsum", "    \tvar sum = 0\n    \tfor (num\
    \ <- lst) {\n    \t\tif (num > 0 && num.toLong == num) {\n    \t\t\tsum += pow(num,\
    \ 2).toLong\n    \t\t}\n    \t}\n    \treturn sum", '        return lst.map(x
    => if (x < 0 || x % 1 != 0) 0 else Math.pow(x, 2).toLong).sum * 2', "        //\
    \ ******************\n        // YOUR CODE HERE\n        // ******************",
  "        var sum : Long = 0\n        for (i <- lst) {\n            if (i > 0 &&\
    \ floor(i) == i) sum += i.toLong * i.toLong\n        }\n        return sum", '        return
    lst.map(x => if (x > 0 && x % 2 != 0) pow(x, 2).toLong else 0).sum', "       \
    \ val longs = lst.filter(x => x % 2 == 1 && x % 1 == 0).map(x => x.toLong).map(x\
    \ => x * x)\n        return longs.reduce((x, y) => x + y)", "        val diff\
    \ = (lst :\\ 0.0) {\n            (f, t) => {\n                if(f < 0)\n    \
    \                t\n                else if(f % 1 != 0)\n                    t\n\
    \                else\n                    t + (f - 1) * (f - 1)\n           \
    \ }\n        }\n        (diff * 2).toLong", "        var sum = 0\n        for\
    \ (i <- lst) {\n            if (i % 2 == 1) sum += i * i\n        }\n        return\
    \ sum", "        var squares : Long = 0\n        for (i <- lst) {\n          \
    \  if (i >= 0 && i % 2 == 1) {\n                squares += pow(i, 2).toLong\n\
    \            }\n        }\n        return 2 * squares", "        var product =\
    \ 1\n        for (i <- lst) {\n            if (i > 0 && i.toInt == i) {\n    \
    \            product *= i\n            }\n        }\n        product * product",
  "        // return lst.filter(_ % 2 == 1).map(pow(_, 2)).sum.toLong\n        return\
    \ lst.filter(x => x % 2 == 1 && x > 0 && x % 1 == 0).map(pow(_, 2).toLong).sum",
  "        if (lst.isEmpty) return 0\n        val isPositiveInteger = (x : Float)\
    \ => (x > 0 && abs(x % 1) <= 1e-6)\n        val isOdd = (x : Float) => (x % 2\
    \ == 1)\n        return 2 * lst.filter(isPositiveInteger).filter(isOdd).map(x\
    \ => x * x).sum.toLong"]
stop_tokens:
- "\n    }\n"
