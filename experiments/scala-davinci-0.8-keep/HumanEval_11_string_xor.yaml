name: HumanEval_11_string_xor
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform\
  \ binary XOR on these inputs and return result also as a string.\n    // >>> string_xor('010',\
  \ '110')\n    // '100'\n    def stringXor(a : String, b : String) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
  ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
  0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n   \
  \ }\n\n}\n"
completions: ["        var length : Int = max(a.length, b.length)\n        var result\
    \ : StringBuilder = new StringBuilder(length)\n        for (i <- 0 until length)\
    \ {\n            var c : Int = 0\n            if (i < a.length && a(i) == '1')\
    \ c = c + 1\n            if (i < b.length && b(i) == '1') c = c + 1\n        \
    \    if (c % 2 == 0) result.append('0')\n            else result.append('1')\n\
    \        }\n        return result.toString", '        (a zip b).map(t => t._1
    ^ t._2).mkString', "        var result = \"\"\n        for (i <- 0 until a.length)\
    \ {\n            if (a(i) == b(i)) result += \"0\"\n            else result +=\
    \ \"1\"\n        }\n        return result", "        assert(a.length == b.length)\n\
    \        var i = 0\n        var result = new StringBuilder\n        while (i <\
    \ a.length) {\n            if (a(i) == b(i)) result += '0'\n            else result\
    \ += '1'\n            i += 1\n        }\n        result.toString", "        val\
    \ result = ArrayBuffer[Char]()\n        for (i <- 0 until a.length) {\n      \
    \      if (a(i) == b(i)) result += '0'\n            else result += '1'\n     \
    \   }\n        result.mkString", "        require(a.length == b.length)\n    \
    \    var i = 0\n        var res = \"\"\n        while (i < a.length) {\n     \
    \       res += (a(i) ^ b(i)).toString\n            i += 1\n        }\n       \
    \ res", "        require(a.length == b.length)\n        for (i <- 0 until a.length)\
    \ {\n            val x = a(i)\n            val y = b(i)\n            require(x\
    \ == '0' || x == '1')\n            require(y == '0' || y == '1')\n        }\n\
    \        val sb = new StringBuilder()\n        for (i <- 0 until a.length) {\n\
    \            val x = a(i)\n            val y = b(i)\n            if (x == y) sb.append('0')\n\
    \            else sb.append('1')\n        }\n        sb.toString", "        require(a.length\
    \ == b.length)\n        val sb = new StringBuilder\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) sb.append('0')\n            else\
    \ sb.append('1')\n        }\n        sb.toString", "        val maxLength = max(a.length,\
    \ b.length)\n        var aRepeated = a.reverse\n        var bRepeated = b.reverse\n\
    \        for (i <- 1 to maxLength - a.length) aRepeated += \"0\"\n        for\
    \ (i <- 1 to maxLength - b.length) bRepeated += \"0\"\n        (aRepeated, bRepeated).zipped.map(xor(_,\
    \ _)).reverse.mkString", "        assert(a.length == b.length)\n        val z\
    \ = new StringBuilder\n        for (i <- 0 until a.length) {\n            z.append((if\
    \ (a(i) == '1') 1 else 0) ^ (if (b(i) == '1') 1 else 0))\n        }\n        z.toString",
  "        var result = new StringBuffer()\n        for (i <- 0 until a.length) {\n\
    \            result.append((a(i) ^ b(i)).toString)\n        }\n        return\
    \ result.toString", "        require(a.length == b.length)\n        val l : Int\
    \ = a.length\n        var result : String = \"\"\n        for (i <- 0 until l)\
    \ {\n            result += (if (a(i) == b(i)) \"0\" else \"1\")\n        }\n \
    \       result", "        // Assume lengths are the same\n        var sb = new\
    \ StringBuilder()\n        for (i <- 0 until a.length) {\n            if (a(i)\
    \ == b(i)) sb.append('0')\n            else sb.append('1')\n        }\n      \
    \  sb.toString", "      a.zip(b).map(x => if (x._1 != x._2) '1' else '0').mkString",
  "        def stringXorAux(x : List[Int], y : List[Int]) : List[Int] = (x, y) match\
    \ {\n            case (xh :: xt, yh :: yt) =>\n                ((xh - 48) ^ (yh\
    \ - 48)) :: stringXorAux(xt, yt)\n            case _ => Nil\n        }\n     \
    \   stringXorAux(a.toList, b.toList).map(_ + 48).mkString", "        val aBinary\
    \ = BigInt(a, 2)\n        val bBinary = BigInt(b, 2)\n        val result = (aBinary\
    \ ^ bBinary).toString(2)\n        val padding = new StringBuilder\n        for\
    \ (i <- 0 until (a.length - result.length)) padding.append(\"0\")\n        padding.append(result).toString",
  "        val len = min(a.length, b.length)\n        var ans = \"\"\n        for\
    \ (i <- 0 until len) {\n            if (a(i) == b(i)) ans += \"0\"\n         \
    \   else ans += \"1\"\n        }\n        ans", "      val pairs = a.zip(b)\n\
    \      var result = \"\"\n      for ((x, y) <- pairs) {\n        result += (if\
    \ (x != y) '1' else '0')\n      }\n      result", "        if (a.length != b.length)\
    \ throw new Exception(\"Inputs are not of equal length\")\n        val c = ArrayBuffer[Char]()\n\
    \        for (i <- 0 until a.length) {\n            if (a(i) == b(i)) c += '0'\n\
    \            else c += '1'\n        }\n        c.mkString", "        val aa =\
    \ BigInt(a, 2)\n        val bb = BigInt(b, 2)\n        val cc = aa ^ bb\n    \
    \    return cc.toString(2)"]
stop_tokens:
- "\n    }\n"
