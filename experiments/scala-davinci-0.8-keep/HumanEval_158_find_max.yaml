name: HumanEval_158_find_max
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function that accepts a list of strings.\n    // The list contains\
  \ different words. Return the word with maximum number\n    // of unique characters.\
  \ If multiple strings have maximum number of unique\n    // characters, return the\
  \ one which comes first in lexicographical order.\n    // find_max([\"name\", \"\
  of\", \"string\"]) == \"string\"\n    // find_max([\"name\", \"enam\", \"game\"\
  ]) == \"enam\"\n    // find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\n\
  \    def findMax(words : List[String]) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(findMax((List[String](\"\
  name\", \"of\", \"string\"))).equals((\"string\")));\n    assert(findMax((List[String](\"\
  name\", \"enam\", \"game\"))).equals((\"enam\")));\n    assert(findMax((List[String](\"\
  aaaaaaa\", \"bb\", \"cc\"))).equals((\"aaaaaaa\")));\n    assert(findMax((List[String](\"\
  abc\", \"cba\"))).equals((\"abc\")));\n    assert(findMax((List[String](\"play\"\
  , \"this\", \"game\", \"of\", \"footbott\"))).equals((\"footbott\")));\n    assert(findMax((List[String](\"\
  we\", \"are\", \"gonna\", \"rock\"))).equals((\"gonna\")));\n    assert(findMax((List[String](\"\
  we\", \"are\", \"a\", \"mad\", \"nation\"))).equals((\"nation\")));\n    assert(findMax((List[String](\"\
  this\", \"is\", \"a\", \"prrk\"))).equals((\"this\")));\n    assert(findMax((List[String](\"\
  b\"))).equals((\"b\")));\n    assert(findMax((List[String](\"play\", \"play\", \"\
  play\"))).equals((\"play\")));\n    }\n\n}\n"
completions: ["        // type: Set[Char]\n        val uniqueChars = (words :\\ Map[String,\
    \ Set[Char]]()) {\n            case (currWord, acc) => {\n                val\
    \ currSet = currWord.toSet\n                val set = if (acc.contains(currWord))\
    \ acc(currWord) else Set[Char]()\n                acc + (currWord -> (set ++ currSet))\n\
    \            }\n        }\n        // type: (String, Int)\n        val uniqueCharsCount\
    \ = uniqueChars.map {\n            case (word, uniqueCharSet) => (word, uniqueCharSet.size)\n\
    \        }\n        // type: (String, Int)\n        val maxValue = uniqueCharsCount.maxBy\
    \ {\n            case (word, count) => count\n        }\n        val wordsWithMaxCount\
    \ = uniqueCharsCount.filter {\n            case (word, count) => count == maxValue._2\n\
    \        }\n        if (wordsWithMaxCount.size == 1) maxValue._1\n        else\
    \ wordsWithMaxCount.minBy {\n            case (word, count) => word\n        }._1",
  "        var m = (\"\", 0)\n        for (word <- words) {\n            val x = word.toSet.size\n\
    \            if (x > m._2) m = (word, x)\n        }\n        m._1", "        val\
    \ m : scala.collection.mutable.Map[String, Int] = new HashMap[String, Int]\n \
    \       for (word <- words) {\n            val u : Set[Char] = word.toSet\n  \
    \          m += word -> u.size\n        }\n        m.maxBy(_._2)._1", "      \
    \  var maxWord = \"\"\n        var maxUniqueChar = 0\n        for (word <- words)\
    \ {\n            val distinctChar = word.toSet.size\n            if (distinctChar\
    \ > maxUniqueChar) {\n                maxUniqueChar = distinctChar\n         \
    \       maxWord = word\n            }\n        }\n        maxWord", "        var\
    \ maxCount = 0\n        var maxWord = \"\"\n        words.foreach(word => {\n\
    \            val count = word.toSet.size\n            if (count >= maxCount) {\n\
    \                maxCount = count\n                maxWord = word\n          \
    \  }\n        })\n        maxWord", "        if (words.isEmpty) \"\"\n       \
    \ else {\n            var charCount = HashMap[Char, Int]()\n            for (c\
    \ <- words.head) {\n                if (charCount.contains(c)) {\n           \
    \         charCount(c) += 1\n                } else {\n                    charCount(c)\
    \ = 1\n                }\n            }\n            var result = (words.head,\
    \ charCount.size)\n            for (w <- words.tail) {\n                charCount\
    \ = HashMap[Char, Int]()\n                for (c <- w) {\n                   \
    \ if (charCount.contains(c)) {\n                        charCount(c) += 1\n  \
    \                  } else {\n                        charCount(c) = 1\n      \
    \              }\n                }\n                if (charCount.size > result._2)\
    \ {\n                    result = (w, charCount.size)\n                } else\
    \ if (charCount.size == result._2) {\n                    if (w < result._1) {\n\
    \                        result = (w, charCount.size)\n                    }\n\
    \                }\n            }\n            result._1\n        }", '      words.minBy(x
    => (x.toSet.size, x))', "        var maxWord = words(0)\n        for (i <- 1 until\
    \ words.length) {\n            if (words(i).toSet.size > maxWord.toSet.size) {\n\
    \                maxWord = words(i)\n            } else if (words(i).toSet.size\
    \ == maxWord.toSet.size) {\n                if (words(i) < maxWord) {\n      \
    \              maxWord = words(i)\n                }\n            }\n        }\n\
    \        maxWord", "      val hash = new HashMap[String, Int]\n      for (w <-\
    \ words) {\n        hash += (w -> w.toSet.size)\n      }\n      val max = hash.values.max\n\
    \      val result = hash.filter(p => p._2 == max).minBy(_._1)\n      result._1",
  "        var max = 0\n        var maxWord = \"\"\n        for (word <- words) {\n\
    \            val map = new HashMap[Char, Int]\n            for (c <- word) map(c)\
    \ = 1\n            if (map.size > max) {\n                max = map.size\n   \
    \             maxWord = word\n            }\n        }\n        maxWord", "  \
    \      var maxLength = -1\n        var maxWords = new ArrayBuffer[String]\n  \
    \      for (word <- words) {\n            val w = word.toSet\n            if (w.size\
    \ > maxLength) {\n                maxLength = w.size\n                maxWords.clear\n\
    \                maxWords += word\n            } else if (w.size == maxLength)\
    \ {\n                maxWords += word\n            }\n        }\n        if (maxWords.isEmpty)\
    \ \"\" else maxWords.min", '        words.foldLeft(("", 0))((s, word) => if (s._2
    > getNumUniqueChars(word)) s else (word, getNumUniqueChars(word)))._1', '        words.maxBy
    { x => x.toSet.size }', "        var max = (\"\", -1)\n        for (word <- words)\
    \ {\n            if (word.distinct.length > max._2) max = (word, word.distinct.length)\n\
    \            else if (word.distinct.length == max._2) if (word < max._1) max =\
    \ (word, word.distinct.length)\n        }\n        max._1", "        var max =\
    \ (\"\", Set[Char]())\n        for (word <- words) {\n            val set = word.toSet\n\
    \            if (set.size > max._2.size) max = (word, set)\n            else if\
    \ (set.size == max._2.size && word < max._1) max = (word, set)\n        }\n  \
    \      max._1", "        var maxUniqueChars = 0\n        var ans = \"\"\n    \
    \    for (word <- words) {\n            val uniqueChars = word.toSet.size\n  \
    \          if (uniqueChars > maxUniqueChars) {\n                maxUniqueChars\
    \ = uniqueChars\n                ans = word\n            }\n        }\n      \
    \  ans", "        var maxLen = 0\n        var maxStr = \"\"\n        for (word\
    \ <- words) {\n            val set = new HashSet[Char]\n            for (c <-\
    \ word) set += c\n            if (set.size > maxLen) {\n                maxLen\
    \ = set.size\n                maxStr = word\n            }\n        }\n      \
    \  maxStr", "        def uniqueCount(word : String) : Int = {\n            var\
    \ f = Set[Char]()\n            for (i <- 0 until word.length) {\n            \
    \    f += word(i)\n            }\n            f.size\n        }\n        val max\
    \ = words.map(uniqueCount(_)).max\n        val maxwords = words.filter(uniqueCount(_)\
    \ == max)\n        maxwords.sorted.head", "        words.foldLeft((\"\", 0))((p,\
    \ c) =>\n            if (p._2 > c.distinct.length) p\n            else if (p._2\
    \ == c.distinct.length) (if (p._1 < c) p._1 else c, p._2)\n            else (c,\
    \ c.distinct.length))._1", "        words.foldLeft(\"\")((a, b) => {\n       \
    \     if (b.distinct.length > a.distinct.length) b else a\n        })"]
stop_tokens:
- "\n    }\n"
