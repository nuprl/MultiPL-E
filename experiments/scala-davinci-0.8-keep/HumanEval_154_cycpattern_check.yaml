name: HumanEval_154_cycpattern_check
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given 2 words. You need to return True if the second word or any\
  \ of its rotations is a substring in the first word\n    // cycpattern_check(\"\
  abcd\",\"abd\") => False\n    // cycpattern_check(\"hello\",\"ell\") => True\n \
  \   // cycpattern_check(\"whassup\",\"psus\") => False\n    // cycpattern_check(\"\
  abab\",\"baa\") => True\n    // cycpattern_check(\"efef\",\"eeff\") => False\n \
  \   // cycpattern_check(\"himenss\",\"simen\") => True\n    def cycpatternCheck(a\
  \ : String, b : String) : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(cycpatternCheck((\"\
  xyzw\"), (\"xyw\")) == (false));\n    assert(cycpatternCheck((\"yello\"), (\"ell\"\
  )) == (true));\n    assert(cycpatternCheck((\"whattup\"), (\"ptut\")) == (false));\n\
  \    assert(cycpatternCheck((\"efef\"), (\"fee\")) == (true));\n    assert(cycpatternCheck((\"\
  abab\"), (\"aabb\")) == (false));\n    assert(cycpatternCheck((\"winemtt\"), (\"\
  tinem\")) == (true));\n    }\n\n}\n"
completions: ["        var sb = new StringBuilder(b)\n        for (i <- 1 to b.length)\
    \ {\n            sb.insert(0, b.charAt(b.length - 1))\n            sb.deleteCharAt(b.length)\n\
    \            if (a.contains(sb.toString)) return true\n        }\n        return\
    \ false", "        var buffer = new StringBuilder\n        for (i <- 0 until b.length)\
    \ {\n            buffer += b(i)\n            if (buffer.toString.equals(a) ||\
    \ a.contains(buffer.toString)) return true\n        }\n        buffer = new StringBuilder\n\
    \        for (i <- 0 until b.length) {\n            buffer += b(b.length - 1 -\
    \ i)\n            if (buffer.toString.equals(a) || a.contains(buffer.toString))\
    \ return true\n        }\n        return false", "        // Write your code here\n\
    \        val rotations = (1 to b.length).toList.map(i => b.slice(i, b.length)\
    \ + b.slice(0, i))\n        if (rotations.contains(a)) true\n        else if (rotations.forall(x\
    \ => !a.contains(x))) false\n        else true", "        val bb = b + b\n   \
    \     a.contains(b) || a.contains(bb)", '        // Write your code here', " \
    \       val hashs = new HashSet[Int]\n        for (i <- 0 until a.length) {\n\
    \            var hash = 0\n            for (j <- i until a.length) {\n       \
    \         hash = hash * 10 + a(j) - 'a'\n                hashs += hash\n     \
    \       }\n        }\n        println(hashs)\n        for (i <- 0 until b.length)\
    \ {\n            var hash = 0\n            for (j <- i until b.length) {\n   \
    \             hash = hash * 10 + b(j) - 'a'\n                if (hashs.contains(hash))\
    \ return true\n            }\n        }\n        false", '        (b + b).contains(a)',
  "        def rotate(s : String) : String = s.tail + s.head\n        var c : String\
    \ = b\n        for (i <- 0 until b.length) {\n            c = rotate(c)\n    \
    \        if (a.contains(c)) {\n                return true\n            }\n  \
    \      }\n        return false", "        val q = Queue[String]()\n        for\
    \ (i <- 0 until b.length) q.enqueue(b.substring(i) + b.substring(0, i))\n    \
    \    while (!q.isEmpty) {\n            val cur = q.dequeue\n            if (a.contains(cur))\
    \ return true\n        }\n        return false", '        return false', "   \
    \     // We will split the 2nd word into 2 substrings that are half the length\
    \ of the word.\n        // Then we will perform a check to see if the first substring\
    \ appears in the first word.\n        // If not, we will shift the substring to\
    \ the right by 1 character and check again.\n        // This will repeat until\
    \ we have done this with all possible shifts, or we found a substring in the first\
    \ word.\n        // The total number of shifts is the length of the word minus\
    \ 1.\n        val len = b.length\n        val half = len / 2\n        var shift\
    \ = 0\n        while (shift < len - 1) {\n            if (a.contains(b.substring(0,\
    \ half))) return true\n            // Shift the first and second substring to\
    \ the right by 1 character\n            b = b.substring(1, len) + b.substring(0,\
    \ 1)\n            shift += 1\n        }\n        return false", "        val (n,\
    \ m) = (a.length, b.length)\n        if (m > n) return false\n        def check(i\
    \ : Int) : Boolean = {\n            var result = true\n            for (j <- 0\
    \ until m) {\n                if (a(i + j) != b(j)) result = false\n         \
    \   }\n            result\n        }\n        for (i <- 0 until n) {\n       \
    \     if (check(i)) return true\n        }\n        var bb = b\n        for (i\
    \ <- 0 until m) {\n            bb = bb.tail + bb.head\n            for (i <- 0\
    \ until n) {\n                if (check(i)) return true\n            }\n     \
    \   }\n        false", "        if (a.contains(b)) return true\n        for (i\
    \ <- 1 until b.length) {\n            if (a.contains(b.slice(i, b.length) + b.slice(0,\
    \ i))) return true\n        }\n        return false", "      val as = a.map(c\
    \ => c - 'a')\n      val bs = b.map(c => c - 'a')\n      val n = as.length\n \
    \     val m = bs.length\n      val cnt = Array.fill(26)(0)\n      for (a <- as)\
    \ cnt(a) += 1\n      for (b <- bs) {\n        cnt(b) -= 1\n        if (cnt(b)\
    \ < 0) return false\n      }\n      val b0 = bs(0)\n      val bs2 = bs.map(b =>\
    \ (b - b0 + 26) % 26)\n      for (k <- 0 until m) {\n        val cnt2 = Array.fill(26)(0)\n\
    \        for (i <- 0 until m) cnt2(bs2(i)) += 1\n        for (i <- 0 until n)\
    \ {\n          val a = as(i)\n          val b = bs2(i % m)\n          cnt2(b)\
    \ -= 1\n          if (cnt2(b) < 0) return false\n        }\n        val temp =\
    \ bs2(0)\n        for (i <- 0 until m - 1) bs2(i) = bs2(i + 1)\n        bs2(m\
    \ - 1) = temp\n      }\n      true", "        var result = false\n        for\
    \ (i <- 0 to b.length - 1) {\n            if (a.contains(b.substring(i) + b.substring(0,\
    \ i))) result = true\n        }\n        result", "        b.length() > a.length()\
    \ match {\n            case true => return false\n            case false =>\n\
    \        }\n        val m = scala.collection.mutable.Map[Char, Int]()\n      \
    \  for (i <- 0 until a.length()) {\n            if (m.contains(a(i))) m(a(i))\
    \ += 1\n            else m(a(i)) = 1\n        }\n        for (i <- 0 until b.length())\
    \ {\n            if (!m.contains(b(i))) return false\n            else m(b(i))\
    \ -= 1\n        }\n        for (i <- 0 until b.length()) {\n            val p\
    \ = (b.length() - i) % b.length()\n            val c = b(p)\n            if (m(c)\
    \ < 0) return false\n        }\n        return true", "        var result = false\n\
    \        for (i <- 0 to b.length - 1) {\n            if (a.contains(b.substring(i)\
    \ + b.substring(0, i))) {\n                result = true\n                break\n\
    \            }\n        }\n        result", "      var rotate = b\n      for (i\
    \ <- 0 until b.length) {\n        rotate = rotate.tail + rotate.head\n       \
    \ if (a.contains(rotate)) return true\n      }\n      return false", "       \
    \ val aLen = a.length\n        val bLen = b.length\n        if (aLen < bLen) false\n\
    \        else {\n            val str = a + a\n            str.substring(str.indexOf(b),\
    \ str.indexOf(b) + bLen) == b\n        }", "        val n = a.length\n       \
    \ val m = b.length\n        val dp = Array.ofDim[Boolean](n + 1, m + 1)\n    \
    \    dp(0)(0) = true\n        for (i <- 1 to n) {\n            for (j <- 1 to\
    \ m) {\n                val k = i % m\n                dp(i)(j) = (dp(i - 1)(j\
    \ - 1) && a(i - 1) == b(k - 1)) || dp(i - 1)(j)\n            }\n        }\n  \
    \      dp(n)(m)"]
stop_tokens:
- "\n    }\n"
