name: HumanEval_43_pairs_sum_to_zero
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // pairs_sum_to_zero takes a list of integers as an input.\n    // it returns\
  \ True if there are two distinct elements in the list that\n    // sum to zero,\
  \ and False otherwise.\n    // >>> pairs_sum_to_zero([1, 3, 5, 0])\n    // False\n\
  \    // >>> pairs_sum_to_zero([1, 3, -2, 1])\n    // False\n    // >>> pairs_sum_to_zero([1,\
  \ 2, 3, 7])\n    // False\n    // >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n \
  \   // True\n    // >>> pairs_sum_to_zero([1])\n    // False\n    def pairsSumToZero(l\
  \ : List[Long]) : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(pairsSumToZero((List[Long](1l.toLong,\
  \ 3l.toLong, 5l.toLong, 0l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](1l.toLong,\
  \ 3l.toLong, -2l.toLong, 1l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 7l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](2l.toLong,\
  \ 4l.toLong, -5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))) == (true));\n    assert(pairsSumToZero((List[Long](1l.toLong)))\
  \ == (false));\n    assert(pairsSumToZero((List[Long](-3l.toLong, 9l.toLong, -1l.toLong,\
  \ 3l.toLong, 2l.toLong, 30l.toLong))) == (true));\n    assert(pairsSumToZero((List[Long](-3l.toLong,\
  \ 9l.toLong, -1l.toLong, 3l.toLong, 2l.toLong, 31l.toLong))) == (true));\n    assert(pairsSumToZero((List[Long](-3l.toLong,\
  \ 9l.toLong, -1l.toLong, 4l.toLong, 2l.toLong, 30l.toLong))) == (false));\n    assert(pairsSumToZero((List[Long](-3l.toLong,\
  \ 9l.toLong, -1l.toLong, 4l.toLong, 2l.toLong, 31l.toLong))) == (false));\n    }\n\
  \n}\n"
completions: ["        val set = new HashSet[Long]\n        for (i <- l) set += i\n\
    \        for (i <- l) if (set.contains(-i)) return true\n        false", "   \
    \     //Time: O(n)\n        val map = HashMap[Long, Long]()\n        for (i <-\
    \ l) {\n            map(i) = map.getOrElse(i, 0) + 1\n        }\n        for (i\
    \ <- l) {\n            val x = map.getOrElse(i, 0)\n            if (x == 1) {\n\
    \                map.remove(i)\n            } else {\n                map(i) =\
    \ x - 1\n            }\n            if (map.contains(-i)) {\n                return\
    \ true\n            }\n        }\n        return false", "\t\tval hs = new HashSet[Long]()\n\
    \t\tl.foreach(x => hs.add(x))\n\t\ths.toList.combinations(2).foreach(x => if (x(0)\
    \ + x(1) == 0) return true)\n\t\treturn false", '        return false', "    \
    \    var x = l.sorted\n        var i = 0\n        var j = x.length - 1\n     \
    \   while (i < j) {\n            var tmp = x(i) + x(j)\n            if (tmp ==\
    \ 0) return true\n            else if (tmp < 0) i += 1\n            else j -=\
    \ 1\n        }\n        return false", "\t\tif (l.length < 2) false\n\t\telse\
    \ if (l.tail.contains(-l.head)) true\n\t\telse pairsSumToZero(l.tail)", "    \
    \    // Note: There are two solutions to this problem that I could come up with\n\
    \        // Solution 1:\n        // Go through the list, add each number to a\
    \ hashset, then check if there is\n        // an element in the list such that\
    \ the negative of that element exists in the\n        // hashset.\n        //\
    \ Solution 2:\n        // Sort the list, then use a two pointer approach to find\
    \ if there are two elements\n        // that sum to zero.\n        // The two\
    \ pointer approach is implemented below\n        if (l.length < 2) return false\n\
    \        val sortedList = l.sorted\n        var i = 0\n        var j = sortedList.length\
    \ - 1\n        while (i < j) {\n            val currSum = sortedList(i) + sortedList(j)\n\
    \            if (currSum == 0) return true\n            else if (currSum < 0)\
    \ i += 1\n            else j -= 1\n        }\n        return false", "       \
    \ // your code here\n        for (i <- 0 until l.length-1) {\n        \tfor (j\
    \ <- i+1 until l.length) {\n        \t\tif (l(i) + l(j) == 0) return true\n  \
    \      \t}\n        }\n        return false", "        val mapped = l.map(e =>\
    \ (e, 1)).groupBy(_._1).mapValues(_.map(_._2).sum)\n        val hasZero = mapped.contains(0)\n\
    \        val hasOdd = mapped.exists(t => t._2 % 2 == 1)\n        hasZero && !hasOdd",
  "        var buf = HashSet[Long]()\n        for (x <- l) {\n            if (buf.contains(-x))\
    \ return true\n            buf += x\n        }\n        return false", "     \
    \   val set = Set[Long]()\n        for (x <- l) {\n            if (set.contains(-x))\
    \ return true\n            set += x\n        }\n        return false", "     \
    \   if (l.size == 1) {\n            false\n        } else {\n            val hs\
    \ = HashSet[Long]()\n            for (i <- l) {\n                if (hs.contains(-i))\
    \ {\n                    return true\n                } else {\n             \
    \       hs += i\n                }\n            }\n            false\n       \
    \ }", "\t\tval s = l.sorted\n\t\tvar i = 0\n\t\tvar j = s.length - 1\n\t\twhile\
    \ (i < j) {\n\t\t\tif (s(i) + s(j) == 0) return true\n\t\t\telse if (s(i) + s(j)\
    \ < 0) i += 1\n\t\t\telse j -= 1\n\t\t}\n\t\treturn false", "        l.groupBy(abs(_)).map(x\
    \ => if (x._2.length >= 2) {\n          for (i <- 0 until x._2.length - 1) {\n\
    \            for (j <- i + 1 until x._2.length) {\n              if (x._2(i) +\
    \ x._2(j) == 0) return true\n            }\n          }\n        }\n        false).find(_\
    \ == true).isDefined", "      var result = false\n      val hs = HashSet[Long]()\n\
    \      for (n <- l) {\n        if (hs.contains(-n)) result = true\n        else\
    \ hs += n\n      }\n      result", '        false', "        var hs = HashSet[Long]()\n\
    \        for (x <- l) {\n            if (hs.contains(-x)) return true\n      \
    \      hs += x\n        }\n        return false", "        var hm = HashMap[Long,\
    \ Long]()\n        for (e <- l) {\n            if (hm.contains(e)) {\n       \
    \         hm(e) += 1\n            } else {\n                hm(e) = 1\n      \
    \      }\n        }\n        for (e <- l) {\n            if (hm.contains(-e))\
    \ {\n                if (e != 0) {\n                    return true\n        \
    \        } else {\n                    if (hm(e) > 1) {\n                    \
    \    return true\n                    }\n                }\n            }\n  \
    \      }\n        return false", "        var m = new HashMap[Long, Boolean]()\n\
    \        for (x <- l) {\n            if (m.contains(x))\n                return\
    \ true\n            m += (x -> true)\n        }\n        return false", "    \
    \    if (l.length <= 1) return false\n        val s = l.toSet\n        for (i\
    \ <- l) {\n            if (s.contains(-i)) return true\n        }\n        return\
    \ false"]
stop_tokens:
- "\n    }\n"
