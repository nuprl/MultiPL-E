name: HumanEval_29_filter_by_prefix
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Filter an input list of strings only for ones that start with a given prefix.\n\
  \    // >>> filter_by_prefix([], 'a')\n    // []\n    // >>> filter_by_prefix(['abc',\
  \ 'bcd', 'cde', 'array'], 'a')\n    // ['abc', 'array']\n    def filterByPrefix(strings\
  \ : List[String], prefix : String) : List[String] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(filterByPrefix((List[String]()),\
  \ (\"john\")).equals((List[String]())));\n    assert(filterByPrefix((List[String](\"\
  xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\")), (\"xxx\")).equals((List[String](\"\
  xxx\", \"xxxAAA\", \"xxx\"))));\n    }\n\n}\n"
completions: ["        var result = List[String]()\n        strings.foreach(e => {\n\
    \            if (e.startsWith(prefix)) result = e :: result\n        })\n    \
    \    result", "        // Case 1: strings is empty\n        if (strings.isEmpty)\
    \ List()\n        // Case 2: strings is not empty\n        else {\n          \
    \  // Step 1: Find the first string that starts with the prefix\n            val\
    \ firstStringIndex = strings.indexWhere(string => string.startsWith(prefix))\n\
    \            // Step 2: If there is no string starting with the prefix, then the\
    \ list is empty.\n            if (firstStringIndex == -1) List()\n           \
    \ // Step 3: Otherwise, the list is the string starting with the prefix\n    \
    \        // and the recursive call on the remaining list elements.\n         \
    \   else {\n                strings(firstStringIndex) :: filterByPrefix(strings.drop(firstStringIndex\
    \ + 1), prefix)\n            }\n        }", '        strings.filter(_.startsWith(prefix))',
  "    \tval result = strings.filter(s => s.startsWith(prefix))\n    \tresult", " \
    \       var filteredList = new ListBuffer[String]()\n        for (string <- strings)\
    \ {\n            if (string.startsWith(prefix)) filteredList += string\n     \
    \   }\n        filteredList.toList", '        return strings.filter(_.startsWith(prefix))',
  "        if (strings.isEmpty)\n            Nil\n        else if (strings.head.startsWith(prefix))\n\
    \            strings.head :: filterByPrefix(strings.tail, prefix)\n        else\n\
    \            filterByPrefix(strings.tail, prefix)", '        strings.filter(s
    => s.startsWith(prefix))', '        return strings.filter(s => s.startsWith(prefix))',
  '        strings.filter(x => x.startsWith(prefix))', "        if (strings.isEmpty)\
    \ return List()\n        var s = strings.head\n        if (s.startsWith(prefix))\n\
    \            return strings.head :: filterByPrefix(strings.tail, prefix)\n   \
    \     else\n            return filterByPrefix(strings.tail, prefix)", "      \
    \  var arr = List[String]()\n        strings.foreach( str => {\n            if\
    \ (str.startsWith(prefix)) {\n                arr = arr :+ str\n            }\n\
    \        })\n        arr", '        strings.filter(p => p.startsWith(prefix))',
  "        def go(prefix : String, strings : List[String]) : List[String] = {\n  \
    \          strings match {\n                case Nil => Nil\n                case\
    \ head :: tail => {\n                    if (head.startsWith(prefix)) {\n    \
    \                    head :: go(prefix, tail)\n                    } else {\n\
    \                        go(prefix, tail)\n                    }\n           \
    \     }\n            }\n        }\n        go(prefix, strings)", "        def\
    \ isPrefix(s : String) : Boolean = {\n            s.length >= prefix.length &&\
    \ s.slice(0, prefix.length) == prefix\n        }\n        strings.filter(isPrefix)",
  '        strings.filter(s => s.startsWith(prefix))', '        strings.filter(s =>
    s.startsWith(prefix))', "        val s = strings.filter(x => x.startsWith(prefix))\n\
    \        println(s)\n        s", '        strings.filter(p => p.startsWith(prefix))',
  "        // Base case\n        if (strings.isEmpty) return strings\n        // If\
    \ current string has prefix, keep it\n        else if (strings.head.startsWith(prefix))\
    \ strings.head :: filterByPrefix(strings.tail, prefix)\n        // If not, don't\
    \ keep it\n        else filterByPrefix(strings.tail, prefix)"]
stop_tokens:
- "\n    }\n"
