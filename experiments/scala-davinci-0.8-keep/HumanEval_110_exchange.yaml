name: HumanEval_110_exchange
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // In this problem, you will implement a function that takes two lists of numbers,\n\
  \    // and determines whether it is possible to perform an exchange of elements\n\
  \    // between them to make lst1 a list of only even numbers.\n    // There is\
  \ no limit on the number of exchanged elements between lst1 and lst2.\n    // If\
  \ it is possible to exchange elements between the lst1 and lst2 to make\n    //\
  \ all the elements of lst1 to be even, return \"YES\".\n    // Otherwise, return\
  \ \"NO\".\n    // For example:\n    // exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"\
  YES\"\n    // exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    // It is assumed\
  \ that the input lists will be non-empty.\n    def exchange(lst1 : List[Long], lst2\
  \ : List[Long]) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(exchange((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
  \ 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong,\
  \ 3l.toLong, 4l.toLong)), (List[Long](1l.toLong, 5l.toLong, 3l.toLong, 4l.toLong))).equals((\"\
  NO\")));\n    assert(exchange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong)),\
  \ (List[Long](2l.toLong, 1l.toLong, 4l.toLong, 3l.toLong))).equals((\"YES\")));\n\
  \    assert(exchange((List[Long](5l.toLong, 7l.toLong, 3l.toLong)), (List[Long](2l.toLong,\
  \ 6l.toLong, 4l.toLong))).equals((\"YES\")));\n    assert(exchange((List[Long](5l.toLong,\
  \ 7l.toLong, 3l.toLong)), (List[Long](2l.toLong, 6l.toLong, 3l.toLong))).equals((\"\
  NO\")));\n    assert(exchange((List[Long](3l.toLong, 2l.toLong, 6l.toLong, 1l.toLong,\
  \ 8l.toLong, 9l.toLong)), (List[Long](3l.toLong, 5l.toLong, 5l.toLong, 1l.toLong,\
  \ 1l.toLong, 1l.toLong))).equals((\"NO\")));\n    assert(exchange((List[Long](100l.toLong,\
  \ 200l.toLong)), (List[Long](200l.toLong, 200l.toLong))).equals((\"YES\")));\n \
  \   }\n\n}\n"
completions: ['        ???', '        return if (lst1.map(_ % 2 == 0).reduce(_ & _))
    "YES" else "NO"', "        var cnt1 = 0\n        for (i <- lst1) {\n         \
    \   if (i % 2 == 1) cnt1 += 1\n        }\n        var cnt2 = 0\n        for (i\
    \ <- lst2) {\n            if (i % 2 == 1) cnt2 += 1\n        }\n        if (cnt1\
    \ == cnt2) \"YES\" else \"NO\"", "        val evens = lst1.filter { _ % 2 == 0\
    \ }\n        val odds = lst2.filter { _ % 2 == 1 }\n        if (evens.size ==\
    \ lst1.size) return \"YES\"\n        if (odds.size == lst2.size) return \"NO\"\
    \n        if (evens.size + odds.size >= lst1.size) return \"YES\"\n        \"\
    NO\"", '        null', "        val odd1 = lst1.filter(x => x % 2 == 1)\n    \
    \    val odd2 = lst2.filter(x => x % 2 == 1)\n        if (odd1.size == odd2.size)\
    \ return \"YES\"\n        return \"NO\"", '        return ""', "        val odd1\
    \ = lst1.filter(_ % 2 == 1)\n        val odd2 = lst2.filter(_ % 2 == 1)\n    \
    \    if (odd1.size < odd2.size) \"YES\" else \"NO\"", "        def f(lst1 : List[Long],\
    \ lst2 : List[Long], index : Int) : Boolean = {\n            if (index == lst1.length)\
    \ {\n                true\n            } else if (lst1(index) % 2 == 0) {\n  \
    \              f(lst1, lst2, index + 1)\n            } else {\n              \
    \  var result = false\n                for (i <- 0 until lst2.length) {\n    \
    \                if (lst2(i) % 2 == 0) {\n                        val temp = lst1(index)\n\
    \                        lst1(index) = lst2(i)\n                        lst2(i)\
    \ = temp\n                        result = result || f(lst1, lst2, index + 1)\n\
    \                        lst2(i) = lst1(index)\n                        lst1(index)\
    \ = temp\n                    }\n                }\n                result\n \
    \           }\n        }\n        if (f(lst1, lst2, 0)) \"YES\" else \"NO\"",
  "        val st1 = new Stack[Long]\n        val st2 = new Stack[Long]\n        var\
    \ ans = true\n        lst1.foreach(st1.push(_))\n        lst2.foreach(st2.push(_))\n\
    \        while (ans && !st1.isEmpty) {\n            if (st1.top % 2 == 1) {\n\
    \                if (st2.isEmpty) ans = false\n                else {\n      \
    \              val tmp = st1.pop\n                    st1.push(st2.pop)\n    \
    \                st2.push(tmp)\n                }\n            }\n           \
    \ else st1.pop\n        }\n        if (ans) \"YES\" else \"NO\"", '        ???',
  "        var lst1even = lst1.filter(_ % 2 == 0)\n        var lst1odd = lst1.filter(_\
    \ % 2 != 0)\n        val lst2odd = lst2.filter(_ % 2 != 0)\n        val lst2even\
    \ = lst2.filter(_ % 2 == 0)\n        if (lst1odd.size > lst2even.size) return\
    \ \"NO\"\n        for (x <- lst1odd) {\n            val lst1even_ = lst1even +\
    \ x\n            val lst2even_ = lst2even.filter(_ % x != 0)\n            if (lst1even_.size\
    \ == lst1.size) return \"YES\"\n            else if (exchange(lst1even_, lst2even_)\
    \ == \"YES\") return \"YES\"\n        }\n        \"NO\"", "        val odds =\
    \ lst1.filter(x => x % 2 == 1)\n        if (odds.length == 0) return \"YES\"\n\
    \        val evens = lst2.filter(x => x % 2 == 0)\n        if (evens.length ==\
    \ 0) return \"NO\"\n        return \"YES\"", "        var len1 = lst1.length\n\
    \        var len2 = lst2.length\n        var map1 = new HashMap[Long, Int]\n \
    \       var map2 = new HashMap[Long, Int]\n        var odd1 = 0\n        var odd2\
    \ = 0\n        lst1.foreach(x => {\n            if (!map1.contains(x)) map1 +=\
    \ (x -> 1)\n            else map1(x) += 1\n            if (x % 2 == 1) odd1 +=\
    \ 1\n        })\n        lst2.foreach(x => {\n            if (!map2.contains(x))\
    \ map2 += (x -> 1)\n            else map2(x) += 1\n            if (x % 2 == 1)\
    \ odd2 += 1\n        })\n        // exchange elements between the two lists\n\
    \        var odd = min(odd1, odd2)\n        if (odd == 0) return \"YES\"\n   \
    \     val odd3 = odd % 2\n        var even1 = len1 - odd1\n        var even2 =\
    \ len2 - odd2\n        var even = min(even1, even2)\n        if (even == 0) return\
    \ \"NO\"\n        val even3 = even % 2\n        if (odd3 + even3 == 0) return\
    \ \"YES\"\n        else return \"NO\"", "        var lst1_odd = new ListBuffer[Long]()\n\
    \        var lst2_even = new ListBuffer[Long]()\n        for (i <- lst1) {\n \
    \           if (i % 2 == 1) lst1_odd += i\n        }\n        for (i <- lst2)\
    \ {\n            if (i % 2 == 0) lst2_even += i\n        }\n        if (lst1_odd.size\
    \ > lst2_even.size) return \"NO\"\n        return \"YES\"", "        val hm =\
    \ HashMap[Long, Long]()\n        lst1.foreach(x => if (!hm.contains(x)) hm(x)\
    \ = 1 else hm(x) += 1)\n        lst2.foreach(x => if (!hm.contains(x)) hm(x) =\
    \ -1 else hm(x) -= 1)\n        val hm2 = HashMap[Long, Long]()\n        hm.foreach\
    \ {\n            case (x, y) =>\n                if (y > 0) {\n              \
    \      if (x % 2 == 0) return \"YES\"\n                    else {\n          \
    \              if (!hm2.contains(x)) hm2(x) = y\n                        else\
    \ hm2(x) += y\n                    }\n                }\n                else\
    \ if (y < 0) {\n                    if (x % 2 == 1) return \"YES\"\n         \
    \           else {\n                        if (!hm2.contains(x)) hm2(x) = y\n\
    \                        else hm2(x) += y\n                    }\n           \
    \     }\n        }\n        hm2.foreach {\n            case (x, y) =>\n      \
    \          if (y > 0) return \"NO\"\n        }\n        \"YES\"", "        val\
    \ n = lst1.size\n        val x = lst1.filter(x => x % 2 == 1)\n        val y =\
    \ lst2.filter(x => x % 2 == 1)\n        if (x.size > y.size) \"NO\" else \"YES\"",
  "        // Fill in the code here\n        \"YES\"", "        val n = lst1.length\n\
    \        val m = lst2.length\n        val s = new HashSet[Long]()\n        lst1.map(x\
    \ => s.add(x))\n        for (i <- 0 until n; j <- 0 until m) {\n            if\
    \ (lst1(i) % 2 == 1 && lst2(j) % 2 == 0) {\n                val v = lst1(i)\n\
    \                lst1(i) = lst2(j)\n                lst2(j) = v\n            \
    \    s.remove(v)\n                s.add(lst2(j))\n            }\n        }\n \
    \       if (s.forall(x => x % 2 == 0)) return \"YES\"\n        else return \"\
    NO\"", '        // Fill in the implementation here']
stop_tokens:
- "\n    }\n"
