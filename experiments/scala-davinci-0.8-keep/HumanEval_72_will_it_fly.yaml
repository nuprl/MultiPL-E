name: HumanEval_72_will_it_fly
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function that returns True if the object q will fly, and False otherwise.\n\
  \    // The object q will fly if it's balanced (it is a palindromic list) and the\
  \ sum of its elements is less than or equal the maximum possible weight w.\n   \
  \ // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n    // # 1+2 is less\
  \ than the maximum possible weight, but it's unbalanced.\n    // will_it_fly([3,\
  \ 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3 is more than the maximum\
  \ possible weight.\n    // will_it_fly([3, 2, 3], 9) \u279E True\n    // # 3+2+3\
  \ is less than the maximum possible weight, and it's balanced.\n    // will_it_fly([3],\
  \ 5) \u279E True\n    // # 3 is less than the maximum possible weight, and it's\
  \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
  \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
  \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
  \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
  \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
  \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
  \    }\n\n}\n"
completions: ["        var halfValue = 0L\n        for (i <- q.indices) {\n      \
    \      if (i == q.length / 2) halfValue = q(i)\n            else if (q(i) != q(q.length\
    \ - 1 - i)) return false\n        }\n        q.sum - halfValue <= w", "      \
    \  var flag = false\n        if (q.sum <= w) {\n            if (q.reverse == q)\
    \ flag = true\n        }\n        flag", "        if(q.length == 1) return true\n\
    \        if(q.length == 2) return q(0) == q(1)\n        if(q.length > 1) {\n \
    \           var m = Map[Long, Long]()\n            for(x <- q) {\n           \
    \     if(m.contains(x)) m(x) += 1\n                else m(x) = 1\n           \
    \ }\n            var b = m.map(x => x._2).toList.sorted\n            if(b.length\
    \ == 1) return true\n            else if(b.length == 2) {\n                if(b(0)\
    \ == 1 && b(1) == 2) return true\n                else return false\n        \
    \    }\n            else return false\n        }\n        else return false",
  "        def isBalanced(q : List[Long]) : Boolean = {\n            def helper(q\
    \ : List[Long], acc : List[Long]) : Boolean = {\n                if (q.isEmpty)\
    \ acc.isEmpty\n                else if (q.head != acc.head) false\n          \
    \      else helper(q.tail, acc.tail)\n            }\n            helper(q, q.reverse)\n\
    \        }\n        q.sum <= w && isBalanced(q)", "        if (q.length <= 1)\
    \ return true\n        if (q.sum <= w) {\n            var first = q.head\n   \
    \         var last = q.last\n            for (i <- 0 until q.length/2) {\n   \
    \             if (first != last) return false\n                first = q(i + 1)\n\
    \                last = q(q.length - i - 2)\n            }\n            return\
    \ true\n        }\n        return false", '        q.sum <= w && q == q.reverse',
  "        def isPalindrome(q : List[Long]) : Boolean = q == q.reverse\n        if\
    \ (q.sum <= w && isPalindrome(q)) true else false", "        val sum = q.sum\n\
    \        val rev = q.reverse\n        sum <= w && q == rev", "        var b =\
    \ true\n        if (q.sum > w) b = false\n        else {\n            var list\
    \ = q.sortWith(_ < _)\n            var reversed = list.reverse\n            if\
    \ (list != reversed) b = false\n        }\n        b", '        return q.sum <=
    w && q == q.reverse', "        val sum = q.sum\n        val palindrome = q.reverse\
    \ == q\n        palindrome && sum <= w", "        if (q.length % 2 == 0) return\
    \ false\n        var l = q.length\n        for (i <- 0 until l / 2) {\n      \
    \      if (q(i) != q(l - i - 1)) return false\n        }\n        if (q.sum <=\
    \ w) return true\n        false", "        val sum = q.sum\n        if (sum >\
    \ w) return false\n        val m = q.max\n        if (m * 2 > w) return false\n\
    \        val list = Array.fill(2 * m.toInt + 1)(false)\n        q.foreach(e =>\
    \ list(e.toInt) = true)\n        for (i <- q.indices) {\n            val e = q(i)\n\
    \            if (list(w.toInt - e.toInt)) return true\n        }\n        false",
  "        var sum = 0L\n        for (i <- q) sum += i\n        if (sum > w) return\
    \ false\n        if (q.isEmpty) return true\n        return q == q.reverse", " \
    \       def isBalanced(q : List[Long]) : Boolean = {\n            def recurse(q\
    \ : List[Long], front : List[Long]) : Boolean = {\n                if (q.length\
    \ == 0) true\n                else if (q.head == front.head) recurse(q.tail, front.tail)\n\
    \                else false\n            }\n            recurse(q, q.reverse)\n\
    \        }\n        if (q.length == 0) true\n        else if (q.sum <= w && isBalanced(q))\
    \ true\n        else false", '        q == q.reverse && q.reduce(_ + _) <= w',
  "        val sum = q.sum\n        val limit = w - sum\n        q.size match {\n\
    \            case 1 => true\n            case 2 => q(0) == q(1)\n            case\
    \ _ => {\n                val half = q.size / 2\n                val lower = q.slice(0,\
    \ half)\n                val upper = if (q.size % 2 == 0) q.slice(half, q.size)\
    \ else q.slice(half + 1, q.size)\n                val lowerSum = lower.sum\n \
    \               val upperSum = upper.sum\n                val lowerUpperSum =\
    \ lowerSum + upperSum\n                val lowerUpperLimit = limit - lowerSum\n\
    \                val lowerUpperLimitNonZero = lowerUpperLimit != 0\n         \
    \       val rightUpperSum = lowerUpperSum + lowerUpperLimit\n                if\
    \ (rightUpperSum > upperSum) false\n                else if (rightUpperSum ==\
    \ upperSum) lowerUpperLimitNonZero\n                else if (rightUpperSum + lowerUpperLimit\
    \ == upperSum) lowerUpperLimitNonZero\n                else if (rightUpperSum\
    \ + 2 * lowerUpperLimit == upperSum) lowerUpperLimitNonZero\n                else\
    \ true\n            }\n        }", "    \tvar temp = true\n    \tvar sum = 0L\n\
    \    \tfor (i <- q) {\n    \t\tsum += i\n    \t}\n    \tif (sum > w) temp = false\n\
    \    \tif (q.length == 1) return temp\n    \tfor (i <- 0 until q.length / 2) {\n\
    \    \t\tif (q(i) != q(q.length - 1 - i)) temp = false\n    \t}\n    \treturn\
    \ temp", "        val s = q.sum\n        val isBalanced = q == q.reverse\n   \
    \     s <= w && isBalanced", "        if (q.length <= 1) return true\n       \
    \ var flag = false\n        for (i <- 0 until q.length / 2) if (q(i) != q(q.length\
    \ - 1 - i)) flag = true\n        if (flag) return false\n        var sum = 0L\n\
    \        for (i <- q) sum += i\n        return sum <= w"]
stop_tokens:
- "\n    }\n"
