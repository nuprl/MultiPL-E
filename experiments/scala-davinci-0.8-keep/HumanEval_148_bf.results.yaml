language: scala
name: HumanEval_148_bf
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // bf(\"Jupiter\"\
    , \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    // bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n    // bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\")\n    def bf(planet1 : String, planet2 : String)\
    \ : List[String] = {\n        val planet_array = Array(\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n   \
    \     var bf_array = new ArrayBuffer[String]()\n        var flag = false\n   \
    \     var b = 0\n        var e = 0\n        for (i <- 0 until planet_array.length)\
    \ {\n            if (planet_array(i) == planet1) {\n                b = i\n  \
    \              flag = true\n            }\n            if (planet_array(i) ==\
    \ planet2) {\n                e = i\n                flag = true\n           \
    \ }\n        }\n        if (flag == false) return List()\n        if (b < e) {\n\
    \            for (i <- b until e + 1) {\n                bf_array += planet_array(i)\n\
    \            }\n        } else {\n            for (i <- e until b + 1) {\n   \
    \             bf_array += planet_array(i)\n            }\n        }\n        return\
    \ bf_array.toList\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptk5rtsir.scala:46)\n\tat Problem.main(tmptk5rtsir.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821011
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // bf(\"Jupiter\"\
    , \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    // bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n    // bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\")\n    def bf(planet1 : String, planet2 : String)\
    \ : List[String] = {\n        var l = new ListBuffer[String]\n        var s =\
    \ if (planet1 < planet2) planet1 else planet2\n        var e = if (planet1 < planet2)\
    \ planet2 else planet1\n        if (s == \"Mercury\") {\n            s = \"Venus\"\
    \n            l += \"Mercury\"\n        }\n        if (e == \"Venus\") {\n   \
    \         e = \"Mercury\"\n            l += \"Venus\"\n        }\n        if (s\
    \ == \"Earth\") {\n            s = \"Mars\"\n            l += \"Earth\"\n    \
    \    }\n        if (e == \"Mars\") {\n            e = \"Earth\"\n            l\
    \ += \"Mars\"\n        }\n        if (s == \"Jupiter\") {\n            s = \"\
    Saturn\"\n            l += \"Jupiter\"\n        }\n        if (e == \"Saturn\"\
    ) {\n            e = \"Jupiter\"\n            l += \"Saturn\"\n        }\n   \
    \     if (s == \"Uranus\") {\n            s = \"Neptune\"\n            l += \"\
    Uranus\"\n        }\n        if (e == \"Neptune\") {\n            e = \"Uranus\"\
    \n            l += \"Neptune\"\n        }\n        if (s == \"Neptune\" || e ==\
    \ \"Venus\") {\n            l.clear\n        }\n        return l.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_mwc3ud7.scala:59)\n\tat Problem.main(tmp_mwc3ud7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821011
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // bf(\"Jupiter\"\
    , \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    // bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n    // bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\")\n    def bf(planet1 : String, planet2 : String)\
    \ : List[String] = {\n        // your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpc6vxxuqx.scala:17:64\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m    \e[33mdef\e[0m \e[36mbf\e\
    [0m(\e[36mplanet1\e[0m : \e[35mString\e[0m, \e[36mplanet2\e[0m : \e[35mString\e\
    [0m) : \e[35mList\e[0m[\e[35mString\e[0m] = {\n\e[31m\e[31m   |\e[0m         \
    \                                                       ^\e[0m\n\e[31m   |\e[0m\
    \                                                  Found:    Unit\n\e[31m   |\e\
    [0m                                                  Required: List[String]\n\e\
    [31m18 |\e[0m        \e[34m// your code here\e[0m\n\e[31m19 |\e[0m    }\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659821010
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // bf(\"Jupiter\"\
    , \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    // bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n    // bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\")\n    def bf(planet1 : String, planet2 : String)\
    \ : List[String] = {\n        var planets = List[String](\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n   \
    \     var index1 = planets.indexOf(planet1)\n        var index2 = planets.indexOf(planet2)\n\
    \        if (index1 == -1 || index2 == -1) return List[String]()\n        if (index1\
    \ < index2) planets.slice(index1, index2 + 1)\n        else planets.slice(index2,\
    \ index1 + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"\
    Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n\
    \    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n\
    \    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"),\
    \ (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgyb_8pwo.scala:26)\n\tat Problem.main(tmpgyb_8pwo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821011
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // bf(\"Jupiter\"\
    , \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    // bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n    // bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\")\n    def bf(planet1 : String, planet2 : String)\
    \ : List[String] = {\n        val planet_pos = Map(\"Mercury\" -> 1, \"Venus\"\
    \ -> 2, \"Earth\" -> 3, \n            \"Mars\" -> 4, \"Jupiter\" -> 5, \"Saturn\"\
    \ -> 6, \"Uranus\" -> 7, \n            \"Neptune\" -> 8)\n        val pos1 = planet_pos.get(planet1)\n\
    \        val pos2 = planet_pos.get(planet2)\n        if (pos1 == None || pos2\
    \ == None) {\n            List()\n        } else {\n            val min_pos =\
    \ min(pos1.get, pos2.get)\n            val max_pos = max(pos1.get, pos2.get)\n\
    \            val range = min_pos to max_pos\n            val planets = planet_pos.filterKeys(planet\
    \ => range.contains(planet_pos(planet)))\n            planets.keys.toList.sorted\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsq0l_76l.scala:34)\n\tat Problem.main(tmpsq0l_76l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821012
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // bf(\"Jupiter\"\
    , \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    // bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n    // bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\")\n    def bf(planet1 : String, planet2 : String)\
    \ : List[String] = {\n        val planets = Map(\"Mercury\" -> 1, \"Venus\" ->\
    \ 2, \"Earth\" -> 3, \"Mars\" -> 4, \"Jupiter\" -> 5, \"Saturn\" -> 6, \"Uranus\"\
    \ -> 7, \"Neptune\" -> 8)\n        var p1 = planets.get(planet1)\n        var\
    \ p2 = planets.get(planet2)\n        if (p1 == None || p2 == None) {\n       \
    \     return List()\n        }\n        if (p1.get < p2.get) {\n            p1\
    \ = planets.get(planet2)\n            p2 = planets.get(planet1)\n        }\n \
    \       var result = List[String]()\n        for (planet <- planets) {\n     \
    \       if (planet._2 >= p2.get && planet._2 < p1.get) {\n                result\
    \ = planet._1 :: result\n            }\n        }\n        return result\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx7ajxn5l.scala:37)\n\tat Problem.main(tmpx7ajxn5l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821012
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // bf(\"Jupiter\"\
    , \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    // bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n    // bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\")\n    def bf(planet1 : String, planet2 : String)\
    \ : List[String] = {\n        List()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_3c7biic.scala:21)\n\tat Problem.main(tmp_3c7biic.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821011
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // bf(\"Jupiter\"\
    , \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    // bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n    // bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\")\n    def bf(planet1 : String, planet2 : String)\
    \ : List[String] = {\n        // Your code here\n        var planets = List(\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\")\n        var startIndex = planets.indexOf(planet1)\n        var\
    \ endIndex = planets.indexOf(planet2)\n        if (startIndex > endIndex) {\n\
    \            planets = planets.slice(endIndex, startIndex)\n        } else {\n\
    \            planets = planets.slice(startIndex, endIndex)\n        }\n      \
    \  planets\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5lud4swp.scala:30)\n\tat Problem.main(tmp5lud4swp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821011
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // bf(\"Jupiter\"\
    , \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    // bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n    // bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\")\n    def bf(planet1 : String, planet2 : String)\
    \ : List[String] = {\n    \tval planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    \tval planetIndexes\
    \ = Map(\"Mercury\" -> 0, \"Venus\" -> 1, \"Earth\" -> 2, \"Mars\" -> 3, \"Jupiter\"\
    \ -> 4, \"Saturn\" -> 5, \"Uranus\" -> 6, \"Neptune\" -> 7)\n    \tval start =\
    \ planetIndexes(planet1)\n    \tval end = planetIndexes(planet2)\n    \tList()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprs4tecd6.scala:25)\n\tat Problem.main(tmprs4tecd6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821011
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // bf(\"Jupiter\"\
    , \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    // bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n    // bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\")\n    def bf(planet1 : String, planet2 : String)\
    \ : List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val p1\
    \ = planets.indexOf(planet1)\n        val p2 = planets.indexOf(planet2)\n    \
    \    if (p1 == -1 || p2 == -1) {\n            List()\n        } else {\n     \
    \       if (p1 < p2) {\n                planets.slice(p1+1, p2)\n            }\
    \ else {\n                planets.slice(p2+1, p1).reverse\n            }\n   \
    \     }\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3l_s95h4.scala:35)\n\tat Problem.main(tmp3l_s95h4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821012
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // bf(\"Jupiter\"\
    , \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    // bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n    // bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\")\n    def bf(planet1 : String, planet2 : String)\
    \ : List[String] = {\n        val planetlist = List(\"Mercury\", \"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n       \
    \ val pos1 = planetlist.indexOf(planet1)\n        val pos2 = planetlist.indexOf(planet2)\n\
    \        if (pos1 < 0 || pos2 < 0) return List()\n        planetlist.slice(min(pos1,\
    \ pos2) + 1, max(pos1, pos2))\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\",\
    \ \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821011
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // bf(\"Jupiter\"\
    , \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    // bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n    // bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\")\n    def bf(planet1 : String, planet2 : String)\
    \ : List[String] = {\n        if (planet1 == \"Mercury\") {\n            planet2\
    \ match {\n                case \"Venus\" => List(\"Venus\")\n               \
    \ case \"Earth\" => List(\"Venus\", \"Earth\")\n                case \"Mars\"\
    \ => List(\"Venus\", \"Earth\", \"Mars\")\n                case \"Jupiter\" =>\
    \ List(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\")\n                case \"Saturn\"\
    \ => List(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n         \
    \       case \"Uranus\" => List(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \"Uranus\")\n                case \"Neptune\" => List(\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n       \
    \         case _ => List()\n            }\n        } else if (planet1 == \"Venus\"\
    ) {\n            planet2 match {\n                case \"Earth\" => List(\"Earth\"\
    )\n                case \"Mars\" => List(\"Earth\", \"Mars\")\n              \
    \  case \"Jupiter\" => List(\"Earth\", \"Mars\", \"Jupiter\")\n              \
    \  case \"Saturn\" => List(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n   \
    \             case \"Uranus\" => List(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\")\n                case \"Neptune\" => List(\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n                case _ => List()\n\
    \            }\n        } else if (planet1 == \"Earth\") {\n            planet2\
    \ match {\n                case \"Mars\" => List(\"Mars\")\n                case\
    \ \"Jupiter\" => List(\"Mars\", \"Jupiter\")\n                case \"Saturn\"\
    \ => List(\"Mars\", \"Jupiter\", \"Saturn\")\n                case \"Uranus\"\
    \ => List(\"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\")\n                case\
    \ \"Neptune\" => List(\"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n                case _ => List()\n            }\n        } else if (planet1\
    \ == \"Mars\") {\n            planet2 match {\n                case \"J\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp9uk1jnbc.scala:50:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m                \e[33mcase\e[0m \"J\n\e[31m\e[31m   |\e\
    [0m                     ^\e[0m\n\e[31m   |\e[0m                     unclosed string\
    \ literal\n\e[31m\e[31m-- Error: /tmp/tmp9uk1jnbc.scala:52:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9uk1jnbc.scala:63:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m63 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp9uk1jnbc.scala:52:4 -------------------------\e[0m\e[0m\n\
    \e[31m52 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m\
    \    Not found: Jdef\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659821009
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // bf(\"Jupiter\"\
    , \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    // bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n    // bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\")\n    def bf(planet1 : String, planet2 : String)\
    \ : List[String] = {\n        if (planet1 == \"Mercury\") {\n            if (planet2\
    \ == \"Venus\") return List(\"Venus\")\n            if (planet2 == \"Earth\")\
    \ return List(\"Venus\", \"Earth\")\n            if (planet2 == \"Mars\") return\
    \ List(\"Venus\", \"Earth\", \"Mars\")\n            if (planet2 == \"Jupiter\"\
    ) return List(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\")\n            if (planet2\
    \ == \"Saturn\") return List(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    )\n            if (planet2 == \"Uranus\") return List(\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\")\n            if (planet2 == \"Neptune\"\
    ) return List(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\")\n        }\n        if (planet1 == \"Venus\") {\n            if\
    \ (planet2 == \"Earth\") return List(\"Earth\")\n            if (planet2 == \"\
    Mars\") return List(\"Earth\", \"Mars\")\n            if (planet2 == \"Jupiter\"\
    ) return List(\"Earth\", \"Mars\", \"Jupiter\")\n            if (planet2 == \"\
    Saturn\") return List(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n        \
    \    if (planet2 == \"Uranus\") return List(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\")\n            if (planet2 == \"Neptune\") return List(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n       \
    \ }\n        if (planet1 == \"Earth\") {\n            if (planet2 == \"Mars\"\
    ) return List(\"Mars\")\n            if (planet2 == \"Jupiter\") return List(\"\
    Mars\", \"Jupiter\")\n            if (planet2 == \"Saturn\") return List(\"Mars\"\
    , \"Jupiter\", \"Saturn\")\n            if (planet2 == \"Uranus\") return List(\"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\")\n            if (planet2 == \"Neptune\"\
    ) return List(\"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Nept\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\"\
    )).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"\
    ), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"Mercury\"\
    ), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpflmrdgso.scala:40:89 -----------------------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            \e[33mif\e[0m (planet2 == \e[31m\"Neptune\"\
    \e[0m) \e[33mreturn\e[0m List(\e[31m\"Mars\"\e[0m, \e[31m\"Jupiter\"\e[0m, \e\
    [31m\"Saturn\"\e[0m, \e[31m\"Uranus\"\e[0m, \"Nept\n\e[31m\e[31m   |\e[0m    \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                            \
    \     unclosed string literal\n\e[31m\e[31m-- Error: /tmp/tmpflmrdgso.scala:42:34\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m42 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m\
    \                                 end of statement expected but '=' found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpflmrdgso.scala:53:0 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpflmrdgso.scala:42:4\
    \ -------------------------\e[0m\e[0m\n\e[31m42 |\e[0m    \e[33mdef\e[0m \e[36mmain\e\
    [0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m  \
    \ |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m    Not found: Neptdef\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659821008
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // bf(\"Jupiter\"\
    , \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    // bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n    // bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\")\n    def bf(planet1 : String, planet2 : String)\
    \ : List[String] = {\n        def swap[A](t: (A, A)) = (t._2, t._1)\n        def\
    \ getDistance(planet : String) : Int = {\n            planet match {\n       \
    \         case \"Mercury\" => 0\n                case \"Venus\" => 1\n       \
    \         case \"Earth\" => 2\n                case \"Mars\" => 3\n          \
    \      case \"Jupiter\" => 4\n                case \"Saturn\" => 5\n         \
    \       case \"Uranus\" => 6\n                case \"Neptune\" => 7\n        \
    \        case _ => -1\n            }\n        }\n        val (start, end) = swap(getDistance(planet1)\
    \ > getDistance(planet2) match {\n            case true => (planet2, planet1)\n\
    \            case false => (planet1, planet2)\n        })\n        val startDistance\
    \ = getDistance(start)\n        val endDistance = getDistance(end)\n        if\
    \ (startDistance == -1 || endDistance == -1) return List()\n        (for (i <-\
    \ startDistance to endDistance if i != startDistance && i != endDistance) yield\
    \ {\n            i match {\n                case 0 => \"Mercury\"\n          \
    \      case 1 => \"Venus\"\n                case 2 => \"Earth\"\n            \
    \    case 3 => \"Mars\"\n                case 4 => \"Jupiter\"\n             \
    \   case 5 => \"Saturn\"\n                case 6 => \"Uranus\"\n             \
    \   case 7 => \"Neptune\"\n            }\n        }).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppbuwqqr2.scala:53)\n\tat Problem.main(tmppbuwqqr2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821012
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // bf(\"Jupiter\"\
    , \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    // bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n    // bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\")\n    def bf(planet1 : String, planet2 : String)\
    \ : List[String] = {\n      // Fill Up this function body\n      // You can add\
    \ another function as well, if required\n      var planets = List(\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n      var planet1_index = planets.indexOf(planet1)\n      var planet2_index\
    \ = planets.indexOf(planet2)\n      var between = List[String]()\n      if (planet1_index\
    \ >= 0 && planet2_index >= 0) {\n        if (planet1_index < planet2_index) {\n\
    \          for (i <- planet1_index + 1 until planet2_index) {\n            between\
    \ = between :+ planets(i)\n          }\n        } else {\n          for (i <-\
    \ planet2_index + 1 until planet1_index) {\n            between = between :+ planets(i)\n\
    \          }\n        }\n      }\n      between\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821012
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // bf(\"Jupiter\"\
    , \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    // bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n    // bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\")\n    def bf(planet1 : String, planet2 : String)\
    \ : List[String] = {\n        val list = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        if (list.contains(planet1)\
    \ && list.contains(planet2)) {\n            val start = list.indexOf(planet1)\n\
    \            val end = list.indexOf(planet2)\n            if (start > end) list.slice(end,\
    \ start+1)\n            else list.slice(start, end+1)\n        }\n        else\
    \ Nil\n    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"\
    ), (\"Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq20v51_s.scala:28)\n\tat Problem.main(tmpq20v51_s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821011
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // bf(\"Jupiter\"\
    , \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    // bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n    // bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\")\n    def bf(planet1 : String, planet2 : String)\
    \ : List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val ind1\
    \ = planets.indexOf(planet1)\n        val ind2 = planets.indexOf(planet2)\n  \
    \      (ind1, ind2) match {\n            case (a, b) if a == -1 || b == -1 =>\
    \ List()\n            case (a, b) if a > b => planets.slice(b + 1, a)\n      \
    \      case (a, b) => planets.slice(a + 1, b)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821012
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // bf(\"Jupiter\"\
    , \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    // bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n    // bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\")\n    def bf(planet1 : String, planet2 : String)\
    \ : List[String] = {\n    \tval planets = Map(\"Mercury\" -> 1, \"Venus\" -> 2,\
    \ \"Earth\" -> 3, \"Mars\" -> 4, \"Jupiter\" -> 5, \"Saturn\" -> 6, \"Uranus\"\
    \ -> 7, \"Neptune\" -> 8)\n    \tif (planets.contains(planet1) && planets.contains(planet2))\
    \ {\n    \t\tList.range(min(planets(planet1), planets(planet2)) + 1, max(planets(planet1),\
    \ planets(planet2))).map(planets.map(_.swap)).map(_.apply(_)).toList\n    \t}\
    \ else {\n    \t\tList()\n    \t}\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"Saturn\"\
    , \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpl6u2hdby.scala:20:134 --------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m    \t\tList.range(min(planets(planet1), planets(planet2))\
    \ + \e[31m1\e[0m, max(planets(planet1), planets(planet2))).map(planets.map(_.swap)).map(_.apply(_)).toList\n\
    \e[31m\e[31m   |\e[0m    \t\t                                                \
    \                                                                            \
    \  ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 Wrong number\
    \ of parameters, expected: 1\n1 error found\n"
  stdout: ''
  timestamp: 1659821010
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // bf(\"Jupiter\"\
    , \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    // bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n    // bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\")\n    def bf(planet1 : String, planet2 : String)\
    \ : List[String] = {\n        val sequence = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val i1\
    \ = sequence.indexOf(planet1)\n        val i2 = sequence.indexOf(planet2)\n  \
    \      if (i1 < 0 || i2 < 0) List()\n        else if (i1 <= i2) sequence.slice(i1,\
    \ i2 + 1)\n        else sequence.slice(i2, i1 + 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"Neptune\")).equals((List[String](\"\
    Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Mercury\")).equals((List[String](\"\
    Venus\"))));\n    assert(bf((\"Mercury\"), (\"Uranus\")).equals((List[String](\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"\
    Neptune\"), (\"Venus\")).equals((List[String](\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"))));\n    assert(bf((\"Earth\"), (\"Earth\")).equals((List[String]())));\n\
    \    assert(bf((\"Mars\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"\
    Jupiter\"), (\"Makemake\")).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp79qutr1t.scala:26)\n\tat Problem.main(tmp79qutr1t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821011
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // There are eight planets in our solar system: the closerst to the Sun\
    \ \n    // is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n    // Uranus, Neptune.\n    // Write a function that takes two planet names\
    \ as strings planet1 and planet2. \n    // The function should return a tuple\
    \ containing all planets whose orbits are \n    // located between the orbit of\
    \ planet1 and the orbit of planet2, sorted by \n    // the proximity to the sun.\
    \ \n    // The function should return an empty tuple if planet1 or planet2\n \
    \   // are not correct planet names. \n    // Examples\n    // bf(\"Jupiter\"\
    , \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    // bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n    // bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\")\n    def bf(planet1 : String, planet2 : String)\
    \ : List[String] = {\n        val planets = List(\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n        val (p1,\
    \ p2) = if (planets.indexOf(planet1) < planets.indexOf(planet2)) (planet1, planet2)\
    \ else (planet2, planet1)\n        planets.slice(planets.indexOf(p1) + 1, planets.indexOf(p2))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(bf((\"Jupiter\"), (\"\
    Neptune\")).equals((List[String](\"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Mercury\")).equals((List[String](\"Venus\"))));\n    assert(bf((\"\
    Mercury\"), (\"Uranus\")).equals((List[String](\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"))));\n    assert(bf((\"Neptune\"), (\"Venus\")).equals((List[String](\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"))));\n    assert(bf((\"\
    Earth\"), (\"Earth\")).equals((List[String]())));\n    assert(bf((\"Mars\"), (\"\
    Earth\")).equals((List[String]())));\n    assert(bf((\"Jupiter\"), (\"Makemake\"\
    )).equals((List[String]())));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgkoi972l.scala:29)\n\tat Problem.main(tmpgkoi972l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659821011
