name: HumanEval_136_largest_smallest_integers
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Create a function that returns a tuple (a, b), where 'a' is\n    // the\
  \ largest of negative integers, and 'b' is the smallest\n    // of positive integers\
  \ in a list.\n    // If there is no negative or positive integers, return them as\
  \ None.\n    // Examples:\n    // largest_smallest_integers([2, 4, 1, 3, 5, 7])\
  \ == (None, 1)\n    // largest_smallest_integers([]) == (None, None)\n    // largest_smallest_integers([0])\
  \ == (None, None)\n    def largestSmallestIntegers(lst : List[Long]) : Tuple2[Option[Long],\
  \ Option[Long]] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n\
  \    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
  \ 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None), Some(1l))));\n\
  \    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
  \ 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n    assert(largestSmallestIntegers((List[Long](4l.toLong,\
  \ 5l.toLong, 3l.toLong, 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l,\
  \ 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong, 3l.toLong, 8l.toLong,\
  \ 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l, 2l)));\n\
  \    assert(largestSmallestIntegers((List[Long]())).equals((Some(None), Some(None))));\n\
  \    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
  \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
  \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
  \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
  \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
  \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
  \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l, 1l)));\n\
  \    }\n\n}\n"
completions: ["        val negatives = lst.filter(x => x < 0)\n        val positives\
    \ = lst.filter(x => x > 0)\n        (if (negatives.isEmpty) None else Some(negatives.max),\
    \ if (positives.isEmpty) None else Some(positives.min))", "        var smallest\
    \ : Option[Long] = None\n        var largest : Option[Long] = None\n        for\
    \ (x <- lst) {\n            if (x > 0) {\n                if (smallest == None)\
    \ smallest = Some(x)\n                else if (x < smallest.get) smallest = Some(x)\n\
    \            }\n            else if (x < 0) {\n                if (largest ==\
    \ None) largest = Some(x)\n                else if (x > largest.get) largest =\
    \ Some(x)\n            }\n        }\n        return (largest, smallest)", "  \
    \      if (lst.isEmpty) {\n            return (None, None)\n        }\n      \
    \  var maxNeg : Option[Long] = None\n        var minPos : Option[Long] = None\n\
    \        for (item <- lst) {\n            if (item < 0) {\n                if\
    \ (maxNeg == None || item > maxNeg.get) {\n                    maxNeg = Some(item)\n\
    \                }\n            } else if (item > 0) {\n                if (minPos\
    \ == None || item < minPos.get) {\n                    minPos = Some(item)\n \
    \               }\n            }\n        }\n        return (maxNeg, minPos)",
  "        if (lst.isEmpty) (None, None)\n        else {\n            val negs = lst.filter(_\
    \ < 0)\n            val poss = lst.filter(_ > 0)\n            if (negs.isEmpty)\
    \ (None, Some(poss.min))\n            else if (poss.isEmpty) (Some(negs.max),\
    \ None)\n            else (Some(negs.max), Some(poss.min))\n        }", "    \
    \    if (lst.length == 0) return (None, None)\n        var min : Option[Long]\
    \ = None\n        var max : Option[Long] = None\n        for (i <- lst) {\n  \
    \          if (i < 0) {\n                if (max == None || max.get < i) max =\
    \ Some(i)\n            } else if (i > 0) {\n                if (min == None ||\
    \ min.get > i) min = Some(i)\n            }\n        }\n        return (max, min)",
  "        var a : Option[Long] = None\n        var b : Option[Long] = None\n    \
    \    for (i <- lst) {\n            if (i < 0) {\n                if (a == None)\
    \ a = Some(i)\n                else if (i > a.get) a = Some(i)\n            }\n\
    \            else if (i > 0) {\n                if (b == None) b = Some(i)\n \
    \               else if (i < b.get) b = Some(i)\n            }\n        }\n  \
    \      return (a, b)", "        var positives = lst.filter(x => x > 0).sorted\n\
    \        var negatives = lst.filter(x => x < 0).sorted\n        if (positives.isEmpty)\
    \ (None, None)\n        else if (negatives.isEmpty) (None, Some(positives.head))\n\
    \        else (Some(negatives.last), Some(positives.head))", "        var lLst\
    \ = lst.sorted\n        var rLst = lLst.reverse\n        if (lLst.size > 0) {\n\
    \            if (lLst.head > 0) {\n                (None, Some(lLst.head))\n \
    \           } else if (rLst.head < 0) {\n                (Some(rLst.head), None)\n\
    \            } else {\n                (None, None)\n            }\n        }\
    \ else {\n            (None, None)\n        }", "        var negativeNumbers =\
    \ List[Long]()\n        var positiveNumbers = List[Long]()\n        var largestNegativeNumber\
    \ = None : Option[Long]\n        var smallestPositiveNumber = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i > 0) positiveNumbers = i :: positiveNumbers\n\
    \            else if (i < 0) negativeNumbers = i :: negativeNumbers\n        }\n\
    \        if (negativeNumbers.size != 0) largestNegativeNumber = Some(negativeNumbers.max)\n\
    \        if (positiveNumbers.size != 0) smallestPositiveNumber = Some(positiveNumbers.min)\n\
    \        return (largestNegativeNumber, smallestPositiveNumber)", "        val\
    \ sorted = lst.sorted\n        (sorted.headOption, sorted.lastOption)", "    \
    \    if (lst.length == 0) {\n            return (None, None)\n        }\n    \
    \    var smallest = Long.MaxValue\n        var largest = Long.MinValue\n     \
    \   for (x <- lst) {\n            if (x >= 0) {\n                if (x < smallest)\
    \ {\n                    smallest = x\n                }\n            } else {\n\
    \                if (x > largest) {\n                    largest = x\n       \
    \         }\n            }\n        }\n        if (largest == Long.MinValue) {\n\
    \            return (None, Some(smallest))\n        }\n        if (smallest ==\
    \ Long.MaxValue) {\n            return (Some(largest), None)\n        }\n    \
    \    return (Some(largest), Some(smallest))", "        // Fill in code here!\n\
    \        Tuple2(None, None)", "        var maxN = None : Option[Long]\n      \
    \  var minP = None : Option[Long]\n        lst.foreach(x => {\n            if\
    \ (x < 0) {\n                if (maxN.isEmpty || x > maxN.get) maxN = Some(x)\n\
    \            } else if (x > 0) {\n                if (minP.isEmpty || x < minP.get)\
    \ minP = Some(x)\n            }\n        })\n        (maxN, minP)", "        val\
    \ len = lst.length\n        if (len == 0) {\n            (None, None)\n      \
    \  } else {\n            var largestNeg = Long.MinValue\n            var smallestPos\
    \ = Long.MaxValue\n            for (i <- 0 until len) {\n                if (lst(i)\
    \ < 0) {\n                    largestNeg = max(largestNeg, lst(i))\n         \
    \       } else if (lst(i) > 0) {\n                    smallestPos = min(smallestPos,\
    \ lst(i))\n                }\n            }\n            if (largestNeg == Long.MinValue)\
    \ {\n                (None, Some(smallestPos))\n            } else if (smallestPos\
    \ == Long.MaxValue) {\n                (Some(largestNeg), None)\n            }\
    \ else {\n                (Some(largestNeg), Some(smallestPos))\n            }\n\
    \        }", "        val minPos = lst.filter(_ > 0).min\n        val maxNeg =\
    \ lst.filter(_ < 0).max\n        (if (maxNeg == Long.MinValue) None else Some(maxNeg),\
    \ if (minPos == Long.MaxValue) None else Some(minPos))", "        var largestNegative\
    \ = None:Option[Long]\n        var smallestPositive = None:Option[Long]\n    \
    \    for (n <- lst) {\n            if (n >= 0) {\n                if (smallestPositive\
    \ == None || n < smallestPositive.get) smallestPositive = Some(n)\n          \
    \  } else {\n                if (largestNegative == None || n > largestNegative.get)\
    \ largestNegative = Some(n)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        val positives = lst.filter(_ > 0)\n        val\
    \ negatives = lst.filter(_ < 0)\n        if (positives.isEmpty && negatives.isEmpty)\
    \ return (None, None)\n        (if (negatives.isEmpty) None else Some(negatives.max),\
    \ if (positives.isEmpty) None else Some(positives.min))", "    \tval lst2 = lst.filter(_\
    \ > 0)\n    \tval lst3 = lst.filter(_ < 0)\n    \tif (lst2.isEmpty) (None, None)\n\
    \    \telse if (lst3.isEmpty) (None, Some(lst2.min))\n    \telse (Some(lst3.max),\
    \ Some(lst2.min))", "        val aset = Set[Long]()\n        val bset = Set[Long]()\n\
    \        for (num <- lst) {\n            if (num < 0) aset += num\n          \
    \  else if (num > 0) bset += num\n        }\n        if (aset.size == 0) (None,\
    \ Some(bset.min))\n        else if (bset.size == 0) (Some(aset.max), None)\n \
    \       else (Some(aset.max), Some(bset.min))", "        if (lst.isEmpty) return\
    \ (None, None)\n        var maxneg = None : Option[Long]\n        var minpos =\
    \ None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n  \
    \              if (maxneg == None) maxneg = Some(i)\n                else maxneg\
    \ = Some(max(maxneg.get, i))\n            }\n            else if (i > 0) {\n \
    \               if (minpos == None) minpos = Some(i)\n                else minpos\
    \ = Some(min(minpos.get, i))\n            }\n        }\n        return (maxneg,\
    \ minpos)"]
stop_tokens:
- "\n    }\n"
