name: HumanEval_107_even_odd_palindrome
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive integer n, return a tuple that has the number of even and\
  \ odd\n    // integer palindromes that fall within the range(1, n), inclusive.\n\
  \    // Example 1:\n    // Input: 3\n    // Output: (1, 2)\n    // Explanation:\n\
  \    // Integer palindrome are 1, 2, 3. one of them is even, and two of them are\
  \ odd.\n    // Example 2:\n    // Input: 12\n    // Output: (4, 6)\n    // Explanation:\n\
  \    // Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even,\
  \ and 6 of them are odd.\n    // Note:\n    // 1. 1 <= n <= 10^3\n    // 2. returned\
  \ tuple has the number of even and odd integer palindromes respectively.\n    def\
  \ evenOddPalindrome(n : Long) : Tuple2[Long, Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(evenOddPalindrome((123l)).equals(((8l,\
  \ 13l))));\n    assert(evenOddPalindrome((12l)).equals(((4l, 6l))));\n    assert(evenOddPalindrome((3l)).equals(((1l,\
  \ 2l))));\n    assert(evenOddPalindrome((63l)).equals(((6l, 8l))));\n    assert(evenOddPalindrome((25l)).equals(((5l,\
  \ 6l))));\n    assert(evenOddPalindrome((19l)).equals(((4l, 6l))));\n    assert(evenOddPalindrome((9l)).equals(((4l,\
  \ 5l))));\n    assert(evenOddPalindrome((1l)).equals(((0l, 1l))));\n    }\n\n}\n"
completions: ["        var even : Long = 0\n        var odd : Long = 0\n        //\
    \      1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        // 1    1  2  3  4  5  6  7  8 \
    \ 9  10\n        // 2    1  2  3  4  5  6  7  8  9  10\n        // 3    1  2 \
    \ 3  4  5  6  7  8  9  10\n        // 4    1  2  3  4  5  6  7  8  9  10\n   \
    \     // 5    1  2  3  4  5  6  7  8  9  10\n        // 6    1  2  3  4  5  6\
    \  7  8  9  10\n        // 7    1  2  3  4  5  6  7  8  9  10\n        // 8  \
    \  1  2  3  4  5  6  7  8  9  10\n        // 9    1  2  3  4  5  6  7  8  9  10\n\
    \        // 10    1  2  3  4  5  6  7  8  9  10\n        // 11   1  2  3  4  5\
    \  6  7  8  9  10\n        // 12   1  2  3  4  5  6  7  8  9  10\n        for\
    \ (k <- 1 to n.toInt) {\n            val str : String = k.toString\n         \
    \   if (str == str.reverse) {\n                if (k % 2 == 0) even += 1\n   \
    \             else odd += 1\n            }\n        }\n        (even, odd)", " \
    \       def isPalindrome(x : Long) : Boolean = {\n            val s = x.toString\n\
    \            var a = 0\n            var b = s.length - 1\n            while (a\
    \ < b) {\n                if (s(a) != s(b)) return false\n                a +=\
    \ 1\n                b -= 1\n            }\n            true\n        }\n    \
    \    var result = (0L, 0L)\n        for (i <- 1L to n) {\n            if (isPalindrome(i))\
    \ {\n                if (i % 2 == 0) result = (result._1 + 1, result._2)\n   \
    \             else result = (result._1, result._2 + 1)\n            }\n      \
    \  }\n        result", "        //        var evens = Set[Long]()\n        //\
    \        var odds = Set[Long]()\n        //        for (i <- 1 to n.toInt) {\n\
    \        //            if (isPalindrome(i)) {\n        //                if (i\
    \ % 2 == 0) evens += i\n        //                else odds += i\n        // \
    \           }\n        //        }\n        //        return (evens.size, odds.size)\n\
    \        def isPalindrome(n : Long) : Boolean = {\n            val s = n.toString()\n\
    \            return s == s.reverse\n        }\n        if (n < 2) return (0, 0)\n\
    \        if (n == 2) return (1, 1)\n        val evens = if (n % 2 == 0) n / 2\
    \ else n / 2 + 1\n        val odds = n / 2\n        return (evens, odds)", " \
    \       def countEven(n : Long) : Long = {\n            if (n < 2) 0\n       \
    \     else {\n                var res = 2L\n                var i = 1\n      \
    \          while (i <= n) {\n                    res += min(n - i, i)\n      \
    \              i += 1\n                }\n                res\n            }\n\
    \        }\n        val (c1, c2) = (countEven(n), n - countEven(n) + 1)\n    \
    \    (c1, c2)", "        val (odd, even) = (1 to n.toInt).partition(x => x.toString\
    \ == x.toString.reverse)\n        (even.length, odd.length)", "        // if x\
    \ > 2^32, the number of digit of x will be greater than the number of digit of\
    \ 2^32,\n        // and the if condition below will be true.\n        // so we\
    \ just need to count all of them.\n        if (n > pow(2, 32).toLong) return (n\
    \ / 2, n / 2)\n        val digits = floor(log10(n)).toInt + 1\n        var odd\
    \ = 0L\n        var even = 0L\n        for (i <- 1 to digits) {\n            if\
    \ (i % 2 == 0) {\n                even += pow(10, i - 1).toLong\n            }\
    \ else {\n                odd += pow(10, i - 1).toLong\n            }\n      \
    \  }\n        val x = n.toString.toCharArray\n        val numOdd = x.length /\
    \ 2\n        val numEven = x.length / 2 + x.length % 2\n        var temp = 0\n\
    \        var res = 0\n        for (i <- 0 until numOdd) {\n            res +=\
    \ x(i) - '0'\n            temp = res\n            for (j <- 0 until numEven) {\n\
    \                res += (x(x.length - 1 - j) - '0') * pow(10, (j + 1)).toInt\n\
    \            }\n            even += temp\n            odd += res\n        }\n\
    \        if (numEven == numOdd) {\n            even += temp\n            odd +=\
    \ res\n        }\n        (even, odd)", "        // First, let's count the number\
    \ of palindromes that have odd number of digits.\n        // n = 7 => (0, 1, 2,\
    \ 3, 4, 5, 6) => (1, 3, 5, 7)\n        // n = 8 => (0, 1, 2, 3, 4, 5, 6, 7) =>\
    \ (1, 3, 5, 7)\n        // n = 9 => (0, 1, 2, 3, 4, 5, 6, 7, 8) => (1, 3, 5, 7,\
    \ 9)\n        // n = 10 => (0, 1, 2, 3, 4, 5, 6, 7, 8, 9) => (1, 3, 5, 7, 9)\n\
    \        val oddCount = if (n == 10) {\n            5\n        } else {\n    \
    \        (n + 1) / 2\n        }\n        // Now, let's count the number of palindromes\
    \ that have even number of digits.\n        // n = 7 => (0, 1, 2, 3, 4, 5, 6)\
    \ => (11, 22, 33, 44, 55, 66)\n        // n = 8 => (0, 1, 2, 3, 4, 5, 6, 7) =>\
    \ (11, 22, 33, 44, 55, 66)\n        // n = 9 => (0, 1, 2, 3, 4, 5, 6, 7, 8) =>\
    \ (11, 22, 33, 44, 55, 66, 77, 88, 99)\n        // n = 10 => (0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9) => (11, 22, 33, 44, 55, 66, 77, 88, 99)\n        val evenCount =\
    \ if (n == 7) {\n            6\n        } else if (n == 8) {\n            6\n\
    \        } else if (n == 9) {\n            9\n        } else {\n            12\n\
    \        }\n        return (evenCount, oddCount)", "        val str = n.toString\n\
    \        val digits = str.length\n        val mid = (digits - 1) / 2\n       \
    \ val (left, right) = str.splitAt(mid)\n        val result = generatePalindromes(left,\
    \ right, 0, digits)\n        val odd = result._1.filterNot(x => left == right).filterNot(x\
    \ => x.length == 1)\n        val even = result._2.filterNot(x => left == right)\n\
    \        val oddCount = if (digits % 2 == 0) odd.length else odd.length + 1\n\
    \        val evenCount = if (digits % 2 == 0) even.length + 1 else even.length\n\
    \        (evenCount, oddCount)", "        var even = 0L\n        var odd = 0L\n\
    \        for (i <- 1L to n) {\n            if (isPalindrome(i.toString)) {\n \
    \               if (i % 2 == 0) even += 1\n                else odd += 1\n   \
    \         }\n        }\n        (even, odd)", "        val tuple = Tuple2(0L,\
    \ 0L)\n        for (i <- 0L to n) {\n            if (i.toString == i.toString.reverse)\
    \ {\n                val (even, odd) = tuple\n                if (i % 2 == 0)\
    \ tuple.copy(_1 = even + 1)\n                else tuple.copy(_2 = odd + 1)\n \
    \           }\n        }\n        tuple", "        val evenOdd = Array.fill(2)(0L)\n\
    \        for (i <- 1 to n.toInt) {\n            evenOdd(i % 2) += 1\n        }\n\
    \        return (evenOdd(0), evenOdd(1))", "        val p = Array.ofDim[Boolean](n.toInt\
    \ + 1)\n        for (i <- 1 to n.toInt if p(i) == false) {\n            var num\
    \ = i\n            var reversed = 0\n            while (num > 0) {\n         \
    \       reversed = 10 * reversed + num % 10\n                num /= 10\n     \
    \       }\n            p(i) = true\n            if (reversed <= n) p(reversed)\
    \ = true\n        }\n        p.filter(x => x == true).partition(x => x % 2 ==\
    \ 0)", "        if (n == 1) return (1, 0)\n        var odd = n.toString.length\
    \ - 1\n        var even = 0\n        if (n.toString.head == n.toString.last) even\
    \ = 1\n        (even, odd)", "        var even = 0L\n        var odd = 0L\n  \
    \      val digits = (1 to log10(n).toInt).map(_ => 0).toArray\n        var index\
    \ = digits.length - 1\n        var number = n\n        while (number > 0) {\n\
    \            digits(index) = (number % 10).toInt\n            number /= 10\n \
    \           index -= 1\n        }\n        //println(digits.mkString(\" \"))\n\
    \        // Odd digits\n        for (i <- 0 to digits.length - 1) {\n        \
    \    var oddDigits = digits.clone\n            oddDigits(i) -= 1\n           \
    \ for (j <- i + 1 to digits.length - 1) oddDigits(j) = 9\n            //println(oddDigits.mkString(\"\
    \ \"))\n            odd += oddDigits.mkString.toLong + 1\n        }\n        //\
    \ Even digits\n        for (i <- 0 to digits.length - 1) {\n            var evenDigits\
    \ = digits.clone\n            evenDigits(i) -= 1\n            if (i + 1 < digits.length)\
    \ evenDigits(i + 1) -= 1\n            for (j <- i + 2 to digits.length - 1) evenDigits(j)\
    \ = 9\n            //println(evenDigits.mkString(\" \"))\n            even +=\
    \ evenDigits.mkString.toLong + 1\n        }\n        (even, odd)", "        def\
    \ isPalindrome(x : Long) : Boolean = {\n            var r = 0L\n            var\
    \ y = x\n            while (y > 0) {\n                r = r * 10 + y % 10\n  \
    \              y /= 10\n            }\n            return x == r\n        }\n\
    \        var odd = 0L\n        var even = 0L\n        for (i <- 1L to n) {\n \
    \           if (isPalindrome(i)) {\n                if (i % 2 == 0) even += 1\n\
    \                else odd += 1\n            }\n        }\n        return (even,\
    \ odd)", "        var evenCount = 0L\n        var oddCount = 0L\n        for (i\
    \ <- 1L to n) {\n            if (isPalindrome(i)) {\n                if (i % 2\
    \ == 0) evenCount += 1\n                else oddCount += 1\n            }\n  \
    \      }\n        return (evenCount, oddCount)", "        val range = (1 to n.toInt).toList\n\
    \        val palindromes = range.filter(i => (i.toString == i.toString.reverse))\n\
    \        return (palindromes.count(i => i % 2 == 0), palindromes.count(i => i\
    \ % 2 == 1))", "      val evens = if (n % 2 == 0) n / 2 else n / 2 + 1\n     \
    \ (evens, n - evens)", "        var even = 0\n        var odd = 0\n        for\
    \ (i <- 1 to n.toInt) {\n            if (isPalindrome(i)) {\n                if\
    \ (i % 2 == 0) even += 1\n                else odd += 1\n            }\n     \
    \   }\n        (even, odd)", "        val nStr = n.toString\n        val len =\
    \ nStr.length\n        val m : HashMap[Long, Long] = HashMap()\n        var evenCount\
    \ = 0L\n        var oddCount = 0L\n        for (i <- 0 until (1 << len)) {\n \
    \           val sb = new StringBuilder()\n            for (j <- 0 until len) {\n\
    \                if ((i & (1 << j)) != 0) {\n                    sb.append(nStr(j))\n\
    \                }\n            }\n            val s = sb.toString\n         \
    \   if (s.length > 0) {\n                if (!m.contains(s.toLong)) {\n      \
    \              val p = new Palindrome(s.toLong)\n                    val palindrome\
    \ = p.getPalindrome()\n                    m.put(palindrome, 1L)\n           \
    \         if (palindrome % 2 == 0) evenCount += 1\n                    else oddCount\
    \ += 1\n                }\n            }\n        }\n        (evenCount, oddCount)"]
stop_tokens:
- "\n    }\n"
