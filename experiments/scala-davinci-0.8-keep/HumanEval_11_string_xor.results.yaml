language: scala
name: HumanEval_11_string_xor
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var length : Int = max(a.length, b.length)\n\
    \        var result : StringBuilder = new StringBuilder(length)\n        for (i\
    \ <- 0 until length) {\n            var c : Int = 0\n            if (i < a.length\
    \ && a(i) == '1') c = c + 1\n            if (i < b.length && b(i) == '1') c =\
    \ c + 1\n            if (c % 2 == 0) result.append('0')\n            else result.append('1')\n\
    \        }\n        return result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        (a zip b).map(t => t._1 ^ t._2).mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until\
    \ a.length) {\n            if (a(i) == b(i)) result += \"0\"\n            else\
    \ result += \"1\"\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        assert(a.length == b.length)\n        var\
    \ i = 0\n        var result = new StringBuilder\n        while (i < a.length)\
    \ {\n            if (a(i) == b(i)) result += '0'\n            else result += '1'\n\
    \            i += 1\n        }\n        result.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val result = ArrayBuffer[Char]()\n       \
    \ for (i <- 0 until a.length) {\n            if (a(i) == b(i)) result += '0'\n\
    \            else result += '1'\n        }\n        result.mkString\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        require(a.length == b.length)\n        var\
    \ i = 0\n        var res = \"\"\n        while (i < a.length) {\n            res\
    \ += (a(i) ^ b(i)).toString\n            i += 1\n        }\n        res\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        require(a.length == b.length)\n        for\
    \ (i <- 0 until a.length) {\n            val x = a(i)\n            val y = b(i)\n\
    \            require(x == '0' || x == '1')\n            require(y == '0' || y\
    \ == '1')\n        }\n        val sb = new StringBuilder()\n        for (i <-\
    \ 0 until a.length) {\n            val x = a(i)\n            val y = b(i)\n  \
    \          if (x == y) sb.append('0')\n            else sb.append('1')\n     \
    \   }\n        sb.toString\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        require(a.length == b.length)\n        val\
    \ sb = new StringBuilder\n        for (i <- 0 until a.length) {\n            if\
    \ (a(i) == b(i)) sb.append('0')\n            else sb.append('1')\n        }\n\
    \        sb.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820899
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val maxLength = max(a.length, b.length)\n\
    \        var aRepeated = a.reverse\n        var bRepeated = b.reverse\n      \
    \  for (i <- 1 to maxLength - a.length) aRepeated += \"0\"\n        for (i <-\
    \ 1 to maxLength - b.length) bRepeated += \"0\"\n        (aRepeated, bRepeated).zipped.map(xor(_,\
    \ _)).reverse.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpl_wu3yic.scala:14:42 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        (aRepeated, bRepeated).zipped.map(xor(_, _)).reverse.mkString\n\
    \e[31m\e[31m   |\e[0m                                          ^^^\e[0m\n\e[31m\
    \   |\e[0m                                          Not found: xor\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659820895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        assert(a.length == b.length)\n        val\
    \ z = new StringBuilder\n        for (i <- 0 until a.length) {\n            z.append((if\
    \ (a(i) == '1') 1 else 0) ^ (if (b(i) == '1') 1 else 0))\n        }\n        z.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        var result = new StringBuffer()\n        for\
    \ (i <- 0 until a.length) {\n            result.append((a(i) ^ b(i)).toString)\n\
    \        }\n        return result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        require(a.length == b.length)\n        val\
    \ l : Int = a.length\n        var result : String = \"\"\n        for (i <- 0\
    \ until l) {\n            result += (if (a(i) == b(i)) \"0\" else \"1\")\n   \
    \     }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        // Assume lengths are the same\n        var\
    \ sb = new StringBuilder()\n        for (i <- 0 until a.length) {\n          \
    \  if (a(i) == b(i)) sb.append('0')\n            else sb.append('1')\n       \
    \ }\n        sb.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n      a.zip(b).map(x => if (x._1 != x._2) '1' else\
    \ '0').mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820899
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        def stringXorAux(x : List[Int], y : List[Int])\
    \ : List[Int] = (x, y) match {\n            case (xh :: xt, yh :: yt) =>\n   \
    \             ((xh - 48) ^ (yh - 48)) :: stringXorAux(xt, yt)\n            case\
    \ _ => Nil\n        }\n        stringXorAux(a.toList, b.toList).map(_ + 48).mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpouoxexxo.scala:14:23\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        stringXorAux(a.toList,\
    \ b.toList).map(_ + \e[31m48\e[0m).mkString\n\e[31m\e[31m   |\e[0m           \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0m                     Found:    List[\e\
    [1m\e[31mChar\e[0m]\n\e[31m   |\e[0m                     Required: List[\e[1m\e\
    [32mInt\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpouoxexxo.scala:14:33\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        stringXorAux(a.toList,\
    \ b.toList).map(_ + \e[31m48\e[0m).mkString\n\e[31m\e[31m   |\e[0m           \
    \                    ^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \     Found:    List[\e[1m\e[31mChar\e[0m]\n\e[31m   |\e[0m                  \
    \             Required: List[\e[1m\e[32mInt\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659820898
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBinary = BigInt(a, 2)\n        val bBinary\
    \ = BigInt(b, 2)\n        val result = (aBinary ^ bBinary).toString(2)\n     \
    \   val padding = new StringBuilder\n        for (i <- 0 until (a.length - result.length))\
    \ padding.append(\"0\")\n        padding.append(result).toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val len = min(a.length, b.length)\n      \
    \  var ans = \"\"\n        for (i <- 0 until len) {\n            if (a(i) == b(i))\
    \ ans += \"0\"\n            else ans += \"1\"\n        }\n        ans\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n      val pairs = a.zip(b)\n      var result = \"\"\
    \n      for ((x, y) <- pairs) {\n        result += (if (x != y) '1' else '0')\n\
    \      }\n      result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        if (a.length != b.length) throw new Exception(\"\
    Inputs are not of equal length\")\n        val c = ArrayBuffer[Char]()\n     \
    \   for (i <- 0 until a.length) {\n            if (a(i) == b(i)) c += '0'\n  \
    \          else c += '1'\n        }\n        c.mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659820899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aa = BigInt(a, 2)\n        val bb = BigInt(b,\
    \ 2)\n        val cc = aa ^ bb\n        return cc.toString(2)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwwdb5m4b.scala:15)\n\tat Problem.main(tmpwwdb5m4b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659820898
