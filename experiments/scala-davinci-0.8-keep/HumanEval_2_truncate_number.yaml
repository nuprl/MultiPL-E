name: HumanEval_2_truncate_number
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive floating point number, it can be decomposed into\n    //\
  \ and integer part (largest integer smaller than given number) and decimals\n  \
  \  // (leftover part always smaller than 1).\n    // Return the decimal part of\
  \ the number.\n    // >>> truncate_number(3.5)\n    // 0.5\n    def truncateNumber(number\
  \ : Float) : Float = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(truncateNumber((3.5f))\
  \ == (0.5f));\n    assert(truncateNumber((1.25f)) == (0.25f));\n    assert(truncateNumber((123.0f))\
  \ == (0.0f));\n    }\n\n}\n"
completions: ['        number - floor(number)', '        floor(number).toFloat - number',
  '        floor(number).toFloat', '        number - floor(number)', '        number
    - floor(number)', "        var n : Float = number\n        while (n >= 1) {\n\
    \            n -= 1\n        }\n        return n", "        var numberI = number.toInt\n\
    \        return number - numberI", '        return number - math.floor(number).toFloat',
  "        if (number < 0) throw new Exception(\"Truncate number only works for positive\
    \ numbers\")\n        else return number - number.toInt", "        val intPart\
    \ = number.toInt\n        return number - intPart", "      val numberAsString\
    \ = number.toString\n      val numberAsArray = numberAsString.split(\"\\\\.\"\
    )\n      if (numberAsArray.length != 2) {\n        return 0\n      }\n      numberAsArray(1).toFloat\
    \ / pow(10, numberAsArray(1).length).toFloat", "        val intPart = floor(number).toInt\n\
    \        val decimals = number - intPart\n        return decimals", '        number
    - number.toInt', "        val integerPart = math.floor(number).toInt\n       \
    \ number - integerPart", "        val intPart = floor(number).toInt\n        val\
    \ decimalPart = number - intPart\n        return decimalPart", '        return
    number - math.floor(number).toFloat', "        val n = abs(number)\n        n\
    \ - abs(math.floor(n))", '        (number - floor(number)).toFloat', '        return
    number % 1', "        val truncated = floor(number).toFloat\n        return number\
    \ - truncated"]
stop_tokens:
- "\n    }\n"
