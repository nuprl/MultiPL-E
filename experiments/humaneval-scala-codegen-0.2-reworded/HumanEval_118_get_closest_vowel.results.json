{
  "name": "HumanEval_118_get_closest_vowel",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "results": [
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = List.of(\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\")\n        var vowelsIndex = List.range(0, word.length).filter(i => vowels.contains(word[i]))\n        var rightVowelIndex = vowelsIndex.filter(i => i + 1 < word.length && !vowels.contains(word[i + 1]))\n        if (rightVowelIndex.isEmpty()) {\n            return \"\"\n        } else {\n            return word[rightVowelIndex.head]\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkm1azzxl.scala:19:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mvowels\u001b[0m = List.of(\u001b[31m\"a\"\u001b[0m, \u001b[31m\"e\"\u001b[0m, \u001b[31m\"i\"\u001b[0m, \u001b[31m\"o\"\u001b[0m, \u001b[31m\"u\"\u001b[0m, \u001b[31m\"A\"\u001b[0m, \u001b[31m\"E\"\u001b[0m, \u001b[31m\"I\"\u001b[0m, \u001b[31m\"O\"\u001b[0m, \u001b[31m\"U\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value of is not a member of object scala.collection.immutable.List\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpkm1azzxl.scala:22:28 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mif\u001b[0m (rightVowelIndex.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkm1azzxl.scala:25:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mreturn\u001b[0m word[rightVowelIndex.head]\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        type head is not a member of List[Int]\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var result = \"\"\n        var i = 0\n        while (i < word.length()) {\n            if (consonants[i] == word.charAt(i)) {\n                i += 1\n            } else {\n                if (i + 1 < word.length() && vowels[word.charAt(i + 1) - 'a'] != null) {\n                    result = word.charAt(i + 1) + result\n                    i += 2\n                } else {\n                    i += 1\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpi5u6hlml.scala:27:63 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                \u001b[33mif\u001b[0m (i + \u001b[31m1\u001b[0m < word.length() && vowels[word.charAt(i + \u001b[31m1\u001b[0m) - \u001b[31m'a'\u001b[0m] != \u001b[31mnull\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             ']' expected, but '(' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpi5u6hlml.scala:24:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m (consonants[\u001b[35mi\u001b[0m] == word.charAt(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = List.of(\"a\", \"e\", \"i\", \"o\", \"u\")\n        var consonants = List.of(\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\")\n        var vowelsAndConsonants = vowels.zip(consonants)\n        var vowelsAndConsonantsMap = vowelsAndConsonants.map { (v, c) => (c, v) }\n        var result = word.toLowerCase.split(\"\").map(c => c.toLowerCase).foldLeft(c => c, (c, w) => {\n            var index = w.indexOf(c)\n            if (index == -1) {\n                return c\n            }\n            var next = w.substring(index + 1)\n            var nextIndex = next.indexOf(c)\n            if (nextIndex == -1) {\n                return c\n            }\n            var nextNext = next.substring(nextIndex + 1)\n            var nextNextIndex = nextNext.indexOf(c)\n            if (nextNextIndex == -1) {\n                return c\n            }\n            var nextNextNext = nextNext.substring(nextNextIndex + 1)\n            var nextNextNextIndex = nextNextNext.indexOf(c)\n            if (nextNextNextIndex == -1) {\n                return c\n            }\n            var nextNextNextNext = nextNextNext.substring(nextNextNextIndex + 1)\n            var nextNextNextNextIndex = nextNextNextNext.indexOf(c)\n            if (nextNextNextNextIndex == -1) {\n                return c\n            }\n            var nextNextNextNextNext = nextNextNextNext.substring(nextNextNextNextIndex + 1)\n            var nextNextNextNextNextIndex = nextNextNextNextNext.indexOf(c)\n            if (nextNextNextNextNextIndex == -1) {\n                return c\n            }\n            var nextNextNextNextNextNext = nextNextNextNextNext.substring\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpuzeld7gk.scala:55:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m    ^^^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but 'def' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpuzeld7gk.scala:72:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuzeld7gk.scala:19:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mvowels\u001b[0m = List.of(\u001b[31m\"a\"\u001b[0m, \u001b[31m\"e\"\u001b[0m, \u001b[31m\"i\"\u001b[0m, \u001b[31m\"o\"\u001b[0m, \u001b[31m\"u\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value of is not a member of object scala.collection.immutable.List\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuzeld7gk.scala:20:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mconsonants\u001b[0m = List.of(\u001b[31m\"b\"\u001b[0m, \u001b[31m\"c\"\u001b[0m, \u001b[31m\"d\"\u001b[0m, \u001b[31m\"f\"\u001b[0m, \u001b[31m\"g\"\u001b[0m, \u001b[31m\"h\"\u001b[0m, \u001b[31m\"j\"\u001b[0m, \u001b[31m\"k\"\u001b[0m, \u001b[31m\"l\"\u001b[0m, \u001b[31m\"m\"\u001b[0m, \u001b[31m\"n\"\u001b[0m, \u001b[31m\"p\"\u001b[0m, \u001b[31m\"q\"\u001b[0m, \u001b[31m\"r\"\u001b[0m, \u001b[31m\"s\"\u001b[0m, \u001b[31m\"t\"\u001b[0m, \u001b[31m\"v\"\u001b[0m, \u001b[31m\"w\"\u001b[0m, \u001b[31m\"x\"\u001b[0m, \u001b[31m\"y\"\u001b[0m, \u001b[31m\"z\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value of is not a member of object scala.collection.immutable.List\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpuzeld7gk.scala:23:81 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = word.toLowerCase.split(\u001b[31m\"\"\u001b[0m).map(\u001b[36mc\u001b[0m => c.toLowerCase).foldLeft(\u001b[36mc\u001b[0m => c, (\u001b[36mc\u001b[0m, \u001b[36mw\u001b[0m) => {\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                          I could not infer the type of the parameter c.\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpuzeld7gk.scala:23:90 -----------------------------\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var i = 0\n        var j = 0\n        var result = \"\"\n        for (i = word.length() - 1; i >= 0; i--) {\n            if (consonants[j] == word.charAt(i)) {\n                j += 1\n            } else {\n                if (vowels[i] != '\\u0000') {\n                    result = vowels[i]\n                    break\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpw09cnqjt.scala:24:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpw09cnqjt.scala:24:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpw09cnqjt.scala:24:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpw09cnqjt.scala:24:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue foreach is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator as",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (consonants[index] == word.charAt(i)) {\n                index++\n            } else if (vowels[index] == word.charAt(i)) {\n                index = 0\n            } else {\n                break\n            }\n        }\n        if (index > 0) {\n            result = vowels[index]\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpb4g0q0lk.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpb4g0q0lk.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpb4g0q0lk.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpb4g0q0lk.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowels_count = 0\n        var consonants_count = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (vowels.indexOf(word.charAt(i)) != -1) {\n                vowels_count += 1\n                if (vowels_count > 1) {\n                    result = word.charAt(i)\n                    break\n                }\n            } else if (consonants.indexOf(word.charAt(i)) != -1) {\n                consonants_count += 1\n                if (consonants_count > 1) {\n                    result = word.charAt(i)\n                    break\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpxwsa78cr.scala:24:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpxwsa78cr.scala:24:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpxwsa78cr.scala:24:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxwsa78cr.scala:24:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowelsAndConsonants = vowels + consonants\n        var right = word.length()\n        var left = 0\n        var rightVowel = \"\"\n        var leftVowel = \"\"\n        var rightConsonant = \"\"\n        var leftConsonant = \"\"\n        var rightIndex = right\n        var leftIndex = left\n        var rightVowelIndex = right\n        var leftVowelIndex = left\n        var rightConsonantIndex = right\n        var leftConsonantIndex = left\n        while (rightVowelIndex < right && leftVowelIndex < left) {\n            if (vowelsAndConsonants[rightVowelIndex] == word[rightVowelIndex]) {\n                rightVowel = vowelsAndConsonants[rightVowelIndex]\n                rightConsonant = consonants[rightConsonantIndex]\n                rightIndex = rightConsonantIndex\n                rightVowelIndex = rightConsonantIndex + 1\n            } else {\n                rightConsonant = consonants[rightConsonantIndex]\n                rightConsonantIndex = rightConsonantIndex + 1\n                rightVowelIndex = rightConsonantIndex + 1\n            }\n            if (vowelsAndConsonants[leftVowelIndex] == word[leftVowelIndex]) {\n                leftVowel = vowelsAndConsonants[leftVowelIndex]\n                leftConsonant = consonants[leftConsonantIndex]\n                leftIndex = leftConsonantIndex\n                leftVowelIndex = leftConsonantIndex + 1\n            } else {\n                leftConsonant = consonants[leftConsonantIndex]\n                leftConsonantIndex = leftConsonantIndex + 1\n                leftVowelIndex = leftConsonantIndex + 1\n            }\n        }\n        if (rightVowelIndex == right && leftVowelIndex == left) {\n            return \"\"\n        } else if (rightVowelIndex == right) {\n            \n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_k0mxvth.scala:78:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_k0mxvth.scala:21:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mvowelsAndConsonants\u001b[0m = vowels + consonants\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of Array[Char], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_k0mxvth.scala:35:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            \u001b[33mif\u001b[0m (vowelsAndConsonants[\u001b[35mrightVowelIndex\u001b[0m] == word[\u001b[35mrightVowelIndex\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type rightVowelIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_k0mxvth.scala:36:49 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                rightVowel = vowelsAndConsonants[\u001b[35mrightVowelIndex\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type rightVowelIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_k0mxvth.scala:37:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                rightConsonant = consonants[\u001b[35mrightConsonantIndex\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var vowelsAndConsonants = vowels + consonants\n        var vowelsAndConsonantsLen = vowelsAndConsonants.length\n        var wordLen = word.length\n        var i = wordLen - 1\n        var j = wordLen - 1\n        var closestVowel = \"\"\n        while(i >= 0 && j >= 0) {\n            if(vowelsAndConsonants[i] == word[j]) {\n                i -= 1\n                j -= 1\n                closestVowel = word[i]\n            } else if(vowelsAndConsonants[i] != word[j]) {\n                i -= 1\n            } else {\n                j -= 1\n            }\n        }\n        return closestVowel\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp004fcv0v.scala:28:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mif\u001b[0m(vowelsAndConsonants[\u001b[35mi\u001b[0m] == word[\u001b[35mj\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp004fcv0v.scala:31:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                closestVowel = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp004fcv0v.scala:32:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m(vowelsAndConsonants[i] != word[j]) {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var index = 0\n        var result = \"\"\n        for (i <- 1 to word.length - 1) {\n            if (consonants.indexOf(word.charAt(i)) != -1 && vowels.indexOf(word.charAt(i - 1)) != -1) {\n                result = word.charAt(i)\n                index = i\n                break\n            }\n        }\n        if (result == \"\") {\n            for (i <- 1 to word.length - 1) {\n                if (consonants.indexOf(word.charAt(i)) != -1 && vowels.indexOf(word.charAt(i + 1)) != -1) {\n                    result = word.charAt(i)\n                    index = i\n                    break\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppjdq1pne.scala:25:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                result = word.charAt(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    Char\n\u001b[31m   |\u001b[0m                         Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppjdq1pne.scala:27:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppjdq1pne.scala:33:40 --------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                    result = word.charAt(i)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    Char\n\u001b[31m   |\u001b[0m                             Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppjdq1pne.scala:35:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var vowels_count = 0\n        var consonants_count = 0\n        var vowels_index = 0\n        var consonants_index = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (vowels.indexOf(word.charAt(i)) != -1) {\n                vowels_count += 1\n                vowels_index = i\n            } else if (consonants.indexOf(word.charAt(i)) != -1) {\n                consonants_count += 1\n                consonants_index = i\n            }\n        }\n        if (vowels_count == 0) {\n            return \"\"\n        } else if (consonants_count == 0) {\n            return word.charAt(vowels_index)\n        } else if (vowels_count == 1) {\n            return word.charAt(vowels_index)\n        } else if (consonants_count == 1) {\n            return word.charAt(consonants_index)\n        } else {\n            if (vowels_index - consonants_index > 1) {\n                return word.charAt(vowels_index - 1)\n            } else if (vowels_index - consonants_index == 1) {\n                return word.charAt(vowels_index)\n            } else {\n                return word.charAt(vowels_index)\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9no2uq0w.scala:38:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            \u001b[33mreturn\u001b[0m word.charAt(vowels_index)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    Char\n\u001b[31m   |\u001b[0m                   Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9no2uq0w.scala:40:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m            \u001b[33mreturn\u001b[0m word.charAt(vowels_index)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    Char\n\u001b[31m   |\u001b[0m                   Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9no2uq0w.scala:42:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m            \u001b[33mreturn\u001b[0m word.charAt(consonants_index)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    Char\n\u001b[31m   |\u001b[0m                   Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9no2uq0w.scala:45:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m                \u001b[33mreturn\u001b[0m word.charAt(vowels_index - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    Char\n\u001b[31m   |\u001b[0m                       Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9no2uq0w.scala:47:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m                \u001b[33mreturn\u001b[0m word.charAt(vowels_index)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    Char\n\u001b[31m   |\u001b[0m                       Required: S",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var result = \"\"\n        var i = 0\n        while (i < word.length()) {\n            if (vowels.indexOf(word.charAt(i)) != -1) {\n                result = word.charAt(i)\n                break\n            }\n            if (consonants.indexOf(word.charAt(i)) != -1) {\n                i += 1\n            } else {\n                i += 2\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292981,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfk0a8o_s.scala:25:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                result = word.charAt(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    Char\n\u001b[31m   |\u001b[0m                         Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfk0a8o_s.scala:26:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowels_count = 0\n        var consonants_count = 0\n        var result = \"\"\n        var i = 0\n        while (i < word.length) {\n            if (vowels[0] == word[i]) {\n                vowels_count += 1\n            } else if (consonants[0] == word[i]) {\n                consonants_count += 1\n            } else {\n                if (vowels_count > 0 && vowels_count < 2) {\n                    result = vowels[vowels_count - 1]\n                } else if (consonants_count > 0 && consonants_count < 2) {\n                    result = consonants[consonants_count - 1]\n                } else {\n                    result = \"\"\n                }\n                break\n            }\n            i += 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp_hxcrpx8.scala:26:22 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (vowels[\u001b[31m0\u001b[0m] == word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mArray\u001b[0m does not take type parameters\n\u001b[31m\u001b[31m-- Error: /tmp/tmp_hxcrpx8.scala:28:33 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (consonants[\u001b[31m0\u001b[0m] == word[i]) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mArray\u001b[0m does not take type parameters\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_hxcrpx8.scala:32:49 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    result = vowels[\u001b[35mvowels_count\u001b[0m \u001b[35m-\u001b[0m \u001b[31m1\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                 Not found: type -\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_hxcrpx8.scala:34:57 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                    result = consonants[\u001b[35mconsonants_count\u001b[0m \u001b[35m-\u001b[0m \u001b[31m1\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: type -\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_hxcrpx8.scala:38:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var i = 0\n        var j = 0\n        var result = \"\"\n        while (i < word.length && j < word.length) {\n            if (vowels[i] == word[j]) {\n                i += 1\n                j += 1\n                result = word[j]\n            } else if (consonants[j] == word[j]) {\n                j += 1\n            } else {\n                i += 1\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpehjujfst.scala:25:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (vowels[\u001b[35mi\u001b[0m] == word[\u001b[35mj\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpehjujfst.scala:28:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                result = word[\u001b[35mj\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpehjujfst.scala:29:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (consonants[j] == word[j]) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var result = \"\"\n        var i = word.length() - 1\n        while (i >= 0) {\n            if (consonants[i] == word[i]) {\n                i -= 1\n                continue\n            }\n            if (vowels[i] == word[i]) {\n                result = word[i]\n                i -= 1\n                continue\n            }\n            i -= 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292977,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpu8bt5f2l.scala:24:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m (consonants[\u001b[35mi\u001b[0m] == word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpu8bt5f2l.scala:26:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                continue\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: continue\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpu8bt5f2l.scala:28:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mif\u001b[0m (vowels[\u001b[35mi\u001b[0m] == word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpu8bt5f2l.scala:29:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpu8bt5f2l.scala:31:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                continue\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: continue\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowelsCount = 0\n        var consonantsCount = 0\n        var result = \"\"\n        for (var i = 0; i < word.length(); i++) {\n            var c = word.charAt(i)\n            if (vowels.indexOf(c) >= 0) {\n                vowelsCount++\n                if (i > 0 && consonants.indexOf(word.charAt(i - 1)) >= 0) {\n                    result = word.substring(i - vowelsCount, i)\n                    break\n                }\n            } else if (consonants.indexOf(c) >= 0) {\n                consonantsCount++\n                if (i > 0 && vowels.indexOf(word.charAt(i - 1)) >= 0) {\n                    result = word.substring(i - consonantsCount, i)\n                    break\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp7l8as13e.scala:24:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7l8as13e.scala:24:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp7l8as13e.scala:24:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7l8as13e.scala:24:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var index = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (vowels.indexOf(word.charAt(i)) >= 0) {\n                index = i\n                break\n            }\n            if (consonants.indexOf(word.charAt(i)) >= 0) {\n                index = i\n                break\n            }\n        }\n        for (i <- index + 1 until word.length) {\n            if (vowels.indexOf(word.charAt(i)) >= 0) {\n                result = word.charAt(i)\n                break\n            }\n            if (consonants.indexOf(word.charAt(i)) >= 0) {\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxi1wrucf.scala:26:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxi1wrucf.scala:30:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxi1wrucf.scala:35:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                result = word.charAt(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    Char\n\u001b[31m   |\u001b[0m                         Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxi1wrucf.scala:36:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxi1wrucf.scala:39:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toSet\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toSet\n        var vowelsAndConsonants = vowels.union(consonants)\n        var vowelsAndConsonantsAndVowels = vowelsAndConsonants.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowels = vowelsAndConsonantsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowels\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292981,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfk6p0buq.scala:31:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfk6p0buq.scala:31:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var vowelsAndConsonants = vowels + consonants\n        var rightSide = word.toLowerCase().split(\"\")\n        var rightSideLength = rightSide.length\n        var rightSideConsonants = rightSide.filter(c -> vowelsAndConsonants.indexOf(c) == -1)\n        var rightSideVowels = rightSide.filter(c -> vowelsAndConsonants.indexOf(c) != -1)\n        var rightSideVowelsLength = rightSideVowels.length\n        var rightSideConsonantsLength = rightSideConsonants.length\n        var rightSideConsonantsIndex = rightSideConsonants.indexOf(\"\")\n        var rightSideVowelsIndex = rightSideVowels.indexOf(\"\")\n        var rightSideConsonantsIndex = rightSideConsonants.indexOf(\"\")\n        var rightSideVowelsIndex = rightSideVowels.indexOf(\"\")\n        var rightSideConsonantsIndex = rightSideConsonants.indexOf(\"\")\n        var rightSideVowelsIndex = rightSideVowels.indexOf(\"\")\n        var rightSideConsonantsIndex = rightSideConsonants.indexOf(\"\")\n        var rightSideVowelsIndex = rightSideVowels.indexOf(\"\")\n        var rightSideConsonantsIndex = rightSideConsonants.indexOf(\"\")\n        var rightSideVowelsIndex = rightSideVowels.indexOf(\"\")\n        var rightSideConsonantsIndex = rightSideConsonants.indexOf(\"\")\n        var rightSideVowelsIndex = rightSideVowels.indexOf(\"\")\n        var rightSideConsonantsIndex = rightSideConsonants.indexOf(\"\")\n        var rightSideVowelsIndex = rightSideVowels.indexOf(\"\")\n        var rightSideConsonantsIndex = rightSideConsonants.indexOf(\"\")\n        var rightSideVowelsIndex = rightSideVowels.indexOf(\"\")\n        var rightSide\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292981,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgf3uifys.scala:45:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpgf3uifys.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideConsonantsIndex\u001b[0m = rightSideConsonants.indexOf(\u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightSideConsonantsIndex is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightSideConsonantsIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpgf3uifys.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideVowelsIndex\u001b[0m = rightSideVowels.indexOf(\u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightSideVowelsIndex is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightSideVowelsIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpgf3uifys.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideConsonantsIndex\u001b[0m = rightSideConsonants.indexOf(\u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightSideConsonantsIndex is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightSideConsonantsIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpgf3uifys.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideVowelsIndex\u001b[0m = rightSideVowels.indexOf(\u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var vowelsAndConsonants = vowels + consonants\n        var rightSide = word.toLowerCase().split(\"\")\n        var rightSideLength = rightSide.length\n        var rightSideConsonants = rightSide.filter(c => vowelsAndConsonants.indexOf(c) == -1)\n        var rightSideVowels = rightSide.filter(c => vowelsAndConsonants.indexOf(c) != -1)\n        var rightSideConsonantsLength = rightSideConsonants.length\n        var rightSideVowelsLength = rightSideVowels.length\n        var rightSideConsonantsIndex = rightSideConsonants.indexOf(rightSide[rightSideLength - 1])\n        var rightSideVowelsIndex = rightSideVowels.indexOf(rightSide[rightSideLength - 1])\n        if (rightSideConsonantsLength == 0 || rightSideVowelsLength == 0) {\n            return \"\"\n        }\n        if (rightSideConsonantsIndex == -1 || rightSideVowelsIndex == -1) {\n            return \"\"\n        }\n        var rightSideConsonantsIndex2 = rightSideConsonants.indexOf(rightSide[rightSideLength - 2])\n        var rightSideVowelsIndex2 = rightSideVowels.indexOf(rightSide[rightSideLength - 2])\n        if (rightSideConsonantsIndex2 == -1 || rightSideVowelsIndex2 == -1) {\n            return \"\"\n        }\n        if (rightSideConsonantsIndex2 < rightSideConsonantsIndex) {\n            return \"\"\n        }\n        if (rightSideVowelsIndex2 < rightSideVowelsIndex) {\n            return \"\"\n        }\n        var rightSideConsonantsIndex3 = rightSideConsonants.indexOf(rightSide[rightSideLength - 3])\n        var rightSideVowelsIndex3 = rightSideVowels.indexOf(rightSide[rightSideLength - 3])\n        if\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292978,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpagwr7la3.scala:49:10 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m        \u001b[33mif\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpagwr7la3.scala:28:93 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideConsonantsIndex\u001b[0m = rightSideConsonants.indexOf(rightSide[\u001b[35mrightSideLength\u001b[0m \u001b[35m-\u001b[0m \u001b[31m1\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: type -\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpagwr7la3.scala:29:85 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideVowelsIndex\u001b[0m = rightSideVowels.indexOf(rightSide[\u001b[35mrightSideLength\u001b[0m \u001b[35m-\u001b[0m \u001b[31m1\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: type -\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpagwr7la3.scala:36:94 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideConsonantsIndex2\u001b[0m = rightSideConsonants.indexOf(rightSide[\u001b[35mrightSideLength\u001b[0m \u001b[35m-\u001b[0m \u001b[31m2\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: type -\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpagwr7la3.scala:37:86 ------------------------\u001b[0m\u001b[0m\n\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (consonants[index] == word.charAt(i)) {\n                index++\n            } else if (vowels[index] == word.charAt(i)) {\n                index = 0\n            } else {\n                result = word.charAt(i)\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpjmmqadro.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpjmmqadro.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpjmmqadro.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjmmqadro.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowels_count = 0\n        var consonants_count = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var consonant_count = 0\n        var consonant_index = 0\n        var vowel_index = 0\n        var consonant_index_count = 0\n        var vowel_index_count = 0\n        var consonant_index_count_count = 0\n        var vowel_index_count_count = 0\n        var consonant_index_count_count_count = 0\n        var vowel_index_count_count_count = 0\n        var consonant_index_count_count_count_count = 0\n        var vowel_index_count_count_count_count = 0\n        var consonant_index_count_count_count_count_count = 0\n        var vowel_index_count_count_count_count_count = 0\n        var consonant_index_count_count_count_count_count_count = 0\n        var vowel_index_count_count_count_count_count_count = 0\n        var consonant_index_count_count_count_count_count_count_count = 0\n        var vowel_index_count_count_count_count_count_count_count = 0\n        var consonant_index_count_count_count_count_count_count_count_count = 0\n        var vowel_index_count_count_count_count_count_count_count_count = 0\n        var consonant_index_count_count_count_count_count_count_count_count_count = 0\n        var vowel_index_count_count_count_count_\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292980,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpy6a51q3w.scala:62:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpy6a51q3w.scala:62:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowelsAndConsonants = vowels + consonants\n        var wordLength = word.length()\n        var rightSide = wordLength - 1\n        var rightSideVowels = \"\"\n        var rightSideConsonants = \"\"\n        var rightSideVowelsAndConsonants = \"\"\n        for (var i = rightSide; i >= 0; i--) {\n            if (vowelsAndConsonants.indexOf(word.charAt(i)) != -1) {\n                rightSideVowels = word.charAt(i) + rightSideVowels\n                rightSideConsonants = word.charAt(i) + rightSideConsonants\n                rightSideVowelsAndConsonants = word.charAt(i) + rightSideVowelsAndConsonants\n            }\n        }\n        var closestVowel = \"\"\n        for (var i = 0; i < rightSideVowelsAndConsonants.length; i++) {\n            if (vowelsAndConsonants.indexOf(rightSideVowelsAndConsonants.charAt(i)) != -1) {\n                closestVowel = rightSideVowelsAndConsonants.charAt(i)\n                break\n            }\n        }\n        return closestVowel\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp3qqy6mgv.scala:27:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = rightSide; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3qqy6mgv.scala:27:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = rightSide; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp3qqy6mgv.scala:27:43 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = rightSide; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp3qqy6mgv.scala:35:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < rightSideVowelsAndConsonants.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3qqy6mgv.scala:35:63 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < rightSideVowelsAndConsonants.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp3qqy6mgv.scala:35:68 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < rightSideVowelsAnd",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var consonantIndex = 0\n        var vowelIndex = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            var c = word.charAt(i)\n            if (consonants[consonantIndex] == c) {\n                consonantIndex += 1\n            } else if (vowels[vowelIndex] == c) {\n                vowelIndex += 1\n            } else {\n                result = c\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpvqq4m2yp.scala:24:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvqq4m2yp.scala:24:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpvqq4m2yp.scala:24:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvqq4m2yp.scala:24:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var vowelsAndConsonants = vowels + consonants\n        var vowelsAndConsonantsLen = vowelsAndConsonants.length\n        var wordLen = word.length\n        var rightSide = word.substring(wordLen - 1)\n        var rightSideLen = rightSide.length\n        var rightSideConsonants = rightSide.substring(0, rightSideLen - 1)\n        var rightSideConsonantsLen = rightSideConsonants.length\n        var rightSideConsonantsVowels = rightSideConsonants.findAllIn(vowelsAndConsonants)\n        var rightSideConsonantsVowelsLen = rightSideConsonantsVowels.length\n        var rightSideConsonantsVowelsIndex = rightSideConsonantsVowels.indexOf(vowels)\n        var rightSideConsonantsVowelsIndex2 = rightSideConsonantsVowels.indexOf(vowels, rightSideConsonantsVowelsIndex + 1)\n        var rightSideConsonantsVowelsIndex3 = rightSideConsonantsVowels.indexOf(vowels, rightSideConsonantsVowelsIndex2 + 1)\n        var rightSideConsonantsVowelsIndex4 = rightSideConsonantsVowels.indexOf(vowels, rightSideConsonantsVowelsIndex3 + 1)\n        var rightSideConsonantsVowelsIndex5 = rightSideConsonantsVowels.indexOf(vowels, rightSideConsonantsVowelsIndex4 + 1)\n        var rightSideConsonantsVowelsIndex6 = rightSideConsonantsVowels.indexOf(vowels, rightSideConsonantsVowelsIndex5 + 1)\n        var rightSideConsonantsVowelsIndex7 = rightSideConsonantsVowels.indexOf(vowels, rightSideConsonantsVowelsIndex6 + 1)\n        var rightSideConsonantsVowelsIndex8 = right\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292990,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpizsmxmz7.scala:28:60 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideConsonantsVowels\u001b[0m = rightSideConsonants.findAllIn(vowelsAndConsonants)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               value findAllIn is not a member of String\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpizsmxmz7.scala:37:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideConsonantsVowelsIndex8\u001b[0m = right\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                              Not found: right\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpizsmxmz7.scala:38:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var vowelsAndConsonants = vowels + consonants\n        var right = word.length\n        var left = 0\n        var rightVowel = \"\"\n        var leftVowel = \"\"\n        for (i <- 0 until right) {\n            if (vowelsAndConsonants.indexOf(word.charAt(i)) >= 0) {\n                if (rightVowel == \"\") {\n                    rightVowel = word.charAt(i)\n                } else {\n                    leftVowel = word.charAt(i)\n                    break\n                }\n            }\n            if (word.charAt(i) == \" \") {\n                left = i + 1\n            }\n        }\n        if (leftVowel == \"\") {\n            return \"\"\n        } else {\n            return leftVowel\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292990,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9t73e3yj.scala:29:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                    rightVowel = word.charAt(i)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    Char\n\u001b[31m   |\u001b[0m                                 Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9t73e3yj.scala:31:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                    leftVowel = word.charAt(i)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    Char\n\u001b[31m   |\u001b[0m                                Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9t73e3yj.scala:32:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp9t73e3yj.scala:35:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            \u001b[33mif\u001b[0m (word.charAt(i) == \u001b[31m\" \"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var vowelsAndConsonants = vowels + consonants\n        var rightSide = word.toLowerCase().split(\"\")\n        var rightSideLength = rightSide.length\n        var rightSideLengthMinus1 = rightSideLength - 1\n        var rightSideLengthMinus2 = rightSideLength - 2\n        var rightSideLengthMinus3 = rightSideLength - 3\n        var rightSideLengthMinus4 = rightSideLength - 4\n        var rightSideLengthMinus5 = rightSideLength - 5\n        var rightSideLengthMinus6 = rightSideLength - 6\n        var rightSideLengthMinus7 = rightSideLength - 7\n        var rightSideLengthMinus8 = rightSideLength - 8\n        var rightSideLengthMinus9 = rightSideLength - 9\n        var rightSideLengthMinus10 = rightSideLength - 10\n        var rightSideLengthMinus11 = rightSideLength - 11\n        var rightSideLengthMinus12 = rightSideLength - 12\n        var rightSideLengthMinus13 = rightSideLength - 13\n        var rightSideLengthMinus14 = rightSideLength - 14\n        var rightSideLengthMinus15 = rightSideLength - 15\n        var rightSideLengthMinus16 = rightSideLength - 16\n        var rightSideLengthMinus17 = rightSideLength - 17\n        var rightSideLengthMinus18 = rightSideLength - 18\n        var rightSideLengthMinus19 = rightSideLength - 19\n        var rightSideLengthMinus20 = rightSideLength - 20\n        var rightSideLengthMinus21 = rightSideLength - 21\n        var rightSideLengthMinus22 = rightSideLength - 22\n        var rightSideLengthMinus23 = rightSideLength - 23\n        var rightSideLengthMinus24 = rightSideLength - 24\n        var rightSideLengthMinus25 = rightSideLength - 25\n        var rightSideLengthMinus26 = rightSideLength - 26\n        var rightSideLengthMinus27 = rightSideLength - 27\n        var rightSideLengthMinus28 = rightSideLength - 28\n        var\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292990,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp5rt80hwz.scala:52:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m        \u001b[33mvar\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5rt80hwz.scala:53:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var result = \"\"\n        var index = 0\n        var i = 0\n        while (i < word.length()) {\n            if (consonants[index] == word.charAt(i)) {\n                index += 1\n            } else if (vowels[index] == word.charAt(i)) {\n                result = word.charAt(i)\n                index += 1\n                break\n            } else {\n                index = 0\n            }\n            i += 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292989,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3v9_ugj4.scala:25:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (consonants[\u001b[35mindex\u001b[0m] == word.charAt(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type index\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3v9_ugj4.scala:27:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (vowels[index] == word.charAt(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type index\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3v9_ugj4.scala:28:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                result = word.charAt(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    Char\n\u001b[31m   |\u001b[0m                         Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3v9_ugj4.scala:30:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var vowelsAndConsonants = vowels + consonants\n        var rightSide = word.toLowerCase().split(\"\")\n        var rightSideLength = rightSide.length\n        var rightSideConsonants = rightSide.filter(c -> vowelsAndConsonants.indexOf(c) == -1)\n        var rightSideVowels = rightSide.filter(c -> vowelsAndConsonants.indexOf(c) != -1)\n        var rightSideConsonantsLength = rightSideConsonants.length\n        var rightSideVowelsLength = rightSideVowels.length\n        var rightSideConsonantsIndex = rightSideConsonants.indexOf(rightSideVowels[rightSideVowelsLength - 1])\n        var rightSideVowelsIndex = rightSideVowels.indexOf(rightSideConsonants[rightSideConsonantsLength - 1])\n        var rightSideConsonantsIndex2 = rightSideConsonants.indexOf(rightSideVowels[rightSideVowelsLength - 2])\n        var rightSideVowelsIndex2 = rightSideVowels.indexOf(rightSideConsonants[rightSideConsonantsLength - 2])\n        var rightSideConsonantsIndex3 = rightSideConsonants.indexOf(rightSideVowels[rightSideVowelsLength - 3])\n        var rightSideVowelsIndex3 = rightSideVowels.indexOf(rightSideConsonants[rightSideConsonantsLength - 3])\n        var rightSideConsonantsIndex4 = rightSideConsonants.indexOf(rightSideVowels[rightSideVowelsLength - 4])\n        var rightSideVowelsIndex4 = rightSideVowels.indexOf(rightSideConsonants[rightSideConsonantsLength - 4])\n        var rightSideConsonantsIndex5 = rightSideConsonants.indexOf(rightSideVowels[rightSideVowelsLength - 5])\n        var rightSideVowelsIndex5 = right\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292989,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfilse818.scala:24:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideConsonants\u001b[0m = rightSide.filter(c -> vowelsAndConsonants.indexOf(c) == -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   Not found: c\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfilse818.scala:25:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideVowels\u001b[0m = rightSide.filter(c -> vowelsAndConsonants.indexOf(c) != -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               Not found: c\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfilse818.scala:28:105 -----------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideConsonantsIndex\u001b[0m = rightSideConsonants.indexOf(rightSideVowels[\u001b[35mrightSideVowelsLength\u001b[0m \u001b[35m-\u001b[0m \u001b[31m1\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: type -\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfilse818.scala:29:105 -----------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideVowelsIndex\u001b[0m = rightSideVowels.indexOf(rightSideConsonants[\u001b[35mrightSideConsonantsLength\u001b[0m \u001b[35m-\u001b[0m \u001b[31m1\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: type -\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available whe",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = List.of(\"a\", \"e\", \"i\", \"o\", \"u\")\n        var consonants = List.of(\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\")\n        var vowelsAndConsonants = vowels.zip(consonants).toMap(tuple -> tuple._1 + tuple._2)\n        var vowelsAndConsonantsLength = vowelsAndConsonants.size()\n        var rightSide = word.length() - 1\n        var rightSideVowels = List.range(0, rightSide).filter(i -> vowelsAndConsonantsLength.get(word.charAt(i))).toList()\n        var rightSideVowelsLength = rightSideVowels.size()\n        var rightSideVowelsAndConsonants = rightSideVowels.zip(rightSideVowels).toMap(tuple -> tuple._1 + tuple._2)\n        var rightSideVowelsAndConsonantsLength = rightSideVowelsAndConsonants.size()\n        var rightSideVowelsAndConsonantsVowels = rightSideVowelsAndConsonants.values().toList()\n        var rightSideVowelsAndConsonantsVowelsLength = rightSideVowelsAndConsonantsVowels.size()\n        var rightSideVowelsAndConsonantsVowelsAndConsonants = rightSideVowelsAndConsonantsVowels.zip(rightSideVowelsAndConsonantsVowels).toMap(tuple -> tuple._1 + tuple._2)\n        var rightSideVowelsAndConsonantsVowelsAndConsonantsLength = rightSideVowelsAndConsonantsVowelsAndConsonants.size()\n        var rightSideVowelsAndConsonantsVowelsAndConsonantsVowels = rightSideVowelsAndConsonantsVowelsAndConsonants.values().toList()\n        var rightSideVowelsAndConsonantsVow\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292992,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqpz6h98q.scala:34:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqpz6h98q.scala:19:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mvowels\u001b[0m = List.of(\u001b[31m\"a\"\u001b[0m, \u001b[31m\"e\"\u001b[0m, \u001b[31m\"i\"\u001b[0m, \u001b[31m\"o\"\u001b[0m, \u001b[31m\"u\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value of is not a member of object scala.collection.immutable.List\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqpz6h98q.scala:20:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mconsonants\u001b[0m = List.of(\u001b[31m\"b\"\u001b[0m, \u001b[31m\"c\"\u001b[0m, \u001b[31m\"d\"\u001b[0m, \u001b[31m\"f\"\u001b[0m, \u001b[31m\"g\"\u001b[0m, \u001b[31m\"h\"\u001b[0m, \u001b[31m\"j\"\u001b[0m, \u001b[31m\"k\"\u001b[0m, \u001b[31m\"l\"\u001b[0m, \u001b[31m\"m\"\u001b[0m, \u001b[31m\"n\"\u001b[0m, \u001b[31m\"p\"\u001b[0m, \u001b[31m\"q\"\u001b[0m, \u001b[31m\"r\"\u001b[0m, \u001b[31m\"s\"\u001b[0m, \u001b[31m\"t\"\u001b[0m, \u001b[31m\"v\"\u001b[0m, \u001b[31m\"w\"\u001b[0m, \u001b[31m\"x\"\u001b[0m, \u001b[31m\"y\"\u001b[0m, \u001b[31m\"z\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value of is not a member of object scala.collection.immutable.List\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqpz6h98q.scala:24:62 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideVowels\u001b[0m = List.range(\u001b[31m0\u001b[0m, rightSide).filter(i -> vowelsAndConsonantsLength.get(word.charAt(i))).toList()\n\u001b[31m\u001b[31m   |\u001b[0m                                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                            Not found: i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqpz6h98q.scala:34:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var result = \"\"\n        for (var i = 0; i < word.length(); i++) {\n            if (vowels.indexOf(word.charAt(i)) >= 0) {\n                result = word.charAt(i)\n                break\n            }\n            if (consonants.indexOf(word.charAt(i)) >= 0) {\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292994,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpesl6ak14.scala:22:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpesl6ak14.scala:22:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpesl6ak14.scala:22:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpesl6ak14.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var index = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (consonants[i] != word[i]) {\n                index = i\n                break\n            }\n        }\n        for (i <- index + 1 until word.length) {\n            if (vowels[i] != word[i]) {\n                result = word[i]\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292989,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpi8iqxjel.scala:24:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m (consonants[\u001b[35mi\u001b[0m] != word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpi8iqxjel.scala:26:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpi8iqxjel.scala:30:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            \u001b[33mif\u001b[0m (vowels[\u001b[35mi\u001b[0m] != word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpi8iqxjel.scala:31:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpi8iqxjel.scala:32:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var closestVowel = \"\"\n        var wordLength = word.length\n        for (var i = wordLength - 1; i >= 0; i--) {\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (vowels[vowelsIndex] == word[i]) {\n                    vowelsIndex += 1\n                } else if (consonants[consonantsIndex] == word[i]) {\n                    consonantsIndex += 1\n                } else {\n                    if (Math.abs(vowelsIndex - vowels.length) < Math.abs(consonantsIndex - consonants.length)) {\n                        closestVowel = vowels[vowelsIndex - 1]\n                    } else {\n                        closestVowel = consonants[consonantsIndex - 1]\n                    }\n                    break\n                }\n            } else {\n                if (Math.abs(vowelsIndex - vowels.length) < Math.abs(consonantsIndex - consonants.length)) {\n                    closestVowel = vowels[vowelsIndex - 1]\n                } else {\n                    closestVowel = consonants[consonantsIndex - 1]\n                }\n                break\n            }\n        }\n        return closestVowel\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpwzr7bgrx.scala:25:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = wordLength - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwzr7bgrx.scala:25:43 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = wordLength - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpwzr7bgrx.scala:25:48 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = wordLength - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwzr7bgrx.scala:25:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = wordLength - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.conve",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var closestVowel = \"\"\n        var wordLength = word.length\n        for (var i = 0; i < wordLength; i++) {\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (vowels[vowelsIndex] == word[i]) {\n                    vowelsIndex += 1\n                } else if (consonants[consonantsIndex] == word[i]) {\n                    consonantsIndex += 1\n                } else {\n                    if (Math.abs(vowelsIndex - consonantsIndex) < Math.abs(vowelsIndex - closestVowel.length)) {\n                        closestVowel = \"\"\n                    }\n                    if (Math.abs(vowelsIndex - consonantsIndex) == Math.abs(vowelsIndex - closestVowel.length)) {\n                        if (vowelsIndex < consonantsIndex) {\n                            closestVowel = \"\"\n                        } else {\n                            closestVowel = \"\"\n                        }\n                    }\n                    if (Math.abs(vowelsIndex - consonantsIndex) > Math.abs(vowelsIndex - closestVowel.length)) {\n                        closestVowel = \"\"\n                    }\n                    if (Math.abs(vowelsIndex - consonantsIndex) == Math.abs(vowelsIndex - closestVowel.length)) {\n                        if (vowelsIndex < consonantsIndex) {\n                            closestVowel = \"\"\n                        } else {\n                            closestVowel = \"\"\n                        }\n                    }\n                    if (Math.abs(vowelsIndex - consonantsIndex) > Math.abs(vowelsIndex - closestVowel.length)) {\n                        closestVowel = \"\"\n                    }\n                    if (Math.abs(vowelsIndex - consonantsIndex) == Math.abs(vowelsIndex - closestVowel.length))\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292994,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpkz1wvona.scala:25:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpkz1wvona.scala:25:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpkz1wvona.scala:25:43 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkz1wvona.scala:25:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.conve",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = List.of(\"a\", \"e\", \"i\", \"o\", \"u\")\n        var consonants = List.of(\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\")\n        var consonantIndex = 0\n        var vowelIndex = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (consonants.indexOf(word.charAt(i)) >= 0) {\n                if (vowels.indexOf(word.charAt(i)) >= 0) {\n                    vowelIndex = i\n                }\n                consonantIndex = i\n            }\n        }\n        if (vowelIndex == 0) {\n            return \"\"\n        } else {\n            return word.substring(vowelIndex - 1, consonantIndex)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292995,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0h3_lkjb.scala:19:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mvowels\u001b[0m = List.of(\u001b[31m\"a\"\u001b[0m, \u001b[31m\"e\"\u001b[0m, \u001b[31m\"i\"\u001b[0m, \u001b[31m\"o\"\u001b[0m, \u001b[31m\"u\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value of is not a member of object scala.collection.immutable.List\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0h3_lkjb.scala:20:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mconsonants\u001b[0m = List.of(\u001b[31m\"b\"\u001b[0m, \u001b[31m\"c\"\u001b[0m, \u001b[31m\"d\"\u001b[0m, \u001b[31m\"f\"\u001b[0m, \u001b[31m\"g\"\u001b[0m, \u001b[31m\"h\"\u001b[0m, \u001b[31m\"j\"\u001b[0m, \u001b[31m\"k\"\u001b[0m, \u001b[31m\"l\"\u001b[0m, \u001b[31m\"m\"\u001b[0m, \u001b[31m\"n\"\u001b[0m, \u001b[31m\"p\"\u001b[0m, \u001b[31m\"q\"\u001b[0m, \u001b[31m\"r\"\u001b[0m, \u001b[31m\"s\"\u001b[0m, \u001b[31m\"t\"\u001b[0m, \u001b[31m\"v\"\u001b[0m, \u001b[31m\"w\"\u001b[0m, \u001b[31m\"x\"\u001b[0m, \u001b[31m\"y\"\u001b[0m, \u001b[31m\"z\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value of is not a member of object scala.collection.immutable.List\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (consonants[index] == word.charAt(i)) {\n                index++\n            } else if (vowels[index] == word.charAt(i)) {\n                result = word.substring(i, i + 1)\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292994,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmps2f0f_45.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmps2f0f_45.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmps2f0f_45.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmps2f0f_45.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var index = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (consonants.indexOf(word[i]) != -1) {\n                index = i\n                break\n            }\n        }\n        for (i <- index + 1 until word.length) {\n            if (vowels.indexOf(word[i]) != -1) {\n                result = word[i]\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292991,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe0ksm67j.scala:24:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m (consonants.indexOf(word[\u001b[35mi\u001b[0m]) != -\u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe0ksm67j.scala:26:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe0ksm67j.scala:30:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            \u001b[33mif\u001b[0m (vowels.indexOf(word[\u001b[35mi\u001b[0m]) != -\u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe0ksm67j.scala:31:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe0ksm67j.scala:32:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var i = 0\n        var j = word.length() - 1\n        var closest = \"\"\n        while (i < j) {\n            if (vowels[i] == word.charAt(i) && vowels[j] == word.charAt(j)) {\n                closest = word.charAt(i)\n                i += 1\n                j -= 1\n            } else if (vowels[i] == word.charAt(i) && consonants[j] == word.charAt(j)) {\n                closest = word.charAt(i)\n                i += 1\n                j -= 1\n            } else if (vowels[j] == word.charAt(j) && consonants[i] == word.charAt(i)) {\n                closest = word.charAt(j)\n                j -= 1\n                i += 1\n            } else if (vowels[j] == word.charAt(j) && vowels[i] == word.charAt(i)) {\n                closest = word.charAt(i)\n                i += 1\n                j -= 1\n            } else if (vowels[i] == word.charAt(i) && vowels[j] == word.charAt(j)) {\n                closest = word.charAt(i)\n                i += 1\n                j -= 1\n            } else if (vowels[j] == word.charAt(j) && vowels[i] == word.charAt(i)) {\n                closest = word.charAt(j)\n                j -= 1\n                i += 1\n            } else if (vowels[i] == word.charAt(i) && consonants[j] == word.charAt(j)) {\n                closest = word.charAt(i)\n                i += 1\n                j -= 1\n            } else if (vowels[j] == word.charAt(j) && consonants[i] == word.charAt(i)) {\n                cl\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpxj9nybs4.scala:73:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxj9nybs4.scala:25:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (vowels[\u001b[35mi\u001b[0m] == word.charAt(i) && vowels[\u001b[35mj\u001b[0m] == word.charAt(j)) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxj9nybs4.scala:26:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                closest = word.charAt(i)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    Char\n\u001b[31m   |\u001b[0m                          Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxj9nybs4.scala:29:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (vowels[i] == word.charAt(i) && consonants[j] == word.charAt(j)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxj9nybs4.scala:30:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                closest = word.charAt(i)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    Char\n\u001b[31m   |\u001b[0m                          Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxj9nybs4.scala:33:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (vowels[j] == word.charAt(j) && consonants[i] == word.charAt(i",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        if (word.length == 0) return \"\"\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var index = 0\n        var result = \"\"\n        for (var i = word.length - 1; i >= 0; i--) {\n            if (vowels.indexOf(word.charAt(i)) != -1) {\n                index = i\n                break\n            }\n        }\n        if (index == 0) return \"\"\n        for (var i = index + 1; i < word.length; i++) {\n            if (consonants.indexOf(word.charAt(i)) != -1) {\n                result = word.charAt(i)\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp3cvt1mx_.scala:24:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3cvt1mx_.scala:24:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp3cvt1mx_.scala:24:49 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                 pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp3cvt1mx_.scala:31:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = index + \u001b[31m1\u001b[0m; i < word.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3cvt1mx_.scala:31:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = index + \u001b[31m1\u001b[0m; i < word.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp3cvt1mx_.scala:31:52 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = index + \u001b[31m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = List(\"a\", \"e\", \"i\", \"o\", \"u\")\n        var consonants = List(\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\")\n        var consonantIndex = 0\n        var vowelIndex = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (consonants.indexOf(word[i]) > -1) {\n                consonantIndex = consonants.indexOf(word[i])\n            } else if (vowels.indexOf(word[i]) > -1) {\n                vowelIndex = vowels.indexOf(word[i])\n            } else {\n                break\n            }\n            if (vowelIndex > consonantIndex) {\n                result = word[i]\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292992,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb9dxxg64.scala:25:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (consonants.indexOf(word[\u001b[35mi\u001b[0m]) > -\u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb9dxxg64.scala:26:57 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                consonantIndex = consonants.indexOf(word[\u001b[35mi\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb9dxxg64.scala:27:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (vowels.indexOf(word[i]) > -\u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb9dxxg64.scala:28:49 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                vowelIndex = vowels.indexOf(word[\u001b[35mi\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                 Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb9dxxg64.scala:30:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb9",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var result = \"\"\n        for (i = word.length() - 1; i >= 0; i--) {\n            if (vowels.indexOf(word.charAt(i)) != -1) {\n                break\n            }\n        }\n        for (j = i + 1; j < word.length(); j++) {\n            if (vowels.indexOf(word.charAt(j)) != -1) {\n                break\n            }\n        }\n        for (k = j + 1; k < word.length(); k++) {\n            if (vowels.indexOf(word.charAt(k)) != -1) {\n                break\n            }\n        }\n        for (l = k + 1; l < word.length(); l++) {\n            if (vowels.indexOf(word.charAt(l)) != -1) {\n                break\n            }\n        }\n        for (m = l + 1; m < word.length(); m++) {\n            if (vowels.indexOf(word.charAt(m)) != -1) {\n                break\n            }\n        }\n        for (n = m + 1; n < word.length(); n++) {\n            if (vowels.indexOf(word.charAt(n)) != -1) {\n                break\n            }\n        }\n        for (o = n + 1; o < word.length(); o++) {\n            if (vowels.indexOf(word.charAt(o)) != -1) {\n                break\n            }\n        }\n\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292999,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpt35vsi0a.scala:40:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpt35vsi0a.scala:40:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpt35vsi0a.scala:40:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpt35vsi0a.scala:45:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mfor\u001b[0m (j = i + \u001b[31m1\u001b[0m; j < word.length(); j++) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpt35vsi0a.scala:45:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mfor\u001b[0m (j = i + \u001b[31m1\u001b[0m; j < word.length(); j++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpt35vsi0a.scala:45:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mfor\u001b[0m (j = i + \u001b[31m1\u001b[0m; j < word.length(); j++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowelsAndConsonants = vowels + consonants\n        var right = word.length\n        var left = 0\n        var rightVowel = \"\"\n        var leftVowel = \"\"\n        while (left < right) {\n            if (vowelsAndConsonants[right] == vowelsAndConsonants[left]) {\n                rightVowel = vowelsAndConsonants[right]\n                leftVowel = vowelsAndConsonants[left]\n                right -= 1\n                left += 1\n            } else if (vowelsAndConsonants[right] == consonants[left]) {\n                right -= 1\n                left += 1\n            } else if (vowelsAndConsonants[left] == vowelsAndConsonants[right]) {\n                right += 1\n                left -= 1\n            } else if (vowelsAndConsonants[left] == consonants[right]) {\n                right += 1\n                left -= 1\n            } else {\n                right -= 1\n                left += 1\n            }\n        }\n        return rightVowel\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmf91lzjz.scala:21:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mvowelsAndConsonants\u001b[0m = vowels + consonants\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of Array[Char], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmf91lzjz.scala:27:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m (vowelsAndConsonants[\u001b[35mright\u001b[0m] == vowelsAndConsonants[\u001b[35mleft\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type right\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmf91lzjz.scala:28:49 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                rightVowel = vowelsAndConsonants[\u001b[35mright\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                 Not found: type right\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmf91lzjz.scala:29:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                leftVowel = vowelsAndConsonants[\u001b[35mleft\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                Not found: type left\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmf91lzjz.scala:32:43 ----------------------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowelsAndConsonants = vowels + consonants\n        var vowelsAndConsonantsLength = vowelsAndConsonants.length\n        var wordLength = word.length\n        var wordConsonants = word.toCharArray()\n        var wordConsonantsLength = wordConsonants.length\n        var wordConsonantsIndex = wordConsonantsLength - 1\n        var wordConsonantsIndexVowels = wordConsonantsIndex - 1\n        var wordConsonantsIndexConsonants = wordConsonantsIndex - 2\n        var wordConsonantsIndexConsonantsVowels = wordConsonantsIndexConsonants - 1\n        var wordConsonantsIndexConsonantsVowelsIndex = wordConsonantsIndexConsonantsVowels - 1\n        var wordConsonantsIndexConsonantsVowelsIndexVowels = wordConsonantsIndexConsonantsVowels - 1\n        var wordConsonantsIndexConsonantsVowelsIndexVowelsIndex = wordConsonantsIndexConsonantsVowelsIndexVowels - 1\n        var wordConsonantsIndexConsonantsVowelsIndexVowelsIndexConsonants = wordConsonantsIndexConsonantsVowelsIndexVowelsIndexConsonants - 1\n        var wordConsonantsIndexConsonantsVowelsIndexVowelsIndexConsonantsVowels = wordConsonantsIndexConsonantsVowelsIndexVowelsIndexConsonantsVowels - 1\n        var wordConsonantsIndexConsonantsVowelsIndexVowelsIndexConsonantsVowelsIndex = wordConsonantsIndexConsonantsVowelsIndexVowelsIndexConsonantsVowelsIndex - 1\n        var wordConsonantsIndexConsonantsVowelsIndexVowelsIndexConsonantsVowelsIndexConsonants = wordConsonantsIndexConsonantsVowelsIndexVowelsIndexConsonantsVowelsIndexConsonants - 1\n        var wordConsonantsIndexConsonantsVowelsIndexVowelsIndex\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpf0qa9xkc.scala:38:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpf0qa9xkc.scala:21:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mvowelsAndConsonants\u001b[0m = vowels + consonants\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of Array[Char], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpf0qa9xkc.scala:33:76 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mwordConsonantsIndexConsonantsVowelsIndexVowelsIndexConsonants\u001b[0m = wordConsonantsIndexConsonantsVowelsIndexVowelsIndexConsonants - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                                            ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvariable\u001b[0m \u001b[35mwordConsonantsIndexConsonantsVowelsIndexVowelsIndexConsonants\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpf0qa9xkc.scala:34:82 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mwordConsonantsIndexConsonantsVowelsIndexVowelsIndexConsonantsVowels\u001b[0m = wordConsonantsIndexConsonantsVowelsIndexVowelsIndexConsonantsVowels - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvariable\u001b[0m \u001b[35mwordConsonantsIndexConsonantsVowelsIndexVowelsIndexConsonantsVowels\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available whe",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var i = 0\n        var j = word.length() - 1\n        var result = \"\"\n        while (i < j) {\n            if (vowels.indexOf(word.charAt(i)) != -1 && consonants.indexOf(word.charAt(j)) != -1) {\n                result = word.charAt(i)\n                break\n            }\n            i = i + 1\n            j = j - 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292995,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpz8ru0_x8.scala:26:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = word.charAt(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    Char\n\u001b[31m   |\u001b[0m                         Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz8ru0_x8.scala:27:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowelsAndConsonants = vowels + consonants\n        var vowelsAndConsonantsLength = vowelsAndConsonants.length\n        var wordLength = word.length\n        var wordConsonants = word.toCharArray\n        var wordConsonantsLength = wordConsonants.length\n        var wordVowels = word.toLowerCase().toCharArray\n        var wordVowelsLength = wordVowels.length\n        var wordConsonantsAndVowels = wordConsonants + wordVowels\n        var wordConsonantsAndVowelsLength = wordConsonantsAndVowels.length\n        var wordConsonantsAndVowelsIndex = 0\n        var wordConsonantsAndVowelsIndexEnd = wordConsonantsAndVowelsLength - 1\n        var wordConsonantsAndVowelsIndexStart = 0\n        var wordConsonantsAndVowelsIndexStartEnd = wordConsonantsAndVowelsLength - 1\n        var wordConsonantsAndVowelsIndexStartEndIndex = 0\n        var wordConsonantsAndVowelsIndexStartEndIndexEnd = wordConsonantsAndVowelsLength - 1\n        var wordConsonantsAndVowelsIndexStartEndIndexStart = 0\n        var wordConsonantsAndVowelsIndexStartEndIndexStartEnd = wordConsonantsAndVowelsLength - 1\n        var wordConsonantsAndVowelsIndexStartEndIndexStartEndIndex = 0\n        var wordConsonantsAndVowelsIndexStartEndIndexStartEndIndexEnd = wordConsonantsAndVowelsLength - 1\n        var wordConsonantsAndVowelsIndexStartEndIndexStartEndIndexStart = 0\n        var wordConsonantsAndVowelsIndexStartEndIndexStartEndIndexStartEnd = wordConsonantsAndVowelsLength - 1\n        var wordConsonantsAndVowelsIndexStartEndIndexStartEndIndexStartEndIndex = 0\n        var wordConsonantsAndVowelsIndexStartEndIndexStartEndIndexStartEndIndexEnd = wordConsonantsAnd\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx651qgf2.scala:21:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mvowelsAndConsonants\u001b[0m = vowels + consonants\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of Array[Char], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx651qgf2.scala:28:53 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mwordConsonantsAndVowels\u001b[0m = wordConsonants + wordVowels\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of Array[Char], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpx651qgf2.scala:43:85 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mwordConsonantsAndVowelsIndexStartEndIndexStartEndIndexStartEndIndexEnd\u001b[0m = wordConsonantsAnd\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                     ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Not found: wordConsonantsAnd\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpx651qgf2.scala:44:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var result = \"\"\n        for (i = word.length() - 1; i >= 0; i--) {\n            if (consonants[i] != \"\") {\n                for (j = i - 1; j >= 0; j--) {\n                    if (consonants[j] != \"\") {\n                        for (k = j - 1; k >= 0; k--) {\n                            if (consonants[k] != \"\") {\n                                for (l = k - 1; l >= 0; l--) {\n                                    if (consonants[l] != \"\") {\n                                        for (m = l - 1; m >= 0; m--) {\n                                            if (consonants[m] != \"\") {\n                                                for (n = m - 1; n >= 0; n--) {\n                                                    if (consonants[n] != \"\") {\n                                                        for (o = n - 1; o >= 0; o--) {\n                                                            if (consonants[o] != \"\") {\n                                                                for (p = o - 1; p >= 0; p--) {\n                                                                    if (consonants[p] != \"\") {\n                                                                        for (q = p - 1; q >= 0; q--) {\n                                                                            if (consonants[q] != \"\") {\n                                                                                for (r = q - 1; r >= 0; r--) {\n                               \n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwakg9z1s.scala:40:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwakg9z1s.scala:40:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpwakg9z1s.scala:40:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwakg9z1s.scala:40:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue foreach is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator as",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var index = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (consonants.indexOf(word.charAt(i)) != -1) {\n                index = i\n                break\n            }\n        }\n        for (i <- index + 1 until word.length) {\n            if (vowels.indexOf(word.charAt(i)) != -1) {\n                result = word.charAt(i)\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292995,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpc_2px4p8.scala:26:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpc_2px4p8.scala:31:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                result = word.charAt(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    Char\n\u001b[31m   |\u001b[0m                         Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpc_2px4p8.scala:32:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var result = \"\"\n        var index = 0\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (consonants[index] == word.charAt(i)) {\n                index += 1\n            } else if (vowels[index] == word.charAt(i)) {\n                index += 1\n                result = word.charAt(i)\n                break\n            } else {\n                index = 0\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpsl7kztta.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpsl7kztta.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpsl7kztta.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsl7kztta.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var result = \"\"\n        for (i = word.length() - 1; i >= 0; i--) {\n            if (vowels.indexOf(word.charAt(i)) != -1) {\n                break\n            }\n        }\n        for (j = i + 1; j < word.length(); j++) {\n            if (vowels.indexOf(word.charAt(j)) != -1) {\n                break\n            }\n        }\n        for (k = j + 1; k < word.length(); k++) {\n            if (vowels.indexOf(word.charAt(k)) != -1) {\n                break\n            }\n        }\n        for (l = k + 1; l < word.length(); l++) {\n            if (vowels.indexOf(word.charAt(l)) != -1) {\n                break\n            }\n        }\n        for (m = l + 1; m < word.length(); m++) {\n            if (vowels.indexOf(word.charAt(m)) != -1) {\n                break\n            }\n        }\n        for (n = m + 1; n < word.length(); n++) {\n            if (vowels.indexOf(word.charAt(n)) != -1) {\n                break\n            }\n        }\n        for (o = n + 1; o < word.length(); o++) {\n            if (vowels.indexOf(word.charAt(o)) != -1) {\n                break\n            }\n        }\n\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292999,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpt35vsi0a.scala:40:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpt35vsi0a.scala:40:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpt35vsi0a.scala:40:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpt35vsi0a.scala:45:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mfor\u001b[0m (j = i + \u001b[31m1\u001b[0m; j < word.length(); j++) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpt35vsi0a.scala:45:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mfor\u001b[0m (j = i + \u001b[31m1\u001b[0m; j < word.length(); j++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpt35vsi0a.scala:45:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mfor\u001b[0m (j = i + \u001b[31m1\u001b[0m; j < word.length(); j++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var vowelsAndConsonants = vowels + consonants\n        var rightSide = word.toLowerCase().split(\"\")\n        var rightSideLength = rightSide.length\n        var rightSideConsonants = rightSide.filter(c -> vowelsAndConsonants.indexOf(c) == -1)\n        var rightSideVowels = rightSide.filter(c -> vowelsAndConsonants.indexOf(c) != -1)\n        var rightSideVowelsLength = rightSideVowels.length\n        var rightSideConsonantsLength = rightSideConsonants.length\n        var closestVowel = \"\"\n        if (rightSideVowelsLength > 0) {\n            var rightSideVowelsIndex = rightSideVowels.indexOf(\"a\")\n            if (rightSideVowelsIndex != -1) {\n                closestVowel = rightSideVowels[rightSideVowelsIndex]\n            } else {\n                var rightSideVowelsIndex = rightSideVowels.indexOf(\"e\")\n                if (rightSideVowelsIndex != -1) {\n                    closestVowel = rightSideVowels[rightSideVowelsIndex]\n                } else {\n                    var rightSideVowelsIndex = rightSideVowels.indexOf(\"i\")\n                    if (rightSideVowelsIndex != -1) {\n                        closestVowel = rightSideVowels[rightSideVowelsIndex]\n                    } else {\n                        var rightSideVowelsIndex = rightSideVowels.indexOf(\"o\")\n                        if (rightSideVowelsIndex != -1) {\n                            closestVowel = rightSideVowels[rightSideVowelsIndex]\n                        } else {\n                            var rightSideVowelsIndex = rightSideVowels.indexOf(\"u\")\n                            if (rightSideVowelsIndex != -1) {\n                                closestVowel = rightSideVowels[right\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292998,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7qvv0k1_.scala:49:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ']' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7qvv0k1_.scala:67:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7qvv0k1_.scala:24:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideConsonants\u001b[0m = rightSide.filter(c -> vowelsAndConsonants.indexOf(c) == -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   Not found: c\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7qvv0k1_.scala:25:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideVowels\u001b[0m = rightSide.filter(c -> vowelsAndConsonants.indexOf(c) != -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               Not found: c\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7qvv0k1_.scala:32:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                closestVowel = rightSideVowels[\u001b[35mrightSideVowelsIndex\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type rightSideVowelsIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7qvv0k1_.scala:36:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    closestVowel = rightSideVowels[\u001b[35mrightSideVowelsIndex\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var result = \"\"\n        for (i = word.length() - 1; i >= 0; i--) {\n            if (vowels.indexOf(word.charAt(i)) != -1) {\n                result = word.charAt(i)\n                break\n            }\n            for (j = i - 1; j >= 0; j--) {\n                if (consonants.indexOf(word.charAt(j)) != -1) {\n                    break\n                }\n            }\n            for (k = j + 1; k < i; k++) {\n                if (consonants.indexOf(word.charAt(k)) != -1) {\n                    break\n                }\n            }\n            for (l = k + 1; l < i; l++) {\n                if (consonants.indexOf(word.charAt(l)) != -1) {\n                    break\n                }\n            }\n            for (m = l + 1; m < i; m++) {\n                if (consonants.indexOf(word.charAt(m)) != -1) {\n                    break\n                }\n            }\n            for (n = m + 1; n < i; n++) {\n                if (consonants.indexOf(word.charAt(n)) != -1) {\n                    break\n                }\n            }\n            for (o = n + 1; o < i; o++) {\n                if (consonants.indexOf(word.charAt(o)) != -1) {\n                    break\n                }\n            }\n            for (\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293004,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpcskxl7wz.scala:40:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpcskxl7wz.scala:40:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpcskxl7wz.scala:40:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpcskxl7wz.scala:94:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m94 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcskxl7wz.scala:40:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue foreach is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.prope",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (consonants[index] == word.charAt(i)) {\n                index = (index + 1) % consonants.length\n            } else {\n                for (var j = 0; j < vowels.length; j++) {\n                    if (vowels[j] == word.charAt(i)) {\n                        result = word.substring(i + 1, word.length)\n                        break\n                    }\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293004,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmprmt7xq2y.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmprmt7xq2y.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmprmt7xq2y.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprmt7xq2y.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (consonants[index] == word.charAt(i)) {\n                index++\n            } else if (vowels[index] == word.charAt(i)) {\n                index = 0\n            } else {\n                break\n            }\n        }\n        if (index > 0) {\n            result = vowels[index]\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpb4g0q0lk.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpb4g0q0lk.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpb4g0q0lk.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpb4g0q0lk.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowels_count = 0\n        var consonants_count = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (vowels[i] == word[i]) {\n                vowels_count += 1\n            } else if (consonants[i] == word[i]) {\n                consonants_count += 1\n                if (vowels_count == 0) {\n                    result = \"\"\n                } else if (consonants_count == 1) {\n                    result = \"\"\n                } else {\n                    result = vowels[i]\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293001,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprxysnnt6.scala:25:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (vowels[\u001b[35mi\u001b[0m] == word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprxysnnt6.scala:27:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (consonants[i] == word[i]) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprxysnnt6.scala:34:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                    result = vowels[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var closestVowel = \"\"\n        var wordLength = word.length()\n        for (var i = 0; i < wordLength; i++) {\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (vowels[vowelsIndex] == word.charAt(i)) {\n                    vowelsIndex += 1\n                } else if (consonants[consonantsIndex] == word.charAt(i)) {\n                    consonantsIndex += 1\n                } else {\n                    if (Math.abs(vowelsIndex - consonantsIndex) < Math.abs(closestVowel.length() - wordLength)) {\n                        closestVowel = \"\"\n                    }\n                    vowelsIndex = 0\n                    consonantsIndex = 0\n                }\n            } else if (vowelsIndex < vowels.length) {\n                if (Math.abs(vowelsIndex - consonantsIndex) < Math.abs(closestVowel.length() - wordLength)) {\n                    closestVowel = \"\"\n                }\n                vowelsIndex = 0\n            } else if (consonantsIndex < consonants.length) {\n                if (Math.abs(vowelsIndex - consonantsIndex) < Math.abs(closestVowel.length() - wordLength)) {\n                    closestVowel = \"\"\n                }\n                consonantsIndex = 0\n            }\n        }\n        return closestVowel\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293004,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpmcu6geyp.scala:25:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpmcu6geyp.scala:25:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpmcu6geyp.scala:25:43 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmcu6geyp.scala:25:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.conve",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var consonantIndex = 0\n        var vowelIndex = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (vowels[vowelIndex] == word.charAt(i)) {\n                result = word.charAt(i)\n                vowelIndex += 1\n                if (vowelIndex == vowels.length) {\n                    vowelIndex = 0\n                }\n            } else if (consonants[consonantIndex] == word.charAt(i)) {\n                consonantIndex += 1\n                if (consonantIndex == consonants.length) {\n                    consonantIndex = 0\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293004,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpkkn6lbe7.scala:24:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpkkn6lbe7.scala:24:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpkkn6lbe7.scala:24:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkkn6lbe7.scala:24:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var i = 0\n        var j = 0\n        var result = \"\"\n        while (i < word.length()) {\n            if (j < word.length() && consonants[j] == word.charAt(i)) {\n                j += 1\n            } else if (j < word.length() && vowels[i] != word.charAt(i)) {\n                j = 0\n            } else {\n                if (j < word.length() && vowels[i] == word.charAt(i)) {\n                    result = word.charAt(i)\n                    break\n                }\n                j = 0\n            }\n            i += 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwbhhfsee.scala:25:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (j < word.length() && consonants[\u001b[35mj\u001b[0m] == word.charAt(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwbhhfsee.scala:27:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (j < word.length() && vowels[i] != word.charAt(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwbhhfsee.scala:30:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                \u001b[33mif\u001b[0m (j < word.length() && vowels[\u001b[35mi\u001b[0m] == word.charAt(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwbhhfsee.scala:31:40 --------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                    result = word.charAt(i)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    Char\n\u001b[31m   |\u001b[0m                             Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwbhhfsee.scala:32:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation availab",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toSet\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toSet\n        var vowelsAndConsonants = vowels.union(consonants)\n        var vowelsAndConsonantsAndVowels = vowelsAndConsonants.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowels = vowelsAndConsonantsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowels\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292981,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfk6p0buq.scala:31:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfk6p0buq.scala:31:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var index = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (consonants.indexOf(word[i]) != -1) {\n                index = i\n                break\n            }\n        }\n        for (i <- index + 1 until word.length) {\n            if (vowels.indexOf(word[i]) != -1) {\n                result = word[i]\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292991,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe0ksm67j.scala:24:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m (consonants.indexOf(word[\u001b[35mi\u001b[0m]) != -\u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe0ksm67j.scala:26:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe0ksm67j.scala:30:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            \u001b[33mif\u001b[0m (vowels.indexOf(word[\u001b[35mi\u001b[0m]) != -\u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe0ksm67j.scala:31:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe0ksm67j.scala:32:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var i = 0\n        var j = 0\n        var result = \"\"\n        while (i < word.length()) {\n            if (j < word.length() && vowels.indexOf(word.charAt(i)) != -1 && consonants.indexOf(word.charAt(j)) != -1) {\n                result = word.charAt(i)\n                break\n            }\n            i = i + 1\n            j = j + 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293005,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppufu9tup.scala:26:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = word.charAt(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    Char\n\u001b[31m   |\u001b[0m                         Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppufu9tup.scala:27:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (vowels[vowelsIndex] == word[i]) {\n                    vowelsIndex += 1\n                } else if (consonants[consonantsIndex] == word[i]) {\n                    consonantsIndex += 1\n                } else {\n                    result = \"\"\n                    break\n                }\n            } else {\n                result = \"\"\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdmahyszs.scala:26:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mif\u001b[0m (vowels[\u001b[35mvowelsIndex\u001b[0m] == word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type vowelsIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdmahyszs.scala:28:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (consonants[consonantsIndex] == word[i]) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: type consonantsIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdmahyszs.scala:32:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdmahyszs.scala:36:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowels_count = 0\n        var consonants_count = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var result = \"\"\n        while (i < word.length) {\n            if (word[i] == vowels[0]) {\n                vowels_count += 1\n                i += 1\n            } else if (word[i] == consonants[0]) {\n                consonants_count += 1\n                i += 1\n            } else if (word[i] == vowels[1]) {\n                vowels_count += 1\n                i += 1\n            } else if (word[i] == consonants[1]) {\n                consonants_count += 1\n                i += 1\n            } else if (word[i] == vowels[2]) {\n                vowels_count += 1\n                i += 1\n            } else if (word[i] == consonants[2]) {\n                consonants_count += 1\n                i += 1\n            } else if (word[i] == vowels[3]) {\n                vowels_count += 1\n                i += 1\n            } else if (word[i] == consonants[3]) {\n                consonants_count += 1\n                i += 1\n            } else if (word[i] == vowels[4]) {\n                vowels_count += 1\n                i += 1\n            } else if (word[i] == consonants[4]) {\n                consonants_count += 1\n                i += 1\n            } else if (word[i] == vowels[5]) {\n                vow\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzgxc_fjk.scala:93:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m93 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzgxc_fjk.scala:43:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m            \u001b[33mif\u001b[0m (word[\u001b[35mi\u001b[0m] == vowels[\u001b[31m0\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzgxc_fjk.scala:46:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (word[i] == consonants[\u001b[31m0\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzgxc_fjk.scala:49:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (word[i] == vowels[\u001b[31m1\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzgxc_fjk.scala:52:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (word[i] == consonants[\u001b[31m1\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzgxc_fjk.scala:55:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (word[i] == vowels[\u001b[31m2\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var vowelsCount = 0\n        var consonantsCount = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (vowels[vowelsIndex] == word[i]) {\n                vowelsIndex += 1\n                vowelsCount += 1\n                if (vowelsCount == 2) {\n                    result = word[i]\n                    break\n                }\n            } else {\n                vowelsIndex = 0\n                vowelsCount = 0\n            }\n            if (consonants[consonantsIndex] == word[i]) {\n                consonantsIndex += 1\n                consonantsCount += 1\n                if (consonantsCount == 2) {\n                    result = word[i]\n                    break\n                }\n            } else {\n                consonantsIndex = 0\n                consonantsCount = 0\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprqatjs9t.scala:27:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m (vowels[\u001b[35mvowelsIndex\u001b[0m] == word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type vowelsIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprqatjs9t.scala:31:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                    result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprqatjs9t.scala:32:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprqatjs9t.scala:38:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            \u001b[33mif\u001b[0m (consonants[\u001b[35mconsonantsIndex\u001b[0m] == word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type consonantsIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprqatjs9t.scala:42:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m                    result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprqatjs9t.scala:43:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m          ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        if (word.length() == 1) {\n            return \"\"\n        }\n        var vowels = \"aeiou\"\n        var consonants = \"bcdfghjklmnpqrstvwxyz\"\n        var rightConsonant = consonants.indexOf(word.charAt(word.length() - 1))\n        var leftConsonant = consonants.indexOf(word.charAt(0))\n        var rightVowel = vowels.indexOf(word.charAt(word.length() - 1))\n        var leftVowel = vowels.indexOf(word.charAt(0))\n        if (rightConsonant == -1 || leftConsonant == -1 || rightVowel == -1 || leftVowel == -1) {\n            return \"\"\n        }\n        var rightVowelIndex = rightConsonant + 1\n        var leftVowelIndex = leftConsonant - 1\n        if (rightVowelIndex >= rightVowel) {\n            return \"\"\n        }\n        if (leftVowelIndex <= leftVowel) {\n            return \"\"\n        }\n        return word.substring(leftVowelIndex, rightVowelIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293007,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp2vyn39m9.scala:42)\n\tat Problem.main(tmp2vyn39m9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (consonants[index] == word.charAt(i)) {\n                index++\n            } else if (vowels[index] == word.charAt(i)) {\n                index = 0\n            } else {\n                result = word.charAt(i)\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpjmmqadro.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpjmmqadro.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpjmmqadro.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjmmqadro.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var result = \"\"\n        for (var i = 0; i < word.length(); i++) {\n            if (consonants.indexOf(word.charAt(i)) >= 0) {\n                for (var j = i + 1; j < word.length(); j++) {\n                    if (vowels.indexOf(word.charAt(j)) >= 0) {\n                        result = word.charAt(j)\n                        break\n                    }\n                }\n                if (result != \"\") break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293007,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpn5zze29q.scala:22:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpn5zze29q.scala:22:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpn5zze29q.scala:22:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpn5zze29q.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var i = 0\n        var j = word.length() - 1\n        var result = \"\"\n        while (i < j) {\n            if (vowels[i] == word.charAt(i) && vowels[j] == word.charAt(j)) {\n                result = word.substring(i, j + 1)\n                break\n            } else if (consonants[i] == word.charAt(i) && consonants[j] == word.charAt(j)) {\n                i += 1\n                j -= 1\n            } else if (consonants[i] == word.charAt(i)) {\n                i += 1\n            } else if (vowels[j] == word.charAt(j)) {\n                j -= 1\n            } else {\n                i += 1\n                j -= 1\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293004,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj93qa114.scala:25:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (vowels[\u001b[35mi\u001b[0m] == word.charAt(i) && vowels[\u001b[35mj\u001b[0m] == word.charAt(j)) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj93qa114.scala:27:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj93qa114.scala:28:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (consonants[i] == word.charAt(i) && consonants[j] == word.charAt(j)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj93qa114.scala:31:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (consonants[i] == word.charAt(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj93qa114.scala:33:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (vowels[j] == word.charAt(j)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowelsAndConsonants = vowels + consonants\n        var vowelsAndConsonantsLength = vowelsAndConsonants.length\n        var wordLength = word.length\n        var rightSide = word.substring(wordLength - 1)\n        var rightSideLength = rightSide.length\n        var rightSideConsonants = rightSide.toCharArray\n        var rightSideConsonantsLength = rightSideConsonants.length\n        var rightSideConsonantsIndex = rightSideConsonants.indexOf(\"c\")\n        var rightSideConsonantsIndex2 = rightSideConsonants.indexOf(\"g\")\n        var rightSideConsonantsIndex3 = rightSideConsonants.indexOf(\"k\")\n        var rightSideConsonantsIndex4 = rightSideConsonants.indexOf(\"p\")\n        var rightSideConsonantsIndex5 = rightSideConsonants.indexOf(\"t\")\n        var rightSideConsonantsIndex6 = rightSideConsonants.indexOf(\"w\")\n        var rightSideConsonantsIndex7 = rightSideConsonants.indexOf(\"x\")\n        var rightSideConsonantsIndex8 = rightSideConsonants.indexOf(\"y\")\n        var rightSideConsonantsIndex9 = rightSideConsonants.indexOf(\"z\")\n        var rightSideConsonantsIndex10 = rightSideConsonants.indexOf(\"j\")\n        var rightSideConsonantsIndex11 = rightSideConsonants.indexOf(\"q\")\n        var rightSideConsonantsIndex12 = rightSideConsonants.indexOf(\"s\")\n        var rightSideConsonantsIndex13 = rightSideConsonants.indexOf(\"v\")\n        var rightSideConsonantsIndex14 = rightSideConsonants.indexOf(\"h\")\n        var rightSideConsonantsIndex15 = rightSideConsonants.indexOf(\"d\")\n        var rightSideConsonantsIndex16 = rightSideConsonants.indexOf(\"b\")\n        var rightSideConsonantsIndex17 = rightSideConsonants.indexOf(\"f\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293012,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpjo2t82vq.scala:44:69 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideConsonantsIndex17\u001b[0m = rightSideConsonants.indexOf(\"f\n\u001b[31m\u001b[31m   |\u001b[0m                                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                 unclosed string literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmpjo2t82vq.scala:46:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 end of statement expected but '=' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjo2t82vq.scala:21:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mvowelsAndConsonants\u001b[0m = vowels + consonants\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of Array[Char], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjo2t82vq.scala:28:67 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideConsonantsIndex\u001b[0m = rightSideConsonants.indexOf(\u001b[31m\"c\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                Found:    (\u001b[32m\"c\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                                                Required: Char\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjo2t82vq.scala:29:68 ------------------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var consonantIndex = 0\n        var vowelIndex = 0\n        var result = \"\"\n        for (i <- word.length - 1) {\n            if (consonantIndex < consonants.length && word.charAt(i) == consonants[consonantIndex]) {\n                consonantIndex += 1\n            } else if (vowelIndex < vowels.length && word.charAt(i) == vowels[vowelIndex]) {\n                vowelIndex += 1\n            } else {\n                break\n            }\n        }\n        if (consonantIndex == consonants.length) {\n            result = \"\"\n        } else if (vowelIndex == vowels.length) {\n            result = vowels[vowelIndex - 1]\n        } else {\n            result = vowels[vowelIndex]\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293008,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcv4i7c8p.scala:24:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- word.length - \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcv4i7c8p.scala:36:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            result = vowels[\u001b[35mvowelIndex\u001b[0m \u001b[35m-\u001b[0m \u001b[31m1\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: type -\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcv4i7c8p.scala:38:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            result = vowels[\u001b[35mvowelIndex\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: type vowelIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            var c = word.charAt(i)\n            if (c == vowels[vowelsIndex]) {\n                vowelsIndex++\n                if (vowelsIndex == vowels.length) {\n                    result = c\n                    break\n                }\n            } else if (c == consonants[consonantsIndex]) {\n                consonantsIndex++\n                if (consonantsIndex == consonants.length) {\n                    result = c\n                    break\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293010,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp9fs1j_v4.scala:24:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9fs1j_v4.scala:24:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp9fs1j_v4.scala:24:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9fs1j_v4.scala:24:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (consonants[index] == word.charAt(i)) {\n                index = (index + 1) % consonants.length\n            } else if (vowels[index] == word.charAt(i)) {\n                index = (index + 1) % vowels.length\n            } else {\n                result = word.charAt(i)\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293010,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmputlzz_ym.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmputlzz_ym.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmputlzz_ym.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmputlzz_ym.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (vowels[word.charAt(i) - 'a'] != null) {\n                index = i\n                break\n            }\n        }\n        for (var i = index + 1; i < word.length(); i++) {\n            if (vowels[word.charAt(i) - 'a'] != null) {\n                result = word.charAt(i) + result\n                break\n            } else if (consonants[word.charAt(i) - 'a'] != null) {\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp74ht0hg9.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp74ht0hg9.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp74ht0hg9.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp74ht0hg9.scala:29:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = index + \u001b[31m1\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp74ht0hg9.scala:29:49 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = index + \u001b[31m1\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp74ht0hg9.scala:29:54 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var vowels_lower = vowels.toLowerCase()\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var consonants_lower = consonants.toLowerCase()\n        var vowels_count = 0\n        var consonants_count = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (word[i].toLowerCase() in vowels_lower) {\n                vowels_count += 1\n                if (i > 0 && word[i - 1].toLowerCase() in consonants_lower) {\n                    result = word[i]\n                    break\n                }\n            } else if (word[i].toLowerCase() in consonants_lower) {\n                consonants_count += 1\n                if (i > 0 && word[i - 1].toLowerCase() in vowels_lower) {\n                    result = word[i]\n                    break\n                }\n            }\n        }\n        if (vowels_count == 0) {\n            if (consonants_count == 0) {\n                result = \"\"\n            } else {\n                result = word[word.length - 1]\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293006,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmo5ubmzr.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m (word[\u001b[35mi\u001b[0m].toLowerCase() in vowels_lower) {\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmo5ubmzr.scala:29:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                \u001b[33mif\u001b[0m (i > \u001b[31m0\u001b[0m && word[\u001b[35mi\u001b[0m \u001b[35m-\u001b[0m \u001b[31m1\u001b[0m].toLowerCase() in consonants_lower) {\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type -\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmo5ubmzr.scala:30:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                    result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmo5ubmzr.scala:31:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmo5ubmzr.scala:33:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (word[i].toLowerCase() in consonants_lower) {\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmo5ubmzr.scala:35:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = List.of(\"a\", \"e\", \"i\", \"o\", \"u\")\n        var consonants = List.of(\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\")\n        var index = 0\n        var result = \"\"\n        while (index < word.length) {\n            if (vowels.contains(word[index])) {\n                result = word[index]\n                break\n            } else if (consonants.contains(word[index])) {\n                index += 1\n            } else {\n                index += 1\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293009,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx70kijq_.scala:19:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mvowels\u001b[0m = List.of(\u001b[31m\"a\"\u001b[0m, \u001b[31m\"e\"\u001b[0m, \u001b[31m\"i\"\u001b[0m, \u001b[31m\"o\"\u001b[0m, \u001b[31m\"u\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value of is not a member of object scala.collection.immutable.List\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx70kijq_.scala:20:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mconsonants\u001b[0m = List.of(\u001b[31m\"b\"\u001b[0m, \u001b[31m\"c\"\u001b[0m, \u001b[31m\"d\"\u001b[0m, \u001b[31m\"f\"\u001b[0m, \u001b[31m\"g\"\u001b[0m, \u001b[31m\"h\"\u001b[0m, \u001b[31m\"j\"\u001b[0m, \u001b[31m\"k\"\u001b[0m, \u001b[31m\"l\"\u001b[0m, \u001b[31m\"m\"\u001b[0m, \u001b[31m\"n\"\u001b[0m, \u001b[31m\"p\"\u001b[0m, \u001b[31m\"q\"\u001b[0m, \u001b[31m\"r\"\u001b[0m, \u001b[31m\"s\"\u001b[0m, \u001b[31m\"t\"\u001b[0m, \u001b[31m\"v\"\u001b[0m, \u001b[31m\"w\"\u001b[0m, \u001b[31m\"x\"\u001b[0m, \u001b[31m\"y\"\u001b[0m, \u001b[31m\"z\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value of is not a member of object scala.collection.immutable.List\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpx70kijq_.scala:25:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                result = word[\u001b[35mindex\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type index\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpx70kijq_.scala:26:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (consonants[index] == word.charAt(i)) {\n                index++\n            } else if (vowels[index] == word.charAt(i)) {\n                index = 0\n            } else {\n                break\n            }\n        }\n        if (index > 0) {\n            result = vowels[index]\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292983,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpb4g0q0lk.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpb4g0q0lk.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpb4g0q0lk.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpb4g0q0lk.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            var c = word.charAt(i)\n            if (consonants.indexOf(c) >= 0) {\n                index = consonants.indexOf(c)\n                break\n            }\n        }\n        for (var i = index + 1; i < word.length(); i++) {\n            var c = word.charAt(i)\n            if (vowels.indexOf(c) >= 0) {\n                result = c\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293012,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpceufkrdj.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpceufkrdj.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpceufkrdj.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpceufkrdj.scala:30:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = index + \u001b[31m1\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpceufkrdj.scala:30:49 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = index + \u001b[31m1\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpceufkrdj.scala:30:54 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowelsAndConsonants = vowels + consonants\n        var wordLength = word.length()\n        var rightSide = wordLength - 1\n        var rightSideVowels = 0\n        var rightSideConsonants = 0\n        var rightSideVowelsAndConsonants = 0\n        var rightSideVowelsAndConsonantsIndex = 0\n        var rightSideVowelsIndex = 0\n        var rightSideConsonantsIndex = 0\n        var rightSideVowelsAndConsonantsIndex = 0\n        var rightSideVowelsIndex = 0\n        var rightSideConsonantsIndex = 0\n        var rightSideVowelsAndConsonantsIndex = 0\n        var rightSideVowelsAndConsonantsIndex = 0\n        var rightSideVowelsIndex = 0\n        var rightSideConsonantsIndex = 0\n        var rightSideVowelsAndConsonantsIndex = 0\n        var rightSideVowelsAndConsonantsIndex = 0\n        var rightSideVowelsIndex = 0\n        var rightSideConsonantsIndex = 0\n        var rightSideVowelsAndConsonantsIndex = 0\n        var rightSideVowelsAndConsonantsIndex = 0\n        var rightSideVowelsIndex = 0\n        var rightSideConsonantsIndex = 0\n        var rightSideVowelsAndConsonantsIndex = 0\n        var rightSideVowelsAndConsonantsIndex = 0\n        var rightSideVowelsIndex = 0\n        var rightSideConsonantsIndex = 0\n        var rightSideVowelsAndConsonantsIndex = 0\n        var rightSideVowelsAndConsonantsIndex = 0\n        var rightSideVowelsIndex = 0\n        var rightSideConsonantsIndex = 0\n        var rightSideVowelsAndConsonantsIndex = 0\n        var rightSideVowelsAndConsonantsIndex = 0\n        var rightSideVowelsIndex = 0\n        var rightSideConsonantsIndex = 0\n        var rightSideVowelsAndConsonantsIndex = 0\n        \n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293012,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1lvrgpl7.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideVowelsAndConsonantsIndex\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightSideVowelsAndConsonantsIndex is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightSideVowelsAndConsonantsIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1lvrgpl7.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideVowelsIndex\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightSideVowelsIndex is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightSideVowelsIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1lvrgpl7.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideConsonantsIndex\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightSideConsonantsIndex is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightSideConsonantsIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1lvrgpl7.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideVowelsAndConsonantsIndex\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightSideVowelsAndConsonantsIndex is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightSideVowelsAndConsonantsIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1lvrgpl7.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var i = 0\n        var j = 0\n        var result = \"\"\n        while (i < word.length) {\n            if (vowels.contains(word[i])) {\n                result = word[i]\n                i += 1\n            } else if (consonants.contains(word[i])) {\n                j = i + 1\n                while (j < word.length && !vowels.contains(word[j])) {\n                    j += 1\n                }\n                if (j - i > 1) {\n                    result = word[i:j]\n                }\n                i = j\n            } else {\n                i += 1\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvic7db5y.scala:34:35 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                    result = word[\u001b[35mi\u001b[0m:j]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   ']' expected, but ':' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvic7db5y.scala:25:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (vowels.contains(word[\u001b[35mi\u001b[0m])) {\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvic7db5y.scala:26:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvic7db5y.scala:28:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (consonants.contains(word[i])) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvic7db5y.scala:30:64 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                \u001b[33mwhile\u001b[0m (j < word.length && !vowels.contains(word[\u001b[35mj\u001b[0m])) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var i = 0\n        var j = 0\n        var closest = \"\"\n        for (i = word.length() - 1; i >= 0; i--) {\n            if (vowels.indexOf(word.charAt(i)) != -1) {\n                j = i + 1\n                break\n            }\n        }\n        for (i = word.length() - 1; i >= 0; i--) {\n            if (vowels.indexOf(word.charAt(i)) != -1) {\n                if (j == 0) {\n                    closest = word.charAt(i)\n                    break\n                } else {\n                    if (consonants.indexOf(word.charAt(i)) != -1 && consonants.indexOf(word.charAt(j)) != -1) {\n                        if (Math.abs(i - j) < Math.abs(i - closest.length())) {\n                            closest = word.charAt(i)\n                        }\n                    }\n                }\n            }\n        }\n        return closest\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293017,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwbs9efrl.scala:24:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwbs9efrl.scala:24:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpwbs9efrl.scala:24:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwbs9efrl.scala:30:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwbs9efrl.scala:30:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpwbs9efrl.scala:30:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            var c = word.charAt(i)\n            if (consonants.indexOf(c) >= 0) {\n                if (index < 0) {\n                    index = 0\n                }\n                if (index > 0) {\n                    result = vowels[index]\n                    break\n                }\n                index = vowels.indexOf(c)\n            } else {\n                index = 0\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293017,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpnqkikepb.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpnqkikepb.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpnqkikepb.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnqkikepb.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            var c = word.charAt(i)\n            if (consonants.indexOf(c) >= 0) {\n                index = i\n                break\n            }\n        }\n        for (var i = index; i < word.length(); i++) {\n            var c = word.charAt(i)\n            if (vowels.indexOf(c) >= 0) {\n                result = c\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293017,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpyluym5ke.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpyluym5ke.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpyluym5ke.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpyluym5ke.scala:30:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = index; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpyluym5ke.scala:30:45 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = index; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpyluym5ke.scala:30:50 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = index; i < word.length();",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (consonants[index] == word.charAt(i)) {\n                index++\n            } else if (vowels[index] == word.charAt(i)) {\n                index = 0\n            } else {\n                result = word.charAt(i)\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpjmmqadro.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpjmmqadro.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpjmmqadro.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjmmqadro.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var i = 0\n        var j = word.length() - 1\n        var result = \"\"\n        while (i < j) {\n            if (vowels[i] == word[i] && vowels[j] == word[j]) {\n                result = word[i]\n                break\n            } else if (vowels[i] == word[i] && consonants[j] == word[j]) {\n                result = word[j]\n                break\n            } else if (vowels[j] == word[j] && consonants[i] == word[i]) {\n                result = word[i]\n                break\n            } else if (vowels[j] == word[j] && vowels[i] == word[i]) {\n                result = word[i]\n                break\n            } else if (vowels[i] == word[i] && vowels[j] == word[j]) {\n                result = word[j]\n                break\n            } else if (vowels[i] == word[i] && consonants[j] == word[j]) {\n                result = word[j]\n                break\n            } else if (vowels[j] == word[j] && consonants[i] == word[i]) {\n                result = word[i]\n                break\n            }\n            i += 1\n            j -= 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293012,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp41eo54f2.scala:25:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (vowels[\u001b[35mi\u001b[0m] == word[\u001b[35mi\u001b[0m] && vowels[\u001b[35mj\u001b[0m] == word[\u001b[35mj\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp41eo54f2.scala:26:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp41eo54f2.scala:27:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp41eo54f2.scala:28:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (vowels[i] == word[i] && consonants[j] == word[j]) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp41eo54f2.scala:29:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                result = word[\u001b[35mj\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp41eo54f2.scala:30:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var vowelsAndConsonants = vowels + consonants\n        var rightSide = word.toLowerCase().split(\"\")\n        var rightSideLength = rightSide.length\n        var rightSideConsonants = rightSide.filter(c -> vowelsAndConsonants.indexOf(c) == -1)\n        var rightSideVowels = rightSide.filter(c -> vowelsAndConsonants.indexOf(c) != -1)\n        var rightSideConsonantsLength = rightSideConsonants.length\n        var rightSideVowelsLength = rightSideVowels.length\n        var rightSideConsonantsIndex = rightSideConsonants.indexOf(rightSide[rightSideLength - 1])\n        var rightSideVowelsIndex = rightSideVowels.indexOf(rightSide[rightSideLength - 1])\n        if (rightSideConsonantsLength == 0) {\n            return \"\"\n        } else if (rightSideVowelsLength == 0) {\n            return \"\"\n        } else if (rightSideConsonantsIndex == -1) {\n            return \"\"\n        } else if (rightSideVowelsIndex == -1) {\n            return \"\"\n        } else {\n            var rightSideConsonantsIndex2 = rightSideConsonantsIndex + 1\n            var rightSideVowelsIndex2 = rightSideVowelsIndex + 1\n            var rightSideConsonantsIndex3 = rightSideConsonantsIndex2 + 1\n            var rightSideVowelsIndex3 = rightSideVowelsIndex2 + 1\n            var rightSideConsonantsIndex4 = rightSideConsonantsIndex3 + 1\n            var rightSideVowelsIndex4 = rightSideVowelsIndex3 + 1\n            var rightSideConsonantsIndex5 = rightSideConsonantsIndex4 + 1\n            var rightSideVowelsIndex5 = rightSideVowelsIndex4 + 1\n            var rightSideConsonantsIndex6 = rightSideConsonantsIndex5 + 1\n            var rightSideV\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293015,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpz2qccrgn.scala:49:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpz2qccrgn.scala:67:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz2qccrgn.scala:24:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideConsonants\u001b[0m = rightSide.filter(c -> vowelsAndConsonants.indexOf(c) == -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   Not found: c\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz2qccrgn.scala:25:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideVowels\u001b[0m = rightSide.filter(c -> vowelsAndConsonants.indexOf(c) != -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               Not found: c\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz2qccrgn.scala:28:93 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideConsonantsIndex\u001b[0m = rightSideConsonants.indexOf(rightSide[\u001b[35mrightSideLength\u001b[0m \u001b[35m-\u001b[0m \u001b[31m1\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: type -\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz2qccrgn.scala:29:85 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideVowelsIndex\u001b[0m = rightSideVowels.indexOf(rightSide",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var i = 0\n        var j = 0\n        var result = \"\"\n        while (i < word.length && j < word.length) {\n            if (vowels[i] == word[j]) {\n                i += 1\n                j += 1\n                result = word[j - 1]\n            } else if (consonants[j] == word[j]) {\n                j += 1\n            } else {\n                i += 1\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293013,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjt_ds7nn.scala:25:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (vowels[\u001b[35mi\u001b[0m] == word[\u001b[35mj\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjt_ds7nn.scala:28:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                result = word[\u001b[35mj\u001b[0m \u001b[35m-\u001b[0m \u001b[31m1\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: type -\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjt_ds7nn.scala:29:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (consonants[j] == word[j]) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var result = \"\"\n        var i = 0\n        var j = 0\n        while (i < word.length) {\n            if (consonants[j] == word[i]) {\n                j += 1\n            } else if (vowels[0] == word[i]) {\n                result = word[i]\n                i += 1\n                break\n            } else {\n                i += 1\n            }\n        }\n        while (i < word.length) {\n            if (consonants[j] == word[i]) {\n                j += 1\n            } else if (vowels[1] == word[i]) {\n                result = word[i]\n                i += 1\n                break\n            } else {\n                i += 1\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293014,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb5f5sbde.scala:25:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (consonants[\u001b[35mj\u001b[0m] == word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpb5f5sbde.scala:27:29 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (vowels[\u001b[31m0\u001b[0m] == word[i]) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mArray\u001b[0m does not take type parameters\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb5f5sbde.scala:28:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb5f5sbde.scala:30:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb5f5sbde.scala:36:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            \u001b[33mif\u001b[0m (consonants[\u001b[35mj\u001b[0m] == word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpb5f5sbde.scala:38:29 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (vowels[\u001b[31m1\u001b[0m] == word[i]) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (consonants[index] == word.charAt(i)) {\n                index++\n            } else if (vowels[index] == word.charAt(i)) {\n                index = 0\n            } else {\n                result = word.charAt(i)\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293017,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmppesuhfw6.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmppesuhfw6.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmppesuhfw6.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppesuhfw6.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\"\n        var consonants = \"bcdfghjklmnpqrstvwxyz\"\n        var index = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (consonants.indexOf(word[i]) != -1) {\n                index = i\n                break\n            }\n        }\n        for (i <- index + 1 until word.length) {\n            if (vowels.indexOf(word[i]) != -1) {\n                result = word[i]\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293013,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp42207kn5.scala:24:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m (consonants.indexOf(word[\u001b[35mi\u001b[0m]) != -\u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp42207kn5.scala:26:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp42207kn5.scala:30:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            \u001b[33mif\u001b[0m (vowels.indexOf(word[\u001b[35mi\u001b[0m]) != -\u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp42207kn5.scala:31:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp42207kn5.scala:32:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowelsCount = 0\n        var consonantsCount = 0\n        var i = 0\n        var j = 0\n        var result = \"\"\n        while (i < word.length) {\n            if (vowels[0] == word[i]) {\n                vowelsCount += 1\n                i += 1\n            } else if (consonants[0] == word[i]) {\n                consonantsCount += 1\n                i += 1\n            } else {\n                i += 1\n            }\n        }\n        while (j < word.length) {\n            if (vowels[vowels.length - 1] == word[j]) {\n                vowelsCount -= 1\n                j += 1\n            } else if (consonants[consonants.length - 1] == word[j]) {\n                consonantsCount -= 1\n                j += 1\n            } else {\n                j += 1\n            }\n        }\n        if (vowelsCount == 0 && consonantsCount == 0) {\n            return \"\"\n        } else if (vowelsCount == 0) {\n            return \"\"\n        } else if (consonantsCount == 0) {\n            return \"\"\n        } else {\n            var i = 0\n            var j = 0\n            while (i < word.length) {\n                if (vowels[0] == word[i]) {\n                    i += 1\n                } else if (consonants[0] == word[i]) {\n                    i += 1\n                } else {\n                    i += 1\n                }\n            }\n            while (j < word.length) {\n                if (vowels[vowels.length - 1] == word[j]) {\n                    j += 1\n                } else if (consonants[consonants.length - 1] == word[j]) {\n                    j += 1\n                } else {\n                    j += 1\n                }\n            }\n            if (i - j == 1) {\n                result = word[j]\n            } else\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293017,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpyiaoware.scala:77:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m            } \u001b[33melse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpyiaoware.scala:96:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m96 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpyiaoware.scala:27:22 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m (vowels[\u001b[31m0\u001b[0m] == word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mArray\u001b[0m does not take type parameters\n\u001b[31m\u001b[31m-- Error: /tmp/tmpyiaoware.scala:30:33 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (consonants[\u001b[31m0\u001b[0m] == word[i]) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mArray\u001b[0m does not take type parameters\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyiaoware.scala:38:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            \u001b[33mif\u001b[0m (vowels[vowels.length \u001b[35m-\u001b[0m \u001b[31m1\u001b[0m] == word[\u001b[35mj\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type -\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyiaoware.scala:41:52 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (consonants[consonants.length - \u001b[31m1\u001b[0m] == word[j]) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Not found: type -\n\u001b[31m   |\u001b[0m\n\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (consonants[index] == word.charAt(i)) {\n                index++\n            } else if (vowels[index] == word.charAt(i)) {\n                index = 0\n            } else {\n                result = word.charAt(i)\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292982,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpjmmqadro.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpjmmqadro.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpjmmqadro.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjmmqadro.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowelsAndConsonants = vowels + consonants\n        var right = word.length\n        var left = 0\n        var rightVowel = \"\"\n        var leftVowel = \"\"\n        var rightConsonant = \"\"\n        var leftConsonant = \"\"\n        var rightIndex = right\n        var leftIndex = left\n        while (rightIndex < right) {\n            if (vowelsAndConsonants[rightIndex] == word[rightIndex]) {\n                rightIndex += 1\n                if (rightIndex < right) {\n                    rightConsonant = \"\"\n                    rightVowel = \"\"\n                    while (rightIndex < right && vowelsAndConsonants[rightIndex] != word[rightIndex]) {\n                        rightConsonant += vowelsAndConsonants[rightIndex]\n                        rightIndex += 1\n                    }\n                    if (rightIndex < right) {\n                        rightVowel = word[rightIndex]\n                        rightIndex += 1\n                    }\n                }\n            } else {\n                rightConsonant = \"\"\n                rightVowel = \"\"\n                while (rightIndex < right && vowelsAndConsonants[rightIndex] != word[rightIndex]) {\n                    rightConsonant += vowelsAndConsonants[rightIndex]\n                    rightIndex += 1\n                }\n                if (rightIndex < right) {\n                    rightVowel = word[rightIndex]\n                    rightIndex += 1\n                }\n            }\n            if (rightIndex == right) {\n                break\n            }\n            if (leftIndex == left) {\n                break\n            }\n            if (vowelsAndConsonants[leftIndex] == word[leftIndex]) {\n                leftIndex += 1\n                if (leftIndex < left) {\n                    leftConsonant = \"\"\n                    leftVowel = \"\"\n                    while (leftIndex < left && vowelsAndConsonants[leftIndex] != word[leftIndex]) {\n                        leftConsonant += vowelsAndConsonants[leftIndex]\n                        leftIndex += 1\n                    }\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293019,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqa8uiugt.scala:90:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m90 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqa8uiugt.scala:21:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mvowelsAndConsonants\u001b[0m = vowels + consonants\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of Array[Char], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqa8uiugt.scala:31:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mif\u001b[0m (vowelsAndConsonants[\u001b[35mrightIndex\u001b[0m] == word[\u001b[35mrightIndex\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type rightIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqa8uiugt.scala:36:69 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    \u001b[33mwhile\u001b[0m (rightIndex < right && vowelsAndConsonants[\u001b[35mrightIndex\u001b[0m] != word[\u001b[35mrightIndex\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                                     ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                              Not found: type rightIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqa8uiugt.scala:37:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                        rightConsonant += vowelsAndConsonants[\u001b[35mrightIndex\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toSet\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toSet\n        var vowelsAndConsonants = vowels.union(consonants)\n        var vowelsAndConsonantsAndVowels = vowelsAndConsonants.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowels = vowelsAndConsonantsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowels\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292981,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfk6p0buq.scala:31:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfk6p0buq.scala:31:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toSet\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toSet\n        var index = 0\n        var result = \"\"\n        while(index < word.length) {\n            if(vowels.contains(word[index])) {\n                result = word[index]\n                break\n            }\n            if(consonants.contains(word[index])) {\n                index += 1\n            } else {\n                index += 2\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293016,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuq6yzxex.scala:24:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m(vowels.contains(word[\u001b[35mindex\u001b[0m])) {\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type index\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuq6yzxex.scala:25:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                result = word[\u001b[35mindex\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type index\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuq6yzxex.scala:26:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuq6yzxex.scala:28:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mif\u001b[0m(consonants.contains(word[\u001b[35mindex\u001b[0m])) {\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Not found: type index\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var i = 0\n        var j = 0\n        var result = \"\"\n        while (i < word.length && j < word.length) {\n            if (consonants[j] == word[i]) {\n                j += 1\n            } else if (vowels[i] == word[i]) {\n                i += 1\n            } else {\n                i += 1\n            }\n        }\n        if (i < word.length) {\n            result = word[i]\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293016,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphoan3to1.scala:25:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (consonants[\u001b[35mj\u001b[0m] == word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphoan3to1.scala:27:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (vowels[i] == word[i]) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphoan3to1.scala:34:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (consonants[index] == word.charAt(i)) {\n                index += 1\n            } else if (vowels[index] == word.charAt(i)) {\n                index += 1\n                result = word.substring(i + 1, word.length())\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293021,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp2v66ooqk.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp2v66ooqk.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp2v66ooqk.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2v66ooqk.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var i = 0\n        var j = word.length() - 1\n        var result = \"\"\n        while (i < j) {\n            if (consonants[i] == word[i] && consonants[j] == word[j]) {\n                i++\n                j--\n                continue\n            }\n            if (vowels[i] == word[i] && vowels[j] == word[j]) {\n                result = word[i]\n                i++\n                j--\n                continue\n            }\n            if (vowels[i] == word[i] && consonants[j] == word[j]) {\n                result = word[j]\n                j--\n                i++\n                continue\n            }\n            if (vowels[j] == word[j] && consonants[i] == word[i]) {\n                result = word[i]\n                i++\n                j--\n                continue\n            }\n            if (vowels[j] == word[j] && vowels[i] == word[i]) {\n                result = word[i]\n                i++\n                j--\n                continue\n            }\n            if (vowels[i] == word[i] && vowels[j] == word[j]) {\n                result = word[i]\n                i++\n                j--\n                continue\n            }\n            if (vowels[i] == word[i] && consonants[j] == word[j]) {\n                result = word[j]\n                j--\n                i++\n                continue\n            }\n            if (vowels[j] == word[j] && consonants[i] == word[i]) {\n                result = word[i]\n                i++\n                j--\n                continue\n            }\n            i++\n            j--\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293022,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpe0um9tih.scala:73:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m            j--\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe0um9tih.scala:25:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (consonants[\u001b[35mi\u001b[0m] == word[\u001b[35mi\u001b[0m] && consonants[\u001b[35mj\u001b[0m] == word[\u001b[35mj\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe0um9tih.scala:26:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                i++\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value ++ is not a member of Int\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe0um9tih.scala:30:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            \u001b[33mif\u001b[0m (vowels[\u001b[35mi\u001b[0m] == word[\u001b[35mi\u001b[0m] && vowels[\u001b[35mj\u001b[0m] == word[\u001b[35mj\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe0um9tih.scala:31:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe0um9tih.scala:32:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                i++\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value ++ is not a member of Int\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe0um9tih.scala",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var vowels_count = 0\n        var consonants_count = 0\n        var vowels_index = 0\n        var consonants_index = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (vowels.indexOf(word.charAt(i)) != -1) {\n                vowels_count += 1\n                vowels_index = i\n            } else if (consonants.indexOf(word.charAt(i)) != -1) {\n                consonants_count += 1\n                consonants_index = i\n            }\n        }\n        if (vowels_count == 0 || consonants_count == 0) {\n            return \"\"\n        }\n        if (vowels_count == 1) {\n            return word.charAt(vowels_index)\n        }\n        if (consonants_count == 1) {\n            return word.charAt(consonants_index)\n        }\n        if (vowels_count == 2) {\n            if (consonants_count == 1) {\n                return word.charAt(vowels_index)\n            }\n            if (consonants_count == 2) {\n                return word.charAt(vowels_index)\n            }\n        }\n        if (consonants_count == 2) {\n            if (vowels_count == 1) {\n                return word.charAt(consonants_index)\n            }\n            if (vowels_count == 2) {\n                return word.charAt(consonants_index)\n            }\n        }\n        return \"\"\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293023,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsllkykud.scala:39:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            \u001b[33mreturn\u001b[0m word.charAt(vowels_index)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    Char\n\u001b[31m   |\u001b[0m                   Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsllkykud.scala:42:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m            \u001b[33mreturn\u001b[0m word.charAt(consonants_index)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    Char\n\u001b[31m   |\u001b[0m                   Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsllkykud.scala:46:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m                \u001b[33mreturn\u001b[0m word.charAt(vowels_index)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    Char\n\u001b[31m   |\u001b[0m                       Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsllkykud.scala:49:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m                \u001b[33mreturn\u001b[0m word.charAt(vowels_index)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    Char\n\u001b[31m   |\u001b[0m                       Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsllkykud.scala:54:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m                \u001b[33mreturn\u001b[0m word.charAt(consonants_index)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    Char\n\u001b[31m   |\u001b[0m                       Requ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var consonantIndex = 0\n        var vowelIndex = 0\n        var result = \"\"\n        for (i <- word.length - 1) {\n            if (consonants[consonantIndex] == word[i]) {\n                consonantIndex += 1\n            } else if (vowels[vowelIndex] == word[i]) {\n                vowelIndex += 1\n            } else {\n                if (consonantIndex > 0) {\n                    result = word[i - 1]\n                    break\n                } else {\n                    result = \"\"\n                    break\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293021,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpz4xupvbh.scala:24:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- word.length - \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowels_count = 0\n        var consonants_count = 0\n        var index = 0\n        var result = \"\"\n        for (var i = 0; i < word.length(); i++) {\n            if (vowels[0] == word.charAt(i)) {\n                vowels_count += 1\n                index = i\n            } else if (consonants[0] == word.charAt(i)) {\n                consonants_count += 1\n            }\n        }\n        for (var i = index + 1; i < word.length(); i++) {\n            if (vowels[0] == word.charAt(i)) {\n                vowels_count += 1\n            } else if (consonants[0] == word.charAt(i)) {\n                consonants_count += 1\n            }\n            if (vowels_count == 2 && consonants_count == 1) {\n                result = word.charAt(i)\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293024,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp5s_th4sv.scala:25:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5s_th4sv.scala:25:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp5s_th4sv.scala:25:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp5s_th4sv.scala:33:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = index + \u001b[31m1\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5s_th4sv.scala:33:49 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = index + \u001b[31m1\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp5s_th4sv.scala:33:54 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = index + \u001b[31m1\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowelsAndConsonants = vowels + consonants\n        var vowelsAndConsonantsLength = vowelsAndConsonants.length\n        var wordLength = word.length\n        var rightSide = word.substring(wordLength - 1)\n        var rightSideLength = rightSide.length\n        var rightSideConsonants = rightSide.toCharArray()\n        var rightSideConsonantsLength = rightSideConsonants.length\n        var rightSideConsonantsIndex = rightSideConsonants.indexOf(rightSide.charAt(rightSideLength - 1))\n        var rightSideConsonantsIndexPlusOne = rightSideConsonantsIndex + 1\n        var rightSideConsonantsIndexMinusOne = rightSideConsonantsIndex - 1\n        var rightSideConsonantsIndexPlusTwo = rightSideConsonantsIndex + 2\n        var rightSideConsonantsIndexMinusTwo = rightSideConsonantsIndex - 2\n        var rightSideConsonantsIndexPlusThree = rightSideConsonantsIndex + 3\n        var rightSideConsonantsIndexMinusThree = rightSideConsonantsIndex - 3\n        var rightSideConsonantsIndexPlusFour = rightSideConsonantsIndex + 4\n        var rightSideConsonantsIndexMinusFour = rightSideConsonantsIndex - 4\n        var rightSideConsonantsIndexPlusFive = rightSideConsonantsIndex + 5\n        var rightSideConsonantsIndexMinusFive = rightSideConsonantsIndex - 5\n        var rightSideConsonantsIndexPlusSix = rightSideConsonantsIndex + 6\n        var rightSideConsonantsIndexMinusSix = rightSideConsonantsIndex - 6\n        var rightSideConsonantsIndexPlusSeven = rightSideConsonantsIndex + 7\n        var rightSideConsonantsIndexMinusSeven = rightSideConsonantsIndex - 7\n        var rightSideConsonantsIndexPlusEight = rightSideConsonantsIndex + 8\n        var rightSideConsonantsIndexMinusEight = rightSideConsonantsIndex - 8\n        var rightSideConsonantsIndexPlus\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293025,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpcvo4duzq.scala:46:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcvo4duzq.scala:21:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mvowelsAndConsonants\u001b[0m = vowels + consonants\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of Array[Char], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcvo4duzq.scala:46:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (consonants.indexOf(word.charAt(i)) != -1) {\n                if (i == 0 || i == word.length - 1) {\n                    result = \"\"\n                } else {\n                    result = vowels.indexOf(word.charAt(i - 1)) != -1 ? word.charAt(i - 1) : \"\"\n                }\n            } else {\n                result = \"\"\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293023,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpri1hsehf.scala:27:70 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                    result = vowels.indexOf(word.charAt(i - \u001b[31m1\u001b[0m)) != -\u001b[31m1\u001b[0m ? word.charAt(i - \u001b[31m1\u001b[0m) : \u001b[31m\"\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                                   ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                          value ? is not a member of Int\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = List(\"a\", \"e\", \"i\", \"o\", \"u\")\n        var consonants = List(\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\")\n        var vowelsAndConsonants = vowels.zip(consonants)\n        var vowelsAndConsonantsAndVowels = vowelsAndConsonants.zip(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowels = vowelsAndConsonantsAndVowels.zip(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowels.zip(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowels.zip(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowels.zip(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels.zip(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels.zip(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAnd\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293025,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2adzx9u3.scala:29:106 -----------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mvowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels\u001b[0m = vowelsAnd\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                          ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Not found: vowelsAnd\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2adzx9u3.scala:30:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (consonants[index] == word.charAt(i)) {\n                index++\n            } else {\n                if (vowels[index] == word.charAt(i)) {\n                    result = word.charAt(i)\n                    break\n                } else {\n                    index = 0\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293026,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpbnj12yo3.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbnj12yo3.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpbnj12yo3.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbnj12yo3.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var result = \"\"\n        while (i < word.length) {\n            if (consonants[j] == word[i]) {\n                j = j + 1\n                i = i + 1\n            } else if (vowels[k] == word[i]) {\n                k = k + 1\n                i = i + 1\n            } else if (vowels[l] == word[i]) {\n                l = l + 1\n                i = i + 1\n            } else if (vowels[m] == word[i]) {\n                m = m + 1\n                i = i + 1\n            } else if (vowels[n] == word[i]) {\n                n = n + 1\n                i = i + 1\n            } else if (vowels[o] == word[i]) {\n                o = o + 1\n                i = i + 1\n            } else if (vowels[p] == word[i]) {\n                p = p + 1\n                i = i + 1\n            } else if (vowels[q] == word[i]) {\n                q = q + 1\n                i = i + 1\n            } else if (vowels[r] == word[i]) {\n                r = r + 1\n                i = i + 1\n            } else if (vowels[s] == word[i]) {\n                s = s + 1\n                i = i + 1\n            } else if (vowels[t] == word[i]) {\n                t = t + 1\n                i = i +\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293022,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpef00k0u9.scala:73:23 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m                i = i +\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpef00k0u9.scala:92:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpef00k0u9.scala:41:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m            \u001b[33mif\u001b[0m (consonants[\u001b[35mj\u001b[0m] == word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpef00k0u9.scala:44:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (vowels[k] == word[i]) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type k\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpef00k0u9.scala:47:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (vowels[l] == word[i]) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type l\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpef00k0u9.scala:50:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (vowels[m] == word[i]) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var result = \"\"\n        for (var i = 0; i < word.length(); i++) {\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (vowels[vowelsIndex] == word.charAt(i)) {\n                    vowelsIndex += 1\n                } else if (consonants[consonantsIndex] == word.charAt(i)) {\n                    consonantsIndex += 1\n                } else {\n                    result = \"\"\n                    break\n                }\n            } else {\n                result = \"\"\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293027,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpuitf6nui.scala:24:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpuitf6nui.scala:24:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpuitf6nui.scala:24:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuitf6nui.scala:24:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var i = 0\n        var j = 0\n        var closestVowel = \"\"\n        while (i < word.length) {\n            if (vowels[i] != null) {\n                i += 1\n                continue\n            }\n            if (j < word.length - 1 && consonants[j] != null && consonants[j + 1] != null) {\n                j += 2\n                continue\n            }\n            closestVowel = vowels[i]\n            i += 1\n            j += 1\n        }\n        return closestVowel\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293022,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6xmzj1ul.scala:25:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (vowels[\u001b[35mi\u001b[0m] != \u001b[31mnull\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6xmzj1ul.scala:27:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                continue\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: continue\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6xmzj1ul.scala:29:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mif\u001b[0m (j < word.length - \u001b[31m1\u001b[0m && consonants[\u001b[35mj\u001b[0m] != \u001b[31mnull\u001b[0m && consonants[\u001b[35mj\u001b[0m \u001b[35m+\u001b[0m \u001b[31m1\u001b[0m] != \u001b[31mnull\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6xmzj1ul.scala:29:77 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mif\u001b[0m (j < word.length - \u001b[31m1\u001b[0m && consonants[\u001b[35mj\u001b[0m] != \u001b[31mnull\u001b[0m && consonants[\u001b[35mj\u001b[0m \u001b[35m+\u001b[0m \u001b[31m1\u001b[0m] != \u001b[31mnull\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: type +\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6xmzj1ul.scala:31:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                continue\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: continue\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowelsCount = 0\n        var consonantsCount = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            var c = word.charAt(i)\n            if (vowels.indexOf(c) >= 0) {\n                vowelsCount++\n                if (vowelsCount > 1) {\n                    result = c\n                    break\n                }\n            } else if (consonants.indexOf(c) >= 0) {\n                consonantsCount++\n                if (consonantsCount > 1) {\n                    result = c\n                    break\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293028,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpj9dudm4q.scala:24:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpj9dudm4q.scala:24:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpj9dudm4q.scala:24:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj9dudm4q.scala:24:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = List.of(\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\")\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var consonants = List.of(\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\")\n        var consonantsIndex = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (vowels[vowelsIndex] == word[i]) {\n                    vowelsIndex += 1\n                } else if (consonants[consonantsIndex] == word[i]) {\n                    consonantsIndex += 1\n                } else {\n                    result = word[i]\n                    break\n                }\n            } else {\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293028,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptl1h6h2x.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mconsonantsIndex\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mconsonantsIndex is already defined as \u001b[33mvariable\u001b[0m \u001b[35mconsonantsIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptl1h6h2x.scala:19:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mvowels\u001b[0m = List.of(\u001b[31m\"a\"\u001b[0m, \u001b[31m\"e\"\u001b[0m, \u001b[31m\"i\"\u001b[0m, \u001b[31m\"o\"\u001b[0m, \u001b[31m\"u\"\u001b[0m, \u001b[31m\"A\"\u001b[0m, \u001b[31m\"E\"\u001b[0m, \u001b[31m\"I\"\u001b[0m, \u001b[31m\"O\"\u001b[0m, \u001b[31m\"U\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value of is not a member of object scala.collection.immutable.List\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptl1h6h2x.scala:22:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mconsonants\u001b[0m = List.of(\u001b[31m\"b\"\u001b[0m, \u001b[31m\"c\"\u001b[0m, \u001b[31m\"d\"\u001b[0m, \u001b[31m\"f\"\u001b[0m, \u001b[31m\"g\"\u001b[0m, \u001b[31m\"h\"\u001b[0m, \u001b[31m\"j\"\u001b[0m, \u001b[31m\"k\"\u001b[0m, \u001b[31m\"l\"\u001b[0m, \u001b[31m\"m\"\u001b[0m, \u001b[31m\"n\"\u001b[0m, \u001b[31m\"p\"\u001b[0m, \u001b[31m\"q\"\u001b[0m, \u001b[31m\"r\"\u001b[0m, \u001b[31m\"s\"\u001b[0m, \u001b[31m\"t\"\u001b[0m, \u001b[31m\"v\"\u001b[0m, \u001b[31m\"w\"\u001b[0m, \u001b[31m\"x\"\u001b[0m, \u001b[31m\"y\"\u001b[0m, \u001b[31m\"z\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value of is not a member of object scala.collection.immutable.List\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptl1h6h2x.scala:27:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                \u001b[33mif\u001b[0m (vowels[\u001b[35mvowelsIndex\u001b[0m] == word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type vowelsIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptl1h6h2x.scala:29:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (consonants",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var vowelsAndConsonants = vowels + consonants\n        var right = word.length\n        var left = 0\n        var rightVowel = \"\"\n        var leftVowel = \"\"\n        var rightConsonant = \"\"\n        var leftConsonant = \"\"\n        var rightVowelIndex = -1\n        var leftVowelIndex = -1\n        var rightConsonantIndex = -1\n        var leftConsonantIndex = -1\n        var rightVowelCount = 0\n        var leftVowelCount = 0\n        var rightConsonantCount = 0\n        var leftConsonantCount = 0\n        for (i <- 0 until right) {\n            if (vowelsAndConsonants.indexOf(word.charAt(i)) >= 0) {\n                if (rightVowelIndex == -1) {\n                    rightVowelIndex = i\n                    rightVowel = word.charAt(i)\n                    rightVowelCount = 1\n                } else {\n                    rightVowelCount += 1\n                }\n            } else {\n                if (rightConsonantIndex == -1) {\n                    rightConsonantIndex = i\n                    rightConsonant = word.charAt(i)\n                    rightConsonantCount = 1\n                } else {\n                    rightConsonantCount += 1\n                }\n            }\n        }\n        for (i <- 0 until left) {\n            if (vowelsAndConsonants.indexOf(word.charAt(i)) >= 0) {\n                if (leftVowelIndex == -1) {\n                    leftVowelIndex = i\n                    leftVowel = word.charAt(i)\n                    leftVowelCount = 1\n                } else {\n                    leftVowelCount += 1\n                }\n            } else {\n                if (leftConsonantIndex == -1) {\n                    leftConsonantIndex = i\n                    leftConsonant = word.charAt(i\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293029,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqfvc1kwh.scala:68:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqfvc1kwh.scala:86:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqfvc1kwh.scala:40:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                    rightVowel = word.charAt(i)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    Char\n\u001b[31m   |\u001b[0m                                 Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqfvc1kwh.scala:48:48 --------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m                    rightConsonant = word.charAt(i)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    Char\n\u001b[31m   |\u001b[0m                                     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqfvc1kwh.scala:59:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m                    leftVowel = word.charAt(i)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    Char\n\u001b[31m   |\u001b[0m                                Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqfvc1kwh.scala:67:47 --------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m                    leftConsonant = word.charAt(i\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Found:    Char\n\u001b[31m   |\u001b[0m                              ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (word[i] == vowels[vowelsIndex]) {\n                    vowelsIndex += 1\n                } else if (word[i] == consonants[consonantsIndex]) {\n                    consonantsIndex += 1\n                } else {\n                    result = \"\"\n                    break\n                }\n            } else {\n                result = \"\"\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293025,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfthqd__z.scala:26:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mif\u001b[0m (word[\u001b[35mi\u001b[0m] == vowels[\u001b[35mvowelsIndex\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfthqd__z.scala:28:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (word[i] == consonants[consonantsIndex]) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfthqd__z.scala:32:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfthqd__z.scala:36:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowelsAndConsonants = vowels + consonants\n        var rightSide = word.toCharArray()\n        var rightSideLength = rightSide.length\n        var rightSideIndex = rightSideLength - 1\n        var rightSideConsonantIndex = rightSideIndex\n        var rightSideVowelIndex = rightSideIndex\n        var rightSideVowel = \"\"\n        while rightSideConsonantIndex >= 0 {\n            if (rightSideConsonantIndex == rightSideLength - 1) {\n                return \"\"\n            }\n            if (rightSide[rightSideConsonantIndex] == vowelsAndConsonants[rightSideConsonantIndex]) {\n                rightSideVowel = rightSide[rightSideConsonantIndex]\n                rightSideVowelIndex = rightSideConsonantIndex\n                rightSideConsonantIndex = rightSideConsonantIndex - 1\n            } else {\n                rightSideConsonantIndex = rightSideConsonantIndex - 1\n            }\n        }\n        return rightSideVowel\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293029,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpkrs0pm9n.scala:40:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mreturn\u001b[0m rightSideVowel\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        'do' expected, but 'return' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkrs0pm9n.scala:21:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mvowelsAndConsonants\u001b[0m = vowels + consonants\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of Array[Char], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpkrs0pm9n.scala:28:41 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mwhile\u001b[0m rightSideConsonantIndex >= \u001b[31m0\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     expression does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkrs0pm9n.scala:32:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mif\u001b[0m (rightSide[\u001b[35mrightSideConsonantIndex\u001b[0m] == vowelsAndConsonants[\u001b[35mrightSideConsonantIndex\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: type rightSideConsonantIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkrs0pm9n.scala:33:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                rightSideVowel = rightSide[\u001b[35mrightSideConsonantIndex\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var result = \"\"\n        var i = word.length() - 1\n        while (i >= 0) {\n            var c = word.charAt(i)\n            if (consonants.indexOf(c) >= 0) {\n                i -= 1\n                continue\n            }\n            if (vowels.indexOf(c) >= 0) {\n                result = c\n                break\n            }\n            i -= 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293028,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd7mauahn.scala:27:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                continue\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: continue\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpd7mauahn.scala:30:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                result = c\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    (c : Char)\n\u001b[31m   |\u001b[0m                         Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd7mauahn.scala:31:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var result = \"\"\n        for (i <- word.length - 1) {\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (vowels[vowelsIndex] == word[i]) {\n                    vowelsIndex += 1\n                } else if (consonants[consonantsIndex] == word[i]) {\n                    consonantsIndex += 1\n                } else {\n                    result = word[i]\n                    break\n                }\n            } else {\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293029,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpedktpza4.scala:24:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- word.length - \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowelsAndConsonants = vowels + consonants\n        var vowelsAndConsonantsLength = vowelsAndConsonants.length\n        var wordLength = word.length\n        var wordIndex = 0\n        var closestVowel = \"\"\n        while wordIndex < wordLength {\n            if (word[wordIndex] in vowelsAndConsonants) {\n                closestVowel = word[wordIndex]\n                break\n            }\n            wordIndex += 1\n        }\n        if (closestVowel == \"\") {\n            return \"\"\n        }\n        var rightSide = word.substring(wordIndex)\n        var rightSideLength = rightSide.length\n        var rightSideIndex = 0\n        while rightSideIndex < rightSideLength {\n            if (rightSide[rightSideIndex] in vowelsAndConsonants) {\n                break\n            }\n            rightSideIndex += 1\n        }\n        return rightSide.substring(0, rightSideIndex)\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293031,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7f4df8ia.scala:33:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mif\u001b[0m (closestVowel == \u001b[31m\"\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m        ^^\u001b[0m\n\u001b[31m   |\u001b[0m        'do' expected, but 'if' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7f4df8ia.scala:45:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mreturn\u001b[0m rightSide.substring(\u001b[31m0\u001b[0m, rightSideIndex)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        'do' expected, but 'return' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7f4df8ia.scala:21:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mvowelsAndConsonants\u001b[0m = vowels + consonants\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of Array[Char], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp7f4df8ia.scala:26:26 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mwhile\u001b[0m wordIndex < wordLength {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          \u001b[33mvariable\u001b[0m \u001b[35mwordLength\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7f4df8ia.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m (word[\u001b[35mwordIndex\u001b[0m] in vowelsAndConsonants) {\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: type wordIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7f4d",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (consonants[index] == word.charAt(i)) {\n                index++\n            } else if (vowels[index] == word.charAt(i)) {\n                result = word.charAt(i)\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293031,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpvgj3ss01.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvgj3ss01.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpvgj3ss01.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvgj3ss01.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\"\n        var consonants = \"bcdfghjklmnpqrstvwxyz\"\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (word[i] == vowels[vowelsIndex]) {\n                    vowelsIndex += 1\n                } else if (word[i] == consonants[consonantsIndex]) {\n                    consonantsIndex += 1\n                } else {\n                    result = \"\"\n                    break\n                }\n            } else {\n                result = \"\"\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293027,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpa965xqcl.scala:26:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mif\u001b[0m (word[\u001b[35mi\u001b[0m] == vowels[\u001b[35mvowelsIndex\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpa965xqcl.scala:28:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (word[i] == consonants[consonantsIndex]) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpa965xqcl.scala:32:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpa965xqcl.scala:36:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var vowelsAndConsonants = vowels + consonants\n        var vowelsAndConsonantsLen = vowelsAndConsonants.length\n        var wordLen = word.length\n        var right = wordLen - 1\n        var left = wordLen - 2\n        var rightVowel = \"\"\n        var leftVowel = \"\"\n        var rightConsonant = \"\"\n        var leftConsonant = \"\"\n        var rightIndex = -1\n        var leftIndex = -1\n        var rightVowelIndex = -1\n        var leftVowelIndex = -1\n        var rightConsonantIndex = -1\n        var leftConsonantIndex = -1\n        var rightVowelFound = false\n        var leftVowelFound = false\n        var rightConsonantFound = false\n        var leftConsonantFound = false\n        while right >= 0 && rightVowelFound == false {\n            if (vowelsAndConsonants[right] == word[right]) {\n                rightVowelFound = true\n                rightVowel = word[right]\n                rightIndex = right\n            }\n            right--\n        }\n        while left >= 0 && leftVowelFound == false {\n            if (vowelsAndConsonants[left] == word[left]) {\n                leftVowelFound = true\n                leftVowel = word[left]\n                leftIndex = left\n            }\n            left--\n        }\n        while right >= 0 && rightConsonantFound == false {\n            if (vowelsAndConsonants[right] == word[right]) {\n                rightConsonantFound = true\n                rightConsonant = word[right]\n                rightIndex = right\n            }\n            right--\n        }\n        while left >= 0 && leftConsonantFound == false {\n            if (vowelsAndConsonants[left] == word[left]) {\n                leftConsonantFound = true\n                leftConsonant = word[left\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293028,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpbhzn67ha.scala:46:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m            right--\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbhzn67ha.scala:48:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m        \u001b[33mwhile\u001b[0m left >= \u001b[31m0\u001b[0m && leftVowelFound == \u001b[31mfalse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        'do' expected, but 'while' found\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpbhzn67ha.scala:62:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m            right--\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbhzn67ha.scala:64:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m        \u001b[33mwhile\u001b[0m left >= \u001b[31m0\u001b[0m && leftConsonantFound == \u001b[31mfalse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        'do' expected, but 'while' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpbhzn67ha.scala:40:47 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mwhile\u001b[0m right >= \u001b[31m0\u001b[0m && rightVowelFound == \u001b[31mfalse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     expression does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbhzn67ha.scala:41:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m            \u001b[33mif\u001b[0m (vowelsAndConsonants[\u001b[35mright\u001b[0m] == word[\u001b[35mright\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type right\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var result = \"\"\n        for (i <- word.length - 1) {\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (vowels[vowelsIndex] == word.charAt(i)) {\n                    vowelsIndex += 1\n                } else if (consonants[consonantsIndex] == word.charAt(i)) {\n                    consonantsIndex += 1\n                } else {\n                    result = word.charAt(i)\n                    break\n                }\n            } else {\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293033,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7x51hlc5.scala:24:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- word.length - \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var result = \"\"\n        for (i = word.length() - 1; i >= 0; i--) {\n            if (word.charAt(i) == 'a' || word.charAt(i) == 'e' || word.charAt(i) == 'i' || word.charAt(i) == 'o' || word.charAt(i) == 'u') {\n                result = word.charAt(i)\n                break\n            }\n            for (j = 0; j < vowels.length; j++) {\n                if (word.charAt(i) == vowels[j]) {\n                    result = word.charAt(i)\n                    break\n                }\n            }\n            if (result != \"\") {\n                break\n            }\n            for (k = 0; k < consonants.length; k++) {\n                if (word.charAt(i) == consonants[k]) {\n                    result = word.charAt(i)\n                    break\n                }\n            }\n            if (result != \"\") {\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293035,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmplgfyjxbt.scala:40:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmplgfyjxbt.scala:40:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmplgfyjxbt.scala:40:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplgfyjxbt.scala:40:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue foreach is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator as",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (consonants[index] == word.charAt(i)) {\n                index = (index + 1) % consonants.length\n            } else if (vowels[index] == word.charAt(i)) {\n                result = word.charAt(i)\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293034,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpn4acl4vy.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpn4acl4vy.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpn4acl4vy.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpn4acl4vy.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var result = \"\"\n        for (i = word.length() - 1; i >= 0; i--) {\n            if (consonants[i] == word[i]) {\n                j = i\n                for (k = i - 1; k >= 0; k--) {\n                    if (consonants[k] == word[k]) {\n                        l = k\n                        for (m = k - 1; m >= 0; m--) {\n                            if (consonants[m] == word[m]) {\n                                n = m\n                                for (o = m - 1; o >= 0; o--) {\n                                    if (consonants[o] == word[o]) {\n                                        p = o\n                                        for (q = o - 1; q >= 0; q--) {\n                                            if (consonants[q] == word[q]) {\n                                                r = q\n                                                for (s = q - 1; s >= 0; s--) {\n                                                    if (consonants[s] == word[s]) {\n                                                        t = s\n                                                        for (u = s - 1; u >= 0; u--) {\n                                                            if (consonants[u] == word[u]) {\n                                                                v = u\n                                                                for (w = u - 1; w >= 0; w--) {\n                                                                    if (consonants[w] == word[w]) {\n\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293036,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7a1c1wf5.scala:40:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7a1c1wf5.scala:40:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp7a1c1wf5.scala:40:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7a1c1wf5.scala:40:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue foreach is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator as",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var closestVowel = \"\"\n        var wordLength = word.length()\n        for (var i = wordLength - 1; i >= 0; i--) {\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (vowels[vowelsIndex] == word.charAt(i)) {\n                    vowelsIndex += 1\n                } else if (consonants[consonantsIndex] == word.charAt(i)) {\n                    consonantsIndex += 1\n                } else {\n                    if (closestVowel == \"\") {\n                        closestVowel = word.charAt(i)\n                    } else {\n                        if (Math.abs(vowelsIndex - consonantsIndex) < Math.abs(closestVowel.length() - word.charAt(i))) {\n                            closestVowel = word.charAt(i)\n                        }\n                    }\n                }\n            }\n        }\n        return closestVowel\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293037,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpe131q1cm.scala:25:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = wordLength - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpe131q1cm.scala:25:43 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = wordLength - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpe131q1cm.scala:25:48 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = wordLength - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe131q1cm.scala:25:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = wordLength - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.conve",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var result = \"\"\n        for (i = word.length() - 1; i >= 0; i--) {\n            if (consonants[i] != \"\") {\n                for (j = i - 1; j >= 0; j--) {\n                    if (consonants[j] != \"\") {\n                        for (k = j - 1; k >= 0; k--) {\n                            if (consonants[k] != \"\") {\n                                for (l = k - 1; l >= 0; l--) {\n                                    if (consonants[l] != \"\") {\n                                        for (m = l - 1; m >= 0; m--) {\n                                            if (consonants[m] != \"\") {\n                                                for (n = m - 1; n >= 0; n--) {\n                                                    if (consonants[n] != \"\") {\n                                                        for (p = n - 1; p >= 0; p--) {\n                                                            if (consonants[p] != \"\") {\n                                                                for (q = p - 1; q >= 0; q--) {\n                                                                    if (consonants[q] != \"\") {\n                                                                        for (r = q - 1; r >= 0; r--) {\n                                                                            if (consonants[r] != \"\") {\n                                                                                for (s = r - 1; s >= 0; s--) {\n                                                                                    if (consonants\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293036,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpv4isi6ld.scala:39:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpv4isi6ld.scala:39:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpv4isi6ld.scala:39:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv4isi6ld.scala:39:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue foreach is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator as",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowelsCount = 0\n        var consonantsCount = 0\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (vowels[vowelsIndex] == word[i]) {\n                vowelsIndex += 1\n                vowelsCount += 1\n                if (vowelsCount == 2) {\n                    result = word[i]\n                    break\n                }\n            } else {\n                if (consonants[consonantsIndex] == word[i]) {\n                    consonantsIndex += 1\n                    consonantsCount += 1\n                    if (consonantsCount == 2) {\n                        result = word[i]\n                        break\n                    }\n                } else {\n                    if (vowelsCount == 1) {\n                        result = word[i]\n                        break\n                    }\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293033,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp36r1ku75.scala:27:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m (vowels[\u001b[35mvowelsIndex\u001b[0m] == word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type vowelsIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp36r1ku75.scala:31:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                    result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp36r1ku75.scala:32:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp36r1ku75.scala:35:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m (consonants[\u001b[35mconsonantsIndex\u001b[0m] == word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type consonantsIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp36r1ku75.scala:39:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                        result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp36r1ku75.scala:40:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                        break\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var i = 0\n        var j = word.length() - 1\n        var closest = \"\"\n        while (i < j) {\n            if (vowels[i] == word.charAt(i) && vowels[j] == word.charAt(j)) {\n                closest = word.charAt(i)\n                i++\n                j--\n            } else if (vowels[i] == word.charAt(i) && consonants[j] == word.charAt(j)) {\n                closest = word.charAt(j)\n                j--\n            } else if (vowels[j] == word.charAt(j) && consonants[i] == word.charAt(i)) {\n                closest = word.charAt(i)\n                i++\n            } else if (vowels[j] == word.charAt(j) && vowels[i] == word.charAt(i)) {\n                closest = word.charAt(i)\n                i++\n                j--\n            } else if (vowels[i] == word.charAt(i) && vowels[j] == word.charAt(j)) {\n                closest = word.charAt(j)\n                j--\n            } else if (vowels[j] == word.charAt(j) && vowels[i] == word.charAt(i)) {\n                closest = word.charAt(i)\n                i++\n            } else if (vowels[i] == word.charAt(i) && consonants[j] == word.charAt(j)) {\n                closest = word.charAt(j)\n                j--\n            } else if (vowels[j] == word.charAt(j) && consonants[i] == word.charAt(i)) {\n                closest = word.charAt(i)\n                i++\n            } else {\n                i++\n                j--\n            }\n        }\n\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293039,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpi3qqfvb_.scala:28:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                j--\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpi3qqfvb_.scala:31:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                j--\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpi3qqfvb_.scala:34:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                i++\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpi3qqfvb_.scala:38:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                j--\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpi3qqfvb_.scala:41:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m                j--\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpi3qqfvb_.scala:44:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m                i++\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var i = 0\n        var j = word.length() - 1\n        var closestVowel = \"\"\n        while (i < j) {\n            if (vowels[i] == word[i] && vowels[j] == word[j]) {\n                closestVowel = word[i]\n                i++\n                j--\n            } else if (vowels[i] == word[i] && consonants[j] == word[j]) {\n                closestVowel = word[j]\n                j--\n            } else if (vowels[j] == word[j] && consonants[i] == word[i]) {\n                closestVowel = word[i]\n                i++\n            } else if (vowels[j] == word[j] && vowels[i] == word[i]) {\n                closestVowel = word[i]\n                i++\n                j--\n            } else if (vowels[i] == word[i] && vowels[j] == word[j]) {\n                closestVowel = word[j]\n                j--\n            } else if (vowels[j] == word[j] && vowels[i] == word[i]) {\n                closestVowel = word[i]\n                i++\n            } else if (vowels[i] == word[i] && consonants[j] == word[j]) {\n                closestVowel = word[j]\n                j--\n            } else if (vowels[j] == word[j] && consonants[i] == word[i]) {\n                closestVowel = word[i]\n                i++\n            } else if (vowels[i] == word[i] && consonants[j] == word[j]) {\n                closestVowel = word[j]\n                j--\n            } else if (vowels[j] == word[j] && conson\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293040,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp9d68vk7f.scala:28:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                j--\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp9d68vk7f.scala:31:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                j--\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp9d68vk7f.scala:34:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                i++\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp9d68vk7f.scala:38:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                j--\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp9d68vk7f.scala:41:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m                j--\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp9d68vk7f.scala:44:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m                i++\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var result = \"\"\n        var index = 0\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (consonants[index] == word.charAt(i)) {\n                index++\n            } else if (vowels[index] == word.charAt(i)) {\n                result = word.charAt(i)\n                index++\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293039,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpoeahkntb.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpoeahkntb.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpoeahkntb.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpoeahkntb.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowels_count = 0\n        var consonants_count = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (vowels[i] != null) {\n                vowels_count += 1\n                if (consonants_count > 0) {\n                    result = vowels[i]\n                    break\n                }\n            } else if (consonants[i] != null) {\n                consonants_count += 1\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293034,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnygbvrcv.scala:25:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (vowels[\u001b[35mi\u001b[0m] != \u001b[31mnull\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnygbvrcv.scala:28:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                    result = vowels[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnygbvrcv.scala:29:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnygbvrcv.scala:31:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (consonants[i] != \u001b[31mnull\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var vowelsAndConsonants = vowels + consonants\n        var rightSide = word.toLowerCase().split(\"\")\n        var rightSideLength = rightSide.length\n        var rightSideConsonants = rightSide.filter(c -> vowelsAndConsonants.contains(c)).toList\n        var rightSideVowels = rightSide.filter(c -> vowels.contains(c)).toList\n        var rightSideConsonantsLength = rightSideConsonants.length\n        var rightSideVowelsLength = rightSideVowels.length\n        var rightSideConsonantsIndex = rightSideConsonants.indexOf(rightSide[rightSideLength - 1])\n        var rightSideVowelsIndex = rightSideVowels.indexOf(rightSide[rightSideLength - 1])\n        var rightSideConsonantsIndexPlus1 = rightSideConsonantsIndex + 1\n        var rightSideVowelsIndexPlus1 = rightSideVowelsIndex + 1\n        if (rightSideConsonantsLength == 0 || rightSideVowelsLength == 0) {\n            return \"\"\n        } else if (rightSideConsonantsIndexPlus1 == rightSideLength) {\n            return \"\"\n        } else if (rightSideVowelsIndexPlus1 == rightSideLength) {\n            return \"\"\n        } else if (rightSideConsonantsIndexPlus1 == rightSideLength - 1) {\n            return \"\"\n        } else if (rightSideVowelsIndexPlus1 == rightSideLength - 1) {\n            return \"\"\n        } else if (rightSideConsonantsIndexPlus1 < rightSideVowelsIndexPlus1) {\n            return rightSideVowels[rightSideVowelsIndexPlus1 - 1]\n        } else if (rightSideConsonantsIndexPlus1 > rightSideVowelsIndexPlus1) {\n            return rightSideConsonants[rightSideConsonantsIndexPlus1 - 1]\n        } else {\n            return \"\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293035,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpanxqsx3j.scala:24:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideConsonants\u001b[0m = rightSide.filter(c -> vowelsAndConsonants.contains(c)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   Not found: c\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpanxqsx3j.scala:25:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideVowels\u001b[0m = rightSide.filter(c -> vowels.contains(c)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               Not found: c\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpanxqsx3j.scala:28:93 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideConsonantsIndex\u001b[0m = rightSideConsonants.indexOf(rightSide[\u001b[35mrightSideLength\u001b[0m \u001b[35m-\u001b[0m \u001b[31m1\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: type -\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpanxqsx3j.scala:29:85 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideVowelsIndex\u001b[0m = rightSideVowels.indexOf(rightSide[\u001b[35mrightSideLength\u001b[0m \u001b[35m-\u001b[0m \u001b[31m1\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: type -\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpanxqsx3j.scala:43:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var result = \"\"\n        for (var i = 0; i < word.length(); i++) {\n            if (consonants.indexOf(word.charAt(i)) != -1) {\n                for (var j = i + 1; j < word.length(); j++) {\n                    if (vowels.indexOf(word.charAt(j)) != -1) {\n                        result = word.charAt(j)\n                        break\n                    }\n                }\n                if (result != \"\") {\n                    break\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpq5wpiy6f.scala:22:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpq5wpiy6f.scala:22:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpq5wpiy6f.scala:22:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpq5wpiy6f.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var i = 0\n        var j = 0\n        var result = \"\"\n        while (i < word.length()) {\n            if (j < word.length() && consonants[j] != word.charAt(i)) {\n                j += 1\n            }\n            if (j < word.length() && vowels[i] != word.charAt(i)) {\n                result = word.charAt(i)\n                break\n            }\n            i += 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293040,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqxqd44d_.scala:25:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (j < word.length() && consonants[\u001b[35mj\u001b[0m] != word.charAt(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqxqd44d_.scala:28:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mif\u001b[0m (j < word.length() && vowels[\u001b[35mi\u001b[0m] != word.charAt(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqxqd44d_.scala:29:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                result = word.charAt(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    Char\n\u001b[31m   |\u001b[0m                         Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqxqd44d_.scala:30:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var closestVowel = \"\"\n        var wordLength = word.length()\n        for (var i = 0; i < wordLength; i++) {\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (vowels[vowelsIndex] == word.charAt(i)) {\n                    vowelsIndex += 1\n                } else if (consonants[consonantsIndex] == word.charAt(i)) {\n                    consonantsIndex += 1\n                } else {\n                    if (vowelsIndex > 0) {\n                        vowelsIndex -= 1\n                    } else if (consonantsIndex > 0) {\n                        consonantsIndex -= 1\n                    }\n                }\n            }\n        }\n        if (vowelsIndex == 0 && consonantsIndex == 0) {\n            closestVowel = \"\"\n        } else if (vowelsIndex == 0) {\n            closestVowel = \"\"\n        } else if (consonantsIndex == 0) {\n            closestVowel = \"\"\n        } else if (vowelsIndex > 0 && consonantsIndex > 0) {\n            if (vowelsIndex > consonantsIndex) {\n                closestVowel = \"\"\n            } else {\n                closestVowel = vowels[vowelsIndex - 1]\n            }\n        } else if (vowelsIndex > 0) {\n            closestVowel = vowels[vowelsIndex - 1]\n        } else if (consonantsIndex > 0) {\n            closestVowel = vowels[vowelsIndex]\n        }\n        return closestVowel\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293042,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpbzclipdq.scala:25:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbzclipdq.scala:25:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpbzclipdq.scala:25:43 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbzclipdq.scala:25:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.conve",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var i = 0\n        var j = word.length() - 1\n        var closestVowel = \"\"\n        while (i < j) {\n            if (vowels.indexOf(word.charAt(i)) != -1 && consonants.indexOf(word.charAt(j)) != -1) {\n                closestVowel = word.charAt(i)\n                break\n            }\n            i = i + 1\n            j = j - 1\n        }\n        return closestVowel\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293040,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp22o9r28g.scala:26:42 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                closestVowel = word.charAt(i)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    Char\n\u001b[31m   |\u001b[0m                               Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp22o9r28g.scala:27:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowelsCount = 0\n        var consonantsCount = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (vowels[i] == word[i]) {\n                vowelsCount += 1\n                if (vowelsCount == 2) {\n                    result = word[i]\n                    break\n                }\n            } else {\n                consonantsCount += 1\n                if (consonantsCount == 2) {\n                    result = word[i]\n                    break\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293037,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_513cz0f.scala:25:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (vowels[\u001b[35mi\u001b[0m] == word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_513cz0f.scala:28:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                    result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_513cz0f.scala:29:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_513cz0f.scala:34:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                    result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_513cz0f.scala:35:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var i = 0\n        var j = word.length() - 1\n        var closest = \"\"\n        while (i < j) {\n            if (consonants[i] == word[i] && consonants[j] == word[j]) {\n                i += 1\n                j -= 1\n                continue\n            }\n            if (vowels[i] == word[i] && vowels[j] == word[j]) {\n                closest = word[i]\n                i += 1\n                j -= 1\n                continue\n            }\n            if (vowels[i] == word[i] && consonants[j] == word[j]) {\n                closest = word[j]\n                i += 1\n                j -= 1\n                continue\n            }\n            if (vowels[j] == word[j] && consonants[i] == word[i]) {\n                closest = word[j]\n                i += 1\n                j -= 1\n                continue\n            }\n            if (vowels[j] == word[j] && vowels[i] == word[i]) {\n                closest = word[i]\n                i += 1\n                j -= 1\n                continue\n            }\n            if (vowels[i] == word[i] && vowels[j] == word[j]) {\n                closest = word[i]\n                i += 1\n                j -= 1\n                continue\n            }\n            if (vowels[i] == word[i] && consonants[j] == word[j]) {\n                closest = word[j]\n                i += 1\n                j -= 1\n                continue\n            }\n            if (vowels[j] == word[j] && consonants[i] == word[i]) {\n                closest = word[j]\n                i += 1\n                j -= 1\n                continue\n            }\n            i += 1\n            j -= 1\n        }\n        return closest\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293037,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5im97zrg.scala:25:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (consonants[\u001b[35mi\u001b[0m] == word[\u001b[35mi\u001b[0m] && consonants[\u001b[35mj\u001b[0m] == word[\u001b[35mj\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5im97zrg.scala:28:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                continue\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: continue\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5im97zrg.scala:30:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            \u001b[33mif\u001b[0m (vowels[\u001b[35mi\u001b[0m] == word[\u001b[35mi\u001b[0m] && vowels[\u001b[35mj\u001b[0m] == word[\u001b[35mj\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5im97zrg.scala:31:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                closest = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5im97zrg.scala:34:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                continue\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: continue\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5im97zrg.scala:36:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            \u001b[33mif\u001b[0m (vowels[\u001b[35mi\u001b[0m] == word[\u001b[35mi\u001b[0m] && consonants[\u001b[35mj\u001b[0m] == word[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var i = 0\n        var j = 0\n        var result = \"\"\n        while (i < word.length) {\n            if (consonants[j] == word[i]) {\n                j += 1\n            } else if (vowels[i] == word[i]) {\n                i += 1\n            } else {\n                i += 1\n            }\n            if (j == consonants.length) {\n                result = word[i]\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm6apl8l7.scala:25:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (consonants[\u001b[35mj\u001b[0m] == word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm6apl8l7.scala:27:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (vowels[i] == word[i]) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm6apl8l7.scala:33:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm6apl8l7.scala:34:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var result = \"\"\n        for (i = word.length() - 1; i >= 0; i--) {\n            if (consonants[i] == word[i]) {\n                for (j = i - 1; j >= 0; j--) {\n                    if (consonants[j] == word[j]) {\n                        for (k = j - 1; k >= 0; k--) {\n                            if (consonants[k] == word[k]) {\n                                for (l = k - 1; l >= 0; l--) {\n                                    if (consonants[l] == word[l]) {\n                                        for (m = l - 1; m >= 0; m--) {\n                                            if (consonants[m] == word[m]) {\n                                                for (n = m - 1; n >= 0; n--) {\n                                                    if (consonants[n] == word[n]) {\n                                                        for (o = n - 1; o >= 0; o--) {\n                                                            if (consonants[o] == word[o]) {\n                                                                for (p = o - 1; p >= 0; p--) {\n                                                                    if (consonants[p] == word[p]) {\n                                                                        for (q = p - 1; q >= 0; q--) {\n                                                                            if (consonants[q] == word[q]) {\n                                                                                \n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgmpc_toh.scala:40:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgmpc_toh.scala:40:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpgmpc_toh.scala:40:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgmpc_toh.scala:40:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue foreach is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator as",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293041,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpupl4mw0i.scala:95:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m95 |\u001b[0m        \u001b[33mvar\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpupl4mw0i.scala:47:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mi\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mi is already defined as \u001b[33mvariable\u001b[0m \u001b[35mi\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpupl4mw0i.scala:48:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mj\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mj is already defined as \u001b[33mvariable\u001b[0m \u001b[35mj\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpupl4mw0i.scala:49:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mk\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mk is already defined as \u001b[33mvariable\u001b[0m \u001b[35mk\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpupl4mw0i.scala:50:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36ml\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0ml is already defined as \u001b[33mvariable\u001b[0m \u001b[35ml\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpupl4mw0i.scala:51:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mm\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mm is already defi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var result = \"\"\n        for (var i = 0; i < word.length(); i++) {\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (vowels[vowelsIndex] == word.charAt(i)) {\n                    vowelsIndex += 1\n                } else if (consonants[consonantsIndex] == word.charAt(i)) {\n                    consonantsIndex += 1\n                } else {\n                    result = \"\"\n                    break\n                }\n            } else {\n                result = \"\"\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293027,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpuitf6nui.scala:24:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpuitf6nui.scala:24:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpuitf6nui.scala:24:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuitf6nui.scala:24:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = List.of(\"a\", \"e\", \"i\", \"o\", \"u\")\n        var consonants = List.of(\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\")\n        var vowelsAndConsonants = vowels.zip(consonants)\n        var vowelsAndConsonantsDistinct = vowelsAndConsonants.distinct\n        var vowelsAndConsonantsDistinctLength = vowelsAndConsonantsDistinct.length\n        var vowelsAndConsonantsDistinctLengthMinusOne = vowelsAndConsonantsDistinctLength - 1\n        var vowelsAndConsonantsDistinctLengthMinusTwo = vowelsAndConsonantsDistinctLength - 2\n        var vowelsAndConsonantsDistinctLengthMinusThree = vowelsAndConsonantsDistinctLength - 3\n        var vowelsAndConsonantsDistinctLengthMinusFour = vowelsAndConsonantsDistinctLength - 4\n        var vowelsAndConsonantsDistinctLengthMinusFive = vowelsAndConsonantsDistinctLength - 5\n        var vowelsAndConsonantsDistinctLengthMinusSix = vowelsAndConsonantsDistinctLength - 6\n        var vowelsAndConsonantsDistinctLengthMinusSeven = vowelsAndConsonantsDistinctLength - 7\n        var vowelsAndConsonantsDistinctLengthMinusEight = vowelsAndConsonantsDistinctLength - 8\n        var vowelsAndConsonantsDistinctLengthMinusNine = vowelsAndConsonantsDistinctLength - 9\n        var vowelsAndConsonantsDistinctLengthMinusTen = vowelsAndConsonantsDistinctLength - 10\n        var vowelsAndConsonantsDistinctLengthMinusEleven = vowelsAndConsonantsDistinctLength - 11\n        var vowelsAndConsonantsDistinctLengthMinusTwelve = vowelsAndConsonantsDistinctLength - 12\n        var vowelsAndConsonantsDistinctLengthMinusThirteen = vowelsAndConsonantsDistinctLength - 13\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293043,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnu1nkb45.scala:19:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mvowels\u001b[0m = List.of(\u001b[31m\"a\"\u001b[0m, \u001b[31m\"e\"\u001b[0m, \u001b[31m\"i\"\u001b[0m, \u001b[31m\"o\"\u001b[0m, \u001b[31m\"u\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value of is not a member of object scala.collection.immutable.List\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnu1nkb45.scala:20:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mconsonants\u001b[0m = List.of(\u001b[31m\"b\"\u001b[0m, \u001b[31m\"c\"\u001b[0m, \u001b[31m\"d\"\u001b[0m, \u001b[31m\"f\"\u001b[0m, \u001b[31m\"g\"\u001b[0m, \u001b[31m\"h\"\u001b[0m, \u001b[31m\"j\"\u001b[0m, \u001b[31m\"k\"\u001b[0m, \u001b[31m\"l\"\u001b[0m, \u001b[31m\"m\"\u001b[0m, \u001b[31m\"n\"\u001b[0m, \u001b[31m\"p\"\u001b[0m, \u001b[31m\"q\"\u001b[0m, \u001b[31m\"r\"\u001b[0m, \u001b[31m\"s\"\u001b[0m, \u001b[31m\"t\"\u001b[0m, \u001b[31m\"v\"\u001b[0m, \u001b[31m\"w\"\u001b[0m, \u001b[31m\"x\"\u001b[0m, \u001b[31m\"y\"\u001b[0m, \u001b[31m\"z\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value of is not a member of object scala.collection.immutable.List\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnu1nkb45.scala:37:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var consonantIndex = 0\n        var vowelIndex = 0\n        var result = \"\"\n        for (i <- word.length - 1) {\n            if (consonantIndex < consonants.length && word[i] == consonants[consonantIndex]) {\n                consonantIndex += 1\n            } else if (vowelIndex < vowels.length && word[i] == vowels[vowelIndex]) {\n                vowelIndex += 1\n            } else {\n                break\n            }\n        }\n        if (vowelIndex == 0 && consonantIndex == consonants.length) {\n            result = \"\"\n        } else if (vowelIndex == vowels.length) {\n            result = vowels[vowelIndex - 1]\n        } else if (vowelIndex == 0) {\n            result = vowels[vowels.length - 1]\n        } else {\n            result = vowels[vowelIndex - 1]\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293042,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe1uz2p8c.scala:24:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- word.length - \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe1uz2p8c.scala:36:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            result = vowels[\u001b[35mvowelIndex\u001b[0m \u001b[35m-\u001b[0m \u001b[31m1\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: type -\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe1uz2p8c.scala:38:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            result = vowels[vowels.length \u001b[35m-\u001b[0m \u001b[31m1\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          Not found: type -\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe1uz2p8c.scala:40:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m            result = vowels[\u001b[35mvowelIndex\u001b[0m \u001b[35m-\u001b[0m \u001b[31m1\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: type -\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var index = 0\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (consonants[index] == word.charAt(i)) {\n                index++\n            } else {\n                break\n            }\n        }\n        if (index == 0) {\n            return \"\"\n        }\n        for (var i = index; i < word.length(); i++) {\n            if (vowels[i] == word.charAt(i)) {\n                return word.substring(i, i + 1)\n            }\n        }\n        return \"\"\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293047,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpl_hw6nkj.scala:22:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpl_hw6nkj.scala:22:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpl_hw6nkj.scala:22:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpl_hw6nkj.scala:32:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = index; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpl_hw6nkj.scala:32:45 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = index; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpl_hw6nkj.scala:32:50 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = index; i < word.length();",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var result = \"\"\n        for (i = word.length() - 1; i >= 0; i--) {\n            if (consonants[i] != \"\") {\n                for (j = i + 1; j < word.length(); j++) {\n                    if (consonants[j] != \"\") {\n                        for (k = j + 1; k < word.length(); k++) {\n                            if (consonants[k] != \"\") {\n                                for (l = k + 1; l < word.length(); l++) {\n                                    if (consonants[l] != \"\") {\n                                        for (m = l + 1; m < word.length(); m++) {\n                                            if (consonants[m] != \"\") {\n                                                for (n = m + 1; n < word.length(); n++) {\n                                                    if (consonants[n] != \"\") {\n                                                        for (o = n + 1; o < word.length(); o++) {\n                                                            if (consonants[o] != \"\") {\n                                                                for (p = o + 1; p < word.length(); p++) {\n                                                                    if (consonants[p] != \"\") {\n                                                                        for (q = p + 1; q < word.length(); q++) {\n                                                                            if (consonants[q] != \"\") {\n                                                                                for (r = q + 1; r < word.\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293046,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpg7dyf43f.scala:40:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpg7dyf43f.scala:40:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpg7dyf43f.scala:40:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpg7dyf43f.scala:40:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue foreach is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator as",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowelsAndConsonants = vowels + consonants\n        var rightSide = word.toCharArray()\n        var rightSideLength = rightSide.length\n        var rightSideIndex = rightSideLength - 1\n        var rightSideVowels = \"\"\n        for (var i = rightSideIndex; i >= 0; i--) {\n            if (vowelsAndConsonants[i] == rightSide[i]) {\n                rightSideVowels = rightSideVowels + rightSide[i]\n            } else {\n                break\n            }\n        }\n        if (rightSideVowels.length == 0) {\n            return \"\"\n        } else {\n            return rightSideVowels\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293049,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpt7ieanp5.scala:26:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = rightSideIndex; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpt7ieanp5.scala:26:43 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = rightSideIndex; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpt7ieanp5.scala:26:48 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = rightSideIndex; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt7ieanp5.scala:21:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mvowelsAndConsonants\u001b[0m = vowels + consonants\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of Array[Char], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt7ieanp5.scala:26:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = rightSideIndex; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                             ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var index = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (consonants.indexOf(word.charAt(i)) != -1) {\n                if (index == 0) {\n                    result = \"\"\n                } else {\n                    result = \"\"\n                }\n            } else if (vowels.indexOf(word.charAt(i)) != -1) {\n                result = word.charAt(i)\n                index = i\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293047,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpaqst4bu0.scala:31:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                result = word.charAt(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    Char\n\u001b[31m   |\u001b[0m                         Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toSet\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toSet\n        var vowelsAndConsonants = vowels.union(consonants)\n        var vowelsAndConsonantsAndVowels = vowelsAndConsonants.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowels = vowelsAndConsonantsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowels\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292981,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfk6p0buq.scala:31:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfk6p0buq.scala:31:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowels_count = 0\n        var consonants_count = 0\n        var index = 0\n        var result = \"\"\n        for (var i = word.length - 1; i >= 0; i--) {\n            if (vowels[word.charAt(i) - 'a'] != 0) {\n                vowels_count += 1\n                if (vowels_count == 2) {\n                    result = word.substring(i, i + 1)\n                    break\n                }\n            } else if (consonants[word.charAt(i) - 'a'] != 0) {\n                consonants_count += 1\n                if (consonants_count == 2) {\n                    result = word.substring(i, i + 1)\n                    break\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293050,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpzcn3prli.scala:25:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzcn3prli.scala:25:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpzcn3prli.scala:25:49 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                 pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzcn3prli.scala:25:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collect",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var closestVowel = \"\"\n        var wordLength = word.length\n        for (var i = wordLength - 1; i >= 0; i--) {\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (vowels[vowelsIndex] == word[i]) {\n                    vowelsIndex += 1\n                } else if (consonants[consonantsIndex] == word[i]) {\n                    consonantsIndex += 1\n                } else {\n                    if (closestVowel.length == 0) {\n                        closestVowel = word[i]\n                    } else {\n                        if (Math.abs(vowelsIndex - vowels.length) < Math.abs(consonantsIndex - consonants.length)) {\n                            closestVowel = word[i]\n                        } else {\n                            closestVowel = \"\"\n                        }\n                    }\n                }\n            } else {\n                if (closestVowel.length == 0) {\n                    closestVowel = word[i]\n                } else {\n                    closestVowel = \"\"\n                }\n            }\n        }\n        return closestVowel\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293049,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp6gex9_n4.scala:25:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = wordLength - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp6gex9_n4.scala:25:43 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = wordLength - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp6gex9_n4.scala:25:48 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = wordLength - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6gex9_n4.scala:25:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = wordLength - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.conve",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var result = \"\"\n        for (i <- word.length - 1) {\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (vowels[vowelsIndex] == word.charAt(i)) {\n                    vowelsIndex += 1\n                } else if (consonants[consonantsIndex] == word.charAt(i)) {\n                    consonantsIndex += 1\n                } else {\n                    result = word.charAt(i)\n                    break\n                }\n            } else {\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293033,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7x51hlc5.scala:24:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- word.length - \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (consonants[index] == word.charAt(i)) {\n                index = (index + 1) % consonants.length\n            } else if (vowels[index] == word.charAt(i)) {\n                index = (index + 1) % vowels.length\n            } else {\n                result = word.charAt(i)\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293010,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmputlzz_ym.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmputlzz_ym.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmputlzz_ym.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmputlzz_ym.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var vowelsAndConsonants = vowels + consonants\n        var vowelsAndConsonantsLength = vowelsAndConsonants.length\n        var wordLength = word.length\n        var rightSide = word.substring(wordLength - 1)\n        var rightSideLength = rightSide.length\n        var rightSideConsonants = rightSide.filter(c -> vowelsAndConsonants.indexOf(c) == -1)\n        var rightSideConsonantsLength = rightSideConsonants.length\n        var rightSideConsonantsIndex = rightSideConsonants.indexOf(rightSide[rightSideLength - 1])\n        var rightSideConsonantsIndex2 = rightSideConsonants.indexOf(rightSide[rightSideLength - 2])\n        var rightSideConsonantsIndex3 = rightSideConsonants.indexOf(rightSide[rightSideLength - 3])\n        var rightSideConsonantsIndex4 = rightSideConsonants.indexOf(rightSide[rightSideLength - 4])\n        var rightSideConsonantsIndex5 = rightSideConsonants.indexOf(rightSide[rightSideLength - 5])\n        var rightSideConsonantsIndex6 = rightSideConsonants.indexOf(rightSide[rightSideLength - 6])\n        var rightSideConsonantsIndex7 = rightSideConsonants.indexOf(rightSide[rightSideLength - 7])\n        var rightSideConsonantsIndex8 = rightSideConsonants.indexOf(rightSide[rightSideLength - 8])\n        var rightSideConsonantsIndex9 = rightSideConsonants.indexOf(rightSide[rightSideLength - 9])\n        var rightSideConsonantsIndex10 = rightSideConsonants.indexOf(rightSide[rightSideLength - 10])\n        var rightSideConsonantsIndex11 = rightSideConsonants.indexOf(rightSide[rightSideLength - 11])\n        var rightSideConsonantsIndex12 = rightSideConsonants.indexOf(rightSide[rightSideLength -\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293049,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpdj7ojjcp.scala:40:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdj7ojjcp.scala:26:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideConsonants\u001b[0m = rightSide.filter(c -> vowelsAndConsonants.indexOf(c) == -\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   Not found: c\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdj7ojjcp.scala:28:93 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideConsonantsIndex\u001b[0m = rightSideConsonants.indexOf(rightSide[\u001b[35mrightSideLength\u001b[0m \u001b[35m-\u001b[0m \u001b[31m1\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: type -\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdj7ojjcp.scala:29:94 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideConsonantsIndex2\u001b[0m = rightSideConsonants.indexOf(rightSide[\u001b[35mrightSideLength\u001b[0m \u001b[35m-\u001b[0m \u001b[31m2\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: type -\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdj7ojjcp.scala:30:94 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightSideConsonantsIndex3\u001b[0m = rightSideConsonants.indexOf(rightSide[\u001b[35mrightSideLength\u001b[0m \u001b[35m-\u001b[0m \u001b[31m3\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var result = \"\"\n        var wordLength = word.length()\n        for (var i = 0; i < wordLength; i++) {\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (vowels[vowelsIndex] == word.charAt(i)) {\n                    vowelsIndex += 1\n                } else if (consonants[consonantsIndex] == word.charAt(i)) {\n                    consonantsIndex += 1\n                } else {\n                    if (vowelsIndex > 0) {\n                        result = word.substring(i - vowelsIndex, i)\n                    } else if (consonantsIndex > 0) {\n                        result = word.substring(i - consonantsIndex, i)\n                    }\n                    break\n                }\n            } else {\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293050,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpl27zel4l.scala:25:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpl27zel4l.scala:25:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpl27zel4l.scala:25:43 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl27zel4l.scala:25:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.conve",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var i = 0\n        var j = 0\n        var result = \"\"\n        while (i < word.length) {\n            if (vowels[0] == word[i]) {\n                i = i + 1\n            } else {\n                i = i + 1\n            }\n            while (j < word.length) {\n                if (vowels[0] == word[j]) {\n                    j = j + 1\n                } else {\n                    j = j + 1\n                }\n                if (i == j) {\n                    result = word[i]\n                    break\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293044,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpm5hl3h6n.scala:25:22 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (vowels[\u001b[31m0\u001b[0m] == word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mArray\u001b[0m does not take type parameters\n\u001b[31m\u001b[31m-- Error: /tmp/tmpm5hl3h6n.scala:31:26 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                \u001b[33mif\u001b[0m (vowels[\u001b[31m0\u001b[0m] == word[\u001b[35mj\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mArray\u001b[0m does not take type parameters\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm5hl3h6n.scala:37:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm5hl3h6n.scala:38:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var i = 0\n        var j = word.length() - 1\n        var result = \"\"\n        while (i < j) {\n            if (vowels.contains(word.charAt(i))) {\n                result = word.charAt(i)\n                break\n            } else if (consonants.contains(word.charAt(i))) {\n                i += 1\n            } else if (consonants.contains(word.charAt(j))) {\n                j -= 1\n            } else {\n                i += 1\n                j -= 1\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293049,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsr2i259f.scala:26:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = word.charAt(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    Char\n\u001b[31m   |\u001b[0m                         Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsr2i259f.scala:27:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowelsAndConsonants = vowels + consonants\n        var right = word.length\n        var left = 0\n        var rightVowel = \"\"\n        var leftVowel = \"\"\n        var rightConsonant = \"\"\n        var leftConsonant = \"\"\n        var rightVowelIndex = -1\n        var leftVowelIndex = -1\n        var rightConsonantIndex = -1\n        var leftConsonantIndex = -1\n        var rightVowelIndex = -1\n        var leftVowelIndex = -1\n        var rightConsonantIndex = -1\n        var leftConsonantIndex = -1\n        for (i <- 0 until right) {\n            if (vowelsAndConsonants[i] == word[i]) {\n                if (rightVowelIndex == -1) {\n                    rightVowelIndex = i\n                }\n                if (leftVowelIndex == -1) {\n                    leftVowelIndex = i\n                }\n                if (rightConsonantIndex == -1) {\n                    rightConsonantIndex = i\n                }\n                if (leftConsonantIndex == -1) {\n                    leftConsonantIndex = i\n                }\n            } else if (rightVowelIndex != -1) {\n                rightVowel = word[rightVowelIndex]\n                rightConsonant = word[rightConsonantIndex]\n                break\n            } else if (leftVowelIndex != -1) {\n                leftVowel = word[leftVowelIndex]\n                leftConsonant = word[leftConsonantIndex]\n                break\n            } else if (rightConsonantIndex != -1) {\n                rightConsonant = word[rightConsonantIndex]\n                break\n            } else if (leftConsonantIndex != -1) {\n                leftConsonant = word[leftConsonantIndex]\n                break\n            }\n        }\n        if (rightVowelIndex != -1\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293051,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpau4hg2y5.scala:67:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpau4hg2y5.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightVowelIndex\u001b[0m = -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightVowelIndex is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightVowelIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpau4hg2y5.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftVowelIndex\u001b[0m = -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftVowelIndex is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftVowelIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpau4hg2y5.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightConsonantIndex\u001b[0m = -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightConsonantIndex is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightConsonantIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpau4hg2y5.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftConsonantIndex\u001b[0m = -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftConsonantIndex is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftConsonantIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpau4hg2y5.scala:21:41 -----------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var i = 0\n        var j = 0\n        var result = \"\"\n        while (i < word.length()) {\n            if (consonants[j] == word.charAt(i)) {\n                j += 1\n            } else if (vowels[i] == word.charAt(i)) {\n                i += 1\n            } else {\n                i += 1\n            }\n            if (j >= consonants.length) {\n                result = word.substring(i)\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293047,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp14ozl78.scala:25:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (consonants[\u001b[35mj\u001b[0m] == word.charAt(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp14ozl78.scala:27:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (vowels[i] == word.charAt(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp14ozl78.scala:34:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            var c = word.charAt(i)\n            if (consonants.indexOf(c) >= 0) {\n                index = i\n                break\n            }\n        }\n        for (var i = index + 1; i < word.length(); i++) {\n            var c = word.charAt(i)\n            if (vowels.indexOf(c) >= 0) {\n                result = c\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293054,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp95o0kppt.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp95o0kppt.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp95o0kppt.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp95o0kppt.scala:30:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = index + \u001b[31m1\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp95o0kppt.scala:30:49 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = index + \u001b[31m1\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp95o0kppt.scala:30:54 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            var c = word.charAt(i)\n            if (vowels.indexOf(c) != -1) {\n                result = c\n                break\n            }\n            if (consonants.indexOf(c) != -1) {\n                index = i\n                break\n            }\n        }\n        if (result.length == 0) {\n            return \"\"\n        }\n        var left = word.substring(0, index)\n        var right = word.substring(index + 1)\n        var leftVowels = left.toLowerCase().chars().filter(e -> vowels.indexOf(e) != -1).toList\n        var rightVowels = right.toLowerCase().chars().filter(e -> vowels.indexOf(e) != -1).toList\n        var leftConsonants = left.toLowerCase().chars().filter(e -> consonants.indexOf(e) != -1).toList\n        var rightConsonants = right.toLowerCase().chars().filter(e -> consonants.indexOf(e) != -1).toList\n        var leftVowelsIndex = leftVowels.indexOf(result)\n        var rightVowelsIndex = rightVowels.indexOf(result)\n        var leftConsonantsIndex = leftConsonants.indexOf(result)\n        var rightConsonantsIndex = rightConsonants.indexOf(result)\n        if (leftVowelsIndex == -1 && rightVowelsIndex == -1 && leftConsonantsIndex == -1 && rightConsonantsIndex == -1) {\n            return \"\"\n        }\n        if (leftVowelsIndex == -1 && rightVowelsIndex != -1) {\n            return rightVowelsIndex\n        }\n        if (leftVowelsIndex != -1 && rightVowelsIndex == -1) {\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293054,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmphku5l15s.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmphku5l15s.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmphku5l15s.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmphku5l15s.scala:72:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphku5l15s.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterabl",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (word.charAt(i) == vowels[vowelsIndex]) {\n                    vowelsIndex += 1\n                } else if (word.charAt(i) == consonants[consonantsIndex]) {\n                    consonantsIndex += 1\n                } else {\n                    result = \"\"\n                    break\n                }\n            } else {\n                result = \"\"\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293048,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgk82g_wo.scala:26:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mif\u001b[0m (word.charAt(i) == vowels[\u001b[35mvowelsIndex\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                             Not found: type vowelsIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgk82g_wo.scala:28:56 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (word.charAt(i) == consonants[consonantsIndex]) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                        ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type consonantsIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgk82g_wo.scala:32:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgk82g_wo.scala:36:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var consonantIndex = 0\n        var vowelIndex = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (consonants[consonantIndex] == word[i]) {\n                consonantIndex += 1\n            } else if (vowels[vowelIndex] == word[i]) {\n                vowelIndex += 1\n            } else {\n                result = word[i]\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293050,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf6e_woii.scala:25:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (consonants[\u001b[35mconsonantIndex\u001b[0m] == word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type consonantIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf6e_woii.scala:27:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (vowels[vowelIndex] == word[i]) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type vowelIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf6e_woii.scala:30:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf6e_woii.scala:31:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var closestVowel = \"\"\n        var wordLength = word.length\n        for (var i = wordLength - 1; i >= 0; i--) {\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (vowels[vowelsIndex] == word.charAt(i)) {\n                    vowelsIndex += 1\n                } else if (consonants[consonantsIndex] == word.charAt(i)) {\n                    consonantsIndex += 1\n                } else {\n                    if (Math.abs(vowelsIndex - consonantsIndex) < Math.abs(vowelsIndex - closestVowel.length)) {\n                        closestVowel = word.charAt(i)\n                    }\n                    vowelsIndex = 0\n                    consonantsIndex = 0\n                }\n            }\n        }\n        return closestVowel\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293053,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmptnyuorqf.scala:25:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = wordLength - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmptnyuorqf.scala:25:43 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = wordLength - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmptnyuorqf.scala:25:48 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = wordLength - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptnyuorqf.scala:25:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = wordLength - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.conve",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (consonants[index] == word.charAt(i)) {\n                index++\n            } else {\n                if (vowels[index] == word.charAt(i)) {\n                    result = word.charAt(i)\n                    break\n                } else {\n                    index = 0\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293026,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpbnj12yo3.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbnj12yo3.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpbnj12yo3.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbnj12yo3.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (consonantsIndex < word.length && vowelsIndex < word.length && word[i] == vowels[vowelsIndex]) {\n                vowelsIndex += 1\n            } else if (consonantsIndex < word.length && vowelsIndex >= word.length && word[i] == consonants[consonantsIndex]) {\n                consonantsIndex += 1\n            } else {\n                result = \"\"\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293051,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyjm1vhr8.scala:25:83 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (consonantsIndex < word.length && vowelsIndex < word.length && word[\u001b[35mi\u001b[0m] == vowels[\u001b[35mvowelsIndex\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyjm1vhr8.scala:27:91 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (consonantsIndex < word.length && vowelsIndex >= word.length && word[i] == consonants[consonantsIndex]) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyjm1vhr8.scala:31:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var index = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (vowels.indexOf(word.charAt(i)) >= 0) {\n                index = i\n                break\n            }\n        }\n        for (i <- index + 1 until word.length) {\n            if (consonants.indexOf(word.charAt(i)) >= 0) {\n                result = word.charAt(i)\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293053,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8rfn1864.scala:26:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8rfn1864.scala:31:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                result = word.charAt(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    Char\n\u001b[31m   |\u001b[0m                         Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8rfn1864.scala:32:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var result = \"\"\n        var wordLength = word.length()\n        for (var i = 0; i < wordLength; i++) {\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (vowels[vowelsIndex] == word.charAt(i)) {\n                    vowelsIndex += 1\n                } else if (consonants[consonantsIndex] == word.charAt(i)) {\n                    consonantsIndex += 1\n                } else {\n                    result = \"\"\n                    break\n                }\n            } else {\n                result = \"\"\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293054,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp77efgpt3.scala:25:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp77efgpt3.scala:25:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp77efgpt3.scala:25:43 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp77efgpt3.scala:25:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.conve",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toSet\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toSet\n        var vowelsAndConsonants = vowels.union(consonants)\n        var vowelsAndConsonantsAndVowels = vowelsAndConsonants.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowels = vowelsAndConsonantsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowels\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292981,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfk6p0buq.scala:31:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfk6p0buq.scala:31:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (consonants[index] == word.charAt(i)) {\n                index++\n            } else {\n                if (vowels[index] != 0) {\n                    result = vowels[index]\n                    break\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293056,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp8e7_ml6c.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8e7_ml6c.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp8e7_ml6c.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8e7_ml6c.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var i = 0\n        var j = 0\n        var result = \"\"\n        while (i < word.length && j < word.length) {\n            if (consonants[j] == word[i]) {\n                j += 1\n            } else if (vowels[i] == word[i]) {\n                i += 1\n            } else {\n                i += 1\n            }\n        }\n        if (i < word.length) {\n            result = word[i]\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293016,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphoan3to1.scala:25:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (consonants[\u001b[35mj\u001b[0m] == word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphoan3to1.scala:27:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (vowels[i] == word[i]) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphoan3to1.scala:34:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var i = 0\n        var j = 0\n        var result = \"\"\n        while (i < word.length()) {\n            if (consonants[j] == word.charAt(i)) {\n                j += 1\n            } else if (vowels[i] == word.charAt(i)) {\n                i += 1\n            } else {\n                result = word.substring(i, j)\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293052,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4t3d0a79.scala:25:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (consonants[\u001b[35mj\u001b[0m] == word.charAt(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4t3d0a79.scala:27:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (vowels[i] == word.charAt(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4t3d0a79.scala:31:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var consonantIndex = 0\n        var vowelIndex = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (consonants[consonantIndex] == word[i]) {\n                consonantIndex += 1\n            } else if (vowels[vowelIndex] == word[i]) {\n                vowelIndex += 1\n            } else {\n                result = word[i]\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293052,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3vssd8uq.scala:25:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (consonants[\u001b[35mconsonantIndex\u001b[0m] == word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type consonantIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3vssd8uq.scala:27:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (vowels[vowelIndex] == word[i]) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type vowelIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3vssd8uq.scala:30:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3vssd8uq.scala:31:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var result = \"\"\n        for (i = word.length() - 1; i >= 0; i--) {\n            if (word.charAt(i) == 'a' || word.charAt(i) == 'e' || word.charAt(i) == 'i' || word.charAt(i) == 'o' || word.charAt(i) == 'u') {\n                result = word.charAt(i)\n                break\n            }\n            for (j = 0; j < vowels.length; j++) {\n                if (word.charAt(i) == vowels[j]) {\n                    result = word.charAt(i)\n                    break\n                }\n            }\n            for (k = 0; k < consonants.length; k++) {\n                if (word.charAt(i) == consonants[k]) {\n                    result = word.charAt(i)\n                    break\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293058,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpx1lrqg3a.scala:40:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpx1lrqg3a.scala:40:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpx1lrqg3a.scala:40:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx1lrqg3a.scala:40:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue foreach is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator as",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var result = \"\"\n        for (i = word.length() - 1; i >= 0; i--) {\n            if (consonants[i] == word[i]) {\n                for (j = i + 1; j < word.length(); j++) {\n                    if (consonants[j] == word[j]) {\n                        for (k = j + 1; k < word.length(); k++) {\n                            if (consonants[k] == word[k]) {\n                                for (l = k + 1; l < word.length(); l++) {\n                                    if (consonants[l] == word[l]) {\n                                        for (m = l + 1; m < word.length(); m++) {\n                                            if (consonants[m] == word[m]) {\n                                                for (n = m + 1; n < word.length(); n++) {\n                                                    if (consonants[n] == word[n]) {\n                                                        for (o = n + 1; o < word.length(); o++) {\n                                                            if (consonants[o] == word[o]) {\n                                                                for (p = o + 1; p < word.length(); p++) {\n                                                                    if (consonants[p] == word[p]) {\n                                                                        for (q = p + 1; q < word.length(); q++) {\n                                                                            if (consonants[q] == word[q\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293060,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbxmn5zbi.scala:40:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbxmn5zbi.scala:40:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpbxmn5zbi.scala:40:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbxmn5zbi.scala:40:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue foreach is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator as",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowelsAndConsonants = vowels + consonants\n        var right = word.length()\n        var left = 0\n        var rightVowel = \"\"\n        var leftVowel = \"\"\n        var rightConsonant = \"\"\n        var leftConsonant = \"\"\n        var rightIndex = -1\n        var leftIndex = -1\n        var rightVowelIndex = -1\n        var leftVowelIndex = -1\n        var rightConsonantIndex = -1\n        var leftConsonantIndex = -1\n        var rightVowelChar = \"\"\n        var leftVowelChar = \"\"\n        var rightConsonantChar = \"\"\n        var leftConsonantChar = \"\"\n        var rightVowelIndex = -1\n        var leftVowelIndex = -1\n        var rightConsonantIndex = -1\n        var leftConsonantIndex = -1\n        var rightVowelCharIndex = -1\n        var leftVowelCharIndex = -1\n        var rightConsonantCharIndex = -1\n        var leftConsonantCharIndex = -1\n        var rightVowelCharIndex = -1\n        var leftVowelCharIndex = -1\n        var rightConsonantCharIndex = -1\n        var leftConsonantCharIndex = -1\n        var rightVowelCharIndex = -1\n        var leftVowelCharIndex = -1\n        var rightConsonantCharIndex = -1\n        var leftConsonantCharIndex = -1\n        var rightVowelCharIndex = -1\n        var leftVowelCharIndex = -1\n        var rightConsonantCharIndex = -1\n        var leftConsonantCharIndex = -1\n        var rightVowelCharIndex = -1\n        var leftVowelCharIndex = -1\n        var rightConsonantCharIndex = -1\n        var leftConsonantCharIndex = -1\n        var rightVowelCharIndex = -1\n        var leftVowelCharIndex =\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293061,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmprozpyyi7.scala:63:32 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftVowelCharIndex\u001b[0m =\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmprozpyyi7.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightVowelIndex\u001b[0m = -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightVowelIndex is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightVowelIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmprozpyyi7.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftVowelIndex\u001b[0m = -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftVowelIndex is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftVowelIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmprozpyyi7.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightConsonantIndex\u001b[0m = -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightConsonantIndex is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightConsonantIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmprozpyyi7.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftConsonantIndex\u001b[0m = -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftConsonantIndex is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftConsonantI",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = List.range(97, 123)\n        var consonants = List.range(97, 123)\n        var index = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (vowels.contains(word.charAt(i))) {\n                index = i\n                break\n            }\n            if (consonants.contains(word.charAt(i))) {\n                index = i\n                break\n            }\n        }\n        if (index == 0) {\n            return \"\"\n        }\n        for (i <- index + 1 until word.length) {\n            if (vowels.contains(word.charAt(i))) {\n                result = word.charAt(i)\n                break\n            }\n            if (consonants.contains(word.charAt(i))) {\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293059,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxz_wh9cl.scala:26:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxz_wh9cl.scala:30:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxz_wh9cl.scala:38:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                result = word.charAt(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    Char\n\u001b[31m   |\u001b[0m                         Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxz_wh9cl.scala:39:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxz_wh9cl.scala:42:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (vowels[vowelsIndex] == word[i]) {\n                    vowelsIndex += 1\n                } else if (consonants[consonantsIndex] == word[i]) {\n                    consonantsIndex += 1\n                } else {\n                    result = word[i]\n                    break\n                }\n            } else {\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293057,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl9jw1heg.scala:26:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mif\u001b[0m (vowels[\u001b[35mvowelsIndex\u001b[0m] == word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type vowelsIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl9jw1heg.scala:28:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (consonants[consonantsIndex] == word[i]) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: type consonantsIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl9jw1heg.scala:31:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                    result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl9jw1heg.scala:32:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl9jw1heg.scala:35:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var consonantIndex = 0\n        var vowelIndex = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            var c = word.charAt(i)\n            if (consonants.indexOf(c) >= 0) {\n                if (vowelIndex == 0) {\n                    consonantIndex = consonants.indexOf(c)\n                }\n            } else if (vowels.indexOf(c) >= 0) {\n                if (consonantIndex == 0) {\n                    vowelIndex = vowels.indexOf(c)\n                }\n            } else {\n                if (vowelIndex != 0 && consonantIndex != 0) {\n                    result = word.substring(i + 1, consonantIndex)\n                    break\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293063,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpg6dok9ci.scala:24:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpg6dok9ci.scala:24:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpg6dok9ci.scala:24:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpg6dok9ci.scala:24:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\"\n        var consonants = \"bcdfghjklmnpqrstvwxyz\"\n        var i = 0\n        var j = word.length() - 1\n        var closestVowel = \"\"\n        while (i < j) {\n            if (vowels.indexOf(word.charAt(i)) != -1 && consonants.indexOf(word.charAt(j)) != -1) {\n                closestVowel = word.charAt(i)\n                break\n            } else if (vowels.indexOf(word.charAt(i)) != -1) {\n                closestVowel = word.charAt(i)\n                i += 1\n            } else if (consonants.indexOf(word.charAt(j)) != -1) {\n                closestVowel = word.charAt(j)\n                j -= 1\n            } else {\n                i += 1\n                j -= 1\n            }\n        }\n        return closestVowel\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293062,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmph9t4i46d.scala:26:42 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                closestVowel = word.charAt(i)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    Char\n\u001b[31m   |\u001b[0m                               Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmph9t4i46d.scala:27:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmph9t4i46d.scala:29:42 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                closestVowel = word.charAt(i)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    Char\n\u001b[31m   |\u001b[0m                               Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmph9t4i46d.scala:32:42 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                closestVowel = word.charAt(j)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    Char\n\u001b[31m   |\u001b[0m                               Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (consonants[index] == word.charAt(i)) {\n                index++\n            } else if (vowels[index] == word.charAt(i)) {\n                index = 0\n            } else {\n                index = 0\n                result = word.charAt(i)\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293062,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp9za8wqip.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9za8wqip.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp9za8wqip.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9za8wqip.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var i = 0\n        var j = 0\n        var result = \"\"\n        while (i < word.length) {\n            if (consonants[j] == word[i]) {\n                j += 1\n            } else if (vowels[i] == word[i]) {\n                i += 1\n            } else {\n                i += 1\n            }\n            if (j == consonants.length) {\n                result = word[i]\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293057,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy_jzhnw9.scala:25:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (consonants[\u001b[35mj\u001b[0m] == word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy_jzhnw9.scala:27:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (vowels[i] == word[i]) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy_jzhnw9.scala:33:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy_jzhnw9.scala:34:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var i = 0\n        var j = 0\n        var closest = \"\"\n        while (i < word.length()) {\n            if (j < word.length() && vowels.indexOf(word.charAt(j)) != -1) {\n                closest = word.charAt(j)\n                i = j + 1\n                j = i\n            } else if (j < word.length() && consonants.indexOf(word.charAt(j)) != -1) {\n                closest = word.charAt(j)\n                i = j + 1\n                j = i\n            } else {\n                i = i + 1\n                j = i\n            }\n        }\n        return closest\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293061,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp03143p25.scala:26:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                closest = word.charAt(j)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    Char\n\u001b[31m   |\u001b[0m                          Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp03143p25.scala:30:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                closest = word.charAt(j)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    Char\n\u001b[31m   |\u001b[0m                          Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var result = \"\"\n        var index = 0\n        for (var i = word.length() - 1; i >= 0; i--) {\n            var c = word.charAt(i)\n            if (consonants.indexOf(c) >= 0) {\n                index = i\n                break\n            }\n        }\n        for (var i = index + 1; i < word.length(); i++) {\n            var c = word.charAt(i)\n            if (vowels.indexOf(c) >= 0) {\n                result = c\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293064,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp459f4q4t.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp459f4q4t.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp459f4q4t.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp459f4q4t.scala:30:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = index + \u001b[31m1\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp459f4q4t.scala:30:49 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = index + \u001b[31m1\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp459f4q4t.scala:30:54 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (vowels[vowelsIndex] == word[i]) {\n                    vowelsIndex += 1\n                } else if (consonants[consonantsIndex] == word[i]) {\n                    consonantsIndex += 1\n                } else {\n                    result = \"\"\n                    break\n                }\n            } else {\n                result = \"\"\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293003,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdmahyszs.scala:26:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mif\u001b[0m (vowels[\u001b[35mvowelsIndex\u001b[0m] == word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type vowelsIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdmahyszs.scala:28:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (consonants[consonantsIndex] == word[i]) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: type consonantsIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdmahyszs.scala:32:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdmahyszs.scala:36:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            var c = word.charAt(i)\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (c == vowels[vowelsIndex]) {\n                    vowelsIndex += 1\n                } else if (c == consonants[consonantsIndex]) {\n                    consonantsIndex += 1\n                } else {\n                    result = c\n                    break\n                }\n            } else {\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293063,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp0xakxhla.scala:24:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0xakxhla.scala:24:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp0xakxhla.scala:24:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0xakxhla.scala:24:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (consonants[index] == word.charAt(i)) {\n                index++\n            } else if (vowels[index] == word.charAt(i)) {\n                index = 0\n            } else {\n                result = word.charAt(i)\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293017,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmppesuhfw6.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmppesuhfw6.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmppesuhfw6.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppesuhfw6.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var result = \"\"\n        var index = 0\n        var wordLength = word.length()\n        for (var i = wordLength - 1; i >= 0; i--) {\n            if (vowels.contains(word.charAt(i))) {\n                result = word.charAt(i)\n                index = i\n                break\n            }\n        }\n        if (result == \"\") {\n            for (var i = index + 1; i < wordLength; i++) {\n                if (consonants.contains(word.charAt(i))) {\n                    result = word.charAt(i)\n                    break\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293064,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp67twxzod.scala:24:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = wordLength - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp67twxzod.scala:24:43 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = wordLength - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp67twxzod.scala:24:48 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = wordLength - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp67twxzod.scala:32:17 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = index + \u001b[31m1\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp67twxzod.scala:32:50 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = index + \u001b[31m1\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp67twxzod.scala:32:55 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i =",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var result = \"\"\n        for (var i = 0; i < word.length(); i++) {\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (vowels[vowelsIndex] == word.charAt(i)) {\n                    vowelsIndex += 1\n                } else if (consonants[consonantsIndex] == word.charAt(i)) {\n                    consonantsIndex += 1\n                } else {\n                    result = \"\"\n                    break\n                }\n            } else {\n                result = \"\"\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293064,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpmuhratx4.scala:24:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpmuhratx4.scala:24:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpmuhratx4.scala:24:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmuhratx4.scala:24:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < word.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (consonants[index] == word.charAt(i)) {\n                index += 1\n            } else if (vowels[index] == word.charAt(i)) {\n                index += 1\n                result = word.substring(i, word.length())\n                break\n            } else {\n                index = 0\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293064,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpftxesxyq.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpftxesxyq.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpftxesxyq.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpftxesxyq.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var i = 0\n        var j = word.length() - 1\n        var closest = \"\"\n        while (i < j) {\n            if (vowels[i] == word.charAt(i) && vowels[j] == word.charAt(j)) {\n                closest = word.substring(i, j + 1)\n                break\n            } else if (vowels[i] == word.charAt(i) && consonants[j] == word.charAt(j)) {\n                closest = word.substring(i, j + 1)\n                break\n            } else if (vowels[j] == word.charAt(j) && consonants[i] == word.charAt(i)) {\n                closest = word.substring(i, j + 1)\n                break\n            } else if (vowels[i] == word.charAt(i) && consonants[j] == word.charAt(j)) {\n                closest = word.substring(i, j + 1)\n                break\n            } else if (vowels[j] == word.charAt(j) && consonants[i] == word.charAt(i)) {\n                closest = word.substring(i, j + 1)\n                break\n            } else if (vowels[i] == word.charAt(i) && vowels[j] == word.charAt(j)) {\n                closest = word.substring(i, j + 1)\n                break\n            } else if (vowels[j] == word.charAt(j) && vowels[i] == word.charAt(i)) {\n                closest = word.substring(i, j + 1)\n                break\n            } else if (vowels[i] == word.charAt(i) && vowels[j] == word.charAt(j)) {\n                closest = word.substring(i, j + 1)\n                break\n            } else\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293065,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpx5q5fz24.scala:49:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m            } \u001b[33melse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpx5q5fz24.scala:68:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpx5q5fz24.scala:25:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (vowels[\u001b[35mi\u001b[0m] == word.charAt(i) && vowels[\u001b[35mj\u001b[0m] == word.charAt(j)) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpx5q5fz24.scala:27:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpx5q5fz24.scala:28:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (vowels[i] == word.charAt(i) && consonants[j] == word.charAt(j)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpx5q5fz24.scala:30:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpx5q5fz24.scala:31:30 --------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = List.of(\"a\", \"e\", \"i\", \"o\", \"u\")\n        var consonants = List.of(\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\")\n        var vowelsAndConsonants = vowels.zip(consonants).toMap(t -> t._1, t -> t._2)\n        var result = \"\"\n        for (i <- 1 until word.length) {\n            if (vowelsAndConsonants.contains(word.substring(i, i + 1))) {\n                result = word.substring(i, i + 1)\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293065,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfuj3i73f.scala:19:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mvowels\u001b[0m = List.of(\u001b[31m\"a\"\u001b[0m, \u001b[31m\"e\"\u001b[0m, \u001b[31m\"i\"\u001b[0m, \u001b[31m\"o\"\u001b[0m, \u001b[31m\"u\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value of is not a member of object scala.collection.immutable.List\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfuj3i73f.scala:20:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mconsonants\u001b[0m = List.of(\u001b[31m\"b\"\u001b[0m, \u001b[31m\"c\"\u001b[0m, \u001b[31m\"d\"\u001b[0m, \u001b[31m\"f\"\u001b[0m, \u001b[31m\"g\"\u001b[0m, \u001b[31m\"h\"\u001b[0m, \u001b[31m\"j\"\u001b[0m, \u001b[31m\"k\"\u001b[0m, \u001b[31m\"l\"\u001b[0m, \u001b[31m\"m\"\u001b[0m, \u001b[31m\"n\"\u001b[0m, \u001b[31m\"p\"\u001b[0m, \u001b[31m\"q\"\u001b[0m, \u001b[31m\"r\"\u001b[0m, \u001b[31m\"s\"\u001b[0m, \u001b[31m\"t\"\u001b[0m, \u001b[31m\"v\"\u001b[0m, \u001b[31m\"w\"\u001b[0m, \u001b[31m\"x\"\u001b[0m, \u001b[31m\"y\"\u001b[0m, \u001b[31m\"z\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value of is not a member of object scala.collection.immutable.List\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfuj3i73f.scala:26:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var i = 0\n        var j = 0\n        var result = \"\"\n        while (i < word.length) {\n            if (vowels.indexOf(word[i]) != -1) {\n                result = word[i]\n                break\n            }\n            if (consonants.indexOf(word[i]) != -1) {\n                j = i + 1\n                while (j < word.length) {\n                    if (vowels.indexOf(word[j]) != -1) {\n                        result = word[j]\n                        break\n                    }\n                    if (consonants.indexOf(word[j]) != -1) {\n                        break\n                    }\n                    j = j + 1\n                }\n                if (result != \"\") {\n                    break\n                }\n            }\n            i = i + 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293062,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl6vdc5di.scala:25:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (vowels.indexOf(word[\u001b[35mi\u001b[0m]) != -\u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl6vdc5di.scala:26:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl6vdc5di.scala:27:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl6vdc5di.scala:29:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mif\u001b[0m (consonants.indexOf(word[\u001b[35mi\u001b[0m]) != -\u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl6vdc5di.scala:32:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    \u001b[33mif\u001b[0m (vowels.indexOf(word[\u001b[35mj\u001b[0m]) != -\u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl6vdc5di.scala:33:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                      ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var closestVowel = \"\"\n        var wordLength = word.length()\n        for (var i = 0; i < wordLength; i++) {\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (vowels[vowelsIndex] == word.charAt(i)) {\n                    vowelsIndex += 1\n                } else if (consonants[consonantsIndex] == word.charAt(i)) {\n                    consonantsIndex += 1\n                } else {\n                    if (Math.abs(vowelsIndex - consonantsIndex) < Math.abs(vowelsIndex - closestVowel.length)) {\n                        closestVowel = \"\"\n                    }\n                    if (Math.abs(vowelsIndex - consonantsIndex) == Math.abs(vowelsIndex - closestVowel.length)) {\n                        if (vowelsIndex < consonantsIndex) {\n                            closestVowel = \"\"\n                        } else {\n                            closestVowel = \"\"\n                        }\n                    }\n                    if (Math.abs(vowelsIndex - consonantsIndex) > Math.abs(vowelsIndex - closestVowel.length)) {\n                        closestVowel = \"\"\n                    }\n                    if (Math.abs(vowelsIndex - consonantsIndex) == Math.abs(vowelsIndex - closestVowel.length)) {\n                        if (vowelsIndex < consonantsIndex) {\n                            closestVowel = \"\"\n                        } else {\n                            closestVowel = \"\"\n                        }\n                    }\n                    if (Math.abs(vowelsIndex - consonantsIndex) > Math.abs(vowelsIndex - closestVowel.length)) {\n                        closestVowel = \"\"\n                    }\n                    if (Math.abs(vowelsIndex - consonantsIndex) == Math.abs(vowelsIndex -\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293066,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp7qwmrk0w.scala:25:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7qwmrk0w.scala:25:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp7qwmrk0w.scala:25:43 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7qwmrk0w.scala:25:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.conve",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var i = 0\n        var j = 0\n        var result = \"\"\n        while (i < word.length()) {\n            if (j < word.length() && consonants[j] == word.charAt(i)) {\n                j += 1\n            } else if (j < word.length() && vowels[i] == word.charAt(i)) {\n                result = word.charAt(i)\n                i += 1\n                j = i\n            } else {\n                i += 1\n                j = i\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293065,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpeqcelnk5.scala:25:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (j < word.length() && consonants[\u001b[35mj\u001b[0m] == word.charAt(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpeqcelnk5.scala:27:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (j < word.length() && vowels[i] == word.charAt(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpeqcelnk5.scala:28:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                result = word.charAt(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    Char\n\u001b[31m   |\u001b[0m                         Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var result = \"\"\n        var wordLength = word.length()\n        for (i = wordLength - 1; i >= 0; i--) {\n            if (consonants[i] == word[i]) {\n                for (j = i + 1; j < wordLength; j++) {\n                    if (consonants[j] == word[j]) {\n                        for (k = j + 1; k < wordLength; k++) {\n                            if (consonants[k] == word[k]) {\n                                for (l = k + 1; l < wordLength; l++) {\n                                    if (consonants[l] == word[l]) {\n                                        for (m = l + 1; m < wordLength; m++) {\n                                            if (consonants[m] == word[m]) {\n                                                for (n = m + 1; n < wordLength; n++) {\n                                                    if (consonants[n] == word[n]) {\n                                                        for (p = n + 1; p < wordLength; p++) {\n                                                            if (consonants[p] == word[p]) {\n                                                                for (q = p + 1; q < wordLength; q++) {\n                                                                    if (consonants[q] == word[q]) {\n                                                                        for (r = q + 1; r < wordLength; r++) {\n                                                                            if (consonants[r] == word[r]) {\n                                                                                \n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293066,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzy95yvqu.scala:40:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = wordLength - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzy95yvqu.scala:40:39 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = wordLength - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpzy95yvqu.scala:40:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = wordLength - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzy95yvqu.scala:40:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (i = wordLength - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue foreach is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator asScala\n\u001b[31m   |\u001b[0m  import",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var result = \"\"\n        for (i <- 0 until word.length) {\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (word.charAt(i) == vowels[vowelsIndex]) {\n                    vowelsIndex += 1\n                } else if (word.charAt(i) == consonants[consonantsIndex]) {\n                    consonantsIndex += 1\n                } else {\n                    result = \"\"\n                    break\n                }\n            } else {\n                result = \"\"\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293048,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgk82g_wo.scala:26:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mif\u001b[0m (word.charAt(i) == vowels[\u001b[35mvowelsIndex\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                             Not found: type vowelsIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgk82g_wo.scala:28:56 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (word.charAt(i) == consonants[consonantsIndex]) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                        ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type consonantsIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgk82g_wo.scala:32:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgk82g_wo.scala:36:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var index = 0\n        var result = \"\"\n        for (var i = word.length() - 1; i >= 0; i--) {\n            if (consonants[index] == word.charAt(i)) {\n                index += 1\n            } else if (vowels[index] == word.charAt(i)) {\n                index += 1\n                result = word.substring(i, word.length())\n                break\n            } else {\n                index = 0\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293064,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpftxesxyq.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpftxesxyq.scala:23:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpftxesxyq.scala:23:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpftxesxyq.scala:23:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = word.length() - \u001b[31m1\u001b[0m; i >= \u001b[31m0\u001b[0m; i--) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toSet\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toSet\n        var vowelsAndConsonants = vowels.union(consonants)\n        var vowelsAndConsonantsAndVowels = vowelsAndConsonants.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowels = vowelsAndConsonantsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels = vowelsAndConsonantsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowelsAndVowels.union(vowels)\n        var vowelsAndConsonantsAndVowelsAndVowels\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664292981,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfk6p0buq.scala:31:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfk6p0buq.scala:31:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiouAEIOU\"\n        var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n        var vowels_count = 0\n        var consonants_count = 0\n        var result = \"\"\n        var i = 0\n        while (i < word.length) {\n            if (vowels.indexOf(word[i]) != -1) {\n                vowels_count += 1\n            } else if (consonants.indexOf(word[i]) != -1) {\n                consonants_count += 1\n            }\n            if (vowels_count == 2 && consonants_count == 1) {\n                result = word[i]\n                break\n            }\n            i += 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293064,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn8tte9z3.scala:26:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (vowels.indexOf(word[\u001b[35mi\u001b[0m]) != -\u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn8tte9z3.scala:28:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (consonants.indexOf(word[i]) != -\u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn8tte9z3.scala:32:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn8tte9z3.scala:33:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var vowelsIndex = 0\n        var consonantsIndex = 0\n        var closestVowelIndex = -1\n        var closestVowel = \"\"\n        var wordLength = word.length()\n        for (var i = 0; i < wordLength; i++) {\n            if (vowelsIndex < vowels.length && consonantsIndex < consonants.length) {\n                if (vowels[vowelsIndex] == word.charAt(i)) {\n                    vowelsIndex += 1\n                } else if (consonants[consonantsIndex] == word.charAt(i)) {\n                    consonantsIndex += 1\n                }\n            }\n            if (vowelsIndex == vowels.length && consonantsIndex == consonants.length) {\n                closestVowel = word.charAt(i)\n                closestVowelIndex = i\n                break\n            }\n        }\n        return closestVowel\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293066,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpmpm3_1ym.scala:26:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpmpm3_1ym.scala:26:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpmpm3_1ym.scala:26:43 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmpm3_1ym.scala:26:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < wordLength; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.conve",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var i = 0\n        var j = 0\n        var result = \"\"\n        while (i < word.length) {\n            if (j < word.length) {\n                if (consonants[j] == word[i]) {\n                    j += 1\n                } else if (vowels[i] == word[i]) {\n                    result = word[i]\n                    i += 1\n                    j = 0\n                } else {\n                    i += 1\n                }\n            } else {\n                i += 1\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293065,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprkfkpjr8.scala:26:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mif\u001b[0m (consonants[\u001b[35mj\u001b[0m] == word[\u001b[35mi\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprkfkpjr8.scala:28:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (vowels[i] == word[i]) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprkfkpjr8.scala:29:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                    result = word[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray\n        var vowelsAndConsonants = vowels + consonants\n        var vowelsAndConsonantsLength = vowelsAndConsonants.length\n        var wordLength = word.length\n        var wordIndex = 0\n        var wordIndexEnd = wordLength - 1\n        var wordIndexStart = wordIndexEnd\n        var wordIndexStartEnd = wordIndexEnd - 1\n        var wordIndexStartStart = wordIndexEnd - 2\n        var wordIndexStartStartEnd = wordIndexEnd - 3\n        var wordIndexStartStartEndEnd = wordIndexEnd - 4\n        var wordIndexStartStartEndEnd = wordIndexEnd - 5\n        var wordIndexStartStartEndEndEnd = wordIndexEnd - 6\n        var wordIndexStartStartEndEndEnd = wordIndexEnd - 7\n        var wordIndexStartStartEndEndEndEnd = wordIndexEnd - 8\n        var wordIndexStartStartEndEndEndEnd = wordIndexEnd - 9\n        var wordIndexStartStartEndEndEndEndEnd = wordIndexEnd - 10\n        var wordIndexStartStartEndEndEndEndEnd = wordIndexEnd - 11\n        var wordIndexStartStartEndEndEndEndEndEnd = wordIndexEnd - 12\n        var wordIndexStartStartEndEndEndEndEndEnd = wordIndexEnd - 13\n        var wordIndexStartStartEndEndEndEndEndEnd = wordIndexEnd - 14\n        var wordIndexStartStartEndEndEndEndEndEnd = wordIndexEnd - 15\n        var wordIndexStartStartEndEndEndEndEndEnd = wordIndexEnd - 16\n        var wordIndexStartStartEndEndEndEndEndEnd = wordIndexEnd - 17\n        var wordIndexStartStartEndEndEndEndEndEnd = wordIndexEnd - 18\n        var wordIndexStartStartEndEndEndEndEndEnd = wordIndexEnd - 19\n        var wordIndexStartStartEndEndEndEndEndEnd = wordIndexEnd - 20\n        var wordIndexStartStartEndEndEndEndEndEnd = wordIndexEnd - 21\n        var wordIndexStartStartEndEndEndEndEndEnd = wordIndexEnd - 22\n        var wordIndexStartStartEndEndEndEndEndEnd = wordIndexEnd - 23\n        var\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293067,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp3khm14q8.scala:50:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m        \u001b[33mvar\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3khm14q8.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mwordIndexStartStartEndEnd\u001b[0m = wordIndexEnd - \u001b[31m5\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mwordIndexStartStartEndEnd is already defined as \u001b[33mvariable\u001b[0m \u001b[35mwordIndexStartStartEndEnd\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3khm14q8.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mwordIndexStartStartEndEndEnd\u001b[0m = wordIndexEnd - \u001b[31m7\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mwordIndexStartStartEndEndEnd is already defined as \u001b[33mvariable\u001b[0m \u001b[35mwordIndexStartStartEndEndEnd\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3khm14q8.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mwordIndexStartStartEndEndEndEnd\u001b[0m = wordIndexEnd - \u001b[31m9\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mwordIndexStartStartEndEndEndEnd is already defined as \u001b[33mvariable\u001b[0m \u001b[35mwordIndexStartStartEndEndEndEnd\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3khm14q8.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mwordIndexStartStartEndEndEndEndEnd\u001b[0m = wordIndexEnd - ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a word. Your task is to find the closest vowel that stands between \n    // two consonants from the right side of the word (case sensitive).\n    // Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    // find any vowel met the above condition. \n    // You may assume that the given string contains English letter only.\n    // Example:\n    // >>> getClosestVowel((\"yogurt\"))\n    // (\"u\")\n    // >>> getClosestVowel((\"FULL\"))\n    // (\"U\")\n    // >>> getClosestVowel((\"quick\"))\n    // (\"\")\n    // >>> getClosestVowel((\"ab\"))\n    // (\"\")\n    def getClosestVowel(word : String) : String = {\n        var vowels = \"aeiou\".toCharArray()\n        var consonants = \"bcdfghjklmnpqrstvwxyz\".toCharArray()\n        var i = 0\n        var j = 0\n        var closest = \"\"\n        while (i < word.length && j < word.length) {\n            if (vowels[i] == word[j]) {\n                i += 1\n                j += 1\n                closest = word[j]\n            } else if (consonants[j] == word[j]) {\n                j += 1\n            } else {\n                i += 1\n            }\n        }\n        return closest\n    }\n    def main(args: Array[String]) = {\n    assert(getClosestVowel((\"yogurt\")).equals((\"u\")));\n    assert(getClosestVowel((\"full\")).equals((\"u\")));\n    assert(getClosestVowel((\"easy\")).equals((\"\")));\n    assert(getClosestVowel((\"eAsy\")).equals((\"\")));\n    assert(getClosestVowel((\"ali\")).equals((\"\")));\n    assert(getClosestVowel((\"bad\")).equals((\"a\")));\n    assert(getClosestVowel((\"most\")).equals((\"o\")));\n    assert(getClosestVowel((\"ab\")).equals((\"\")));\n    assert(getClosestVowel((\"ba\")).equals((\"\")));\n    assert(getClosestVowel((\"quick\")).equals((\"\")));\n    assert(getClosestVowel((\"anime\")).equals((\"i\")));\n    assert(getClosestVowel((\"Asia\")).equals((\"\")));\n    assert(getClosestVowel((\"Above\")).equals((\"o\")));\n    }\n\n}\n",
      "timestamp": 1664293066,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp60y3thc4.scala:25:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (vowels[\u001b[35mi\u001b[0m] == word[\u001b[35mj\u001b[0m]) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp60y3thc4.scala:28:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                closest = word[\u001b[35mj\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp60y3thc4.scala:29:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (consonants[j] == word[j]) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}