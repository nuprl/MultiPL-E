{
  "name": "HumanEval_99_closest_integer",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "results": [
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            return numAsInt\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return numAsFloat\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return numAsDouble\n        }\n        val numAsBigInt = num.toBigInt\n        if (numAsBigInt.isNaN) {\n            return numAsBigInt\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return numAsBigDecimal\n        }\n        val numAsBigDecimalToBigInt = numAsBigDecimal.toBigInt\n        if (numAsBigDecimalToBigInt.isNaN) {\n            return numAsBigDecimalToBigInt\n        }\n        val numAsBigDecimalToBigDecimal = numAsBigDecimal.toBigDecimal\n        if (numAsBigDecimalToBigDecimal.isNaN) {\n            return numAsBigDecimalToBigDecimal\n        }\n        val numAsBigDecimalToInt = numAsBigDecimal.toInt\n        if (numAsBigDecimalToInt.isNaN) {\n            return numAsBigDecimalToInt\n        }\n        val numAsBigDecimalToFloat = numAsBigDecimal.toFloat\n        if (numAsBigDecimalToFloat.isNaN) {\n            return numAsBigDecimalToFloat\n        }\n        val numAsBigDecimalToDouble = numAsBigDecimal.toDouble\n        if (numAsBigDecimalToDouble.isNaN) {\n            return numAsBigDecimalToDouble\n        }\n        val numAsBigDecimalToLong = numAsBigDecimal.toLong\n        if (numAsBigDecimalToLong.isNaN) {\n            return numAsBigDecimalToLong\n        }\n        \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9hgkwypq.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9hgkwypq.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsInt)\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9hgkwypq.scala:28:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsFloat\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsFloat : Float)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9hgkwypq.scala:32:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsDouble\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsDouble : Double)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9hgkwypq.scala:34:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecima",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val abs = num.abs\n        if (abs.isNaN) {\n            return 0l\n        }\n        val absInt = abs.toInt\n        if (absInt.isNaN) {\n            return 0l\n        }\n        val absIntPlusOne = absInt + 1\n        if (absIntPlusOne.isNaN) {\n            return 0l\n        }\n        val absIntMinusOne = absInt - 1\n        if (absIntMinusOne.isNaN) {\n            return 0l\n        }\n        val absIntPlusOneHalf = absIntPlusOne / 2\n        if (absIntPlusOneHalf.isNaN) {\n            return 0l\n        }\n        val absIntMinusOneHalf = absIntMinusOne / 2\n        if (absIntMinusOneHalf.isNaN) {\n            return 0l\n        }\n        val absIntPlusOneHalfInt = absIntPlusOneHalf.toInt\n        if (absIntPlusOneHalfInt.isNaN) {\n            return 0l\n        }\n        val absIntMinusOneHalfInt = absIntMinusOneHalf.toInt\n        if (absIntMinusOneHalfInt.isNaN) {\n            return 0l\n        }\n        val absIntPlusOneHalfIntPlusOne = absIntPlusOneHalfInt + 1\n        if (absIntPlusOneHalfIntPlusOne.isNaN) {\n            return 0l\n        }\n        val absIntMinusOneHalfIntMinusOne = absIntMinusOneHalfInt - 1\n        if (absIntMinusOneHalfIntMinusOne.isNaN) {\n            return 0l\n        }\n        val absIntPlusOneHalfIntPlusOneHalf = absIntPlusOneHalfInt + 1 / 2\n        if (absIntPlusOneHalfIntPlusOneHalf.isNaN) {\n            return 0l\n        }\n        val absIntMinusOneHalfIntMinusOneHalf = absIntMinusOneHalfInt - 1 / 2\n        if (absIntMinusOneHalfIntMinusOneHalf.isNaN\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293170,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzk3wz97g.scala:68:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzk3wz97g.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzk3wz97g.scala:23:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (abs.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(abs)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzk3wz97g.scala:27:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mif\u001b[0m (absInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(absInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzk3wz97g.scala:31:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mif\u001b[0m (absIntPlusOne.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(absIntPlusOne)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzk3wz97g.scala:35:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mif\u001b[0m (absIntMinusOne.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            return -num\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpp5jr_wxg.scala:18)\n\tat Problem$.main(tmpp5jr_wxg.scala:27)\n\tat Problem.main(tmpp5jr_wxg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val div = abs / 2\n            val rem = abs % 2\n            val res = div + rem\n            if (num < 0) res = -res\n            return res\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293169,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpfriy5rv8.scala:24:29 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m (num < \u001b[31m0\u001b[0m) res = -res\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Reassignment to val res\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val abs_int = abs.toInt\n            val abs_long = abs.toLong\n            val abs_float = abs.toFloat\n            val abs_double = abs.toDouble\n            val abs_big_int = abs.toBigInt\n            val abs_big_decimal = abs.toBigDecimal\n            val abs_big_float = abs.toBigFloat\n            val abs_big_double = abs.toBigDouble\n            val abs_big_big_int = abs.toBigBigInt\n            val abs_big_big_decimal = abs.toBigBigDecimal\n            val abs_big_big_float = abs.toBigBigFloat\n            val abs_big_big_double = abs.toBigBigDouble\n            val abs_big_big_big_int = abs.toBigBigBigInt\n            val abs_big_big_big_decimal = abs.toBigBigBigDecimal\n            val abs_big_big_big_float = abs.toBigBigBigFloat\n            val abs_big_big_big_double = abs.toBigBigBigDouble\n            val abs_big_big_big_big_int = abs.toBigBigBigBigInt\n            val abs_big_big_big_big_decimal = abs.toBigBigBigBigDecimal\n            val abs_big_big_big_big_float = abs.toBigBigBigBigFloat\n            val abs_big_big_big_big_double = abs.toBigBigBigBigDouble\n            val abs_big_big_big_big_big_int = abs.toBigBigBigBigBigInt\n            val abs_big_big_big_big_big_decimal = abs.toBigBigBigBigBigDecimal\n            val abs_big_big_big_big_big_float = abs.toBigBigBigBigBigFloat\n            val abs_big_big_big_big_big_double = abs.toBigBigBigBigBigDouble\n            val abs_big_big_big_big_big_big_int = abs.toBigBigBigBigBigBigInt\n\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293178,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpl6bc1nw3.scala:57:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl6bc1nw3.scala:25:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mabs_big_int\u001b[0m = abs.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl6bc1nw3.scala:26:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mabs_big_decimal\u001b[0m = abs.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl6bc1nw3.scala:27:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mabs_big_float\u001b[0m = abs.toBigFloat\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value toBigFloat is not a member of Long - did you mean abs.toFloat?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl6bc1nw3.scala:28:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mabs_big_double\u001b[0m = abs.toBigDouble\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m  value toBigDouble is not a member of Long - did you mean abs.toDouble?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl6bc1nw3.scala:29:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mabs_big_big_int\u001b[0m = abs.toBigBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               value toBigBigInt is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Foun",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            return -num\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpp5jr_wxg.scala:18)\n\tat Problem$.main(tmpp5jr_wxg.scala:27)\n\tat Problem.main(tmpp5jr_wxg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            return numAsInt\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return numAsFloat\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return numAsDouble\n        }\n        val numAsBigInt = num.toBigInt\n        if (numAsBigInt.isNaN) {\n            return numAsBigInt\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return numAsBigDecimal\n        }\n        val numAsBigDecimalWithScale = num.toBigDecimalWithScale\n        if (numAsBigDecimalWithScale.isNaN) {\n            return numAsBigDecimalWithScale\n        }\n        val numAsBigDecimalWithScaleAndPrecision = num.toBigDecimalWithScaleAndPrecision\n        if (numAsBigDecimalWithScaleAndPrecision.isNaN) {\n            return numAsBigDecimalWithScaleAndPrecision\n        }\n        val numAsBigDecimalWithPrecision = num.toBigDecimalWithPrecision\n        if (numAsBigDecimalWithPrecision.isNaN) {\n            return numAsBigDecimalWithPrecision\n        }\n        val numAsBigDecimalWithPrecisionAndScale = num.toBigDecimalWithPrecisionAndScale\n        if (numAsBigDecimalWithPrecisionAndScale.isNaN) {\n            return numAsBigDecimalWithPrecisionAndScale\n        }\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingMode = num.toBigDecimalWithPrecisionAndScaleAndRoundingMode\n        if (numAsBigDecimalWithPrecisionAndScaleAndRoundingMode.isNaN) {\n            return numAsBigDecimalWithPrecisionAndScaleAndRoundingMode\n        }\n        val numAsBigDec\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293177,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5at8uvxl.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5at8uvxl.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5at8uvxl.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(numAsInt)\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5at8uvxl.scala:28:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsFloat\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsFloat : Float)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5at8uvxl.scala:32:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsDouble\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsDouble : Double)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5at8uvxl.scala:34:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val max = (abs / 2) + 1\n            val min = max - 1\n            val res = max if (num > 0) else min\n            return res\n        } else {\n            val abs = Math.abs(num)\n            val max = (abs / 2)\n            val min = max - 1\n            val res = min if (num < 0) else max\n            return res\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293169,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp7p670uei.scala:23:26 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = max \u001b[33mif\u001b[0m (num > \u001b[31m0\u001b[0m) \u001b[33melse\u001b[0m min\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^\u001b[0m\n\u001b[31m   |\u001b[0m                          end of statement expected but 'if' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmp7p670uei.scala:29:26 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = min \u001b[33mif\u001b[0m (num < \u001b[31m0\u001b[0m) \u001b[33melse\u001b[0m max\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^\u001b[0m\n\u001b[31m   |\u001b[0m                          end of statement expected but 'if' found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            throw new NumberFormatException(\"Invalid input\")\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimalWithScale = num.withScale(0)\n        val numAsBigDecimalWithScaleAndPrecision = num.withScale(0).precision()\n        val numAsBigDecimalWithPrecision = num.precision()\n        val numAsBigDecimalWithPrecisionAndScale = num.precision().withScale(0)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingMode = num.precision().withScale(0).withRoundingMode(RoundingMode.HALF_UP)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingMode = num.precision().withScale(0).withRoundingMode(RoundingMode.HALF_UP)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingMode = num.precision().withScale(0).withRoundingMode(RoundingMode.HALF_UP)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingMode = num.precision().withScale(0).withRoundingMode(RoundingMode.HALF_UP)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingMode = num.precision().withScale(0).withRoundingMode(RoundingMode.HALF_UP)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingMode = num.precision().withScale(0).withRoundingMode(RoundingMode.HALF_UP)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingMode = num.precision().withScale(0).withRoundingMode(RoundingMode.HALF_UP)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingMode = num.precision().withScale(0).withRoundingMode(R\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293177,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpropitngq.scala:39:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpropitngq.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalWithPrecisionAndScaleAndRoundingMode\u001b[0m = num.precision().withScale(\u001b[31m0\u001b[0m).withRoundingMode(RoundingMode.HALF_UP)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimalWithPrecisionAndScaleAndRoundingMode is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimalWithPrecisionAndScaleAndRoundingMode\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpropitngq.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalWithPrecisionAndScaleAndRoundingMode\u001b[0m = num.precision().withScale(\u001b[31m0\u001b[0m).withRoundingMode(RoundingMode.HALF_UP)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimalWithPrecisionAndScaleAndRoundingMode is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimalWithPrecisionAndScaleAndRoundingMode\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpropitngq.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalWithPrecisionAndScaleAndRoundingMode\u001b[0m = num.precision().withScale(\u001b[31m0\u001b[0m).withRoundingMode(RoundingMode.HALF_UP)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            return num\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return num\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return num\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return num\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            return num\n        }\n        val numAsShort = num.toShort\n        if (numAsShort.isNaN) {\n            return num\n        }\n        val numAsByte = num.toByte\n        if (numAsByte.isNaN) {\n            return num\n        }\n        val numAsLong = num.toLong\n        if (numAsLong.isNaN) {\n            return num\n        }\n        val numAsInteger = num.toInt\n        if (numAsInteger.isNaN) {\n            return num\n        }\n        val numAsFloatAsDouble = num.toFloat\n        if (numAsFloatAsDouble.isNaN) {\n            return num\n        }\n        val numAsDoubleAsFloat = num.toDouble\n        if (numAsDoubleAsFloat.isNaN) {\n            return num\n        }\n        val numAsBigDecimalAsDouble = num.toBigDecimal\n        if (numAsBigDecimalAsDouble.isNaN) {\n            return num\n        }\n        val numAsBigIntegerAsDouble = num.toBigInteger\n        if (numAsBigIntegerAsDouble.isNaN) {\n            return num\n        }\n        val numAsShortAsDouble = num.toShort\n        if (numAsShortAsDouble.isNaN) {\n            return num\n        }\n        val numAsByteAsDouble = num.toByte\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293177,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi88t41ye.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi88t41ye.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi88t41ye.scala:34:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi88t41ye.scala:38:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInteger\u001b[0m = num.toBigInteger\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigInteger is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi88t41ye.scala:43:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mif\u001b[0m (numAsShort.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Short.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsShort)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi88t41ye.scala:47:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m        \u001b[33mif\u001b[0m (numAsByte.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return num\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            return num\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return num\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return num\n        }\n        val numAsBigInt = num.toBigInt\n        if (numAsBigInt.isNaN) {\n            return num\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return num\n        }\n        val numAsBigDecimalInt = numAsBigDecimal.toBigInteger\n        if (numAsBigDecimalInt.isNaN) {\n            return num\n        }\n        val numAsBigDecimalLong = numAsBigDecimal.toBigInteger\n        if (numAsBigDecimalLong.isNaN) {\n            return num\n        }\n        val numAsBigDecimalIntAsLong = numAsBigDecimalInt.toLong\n        if (numAsBigDecimalIntAsLong.isNaN) {\n            return num\n        }\n        val numAsBigDecimalLongAsLong = numAsBigDecimalLong.toLong\n        if (numAsBigDecimalLongAsLong.isNaN) {\n            return num\n        }\n        val numAsBigDecimalIntAsInt = numAsBigDecimalInt.toInt\n        if (numAsBigDecimalIntAsInt.isNaN) {\n            return num\n        }\n        val numAsBigDecimalLongAsInt = numAsBigDecimalLong.toInt\n        if (numAsBigDecimalLongAsInt.isNaN) {\n            return num\n        }\n        val numAsBigDecimalIntAsFloat = numAsBigDecimalInt.toFloat\n        if (numAsBigDecimalIntAsFloat.isNaN) {\n            return num\n        }\n        val numAsBigDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7qe3q2sc.scala:71:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7qe3q2sc.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7qe3q2sc.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(numAsInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7qe3q2sc.scala:34:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7qe3q2sc.scala:38:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7qe3q2sc.scala:71:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val abs = num.abs\n        if (abs.isNaN) {\n            return 0l\n        }\n        val absInt = abs.toInt\n        if (absInt.isNaN) {\n            return 0l\n        }\n        val absIntPlusOne = absInt + 1\n        if (absIntPlusOne.isNaN) {\n            return 0l\n        }\n        val absIntMinusOne = absInt - 1\n        if (absIntMinusOne.isNaN) {\n            return 0l\n        }\n        val absIntPlusOneHalf = absIntPlusOne / 2\n        if (absIntPlusOneHalf.isNaN) {\n            return 0l\n        }\n        val absIntMinusOneHalf = absIntMinusOne / 2\n        if (absIntMinusOneHalf.isNaN) {\n            return 0l\n        }\n        val absIntPlusOneHalfInt = absIntPlusOneHalf.toInt\n        if (absIntPlusOneHalfInt.isNaN) {\n            return 0l\n        }\n        val absIntMinusOneHalfInt = absIntMinusOneHalf.toInt\n        if (absIntMinusOneHalfInt.isNaN) {\n            return 0l\n        }\n        val absIntPlusOneHalfIntPlusOne = absIntPlusOneHalfInt + 1\n        if (absIntPlusOneHalfIntPlusOne.isNaN) {\n            return 0l\n        }\n        val absIntMinusOneHalfIntMinusOne = absIntMinusOneHalfInt - 1\n        if (absIntMinusOneHalfIntMinusOne.isNaN) {\n            return 0l\n        }\n        val absIntPlusOneHalfIntPlusOneHalf = absIntPlusOneHalfInt + 1 / 2\n        if (absIntPlusOneHalfIntPlusOneHalf.isNaN) {\n            return 0l\n        }\n        val absIntMinusOneHalfIntMinusOneHalf = absIntMinusOneHalfInt - 1 / 2\n        if (absIntMinusOneHalfIntMinusOneHalf.isNaN\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293170,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzk3wz97g.scala:68:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzk3wz97g.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzk3wz97g.scala:23:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (abs.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(abs)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzk3wz97g.scala:27:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mif\u001b[0m (absInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(absInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzk3wz97g.scala:31:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mif\u001b[0m (absIntPlusOne.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(absIntPlusOne)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzk3wz97g.scala:35:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mif\u001b[0m (absIntMinusOne.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            return -num\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpp5jr_wxg.scala:18)\n\tat Problem$.main(tmpp5jr_wxg.scala:27)\n\tat Problem.main(tmpp5jr_wxg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val abs = num.abs\n        if (abs.isNaN) {\n            return 0l\n        }\n        val abs_int = abs.toInt\n        if (abs_int.isNaN) {\n            return 0l\n        }\n        val abs_long = abs_int.toLong\n        if (abs_long.isNaN) {\n            return 0l\n        }\n        val abs_long_int = abs_long.toInt\n        if (abs_long_int.isNaN) {\n            return 0l\n        }\n        val abs_long_long = abs_long_int.toLong\n        if (abs_long_long.isNaN) {\n            return 0l\n        }\n        val abs_long_long_int = abs_long_long.toInt\n        if (abs_long_long_int.isNaN) {\n            return 0l\n        }\n        val abs_long_long_long = abs_long_long_int.toLong\n        if (abs_long_long_long.isNaN) {\n            return 0l\n        }\n        val abs_long_long_long_int = abs_long_long_long.toInt\n        if (abs_long_long_long_int.isNaN) {\n            return 0l\n        }\n        val abs_long_long_long_long = abs_long_long_long_int.toLong\n        if (abs_long_long_long_long.isNaN) {\n            return 0l\n        }\n        val abs_long_long_long_long_int = abs_long_long_long_long.toInt\n        if (abs_long_long_long_long_int.isNaN) {\n            return 0l\n        }\n        val abs_long_long_long_long_long = abs_long_long_long_long_int.toLong\n        if (abs_long_long_long_long_long.isNaN) {\n            return 0l\n        }\n        val abs_long_long\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp1r4fozgy.scala:67:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1r4fozgy.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1r4fozgy.scala:23:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (abs.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(abs)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1r4fozgy.scala:27:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mif\u001b[0m (abs_int.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(abs_int)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1r4fozgy.scala:31:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mif\u001b[0m (abs_long.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(abs_long)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1r4fozgy.scala:35:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mif\u001b[0m (abs_long_int.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) num = -num\n        val numAsInt = num.toInt\n        if (numAsInt == num) {\n            val numAsLong = num.toLong\n            if (numAsLong == num) {\n                val numAsDouble = num.toDouble\n                if (numAsDouble == num) {\n                    val numAsFloat = num.toFloat\n                    if (numAsFloat == num) {\n                        val numAsShort = num.toShort\n                        if (numAsShort == num) {\n                            val numAsByte = num.toByte\n                            if (numAsByte == num) {\n                                val numAsChar = num.toChar\n                                if (numAsChar == num) {\n                                    val numAsBoolean = num.toBoolean\n                                    if (numAsBoolean == num) {\n                                        val numAsBigInt = num.toBigInt\n                                        if (numAsBigInt == num) {\n                                            val numAsBigDecimal = num.toBigDecimal\n                                            if (numAsBigDecimal == num) {\n                                                val numAsBigFloat = num.toBigFloat\n                                                if (numAsBigFloat == num) {\n                                                    val numAsBigLong = num.toBigLong\n                                                    if (numAsBigLong == num) {\n                                                        val numAsBigInteger = num.toBigInteger\n                                                        if (numAsBigInteger == num) {\n                                                            val numAsBigDecimal = num.toBigDecimal\n                                                            if (numAsBigDecimal == num) {\n                                                                val numAsBigFloat = num.toBigFloat\n                                                                if (numAsBigFloat == num) {\n                                                                    val numAsBigLong = num.toBigLong\n                                                                    if (numAsBigLong == num) {\n                                                                        val numAsBigInteger = num.toBigInteger\n                                                                        if (numAsBigInteger == num) {\n                                                               \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpma0mv2si.scala:65:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m65 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpma0mv2si.scala:19:25 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num < \u001b[31m0\u001b[0m) num = -num\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Reassignment to val num\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpma0mv2si.scala:34:59 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                                    \u001b[33mval\u001b[0m \u001b[36mnumAsBoolean\u001b[0m = num.toBoolean\n\u001b[31m\u001b[31m   |\u001b[0m                                                       ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value toBoolean is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpma0mv2si.scala:36:62 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                                        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                                                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpma0mv2si.scala:38:70 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                                            \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpma0mv2si.scala:40:72 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                                                \u001b[33mval\u001b[0m \u001b[3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) num = -num\n        val abs = num.abs\n        val intPart = num.div(abs).floor\n        val fracPart = num.div(abs).remainder\n        val rounded = intPart + fracPart.div(abs).floor\n        if (abs.toInt > 0 && abs.toInt % 2 == 0) {\n            return rounded.toInt\n        } else {\n            return rounded.toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293174,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp8o7v4_fp.scala:19:25 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num < \u001b[31m0\u001b[0m) num = -num\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Reassignment to val num\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8o7v4_fp.scala:21:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mintPart\u001b[0m = num.div(abs).floor\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8o7v4_fp.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mfracPart\u001b[0m = num.div(abs).remainder\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value div is not a member of Long\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(abs.div(scala.math.BigInt(\"1\")))\n            val ceil = abs.ceilDiv(abs.div(scala.math.BigInt(\"1\")))\n            val diff = abs.sub(floor).div(ceil).toInt\n            if (diff == 0) {\n                return floor\n            } else if (diff > 0) {\n                return ceil\n            } else {\n                return floor\n            }\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293174,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnacf62s1.scala:21:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnacf62s1.scala:21:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnacf62s1.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceilDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnacf62s1.scala:22:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnacf62s1.scala:23:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdiff\u001b[0m = abs.sub(floor).div(ceil).toInt\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value sub is not a member of Long\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsShort = num.toShort\n        if (numAsShort.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsByte = num.toByte\n        if (numAsByte.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsChar = num.toChar\n        if (numAsChar.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBoolean = num.toBoolean\n        if (numAsBoolean.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            throw new NumberFormatException\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpknzjw6qa.scala:79:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpknzjw6qa.scala:58:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpknzjw6qa.scala:62:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpknzjw6qa.scala:66:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m66 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpknzjw6qa.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpknzjw6qa.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val nearest = abs.div(scala.math.BigInt(2)).toInt\n            val diff = abs.sub(scala.math.BigInt(nearest * 2)).toInt\n            if (diff == 0) {\n                return nearest\n            } else {\n                return nearest + 1\n            }\n        } else {\n            val abs = Math.abs(num)\n            val nearest = abs.div(scala.math.BigInt(2)).toInt\n            val diff = abs.sub(scala.math.BigInt(nearest * 2)).toInt\n            if (diff == 0) {\n                return nearest\n            } else {\n                return nearest - 1\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpk0oxonk2.scala:21:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnearest\u001b[0m = abs.div(scala.math.BigInt(\u001b[31m2\u001b[0m)).toInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpk0oxonk2.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdiff\u001b[0m = abs.sub(scala.math.BigInt(nearest * \u001b[31m2\u001b[0m)).toInt\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value sub is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpk0oxonk2.scala:30:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnearest\u001b[0m = abs.div(scala.math.BigInt(\u001b[31m2\u001b[0m)).toInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpk0oxonk2.scala:31:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdiff\u001b[0m = abs.sub(scala.math.BigInt(nearest * \u001b[31m2\u001b[0m)).toInt\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value sub is not a member of Long\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            return -num\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpp5jr_wxg.scala:18)\n\tat Problem$.main(tmpp5jr_wxg.scala:27)\n\tat Problem.main(tmpp5jr_wxg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            return 0l\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return 0l\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return 0l\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return 0l\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            return 0l\n        }\n        val numAsLong = num.toLong\n        if (numAsLong.isNaN) {\n            return 0l\n        }\n        val numAsIntAsLong = numAsInt.toLong\n        if (numAsIntAsLong.isNaN) {\n            return 0l\n        }\n        val numAsFloatAsLong = numAsFloat.toLong\n        if (numAsFloatAsLong.isNaN) {\n            return 0l\n        }\n        val numAsDoubleAsLong = numAsDouble.toLong\n        if (numAsDoubleAsLong.isNaN) {\n            return 0l\n        }\n        val numAsBigDecimalAsLong = numAsBigDecimal.toLong\n        if (numAsBigDecimalAsLong.isNaN) {\n            return 0l\n        }\n        val numAsBigIntegerAsLong = numAsBigInteger.toLong\n        if (numAsBigIntegerAsLong.isNaN) {\n            return 0l\n        }\n        val numAsLongAsLong = numAsLong.toLong\n        if (numAsLongAsLong.isNaN) {\n            return 0l\n        }\n        val numAsIntAsLongAsLong = numAsIntAsLong.toLong\n        if (numAsIntAsLongAsLong.isNaN) {\n            return 0l\n        }\n        val\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpwablapva.scala:74:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m        \u001b[33mval\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwablapva.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwablapva.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwablapva.scala:34:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwablapva.scala:38:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInteger\u001b[0m = num.toBigInteger\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigInteger is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwablapva.scala:43:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mif\u001b[0m (numAsLong.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (num.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsInt.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsFloat.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsDouble.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsBigDecimal.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsBigInteger.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsBigDecimalScala = num.toBigDecimalScala\n        if (numAsBigDecimalScala.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsBigDecimalScala.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsBigIntegerScala = num.toBigIntegerScala\n        if (numAsBigIntegerScala.isNaN) {\n            throw\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpj6795w91.scala:69:17 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m            \u001b[33mthrow\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                 expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpj6795w91.scala:80:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj6795w91.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj6795w91.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mif\u001b[0m (num.isInfinite) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isInfinite is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj6795w91.scala:26:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj6795w91.scala:29:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isInfinite) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isInfinite is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            return -num\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpp5jr_wxg.scala:18)\n\tat Problem$.main(tmpp5jr_wxg.scala:27)\n\tat Problem.main(tmpp5jr_wxg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            return -num\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpp5jr_wxg.scala:18)\n\tat Problem$.main(tmpp5jr_wxg.scala:27)\n\tat Problem.main(tmpp5jr_wxg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            if (abs % 2 == 0) {\n                return abs / 2\n            } else {\n                return abs / 2 + 1\n            }\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293173,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpdvoz7l7z.scala:18)\n\tat Problem$.main(tmpdvoz7l7z.scala:32)\n\tat Problem.main(tmpdvoz7l7z.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(abs.intPart)\n            val ceil = abs.div(abs.intPart).add(1)\n            if (num.compareTo(floor) < 0)\n                return floor\n            else\n                return ceil\n        } else {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(abs.intPart)\n            val ceil = abs.div(abs.intPart).add(1)\n            if (num.compareTo(ceil) > 0)\n                return ceil\n            else\n                return floor\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3zdvwc_v.scala:21:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(abs.intPart)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3zdvwc_v.scala:21:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(abs.intPart)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   value intPart is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3zdvwc_v.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.div(abs.intPart).add(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3zdvwc_v.scala:22:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.div(abs.intPart).add(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               value intPart is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3zdvwc_v.scala:29:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(abs.intPart)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3zdvwc_v.scala:29:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(abs.intPart)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   value intPart is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3zdvwc_v.scala:30:27 ------------------------\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) num = -num\n        val abs = Math.abs(num)\n        val intPart = abs % 1\n        val fracPart = abs - intPart\n        if (fracPart == 0) return num\n        val res = num / abs\n        if (res < 0) return -res\n        else return res\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293169,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpqhstfy1y.scala:19:25 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num < \u001b[31m0\u001b[0m) num = -num\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Reassignment to val num\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        val num_int = num.toInt\n        val num_long = num.toLong\n        val num_float = num.toFloat\n        val num_double = num.toDouble\n        val num_big_int = num.toBigInt\n        val num_big_decimal = num.toBigDecimal\n        val num_big_float = num.toBigFloat\n        val num_big_double = num.toBigDouble\n        val num_big_big_int = num.toBigInt\n        val num_big_big_decimal = num.toBigDecimal\n        val num_big_big_float = num.toBigFloat\n        val num_big_big_double = num.toBigDouble\n        val num_big_big_big_int = num.toBigInt\n        val num_big_big_big_decimal = num.toBigDecimal\n        val num_big_big_big_float = num.toBigFloat\n        val num_big_big_big_double = num.toBigDouble\n        val num_big_big_big_big_int = num.toBigInt\n        val num_big_big_big_big_decimal = num.toBigDecimal\n        val num_big_big_big_big_float = num.toBigFloat\n        val num_big_big_big_big_double = num.toBigDouble\n        val num_big_big_big_big_big_int = num.toBigInt\n        val num_big_big_big_big_big_decimal = num.toBigDecimal\n        val num_big_big_big_big_big_float = num.toBigFloat\n        val num_big_big_big_big_big_double = num.toBigDouble\n        val num_big_big_big_big_big_big_int = num.toBigInt\n        val num_big_big_big_big_big_big_decimal = num.toBigDecimal\n        val num_big_big_big_big_big_big_float = num.toBigFloat\n        val num_big_big_big_big_big_big\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293178,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp6tu4oa5w.scala:47:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6tu4oa5w.scala:23:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnum_big_int\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6tu4oa5w.scala:24:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnum_big_decimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6tu4oa5w.scala:25:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnum_big_float\u001b[0m = num.toBigFloat\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value toBigFloat is not a member of Long - did you mean num.toFloat?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6tu4oa5w.scala:26:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnum_big_double\u001b[0m = num.toBigDouble\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m  value toBigDouble is not a member of Long - did you mean num.toDouble?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6tu4oa5w.scala:27:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnum_big_big_int\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following i",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            if (abs < 10) {\n                return abs\n            } else {\n                return abs - 10\n            }\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpv4dlkald.scala:18)\n\tat Problem$.main(tmpv4dlkald.scala:32)\n\tat Problem.main(tmpv4dlkald.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val v = value.toLowerCase()\n        if (v.contains(\".\")) {\n            val n = v.replaceAll(\"[^0-9.]\", \"\")\n            val f = n.indexOf(\".\")\n            val s = n.substring(0, f)\n            val e = n.substring(f + 1)\n            val i = Long.parseLong(s)\n            val f = Long.parseLong(e)\n            val diff = Math.abs(i - f)\n            if (diff == 0) {\n                return i\n            } else if (diff > 0) {\n                return i\n            } else {\n                return i + 1\n            }\n        } else {\n            val i = Long.parseLong(v)\n            return i\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293182,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpam8my5f5.scala:25:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mf\u001b[0m = Long.parseLong(e)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mf is already defined as \u001b[33mvalue\u001b[0m \u001b[35mf\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpam8my5f5.scala:24:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mi\u001b[0m = Long.parseLong(s)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value parseLong is not a member of object Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpam8my5f5.scala:35:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mi\u001b[0m = Long.parseLong(v)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value parseLong is not a member of object Long\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            return numAsInt\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return numAsFloat\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return numAsDouble\n        }\n        val numAsBigInt = num.toBigInt\n        if (numAsBigInt.isNaN) {\n            return numAsBigInt\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return numAsBigDecimal\n        }\n        val numAsBigDecimalToInt = numAsBigDecimal.toBigInteger\n        if (numAsBigDecimalToInt.isNaN) {\n            return numAsBigDecimalToInt\n        }\n        val numAsBigDecimalToFloat = numAsBigDecimal.toBigDecimal\n        if (numAsBigDecimalToFloat.isNaN) {\n            return numAsBigDecimalToFloat\n        }\n        val numAsBigDecimalToDouble = numAsBigDecimal.toBigDecimal\n        if (numAsBigDecimalToDouble.isNaN) {\n            return numAsBigDecimalToDouble\n        }\n        val numAsBigDecimalToBigInt = numAsBigDecimal.toBigInteger\n        if (numAsBigDecimalToBigInt.isNaN) {\n            return numAsBigDecimalToBigInt\n        }\n        val numAsBigDecimalToBigDecimal = numAsBigDecimal.toBigDecimal\n        if (numAsBigDecimalToBigDecimal.isNaN) {\n            return numAsBigDecimalToBigDecimal\n        }\n        val numAsBigDecimalToBigDecimalToInt = numAsBigDecimal.toBigDecimalToBigInteger\n        if (numAsBigDecimalToBigDecimalToInt.isNa\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293185,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8ekm372i.scala:64:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8ekm372i.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8ekm372i.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsInt)\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8ekm372i.scala:28:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsFloat\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsFloat : Float)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8ekm372i.scala:32:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsDouble\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsDouble : Double)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8ekm372i.scala:34:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val max = abs.max\n            val min = abs.min\n            val diff = max - min\n            val diff2 = diff / 2\n            val diff3 = diff2 / 2\n            val diff4 = diff3 / 2\n            val diff5 = diff4 / 2\n            val diff6 = diff5 / 2\n            val diff7 = diff6 / 2\n            val diff8 = diff7 / 2\n            val diff9 = diff8 / 2\n            val diff10 = diff9 / 2\n            val diff11 = diff10 / 2\n            val diff12 = diff11 / 2\n            val diff13 = diff12 / 2\n            val diff14 = diff13 / 2\n            val diff15 = diff14 / 2\n            val diff16 = diff15 / 2\n            val diff17 = diff16 / 2\n            val diff18 = diff17 / 2\n            val diff19 = diff18 / 2\n            val diff20 = diff19 / 2\n            val diff21 = diff20 / 2\n            val diff22 = diff21 / 2\n            val diff23 = diff22 / 2\n            val diff24 = diff23 / 2\n            val diff25 = diff24 / 2\n            val diff26 = diff25 / 2\n            val diff27 = diff26 / 2\n            val diff28 = diff27 / 2\n            val diff29 = diff28 / 2\n            val diff30 = diff29 / 2\n            val diff31 = diff30 / 2\n            val diff32 = diff31 / 2\n            val diff33 = diff32 / 2\n            val diff34 = diff33 / 2\n            val diff35 = diff34 / 2\n            val diff36 = diff35 / 2\n            val diff37 = diff36 / 2\n            val diff38 = diff37 / 2\n            val diff39 = diff38 / 2\n            val diff40 = diff39 / 2\n            val diff41 = diff40 / 2\n            val diff42 = diff41 / 2\n            val diff43 = diff42 / 2\n            val diff44 = diff43 / 2\n            val diff45 = diff44 / 2\n            val diff46 = diff45 / 2\n            val diff47 = diff46 / 2\n\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293185,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpblz9zaio.scala:81:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpblz9zaio.scala:23:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdiff\u001b[0m = max - min\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue - is not a member of Long => Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpblz9zaio.scala:80:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpblz9zaio.scala:72:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m72 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimalWithScale = num.toBigDecimal(2)\n        val numAsBigDecimalWithScale2 = num.toBigDecimal(2, 2)\n        val numAsBigDecimalWithScale3 = num.toBigDecimal(2, 2, 2)\n        val numAsBigDecimalWithScale4 = num.toBigDecimal(2, 2, 2, 2)\n        val numAsBigDecimalWithScale5 = num.toBigDecimal(2, 2, 2, 2, 2)\n        val numAsBigDecimalWithScale6 = num.toBigDecimal(2, 2, 2, 2, 2, 2)\n        val numAsBigDecimalWithScale7 = num.toBigDecimal(2, 2, 2, 2, 2, 2, 2)\n        val numAsBigDecimalWithScale8 = num.toBigDecimal(2, 2, 2, 2, 2, 2, 2, 2)\n        val numAsBigDecimalWithScale9 = num.toBigDecimal(2, 2, 2, 2, 2, 2, 2, 2, 2)\n        val numAsBigDecimalWithScale10 = num.toBigDecimal(2, 2, 2, 2, 2, 2, 2, 2, 2, 2)\n        val numAsBigDecimalWithScale11 = num.toBigDecimal(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2)\n        val numAsBigDecimalWithScale12 = num.toBigDecimal(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2)\n        val numAsBigDecimalWithScale13 = num.toBigDecimal(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293188,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpffqb5fgy.scala:40:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpffqb5fgy.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpffqb5fgy.scala:25:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpffqb5fgy.scala:26:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpffqb5fgy.scala:27:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalWithScale\u001b[0m = num.toBigDecimal(\u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpffqb5fgy.scala:28:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalWithScale2\u001b[0m = num.toBigDecimal(\u001b[31m2\u001b[0m, \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^^^^^^^^\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val nearest = abs.div(scala.math.BigInt(2)).toInt\n            val result = nearest * 2 - abs\n            if (result == 0) result = nearest\n            return result\n        } else {\n            val abs = Math.abs(num)\n            val nearest = abs.div(scala.math.BigInt(2)).toInt\n            val result = nearest\n            if (result == 0) result = nearest\n            return result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293187,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpaedoek9o.scala:21:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnearest\u001b[0m = abs.div(scala.math.BigInt(\u001b[31m2\u001b[0m)).toInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value div is not a member of Long\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpaedoek9o.scala:23:36 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m (result == \u001b[31m0\u001b[0m) result = nearest\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpaedoek9o.scala:27:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnearest\u001b[0m = abs.div(scala.math.BigInt(\u001b[31m2\u001b[0m)).toInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value div is not a member of Long\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpaedoek9o.scala:29:36 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mif\u001b[0m (result == \u001b[31m0\u001b[0m) result = nearest\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val abs_int = abs.toInt\n            val abs_long = abs.toLong\n            val abs_float = abs.toFloat\n            val abs_double = abs.toDouble\n            val abs_big_int = abs.toBigInt\n            val abs_big_decimal = abs.toBigDecimal\n            val abs_big_float = abs.toBigFloat\n            val abs_big_double = abs.toBigDouble\n            val abs_big_big_int = abs.toBigBigInt\n            val abs_big_big_decimal = abs.toBigBigDecimal\n            val abs_big_big_float = abs.toBigBigFloat\n            val abs_big_big_double = abs.toBigBigDouble\n            val abs_big_big_big_int = abs.toBigBigBigInt\n            val abs_big_big_big_decimal = abs.toBigBigBigDecimal\n            val abs_big_big_big_float = abs.toBigBigBigFloat\n            val abs_big_big_big_double = abs.toBigBigBigDouble\n            val abs_big_big_big_big_int = abs.toBigBigBigBigInt\n            val abs_big_big_big_big_decimal = abs.toBigBigBigBigDecimal\n            val abs_big_big_big_big_float = abs.toBigBigBigBigFloat\n            val abs_big_big_big_big_double = abs.toBigBigBigBigDouble\n            val abs_big_big_big_big_big_int = abs.toBigBigBigBigBigInt\n            val abs_big_big_big_big_big_decimal = abs.toBigBigBigBigBigDecimal\n            val abs_big_big_big_big_big_float = abs.toBigBigBigBigBigFloat\n            val abs_big_big_big_big_big_double = abs.toBigBigBigBigBigDouble\n            val abs_big_big_big_big_big_big_int = abs.toBigBigBigBigBigBigInt\n\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293178,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpl6bc1nw3.scala:57:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl6bc1nw3.scala:25:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mabs_big_int\u001b[0m = abs.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl6bc1nw3.scala:26:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mabs_big_decimal\u001b[0m = abs.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl6bc1nw3.scala:27:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mabs_big_float\u001b[0m = abs.toBigFloat\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value toBigFloat is not a member of Long - did you mean abs.toFloat?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl6bc1nw3.scala:28:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mabs_big_double\u001b[0m = abs.toBigDouble\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m  value toBigDouble is not a member of Long - did you mean abs.toDouble?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl6bc1nw3.scala:29:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mabs_big_big_int\u001b[0m = abs.toBigBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               value toBigBigInt is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Foun",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val abs = num.abs\n        val intPart = abs.floor\n        val fracPart = abs.subtract(intPart).toDouble\n        if (fracPart.abs.isNaN) {\n            return intPart\n        }\n        val frac = fracPart.abs\n        if (frac.isNaN) {\n            return intPart\n        }\n        val res = intPart.add(frac.div(scala.math.BigInt.ONE).toLong)\n        if (num.signum() < 0) {\n            return -res\n        } else {\n            return res\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293189,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8bfoqr60.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8bfoqr60.scala:23:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mintPart\u001b[0m = abs.floor\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value floor is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          floatWrapper(abs)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8bfoqr60.scala:24:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mfracPart\u001b[0m = abs.subtract(intPart).toDouble\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp8bfoqr60.scala:33:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mif\u001b[0m (num.signum() < \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        \u001b[33mmethod\u001b[0m \u001b[35msignum\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mScalaNumberProxy\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val abs = num.abs\n        val abs_floor = abs.floor\n        val abs_ceil = abs.ceiling\n        val abs_half = abs.half\n        val abs_half_floor = abs_half.floor\n        val abs_half_ceil = abs_half.ceiling\n        val abs_half_half = abs_half.half\n        val abs_half_half_floor = abs_half_half.floor\n        val abs_half_half_ceil = abs_half_half.ceiling\n        val abs_half_half_half = abs_half_half.half\n        val abs_half_half_half_floor = abs_half_half_half.floor\n        val abs_half_half_half_ceil = abs_half_half_half.ceiling\n        val abs_half_half_half_half = abs_half_half_half_half.half\n        val abs_half_half_half_half_floor = abs_half_half_half_half_half.floor\n        val abs_half_half_half_half_ceil = abs_half_half_half_half_half.ceiling\n        val abs_half_half_half_half_half = abs_half_half_half_half_half_half.half\n        val abs_half_half_half_half_half_floor = abs_half_half_half_half_half_half.floor\n        val abs_half_half_half_half_half_ceil = abs_half_half_half_half_half_half.ceiling\n        val abs_half_half_half_half_half_half = abs_half_half_half_half_half_half_half.half\n        val abs_half_half_half_half_half_half_floor = abs_half_half_half_half_half_half_half.floor\n        val abs_half_half_half_half_half_half_ceil = abs_half_half_half_half_half_half_half.ceiling\n        val abs_half_half_half_half_\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293188,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpeuw6p7fm.scala:44:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpeuw6p7fm.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpeuw6p7fm.scala:23:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mabs_floor\u001b[0m = abs.floor\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value floor is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          floatWrapper(abs)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpeuw6p7fm.scala:24:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mabs_ceil\u001b[0m = abs.ceiling\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceiling is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpeuw6p7fm.scala:25:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mabs_half\u001b[0m = abs.half\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value half is not a member of Long\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpeuw6p7fm.scala:34:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mabs_half_half_half_half\u001b[0m = abs_half_half_half_half.half\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Recursive \u001b[33mvalue\u001b[0m \u001b[35mabs_half_half_half_half\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val abs = num.abs\n        val abs_floor = abs.floor\n        val abs_ceil = abs.ceil\n        val abs_half = abs.half\n        val abs_half_floor = abs_half.floor\n        val abs_half_ceil = abs_half.ceil\n        val abs_half_half = abs_half.half\n        val abs_half_half_floor = abs_half_half.floor\n        val abs_half_half_ceil = abs_half_half.ceil\n        val abs_half_half_half = abs_half_half.half\n        val abs_half_half_half_floor = abs_half_half_half.floor\n        val abs_half_half_half_ceil = abs_half_half_half.ceil\n        val abs_half_half_half_half = abs_half_half_half_half.half\n        val abs_half_half_half_half_floor = abs_half_half_half_half_half.floor\n        val abs_half_half_half_half_ceil = abs_half_half_half_half_half.ceil\n        val abs_half_half_half_half_half = abs_half_half_half_half_half_half.half\n        val abs_half_half_half_half_half_floor = abs_half_half_half_half_half_half.floor\n        val abs_half_half_half_half_half_ceil = abs_half_half_half_half_half_half.ceil\n        val abs_half_half_half_half_half_half = abs_half_half_half_half_half_half_half.half\n        val abs_half_half_half_half_half_half_floor = abs_half_half_half_half_half_half_half.floor\n        val abs_half_half_half_half_half_half_ceil = abs_half_half_half_half_half_half_half.ceil\n        val abs_half_half_half_half_\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293189,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpy5csnhlv.scala:44:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy5csnhlv.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy5csnhlv.scala:23:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mabs_floor\u001b[0m = abs.floor\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value floor is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          doubleWrapper(abs)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy5csnhlv.scala:24:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mabs_ceil\u001b[0m = abs.ceil\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value ceil is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          doubleWrapper(abs)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy5csnhlv.scala:25:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mabs_half\u001b[0m = abs.half\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value half is not a member of Long\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpy5csnhlv.scala:34:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mabs_half_half_half_half\u001b[0m = abs_half_half_half_half.half\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Recursive \u001b[33mvalue\u001b[0m \u001b[35mabs_half_half_half_half\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val nearest = abs.div(scala.math.BigInt(10)).toInt\n            val diff = abs.sub(scala.math.BigInt(nearest * 10)).div(scala.math.BigInt(10))\n            if (diff.toInt > 0) {\n                return nearest + 1\n            } else {\n                return nearest\n            }\n        } else {\n            val abs = Math.abs(num)\n            val nearest = abs.div(scala.math.BigInt(10)).toInt\n            val diff = abs.sub(scala.math.BigInt(nearest * 10)).div(scala.math.BigInt(10))\n            if (diff.toInt > 0) {\n                return nearest\n            } else {\n                return nearest - 1\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293189,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy9pfmr2u.scala:21:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnearest\u001b[0m = abs.div(scala.math.BigInt(\u001b[31m10\u001b[0m)).toInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy9pfmr2u.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdiff\u001b[0m = abs.sub(scala.math.BigInt(nearest * \u001b[31m10\u001b[0m)).div(scala.math.BigInt(\u001b[31m10\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value sub is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy9pfmr2u.scala:30:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnearest\u001b[0m = abs.div(scala.math.BigInt(\u001b[31m10\u001b[0m)).toInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy9pfmr2u.scala:31:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdiff\u001b[0m = abs.sub(scala.math.BigInt(nearest * \u001b[31m10\u001b[0m)).div(scala.math.BigInt(\u001b[31m10\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value sub is not a member of Long\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            if (abs % 2 == 0) {\n                return abs / 2\n            } else {\n                return abs / 2 + 1\n            }\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293173,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpdvoz7l7z.scala:18)\n\tat Problem$.main(tmpdvoz7l7z.scala:32)\n\tat Problem.main(tmpdvoz7l7z.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293183,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpojhx9q1v.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            return numAsInt\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return numAsFloat\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return numAsDouble\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return numAsBigDecimal\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            return numAsBigInteger\n        }\n        val numAsShort = num.toShort\n        if (numAsShort.isNaN) {\n            return numAsShort\n        }\n        val numAsByte = num.toByte\n        if (numAsByte.isNaN) {\n            return numAsByte\n        }\n        val numAsChar = num.toChar\n        if (numAsChar.isNaN) {\n            return numAsChar\n        }\n        val numAsFloatChar = num.toFloatChar\n        if (numAsFloatChar.isNaN) {\n            return numAsFloatChar\n        }\n        val numAsDoubleChar = num.toDoubleChar\n        if (numAsDoubleChar.isNaN) {\n            return numAsDoubleChar\n        }\n        val numAsBigDecimalChar = num.toBigDecimalChar\n        if (numAsBigDecimalChar.isNaN) {\n            return numAsBigDecimalChar\n        }\n        val numAsBigIntegerChar = num.toBigIntegerChar\n        if (numAsBigIntegerChar.isNaN) {\n            return numAsBigIntegerChar\n        }\n        val numAsShortChar = num.toShortChar\n        if (numAsShortChar.isNaN) {\n            return numAsShortChar\n        }\n        val numAsByteChar = num.toByte\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293191,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsx5d7bwq.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsx5d7bwq.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsInt)\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsx5d7bwq.scala:28:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsFloat\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsFloat : Float)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsx5d7bwq.scala:32:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsDouble\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsDouble : Double)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsx5d7bwq.scala:34:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsx5d7bwq.scala:38:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(1)\n            val ceil = abs.ceilDiv(1)\n            if (num.equals(floor)) {\n                return floor\n            } else if (num.equals(ceil)) {\n                return ceil\n            } else {\n                return num\n            }\n        } else {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(1)\n            val ceil = abs.ceilDiv(1)\n            if (num.equals(floor)) {\n                return floor\n            } else if (num.equals(ceil)) {\n                return ceil\n            } else {\n                return num\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293189,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxysj_c6i.scala:21:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxysj_c6i.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceilDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxysj_c6i.scala:32:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxysj_c6i.scala:33:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceilDiv is not a member of Long\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(1)\n            val ceil = abs.ceilDiv(1)\n            if (num.equals(floor)) {\n                return num\n            } else if (num.equals(ceil)) {\n                return num.subtract(1)\n            } else {\n                return num.subtract(floor).add(1)\n            }\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293189,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9w8su06b.scala:21:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9w8su06b.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceilDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9w8su06b.scala:26:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mreturn\u001b[0m num.subtract(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9w8su06b.scala:28:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                \u001b[33mreturn\u001b[0m num.subtract(floor).add(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value subtract is not a member of Long\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val abs = num.abs\n        if (abs.isNaN) {\n            return 0l\n        }\n        val abs_int = abs.toInt\n        if (abs_int.isNaN) {\n            return 0l\n        }\n        val abs_long = abs_int.toLong\n        if (abs_long.isNaN) {\n            return 0l\n        }\n        val abs_float = abs_long.toFloat\n        if (abs_float.isNaN) {\n            return 0l\n        }\n        val abs_double = abs_float.toDouble\n        if (abs_double.isNaN) {\n            return 0l\n        }\n        val abs_big_int = abs_double.toBigInt\n        if (abs_big_int.isNaN) {\n            return 0l\n        }\n        val abs_big_long = abs_big_int.toBigLong\n        if (abs_big_long.isNaN) {\n            return 0l\n        }\n        val abs_big_float = abs_big_long.toBigFloat\n        if (abs_big_float.isNaN) {\n            return 0l\n        }\n        val abs_big_double = abs_big_float.toBigDouble\n        if (abs_big_double.isNaN) {\n            return 0l\n        }\n        val abs_big_big_int = abs_big_double.toBigInt\n        if (abs_big_big_int.isNaN) {\n            return 0l\n        }\n        val abs_big_big_long = abs_big_big_int.toBigLong\n        if (abs_big_big_long.isNaN) {\n            return 0l\n        }\n        val abs_big_big_float = abs_big_big_long.toBigFloat\n        if (abs_big_big_float.isNaN) {\n            return 0l\n        }\n        val abs_big_big_double = abs_big_big_float.toBigDouble\n\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293190,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj_kr5y5v.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj_kr5y5v.scala:23:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (abs.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(abs)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj_kr5y5v.scala:27:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mif\u001b[0m (abs_int.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(abs_int)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj_kr5y5v.scala:31:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mif\u001b[0m (abs_long.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(abs_long)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj_kr5y5v.scala:42:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mabs_big_int\u001b[0m = abs_double.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Double, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDeci",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimalWithScale = num.toBigDecimal(2)\n        val numAsBigDecimalWithScaleAndPrecision = num.toBigDecimal(2, 20)\n        val numAsBigDecimalWithPrecision = num.toBigDecimal(20)\n        val numAsBigDecimalWithPrecisionAndScale = num.toBigDecimal(20, 2)\n        val numAsBigDecimalWithScaleAndPrecisionAndRoundingMode = num.toBigDecimal(2, 20, RoundingMode.HALF_UP)\n        val numAsBigDecimalWithPrecisionAndRoundingMode = num.toBigDecimal(20, RoundingMode.HALF_UP)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingMode = num.toBigDecimal(20, 2, RoundingMode.HALF_UP)\n        val numAsBigDecimalWithScaleAndRoundingMode = num.toBigDecimal(2, RoundingMode.HALF_UP)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingMode = num.toBigDecimal(20, 2, RoundingMode.HALF_UP)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingModeAndOption = num.toBigDecimal(20, 2, RoundingMode.HALF_UP, Some(\"\"))\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingModeAndOption = num.toBigDecimal(20, 2, RoundingMode.HALF_UP, None)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingModeAndOption = num.toBigDecimal(20, 2, RoundingMode.HALF_UP, None)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingMode\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293191,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpc__x62r5.scala:40:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpc__x62r5.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalWithPrecisionAndScaleAndRoundingMode\u001b[0m = num.toBigDecimal(\u001b[31m20\u001b[0m, \u001b[31m2\u001b[0m, RoundingMode.HALF_UP)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimalWithPrecisionAndScaleAndRoundingMode is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimalWithPrecisionAndScaleAndRoundingMode\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpc__x62r5.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalWithPrecisionAndScaleAndRoundingModeAndOption\u001b[0m = num.toBigDecimal(\u001b[31m20\u001b[0m, \u001b[31m2\u001b[0m, RoundingMode.HALF_UP, None)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimalWithPrecisionAndScaleAndRoundingModeAndOption is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimalWithPrecisionAndScaleAndRoundingModeAndOption\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpc__x62r5.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalWithPrecisionAndScaleAndRoundingModeAndOption\u001b[0m = num.toBigDecimal(\u001b[31m20\u001b[0m, \u001b[31m2\u001b[0m, RoundingMode.HALF_UP, None)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimalWithPre",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigInt = num.toBigInt\n        if (numAsBigInt.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimalToBigInt = num.toBigDecimal.toBigInt\n        if (numAsBigDecimalToBigInt.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimalToBigIntToInt = num.toBigDecimal.toBigInt.toInt\n        if (numAsBigDecimalToBigIntToInt.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimalToBigIntToIntToLong = num.toBigDecimal.toBigInt.toInt.toLong\n        if (numAsBigDecimalToBigIntToIntToLong.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimalToBigIntToIntToLongToInt = num.toBigDecimal.toBigInt.toInt.toLong.toInt\n        if (numAsBigDecimalToBigIntToIntToLongToInt.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimalToBigIntToIntToLongToIntToLong = num.\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293191,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfz415_n2.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfz415_n2.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfz415_n2.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfz415_n2.scala:34:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfz415_n2.scala:38:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfz415_n2.scala:42:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalToBigInt\u001b[0m = num.toBigDecimal.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                             ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val nearest = abs.div(abs.div(2)).floorDiv(2)\n            return nearest.toLong\n        } else {\n            val abs = Math.abs(num)\n            val nearest = abs.div(abs.div(2)).floorDiv(2)\n            return -nearest.toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293190,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5060m0g3.scala:21:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnearest\u001b[0m = abs.div(abs.div(\u001b[31m2\u001b[0m)).floorDiv(\u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5060m0g3.scala:21:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnearest\u001b[0m = abs.div(abs.div(\u001b[31m2\u001b[0m)).floorDiv(\u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5060m0g3.scala:25:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnearest\u001b[0m = abs.div(abs.div(\u001b[31m2\u001b[0m)).floorDiv(\u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5060m0g3.scala:25:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnearest\u001b[0m = abs.div(abs.div(\u001b[31m2\u001b[0m)).floorDiv(\u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  value div is not a member of Long\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            return -num\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpp5jr_wxg.scala:18)\n\tat Problem$.main(tmpp5jr_wxg.scala:27)\n\tat Problem.main(tmpp5jr_wxg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n        val intPart = num.intPart\n        val fracPart = num.fracPart\n        val intPartAsLong = intPart.toLong\n        val fracPartAsLong = fracPart.toLong\n        val intPartAsDouble = intPartAsLong.toDouble\n        val fracPartAsDouble = fracPartAsLong.toDouble\n        val intPartAsFloat = intPartAsDouble.toFloat\n        val fracPartAsFloat = fracPartAsDouble.toFloat\n        val intPartAsInt = intPartAsFloat.toInt\n        val fracPartAsInt = fracPartAsFloat.toInt\n        val intPartAsShort = intPartAsInt.toShort\n        val fracPartAsShort = fracPartAsInt.toShort\n        val intPartAsByte = intPartAsShort.toByte\n        val fracPartAsByte = fracPartAsShort.toByte\n        val intPartAsChar = intPartAsByte.toChar\n        val fracPartAsChar = fracPartAsByte.toChar\n        val intPartAsBoolean = intPartAsChar.toBoolean\n        val fracPartAsBoolean = fracPartAsChar.toBoolean\n        val intPartAsString = intPartAsBoolean.toString\n        val fracPartAsString = fracPartAsBoolean.toString\n        val intPartAsInt = intPartAsString.toInt\n        val fracPartAsInt = fracPartAsString.toInt\n        val intPartAsShort = intPartAsInt.toShort\n        val fracPartAsShort = fracPartAsInt.toShort\n        val intPartAsByte = intPartAsShort.toByte\n        val fracPartAsByte = fracPartAsShort.toByte\n        val intPartAsChar = intPartAsByte.toChar\n        val fracPartAsChar = fracPartAsByte.toChar\n        val intPartAsBoolean = intPartAsChar.toBoolean\n        val fracPartAsBoolean = fracPartAsChar.toBoolean\n        val intPartAsString = intPartAsBoolean.toString\n        val fracPartAsString = fracPartAs\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293189,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8tj7o5np.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mintPartAsInt\u001b[0m = intPartAsString.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mintPartAsInt is already defined as \u001b[33mvalue\u001b[0m \u001b[35mintPartAsInt\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8tj7o5np.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mfracPartAsInt\u001b[0m = fracPartAsString.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mfracPartAsInt is already defined as \u001b[33mvalue\u001b[0m \u001b[35mfracPartAsInt\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8tj7o5np.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mintPartAsShort\u001b[0m = intPartAsInt.toShort\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mintPartAsShort is already defined as \u001b[33mvalue\u001b[0m \u001b[35mintPartAsShort\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8tj7o5np.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mfracPartAsShort\u001b[0m = fracPartAsInt.toShort\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mfracPartAsShort is already defined as \u001b[33mvalue\u001b[0m \u001b[35mfracPartAsShort\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8tj7o5np.scala:43:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mintPartAsByte\u001b[0m = intPartAsShort.toByte\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            return -num\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpp5jr_wxg.scala:18)\n\tat Problem$.main(tmpp5jr_wxg.scala:27)\n\tat Problem.main(tmpp5jr_wxg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num == 0) {\n            return 0l\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293190,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmp6dy2no1c.scala:18)\n\tat Problem$.main(tmp6dy2no1c.scala:27)\n\tat Problem.main(tmp6dy2no1c.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsByte = num.toByte\n        val numAsShort = num.toShort\n        val numAsChar = num.toChar\n        val numAsLong = num.toLong\n        val numAsInt8 = num.toInt8\n        val numAsInt16 = num.toInt16\n        val numAsInt32 = num.toInt32\n        val numAsInt64 = num.toInt64\n        val numAsFloat32 = num.toFloat32\n        val numAsFloat64 = num.toFloat64\n        val numAsFloat128 = num.toFloat128\n        val numAsByteArray = num.toByteArray\n        val numAsShortArray = num.toShortArray\n        val numAsCharArray = num.toCharArray\n        val numAsIntArray = num.toIntArray\n        val numAsLongArray = num.toLongArray\n        val numAsFloatArray = num.toFloatArray\n        val numAsDoubleArray = num.toDoubleArray\n        val numAsBigIntArray = num.toBigIntArray\n        val numAsBigDecimalArray = num.toBigDecimalArray\n        val numAsString = num.toString\n        val numAsIntString = num.toIntString\n        val numAsLongString = num.toLongString\n        val numAsFloatString = num.toFloatString\n        val numAsDoubleString = num.toDoubleString\n        val numAsBigIntString = num.toBigIntString\n        val numAsBigDecimalString = num.toBigDecimalString\n        val numAsByteString = num.toByteString\n        val numAsShortString = num.toShortString\n        val numAsCharString = num.toCharString\n        val numAsIntString = num.toIntString\n        val numAsLongString = num.toLongString\n        val numAsFloat\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293194,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpjd90j49q.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjd90j49q.scala:57:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsIntString\u001b[0m = num.toIntString\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsIntString is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsIntString\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjd90j49q.scala:58:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsLongString\u001b[0m = num.toLongString\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsLongString is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsLongString\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjd90j49q.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjd90j49q.scala:25:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjd90j49q.scala:26:34 -----------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(1)\n            val ceil = abs.ceilDiv(1)\n            if (abs.subtract(floor).compareTo(ceil.subtract(abs)) > 0)\n                return -floor\n            else\n                return -ceil\n        } else {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(1)\n            val ceil = abs.ceilDiv(1)\n            if (abs.subtract(floor).compareTo(ceil.subtract(abs)) > 0)\n                return floor\n            else\n                return ceil\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293191,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo4jky9lb.scala:21:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo4jky9lb.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceilDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo4jky9lb.scala:23:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m (abs.subtract(floor).compareTo(ceil.subtract(abs)) > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo4jky9lb.scala:29:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo4jky9lb.scala:30:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceilDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo4jky9lb.scala:31:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mif\u001b[0m (abs.subtract(floor).compareTo(ceil.subtract(abs)) > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value subtract is not a member of Long\n6 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(1)\n            val ceil = abs.ceilDiv(1)\n            val diff = abs.subtract(floor).div(1)\n            if (diff.compareTo(ceil.subtract(floor).div(1)) > 0) {\n                return -floor\n            } else {\n                return -ceil\n            }\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293192,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxs20l1nd.scala:21:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxs20l1nd.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceilDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxs20l1nd.scala:23:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdiff\u001b[0m = abs.subtract(floor).div(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value subtract is not a member of Long\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val max = (abs / 2) + 1\n            val min = max - 1\n            val res = max\n            if (num < 0) res = min\n            return res\n        } else {\n            val abs = Math.abs(num)\n            val max = (abs / 2)\n            val min = max - 1\n            val res = min\n            if (num > 0) res = max\n            return res\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293186,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpl83d7qp_.scala:24:29 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m (num < \u001b[31m0\u001b[0m) res = min\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Reassignment to val res\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpl83d7qp_.scala:31:29 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mif\u001b[0m (num > \u001b[31m0\u001b[0m) res = max\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Reassignment to val res\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val abs = num.abs\n        if (abs.isNaN) {\n            return 0l\n        }\n        val abs_int = abs.toInt\n        if (abs_int.isNaN) {\n            return 0l\n        }\n        val abs_frac = abs.subtract(abs_int).toDouble\n        if (abs_frac.isNaN) {\n            return 0l\n        }\n        val abs_frac_int = abs_frac.toInt\n        if (abs_frac_int.isNaN) {\n            return 0l\n        }\n        val abs_frac_frac = abs_frac.subtract(abs_frac_int).toDouble\n        if (abs_frac_frac.isNaN) {\n            return 0l\n        }\n        val abs_frac_frac_int = abs_frac_frac.toInt\n        if (abs_frac_frac_int.isNaN) {\n            return 0l\n        }\n        val abs_frac_frac_frac = abs_frac_frac.subtract(abs_frac_frac_int).toDouble\n        if (abs_frac_frac_frac.isNaN) {\n            return 0l\n        }\n        val abs_frac_frac_frac_int = abs_frac_frac_frac.toInt\n        if (abs_frac_frac_frac_int.isNaN) {\n            return 0l\n        }\n        val abs_frac_frac_frac_frac = abs_frac_frac_frac_int.subtract(abs_frac_frac_frac).toDouble\n        if (abs_frac_frac_frac_frac.isNaN) {\n            return 0l\n        }\n        val abs_frac_frac_frac_frac_int = abs_frac_frac_frac_frac.toInt\n        if (abs_frac_frac_frac_frac_int.isNaN) {\n            return 0l\n        }\n        val abs_frac_frac_frac_frac_frac = abs_frac_frac_frac_frac_int.subtract\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293197,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkep7r6vg.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkep7r6vg.scala:23:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (abs.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(abs)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkep7r6vg.scala:27:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mif\u001b[0m (abs_int.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(abs_int)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkep7r6vg.scala:30:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mabs_frac\u001b[0m = abs.subtract(abs_int).toDouble\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkep7r6vg.scala:63:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        val abs = num.abs\n        val sign = num.signum\n        if (abs == 0) {\n            return 0l\n        } else if (abs < 0) {\n            return -closestInteger(value.substring(1))\n        } else if (abs > 0 && sign == 1) {\n            return num.div(scala.math.BigInteger.ONE)\n        } else if (abs > 0 && sign == -1) {\n            return num.sub(scala.math.BigInteger.ONE)\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293198,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm16gl1ni.scala:26:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mreturn\u001b[0m num.div(scala.math.BigInteger.ONE)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm16gl1ni.scala:26:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mreturn\u001b[0m num.div(scala.math.BigInteger.ONE)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value BigInteger is not a member of math\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm16gl1ni.scala:28:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mreturn\u001b[0m num.sub(scala.math.BigInteger.ONE)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value sub is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm16gl1ni.scala:28:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mreturn\u001b[0m num.sub(scala.math.BigInteger.ONE)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value BigInteger is not a member of math\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(1)\n            val ceil = abs.ceilDiv(1)\n            if (num.equals(floor)) {\n                return (floor.toLong)\n            } else if (num.equals(ceil)) {\n                return (ceil.toLong)\n            } else {\n                return (abs.toLong)\n            }\n        } else {\n            return (num.toLong)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293197,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvvrtyllq.scala:21:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvvrtyllq.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceilDiv is not a member of Long\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            return numAsInt\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return numAsFloat\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return numAsDouble\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return numAsBigDecimal\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            return numAsBigInteger\n        }\n        val numAsShort = num.toShort\n        if (numAsShort.isNaN) {\n            return numAsShort\n        }\n        val numAsByte = num.toByte\n        if (numAsByte.isNaN) {\n            return numAsByte\n        }\n        val numAsLong = num.toLong\n        if (numAsLong.isNaN) {\n            return numAsLong\n        }\n        val numAsInteger = num.toInt\n        if (numAsInteger.isNaN) {\n            return numAsInteger\n        }\n        val numAsFloatAsInt = num.toInt\n        if (numAsFloatAsInt.isNaN) {\n            return numAsFloatAsInt\n        }\n        val numAsFloatAsLong = num.toLong\n        if (numAsFloatAsLong.isNaN) {\n            return numAsFloatAsLong\n        }\n        val numAsFloatAsDouble = num.toDouble\n        if (numAsFloatAsDouble.isNaN) {\n            return numAsFloatAsDouble\n        }\n        val numAsFloatAsBigDecimal = num.toBigDecimal\n        if (numAsFloatAsBigDecimal.isNaN) {\n            return numAsFloatAsBigDecimal\n        }\n        val numAsFloatAsBigInteger = num.\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293203,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpb6x03r0_.scala:75:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpb6x03r0_.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpb6x03r0_.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(numAsInt)\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb6x03r0_.scala:28:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsFloat\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsFloat : Float)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb6x03r0_.scala:32:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsDouble\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsDouble : Double)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpb6x03r0_.scala:34:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val abs = num.abs\n        if (abs.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val sign = num.signum\n        if (sign == 0) {\n            throw new NumberFormatException(\"Zero\")\n        }\n        val absInt = abs.toInt\n        if (absInt.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val absIntPlusOne = absInt + 1\n        if (absIntPlusOne.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val absIntMinusOne = absInt - 1\n        if (absIntMinusOne.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val absIntPlusOneHalf = absIntPlusOne / 2\n        if (absIntPlusOneHalf.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val absIntMinusOneHalf = absIntMinusOne / 2\n        if (absIntMinusOneHalf.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val absIntPlusOneHalfInt = absIntPlusOneHalf.toInt\n        if (absIntPlusOneHalfInt.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val absIntMinusOneHalfInt = absIntMinusOneHalf.toInt\n        if (absIntMinusOneHalfInt.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val absIntPlusOneHalfIntPlusOne = absIntPlusOneHalfInt + 1\n        if (absIntPlusOneHalfIntPlusOne.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val absIntMinusOneHalfIntMinusOne = absIntMinusOneHalfInt - 1\n        if (absIntMinusOneHalfIntMinusOne.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293198,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvaiid42f.scala:76:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvaiid42f.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvaiid42f.scala:23:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (abs.isInfinite) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isInfinite is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(abs)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvaiid42f.scala:31:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mif\u001b[0m (absInt.isInfinite) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isInfinite is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(absInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvaiid42f.scala:35:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mif\u001b[0m (absIntPlusOne.isInfinite) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isInfinite is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(absIntPlusOne)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvaiid42f.scala:39:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mif\u001b[0m (absIntMinusOne.isInfinite) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (num.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsInt.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsFloat.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsDouble.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsBigDecimal.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsBigInteger.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsBigDecimal.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293201,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpl4rag9u8.scala:71:10 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m        \u001b[33mif\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpl4rag9u8.scala:60:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpl4rag9u8.scala:67:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInteger\u001b[0m = num.toBigInteger\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigInteger is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigInteger\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl4rag9u8.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl4rag9u8.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mif\u001b[0m (num.isInfinite) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isInfinite is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found E",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) num = -num\n        val abs = Math.abs(num)\n        if (abs < 1) return num\n        val intPart = num.div(abs).floorDiv(1).toLong\n        val fracPart = num.sub(intPart).div(abs).floorDiv(1).toLong\n        if (fracPart == 0) return intPart\n        if (fracPart > 0) return intPart + 1\n        return intPart - 1\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293200,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp5c4y2j7m.scala:19:25 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num < \u001b[31m0\u001b[0m) num = -num\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Reassignment to val num\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5c4y2j7m.scala:22:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mintPart\u001b[0m = num.div(abs).floorDiv(\u001b[31m1\u001b[0m).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5c4y2j7m.scala:23:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mfracPart\u001b[0m = num.sub(intPart).div(abs).floorDiv(\u001b[31m1\u001b[0m).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value sub is not a member of Long\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimalUnscaled = num.unscaled\n        if (numAsBigDecimalUnscaled.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigIntegerUnscaled = num.unscaled\n        if (numAsBigIntegerUnscaled.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimalUnscaledAsInt = num.unscaled.toInt\n        if (numAsBigDecimalUnscaledAsInt.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigIntegerUnscaledAsInt = num.unscaled.toInt\n        if (numAsBigIntegerUnscaledAsInt.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimalUnscaledAsFloat = num.unscaled.toFloat\n        if (numAsBigDecimalUnscaledAsFloat.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigIntegerUnscaledAsFloat = num.unscaled\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293206,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8b1jqpr8.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8b1jqpr8.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8b1jqpr8.scala:34:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8b1jqpr8.scala:38:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInteger\u001b[0m = num.toBigInteger\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigInteger is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8b1jqpr8.scala:42:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalUnscaled\u001b[0m = num.unscaled\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  value unscaled is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8b1jqpr8.scala:46:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigIntegerUnscaled\u001b[0m = num.unscaled\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^\u001b[0m\n\u001b[31",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val intPart = abs.floorDiv(1)\n            val fracPart = abs.subtract(intPart).floorDiv(1)\n            val result = intPart.add(fracPart.multiply(10))\n            if (num < 0) result = result.subtract(1)\n            return result\n        } else {\n            val abs = Math.abs(num)\n            val intPart = abs.floorDiv(1)\n            val fracPart = abs.subtract(intPart).floorDiv(1)\n            val result = intPart.add(fracPart.multiply(10))\n            if (num > 0) result = result.add(1)\n            return result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293203,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwafqg3h7.scala:21:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mintPart\u001b[0m = abs.floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwafqg3h7.scala:22:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfracPart\u001b[0m = abs.subtract(intPart).floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpwafqg3h7.scala:24:32 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m (num < \u001b[31m0\u001b[0m) result = result.subtract(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwafqg3h7.scala:28:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mintPart\u001b[0m = abs.floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwafqg3h7.scala:29:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfracPart\u001b[0m = abs.subtract(intPart).floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpwafqg3h7.scala:31:32 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mif\u001b[0m (num > \u001b[31m0\u001b[0m) result = result.add(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Reassignmen",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsChar = num.toChar\n        val numAsByte = num.toByte\n        val numAsShort = num.toShort\n        val numAsLong = num.toLong\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAs\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293205,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp65iz75zc.scala:57:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp65iz75zc.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp65iz75zc.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp65iz75zc.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp65iz75zc.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val floor = abs.floor\n            val ceil = abs.ceiling\n            val diff = abs.subtract(floor)\n            val diff2 = diff.abs\n            val diff3 = diff2.subtract(1)\n            val diff4 = diff3.abs\n            val diff5 = diff4.subtract(1)\n            val diff6 = diff5.abs\n            val diff7 = diff6.subtract(1)\n            val diff8 = diff7.abs\n            val diff9 = diff8.subtract(1)\n            val diff10 = diff9.abs\n            val diff11 = diff10.subtract(1)\n            val diff12 = diff11.abs\n            val diff13 = diff12.subtract(1)\n            val diff14 = diff13.abs\n            val diff15 = diff14.subtract(1)\n            val diff16 = diff15.abs\n            val diff17 = diff16.subtract(1)\n            val diff18 = diff17.abs\n            val diff19 = diff18.subtract(1)\n            val diff20 = diff19.abs\n            val diff21 = diff20.subtract(1)\n            val diff22 = diff21.abs\n            val diff23 = diff22.subtract(1)\n            val diff24 = diff23.abs\n            val diff25 = diff24.subtract(1)\n            val diff26 = diff25.abs\n            val diff27 = diff26.subtract(1)\n            val diff28 = diff27.abs\n            val diff29 = diff28.subtract(1)\n            val diff30 = diff29.abs\n            val diff31 = diff30.subtract(1)\n            val diff32 = diff31.abs\n            val diff33 = diff32.subtract(1)\n            val diff34 = diff33.abs\n            val diff35 = diff34.subtract(1)\n            val diff36 = diff35.abs\n            val diff37 = diff36.subtract(1)\n            val diff\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293205,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwkdvgrzx.scala:61:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwkdvgrzx.scala:71:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwkdvgrzx.scala:21:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floor\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value floor is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          doubleWrapper(abs)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwkdvgrzx.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceiling\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceiling is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwkdvgrzx.scala:23:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdiff\u001b[0m = abs.subtract(floor)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwkdvgrzx.scala:70:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m70 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpwkdvgrzx.scala:62:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m62 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n6 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            return numAsInt\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return numAsFloat\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return numAsDouble\n        }\n        val numAsBigInt = num.toBigInt\n        if (numAsBigInt.isNaN) {\n            return numAsBigInt\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return numAsBigDecimal\n        }\n        val numAsBigDecimalWithScale = num.toBigDecimalWithScale\n        if (numAsBigDecimalWithScale.isNaN) {\n            return numAsBigDecimalWithScale\n        }\n        val numAsBigDecimalWithScaleAndPrecision = num.toBigDecimalWithScaleAndPrecision\n        if (numAsBigDecimalWithScaleAndPrecision.isNaN) {\n            return numAsBigDecimalWithScaleAndPrecision\n        }\n        val numAsBigDecimalWithPrecision = num.toBigDecimalWithPrecision\n        if (numAsBigDecimalWithPrecision.isNaN) {\n            return numAsBigDecimalWithPrecision\n        }\n        val numAsBigDecimalWithPrecisionAndScale = num.toBigDecimalWithPrecisionAndScale\n        if (numAsBigDecimalWithPrecisionAndScale.isNaN) {\n            return numAsBigDecimalWithPrecisionAndScale\n        }\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingMode = num.toBigDecimalWithPrecisionAndScaleAndRoundingMode\n        if (numAsBigDecimalWithPrecisionAndScaleAndRoundingMode.isNaN) {\n            return numAsBigDecimalWithPrecisionAndScaleAndRoundingMode\n        }\n        val numAsBigDec\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293177,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5at8uvxl.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5at8uvxl.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5at8uvxl.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(numAsInt)\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5at8uvxl.scala:28:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsFloat\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsFloat : Float)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5at8uvxl.scala:32:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsDouble\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsDouble : Double)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5at8uvxl.scala:34:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            return -num\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpp5jr_wxg.scala:18)\n\tat Problem$.main(tmpp5jr_wxg.scala:27)\n\tat Problem.main(tmpp5jr_wxg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsChar = num.toChar\n        val numAsByte = num.toByte\n        val numAsShort = num.toShort\n        val numAsLong = num.toLong\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimalInt = num.toBigDecimalInt\n        val numAsBigDecimalLong = num.toBigDecimalLong\n        val numAsBigDecimalShort = num.toBigDecimalShort\n        val numAsBigDecimalByte = num.toBigDecimalByte\n        val numAsBigDecimalChar = num.toBigDecimalChar\n        val numAsBigDecimalFloat = num.toBigDecimalFloat\n        val numAsBigDecimalDouble = num.toBigDecimalDouble\n        val numAsBigDecimalBigInt = num.toBigDecimalBigInt\n        val numAsBigDecimalBigDecimal = num.toBigDecimalBigDecimal\n        val numAsBigDecimalBigDecimalInt = num.toBigDecimalBigDecimalInt\n        val numAsBigDecimalBigDecimalLong = num.toBigDecimalBigDecimalLong\n        val numAsBigDecimalBigDecimalShort = num.toBigDecimalBigDecimalShort\n        val numAsBigDecimalBigDecimalByte = num.toBigDecimalBigDecimalByte\n        val numAsBigDecimalBigDecimalChar = num.toBigDecimalBigDecimalChar\n        val numAsBigDecimalBigDecimalFloat = num.toBigDecimalBigDecimalFloat\n        val numAsBigDecimalBigDecimalDouble = num.toBigDecimalBigDecimalDouble\n        val numAsBigDecimalBigDecimalBigInt = num.toBigDecimalBigDecimalBigInt\n        val numAsBigDecimalBigDecimalBigDecimal = num.toBigDecimalBigDecimalBigDecimal\n        val numAsBigDecimalBigDecimalBigDecimalInt = num.toBigDecimalBigDecimalBigDec\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293206,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqpomyfh0.scala:26:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqpomyfh0.scala:27:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqpomyfh0.scala:28:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalInt\u001b[0m = num.toBigDecimalInt\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value toBigDecimalInt is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqpomyfh0.scala:29:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalLong\u001b[0m = num.toBigDecimalLong\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value toBigDecimalLong is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqpomyfh0.scala:30:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalShort\u001b[0m = num.toBigDecimalShort\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         value toBigDecimalShort is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqpomyfh0.scala:31:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalByte\u001b[0m = num.toBigDecimalByte",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            return -num\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpp5jr_wxg.scala:18)\n\tat Problem$.main(tmpp5jr_wxg.scala:27)\n\tat Problem.main(tmpp5jr_wxg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            return numAsInt\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return numAsFloat\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return numAsDouble\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return numAsBigDecimal\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            return numAsBigInteger\n        }\n        val numAsBigDecimalUnscaled = num.unscaled\n        if (numAsBigDecimalUnscaled.isNaN) {\n            return numAsBigDecimalUnscaled\n        }\n        val numAsBigIntegerUnscaled = num.unscaled\n        if (numAsBigIntegerUnscaled.isNaN) {\n            return numAsBigIntegerUnscaled\n        }\n        val numAsBigDecimalUnscaledAsInt = num.unscaled.toInt\n        if (numAsBigDecimalUnscaledAsInt.isNaN) {\n            return numAsBigDecimalUnscaledAsInt\n        }\n        val numAsBigIntegerUnscaledAsInt = num.unscaled.toInt\n        if (numAsBigIntegerUnscaledAsInt.isNaN) {\n            return numAsBigIntegerUnscaledAsInt\n        }\n        val numAsBigDecimalUnscaledAsFloat = num.unscaled.toFloat\n        if (numAsBigDecimalUnscaledAsFloat.isNaN) {\n            return numAsBigDecimalUnscaledAsFloat\n        }\n        val numAsBigIntegerUnscaledAsFloat = num.unscaled.toFloat\n        if (numAsBigIntegerUnscaledAsFloat.isNaN) {\n            \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293206,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpu61xqsov.scala:75:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu61xqsov.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu61xqsov.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsInt)\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu61xqsov.scala:28:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsFloat\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsFloat : Float)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu61xqsov.scala:32:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsDouble\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsDouble : Double)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu61xqsov.scala:34:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val nearest = abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9te5ay0q.scala:22:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9te5ay0q.scala:32:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9te5ay0q.scala:21:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnearest\u001b[0m = abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9te5ay0q.scala:21:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnearest\u001b[0m = abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.div(abs.di",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val nearest = abs.div(scala.math.BigInt(\"1\" + abs.subtract(abs.div(scala.math.BigInt(\"1\" + abs.subtract(abs.div(scala.math.BigInt(\"1\" + abs.subtract(abs.div(scala.math.BigInt(\"1\" + abs.subtract(abs.div(scala.math.BigInt(\"1\" + abs.subtract(abs.div(scala.math.BigInt(\"1\" + abs.subtract(abs.div(scala.math.BigInt(\"1\" + abs.subtract(abs.div(scala.math.BigInt(\"1\" + abs.subtract(abs.div(scala.math.BigInt(\"1\" + abs.subtract(abs.div(scala.math.BigInt(\"1\" + abs.subtract(abs.div(scala.math.BigInt(\"1\" + abs.subtract(abs.div(scala.math.BigInt(\"1\" + abs.subtract(abs.div(scala.math.BigInt(\"1\" + abs.subtract(abs.div(scala.math.BigInt(\"1\" + abs.subtract(abs.div(scala.math.BigInt(\"1\" + abs.subtract(abs.div(scala.math.BigInt(\"1\" + abs.subtract(abs.div(scala.math.BigInt(\"1\" + abs.subtract(abs.div(scala.math.BigInt(\"1\" + abs.subtract(abs.div(scala.math.BigInt(\"1\" + abs.subtract(abs.div(scala.math.BigInt(\"1\" + abs.subtract(abs.div(scala.math.BigInt(\"1\" + abs.subtract(abs.div(scala.math.BigInt(\"1\" + abs.subtract(abs.div(scala.math.BigInt(\"1\" + abs.\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293261,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8z9u7o_1.scala:22:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8z9u7o_1.scala:32:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8z9u7o_1.scala:21:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnearest\u001b[0m = abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m + abs.subtract(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m + abs.subtract(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m + abs.subtract(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m + abs.subtract(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m + abs.subtract(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m + abs.subtract(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m + abs.subtract(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m + abs.subtract(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m + abs.subtract(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m + abs.subtract(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m + abs.subtract(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m + abs.subtract(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m + abs.subtract(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m + abs.subtract(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m + abs.subtract(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m + abs.subtract(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m + abs.subtract(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m + abs.subtract(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m + abs.subtract(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m + abs.subtract(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m + abs.subtract(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m + abs.subtract(abs.div(scala.math.BigInt(\u001b[31m\"1\"\u001b[0m + abs.\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value div is not a member of Long\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val abs = num.abs\n        if (abs.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val sign = num.signum\n        if (sign == 0) {\n            throw new NumberFormatException(\"Zero\")\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsBigDecimalInt = numAsBigDecimal.intValue\n        if (numAsBigDecimalInt.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsBigDecimalLong = numAsBigDecimal.longValue\n        if (numAsBigDecimalLong.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsBigDecimalFloat = numAsBigDecimal.floatValue\n        if (numAsBigDecimalFloat.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsBigDecimalDouble = numAsBigDecimal.doubleValue\n        if (numAsBigDecimalDouble.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsBigDecimalBigInteger = numAsBigDecimal.bigIntegerValue\n        if (\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293205,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp2rbtlmrl.scala:67:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m        \u001b[33mif\u001b[0m (\n\u001b[31m\u001b[31m   |\u001b[0m            ^\u001b[0m\n\u001b[31m   |\u001b[0m            expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2rbtlmrl.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2rbtlmrl.scala:23:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (abs.isInfinite) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isInfinite is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(abs)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2rbtlmrl.scala:31:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isInfinite) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isInfinite is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(numAsInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2rbtlmrl.scala:42:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2rbtlmrl.scala:46:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInteger\u001b[0m = num.toBigInteger\n\u001b[31m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            return -num\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpp5jr_wxg.scala:18)\n\tat Problem$.main(tmpp5jr_wxg.scala:27)\n\tat Problem.main(tmpp5jr_wxg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsChar = num.toChar\n        val numAsByte = num.toByte\n        val numAsShort = num.toShort\n        val numAsLong = num.toLong\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAs\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293205,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp65iz75zc.scala:57:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp65iz75zc.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp65iz75zc.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp65iz75zc.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp65iz75zc.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val nearest = abs.div(scala.math.BigInt(2)).floorDiv(scala.math.BigInt(2))\n            val diff = abs.sub(nearest)\n            if (diff.abs().toInt > 1) {\n                val diff2 = diff.div(scala.math.BigInt(2))\n                val nearest2 = nearest.add(diff2)\n                val diff3 = abs.sub(nearest2)\n                if (diff3.abs().toInt > 1) {\n                    val diff4 = diff3.div(scala.math.BigInt(2))\n                    val nearest4 = nearest2.add(diff4)\n                    val diff5 = abs.sub(nearest4)\n                    if (diff5.abs().toInt > 1) {\n                        val diff6 = diff5.div(scala.math.BigInt(2))\n                        val nearest6 = nearest4.add(diff6)\n                        val diff7 = abs.sub(nearest6)\n                        if (diff7.abs().toInt > 1) {\n                            val diff8 = diff7.div(scala.math.BigInt(2))\n                            val nearest8 = nearest6.add(diff8)\n                            val diff9 = abs.sub(nearest8)\n                            if (diff9.abs().toInt > 1) {\n                                val diff10 = diff9.div(scala.math.BigInt(2))\n                                val nearest10 = nearest8.add(diff10)\n                                val diff11 = abs.sub(nearest10)\n                                if (diff11.abs().toInt > 1) {\n                                    val diff12 = diff11.div(scala.math.BigInt(2))\n                                    val nearest12 = nearest10.add(diff12)\n                                    val diff13 = abs.sub(nearest12)\n                                    if (diff13.abs().toInt > 1) {\n                                        val diff14 = diff13.div(scala.math.BigInt(2))\n                                        val nearest14 = nearest12.add(\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293205,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpptn4e8g2.scala:49:70 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m                                        \u001b[33mval\u001b[0m \u001b[36mnearest14\u001b[0m = nearest12.add(\n\u001b[31m\u001b[31m   |\u001b[0m                                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpptn4e8g2.scala:60:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpptn4e8g2.scala:21:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnearest\u001b[0m = abs.div(scala.math.BigInt(\u001b[31m2\u001b[0m)).floorDiv(scala.math.BigInt(\u001b[31m2\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpptn4e8g2.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdiff\u001b[0m = abs.sub(nearest)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value sub is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpptn4e8g2.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mdiff3\u001b[0m = abs.sub(nearest2)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            value sub is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpptn4e8g2.scala:30:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                    \u001b[33mval\u001b[0m \u001b[36mdiff5\u001b[0m = abs.sub(nearest4)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                value sub is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpptn4e8g2.scala:34:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsChar = num.toChar\n        val numAsByte = num.toByte\n        val numAsShort = num.toShort\n        val numAsLong = num.toLong\n        val numAsFloat32 = num.toFloat32\n        val numAsFloat64 = num.toFloat64\n        val numAsFloat128 = num.toFloat128\n        val numAsInt32 = num.toInt32\n        val numAsInt64 = num.toInt64\n        val numAsInt128 = num.toInt128\n        val numAsChar32 = num.toChar32\n        val numAsChar64 = num.toChar64\n        val numAsChar128 = num.toChar128\n        val numAsByte32 = num.toByte32\n        val numAsByte64 = num.toByte64\n        val numAsByte128 = num.toByte128\n        val numAsShort32 = num.toShort32\n        val numAsShort64 = num.toShort64\n        val numAsShort128 = num.toShort128\n        val numAsInt256 = num.toInt256\n        val numAsInt512 = num.toInt512\n        val numAsInt1024 = num.toInt1024\n        val numAsInt2048 = num.toInt2048\n        val numAsInt4096 = num.toInt4096\n        val numAsInt8192 = num.toInt8192\n        val numAsInt16384 = num.toInt16384\n        val numAsInt32768 = num.toInt32768\n        val numAsInt65536 = num.toInt65536\n        val numAsInt131072 = num.toInt131072\n        val numAsInt262144 = num.toInt262144\n        val numAsInt524288 = num.toInt524288\n        val numAsInt1048576\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293210,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpuhz5grp_.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuhz5grp_.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuhz5grp_.scala:25:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuhz5grp_.scala:26:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuhz5grp_.scala:31:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsFloat32\u001b[0m = num.toFloat32\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m     value toFloat32 is not a member of Long - did you mean num.toFloat?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuhz5grp_.scala:32:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsFloat64\u001b[0m = num.toFloat64\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m     value toFloat64 is not a member of Long - did you mean num.toFloat?\n\u001b[31m\u001b[31",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(1)\n            val ceil = abs.ceilDiv(1)\n            if (num.equals(floor)) {\n                return -floor\n            } else if (num.equals(ceil)) {\n                return -ceil\n            } else {\n                return -num\n            }\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293204,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0cpczc8k.scala:21:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0cpczc8k.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceilDiv is not a member of Long\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsChar = num.toChar\n        val numAsByte = num.toByte\n        val numAsShort = num.toShort\n        val numAsLong = num.toLong\n        val numAsFloat32 = num.toFloat32\n        val numAsFloat64 = num.toFloat64\n        val numAsFloat128 = num.toFloat128\n        val numAsInt32 = num.toInt32\n        val numAsInt64 = num.toInt64\n        val numAsInt128 = num.toInt128\n        val numAsInt256 = num.toInt256\n        val numAsInt512 = num.toInt512\n        val numAsInt1024 = num.toInt1024\n        val numAsInt2048 = num.toInt2048\n        val numAsInt4096 = num.toInt4096\n        val numAsInt8192 = num.toInt8192\n        val numAsInt16384 = num.toInt16384\n        val numAsInt32768 = num.toInt32768\n        val numAsInt65536 = num.toInt65536\n        val numAsInt131072 = num.toInt131072\n        val numAsInt262144 = num.toInt262144\n        val numAsInt524288 = num.toInt524288\n        val numAsInt1048576 = num.toInt1048576\n        val numAsInt2097152 = num.toInt2097152\n        val numAsInt4194304 = num.toInt4194304\n        val numAsInt8388608 = num.toInt8388608\n        val numAsInt16777216 = num.toInt16777216\n        val numAsInt33554432 = num.toInt33554432\n        val numAsInt67108864 = num.toInt67108864\n\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293209,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa8n9revz.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa8n9revz.scala:25:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa8n9revz.scala:26:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa8n9revz.scala:31:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsFloat32\u001b[0m = num.toFloat32\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m     value toFloat32 is not a member of Long - did you mean num.toFloat?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa8n9revz.scala:32:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsFloat64\u001b[0m = num.toFloat64\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m     value toFloat64 is not a member of Long - did you mean num.toFloat?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa8n9revz.scala:33:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsFloat128\u001b[0m = num.toFloat128\n\u001b[31m\u001b[31m   |\u001b[0m         ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            throw new IllegalArgumentException(\"Invalid number: \" + value)\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            throw new IllegalArgumentException(\"Invalid number: \" + value)\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            throw new IllegalArgumentException(\"Invalid number: \" + value)\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            throw new IllegalArgumentException(\"Invalid number: \" + value)\n        }\n        val numAsShort = num.toShort\n        if (numAsShort.isNaN) {\n            throw new IllegalArgumentException(\"Invalid number: \" + value)\n        }\n        val numAsByte = num.toByte\n        if (numAsByte.isNaN) {\n            throw new IllegalArgumentException(\"Invalid number: \" + value)\n        }\n        val numAsChar = num.toChar\n        if (numAsChar.isNaN) {\n            throw new IllegalArgumentException(\"Invalid number: \" + value)\n        }\n        val numAsLong = num.toLong\n        if (numAsLong.isNaN) {\n            throw new IllegalArgumentException(\"Invalid number: \" + value)\n        }\n        val numAsBigInt = num.toBigInt\n        if (numAsBigInt.isNaN) {\n            throw new IllegalArgumentException(\"Invalid number: \" + value)\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            throw new IllegalArgumentException(\"Invalid number: \" + value)\n        }\n        val numAsBigDecimalInt = num.toBigDecimalInt\n        if (numAsBigDecimalInt.isNaN) {\n            throw new IllegalArgumentException(\"Invalid number: \" + value)\n        }\n        val numAsBigDecimalLong = num.toBigDecimalLong\n        if (numAsBigDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293207,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgf9uwr_w.scala:64:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgf9uwr_w.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgf9uwr_w.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgf9uwr_w.scala:35:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mif\u001b[0m (numAsShort.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Short.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsShort)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgf9uwr_w.scala:39:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mif\u001b[0m (numAsByte.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Byte.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsByte)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgf9uwr_w.scala:43:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mif\u001b[0m (numAsChar.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Char.\n\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            return numAsInt\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return numAsFloat\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return numAsDouble\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return numAsBigDecimal\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            return numAsBigInteger\n        }\n        val numAsLong = num.toLong\n        if (numAsLong.isNaN) {\n            return numAsLong\n        }\n        val numAsIntAsLong = numAsInt.toLong\n        if (numAsIntAsLong.isNaN) {\n            return numAsIntAsLong\n        }\n        val numAsFloatAsLong = numAsFloat.toLong\n        if (numAsFloatAsLong.isNaN) {\n            return numAsFloatAsLong\n        }\n        val numAsDoubleAsLong = numAsDouble.toLong\n        if (numAsDoubleAsLong.isNaN) {\n            return numAsDoubleAsLong\n        }\n        val numAsBigDecimalAsLong = numAsBigDecimal.toLong\n        if (numAsBigDecimalAsLong.isNaN) {\n            return numAsBigDecimalAsLong\n        }\n        val numAsBigIntegerAsLong = numAsBigInteger.toLong\n        if (numAsBigIntegerAsLong.isNaN) {\n            return numAsBigIntegerAsLong\n        }\n        val numAsLongAsLong = numAsLong.toLong\n        if (numAsLongAsLong.isNaN) {\n            return numAsLongAsLong\n        }\n        val numAsIntAsLongAsLong = numAsIntAsLong.\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293208,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpupqz3feg.scala:71:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpupqz3feg.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpupqz3feg.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(numAsInt)\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpupqz3feg.scala:28:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsFloat\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsFloat : Float)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpupqz3feg.scala:32:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsDouble\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsDouble : Double)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpupqz3feg.scala:34:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return numAsInt\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return numAsInt\n        }\n        val numAsBigInt = num.toBigInt\n        if (numAsBigInt.isNaN) {\n            return numAsInt\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return numAsInt\n        }\n        val numAsBigDecimalInt = numAsBigDecimal.toBigInteger\n        if (numAsBigDecimalInt.isNaN) {\n            return numAsInt\n        }\n        val numAsBigDecimalLong = numAsBigDecimal.toBigInteger\n        if (numAsBigDecimalLong.isNaN) {\n            return numAsInt\n        }\n        val numAsBigDecimalIntAsLong = numAsBigDecimalInt.longValue\n        if (numAsBigDecimalIntAsLong.isNaN) {\n            return numAsInt\n        }\n        val numAsBigDecimalLongAsLong = numAsBigDecimalLong.longValue\n        if (numAsBigDecimalLongAsLong.isNaN) {\n            return numAsInt\n        }\n        val numAsBigDecimalIntAsInt = numAsBigDecimalInt.intValue\n        if (numAsBigDecimalIntAsInt.isNaN) {\n            return numAsInt\n        }\n        val numAsBigDecimalLongAsInt = numAsBigDecimalLong.intValue\n        if (numAsBigDecimalLongAsInt.isNaN) {\n            return numAsInt\n        }\n        val numAsBigDecimalIntAsDouble = numAsBigDecimalInt.doubleValue\n        if (numAsBigDecimalIntAsDouble.isNaN) {\n            return numAsInt\n        }\n        val numAs\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293210,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpxacnbd_y.scala:68:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxacnbd_y.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxacnbd_y.scala:31:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxacnbd_y.scala:35:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxacnbd_y.scala:68:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            return numAsInt\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return numAsFloat\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return numAsDouble\n        }\n        val numAsBigInt = num.toBigInt\n        if (numAsBigInt.isNaN) {\n            return numAsBigInt\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return numAsBigDecimal\n        }\n        val numAsBigDecimalToBigInt = numAsBigDecimal.toBigInt\n        if (numAsBigDecimalToBigInt.isNaN) {\n            return numAsBigDecimalToBigInt\n        }\n        val numAsBigDecimalToBigDecimal = numAsBigDecimal.toBigDecimal\n        if (numAsBigDecimalToBigDecimal.isNaN) {\n            return numAsBigDecimalToBigDecimal\n        }\n        val numAsBigDecimalToInt = numAsBigDecimal.toInt\n        if (numAsBigDecimalToInt.isNaN) {\n            return numAsBigDecimalToInt\n        }\n        val numAsBigDecimalToLong = numAsBigDecimal.toLong\n        if (numAsBigDecimalToLong.isNaN) {\n            return numAsBigDecimalToLong\n        }\n        val numAsBigDecimalToFloat = numAsBigDecimal.toFloat\n        if (numAsBigDecimalToFloat.isNaN) {\n            return numAsBigDecimalToFloat\n        }\n        val numAsBigDecimalToDouble = numAsBigDecimal.toDouble\n        if (numAsBigDecimalToDouble.isNaN) {\n            return numAsBigDecimalToDouble\n        }\n        \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293214,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp81zey0o9.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp81zey0o9.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsInt)\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp81zey0o9.scala:28:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsFloat\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsFloat : Float)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp81zey0o9.scala:32:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsDouble\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsDouble : Double)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp81zey0o9.scala:34:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecima",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsChar = num.toChar\n        val numAsByte = num.toByte\n        val numAsShort = num.toShort\n        val numAsLong = num.toLong\n        val numAsFloat32 = num.toFloat32\n        val numAsFloat64 = num.toFloat64\n        val numAsFloat128 = num.toFloat128\n        val numAsInt32 = num.toInt32\n        val numAsInt64 = num.toInt64\n        val numAsInt128 = num.toInt128\n        val numAsInt256 = num.toInt256\n        val numAsInt512 = num.toInt512\n        val numAsInt1024 = num.toInt1024\n        val numAsInt2048 = num.toInt2048\n        val numAsInt4096 = num.toInt4096\n        val numAsInt8192 = num.toInt8192\n        val numAsInt16384 = num.toInt16384\n        val numAsInt32768 = num.toInt32768\n        val numAsInt65536 = num.toInt65536\n        val numAsInt131072 = num.toInt131072\n        val numAsInt262144 = num.toInt262144\n        val numAsInt524288 = num.toInt524288\n        val numAsInt1048576 = num.toInt1048576\n        val numAsInt2097152 = num.toInt2097152\n        val numAsInt4194304 = num.toInt4194304\n        val numAsInt8388608 = num.toInt8388608\n        val numAsInt16777216 = num.toInt16777216\n        val numAsInt33554432 = num.toInt33554432\n        val numAsInt67108864 = num.toInt67108864\n\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293209,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa8n9revz.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa8n9revz.scala:25:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa8n9revz.scala:26:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa8n9revz.scala:31:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsFloat32\u001b[0m = num.toFloat32\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m     value toFloat32 is not a member of Long - did you mean num.toFloat?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa8n9revz.scala:32:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsFloat64\u001b[0m = num.toFloat64\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m     value toFloat64 is not a member of Long - did you mean num.toFloat?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa8n9revz.scala:33:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsFloat128\u001b[0m = num.toFloat128\n\u001b[31m\u001b[31m   |\u001b[0m         ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsChar = num.toChar\n        val numAsShort = num.toShort\n        val numAsByte = num.toByte\n        val numAsFloat32 = num.toFloat32\n        val numAsFloat64 = num.toFloat64\n        val numAsFloat128 = num.toFloat128\n        val numAsInt32 = num.toInt32\n        val numAsInt64 = num.toInt64\n        val numAsInt128 = num.toInt128\n        val numAsLong = num.toLong\n        val numAsBigInt128 = num.toBigInt128\n        val numAsBigInt256 = num.toBigInt256\n        val numAsBigDecimal128 = num.toBigDecimal128\n        val numAsBigDecimal256 = num.toBigDecimal256\n        val numAsChar256 = num.toChar256\n        val numAsShort256 = num.toShort256\n        val numAsByte256 = num.toByte256\n        val numAsFloat32256 = num.toFloat32256\n        val numAsFloat64256 = num.toFloat64256\n        val numAsFloat128256 = num.toFloat128256\n        val numAsInt32256 = num.toInt32256\n        val numAsInt64256 = num.toInt64256\n        val numAsInt128256 = num.toInt128256\n        val numAsLong256 = num.toLong256\n        val numAsBigInt128256 = num.toBigInt128256\n        val numAsBigInt256256 = num.toBigInt256256\n        val numAsBigDecimal128256 = num.toBigDecimal128256\n        val numAsBigDecimal256256 = num.toBigDecimal256256\n        val numAsChar512 = num.toChar512\n        val numAsShort512 = num.to\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293217,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbvdr0ano.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbvdr0ano.scala:25:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbvdr0ano.scala:26:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbvdr0ano.scala:30:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsFloat32\u001b[0m = num.toFloat32\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m     value toFloat32 is not a member of Long - did you mean num.toFloat?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbvdr0ano.scala:31:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsFloat64\u001b[0m = num.toFloat64\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m     value toFloat64 is not a member of Long - did you mean num.toFloat?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbvdr0ano.scala:32:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsFloat128\u001b[0m = num.toFloat128\n\u001b[31m\u001b[31m   |\u001b[0m         ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val abs = num.abs\n        if (abs.isNaN) {\n            return 0l\n        }\n        val absInt = abs.toInt\n        if (absInt.isNaN) {\n            return 0l\n        }\n        val absIntPlusOne = absInt + 1\n        if (absIntPlusOne.isNaN) {\n            return 0l\n        }\n        val absIntMinusOne = absInt - 1\n        if (absIntMinusOne.isNaN) {\n            return 0l\n        }\n        if (absInt.equals(absIntPlusOne)) {\n            return absIntPlusOne\n        } else if (absInt.equals(absIntMinusOne)) {\n            return absIntMinusOne\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293210,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmr0nwu4a.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmr0nwu4a.scala:23:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (abs.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(abs)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmr0nwu4a.scala:27:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mif\u001b[0m (absInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(absInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmr0nwu4a.scala:31:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mif\u001b[0m (absIntPlusOne.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(absIntPlusOne)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmr0nwu4a.scala:35:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mif\u001b[0m (absIntMinusOne.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(absIntMinusOne)\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsLong = num.toLong\n        if (numAsLong.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsIntAsLong = numAsInt.toLong\n        if (numAsIntAsLong.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsFloatAsLong = numAsFloat.toLong\n        if (numAsFloatAsLong.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsDoubleAsLong = numAsDouble.toLong\n        if (numAsDoubleAsLong.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimalAsLong = numAsBigDecimal.toLong\n        if (numAsBigDecimalAsLong.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigIntegerAsLong = numAsBigInteger.toLong\n        if (numAsBigIntegerAsLong.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsLongAsInt = numAsLong.\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293215,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpebxepf2t.scala:67:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpebxepf2t.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpebxepf2t.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpebxepf2t.scala:34:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpebxepf2t.scala:38:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInteger\u001b[0m = num.toBigInteger\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigInteger is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpebxepf2t.scala:43:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mif\u001b[0m (numAsLong.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numA",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n        val abs = Math.abs(num)\n        val intPart = num.intPart\n        val fracPart = num.fracPart\n        val intPartAbs = intPart.abs\n        val fracPartAbs = fracPart.abs\n        val intPartSign = intPart.sign\n        val fracPartSign = fracPart.sign\n        val intPartAbsSign = intPartAbs.sign\n        val fracPartAbsSign = fracPartAbs.sign\n        val intPartAbsAbs = intPartAbs.abs\n        val fracPartAbsAbs = fracPartAbs.abs\n        val intPartAbsAbsSign = intPartAbsAbs.sign\n        val fracPartAbsAbsSign = fracPartAbsAbs.sign\n        val intPartAbsAbsAbs = intPartAbsAbs.abs\n        val fracPartAbsAbsAbs = fracPartAbsAbs.abs\n        val intPartAbsAbsAbsSign = intPartAbsAbsAbs.sign\n        val fracPartAbsAbsAbsSign = fracPartAbsAbsAbs.sign\n        val intPartAbsAbsAbsAbs = intPartAbsAbsAbs.abs\n        val fracPartAbsAbsAbsAbs = fracPartAbsAbsAbs.abs\n        val intPartAbsAbsAbsAbsSign = intPartAbsAbsAbsAbs.sign\n        val fracPartAbsAbsAbsAbsSign = fracPartAbsAbsAbsAbs.sign\n        val intPartAbsAbsAbsAbsAbs = intPartAbsAbsAbsAbs.abs\n        val fracPartAbsAbsAbsAbsAbs = fracPartAbsAbsAbsAbs.abs\n        val intPartAbsAbsAbsAbsAbsSign = intPartAbsAbsAbsAbsAbs.sign\n        val fracPartAbsAbsAbsAbsAbsSign = fracPartAbsAbsAbsAbsAbs.sign\n        val intPartAbsAbsAbsAbsAbsAbs = intPartAbsAbsAbsAbsAbs.abs\n        val fracPartAbsAbsAbsAbsAbsAbs = fracPartAbsAbsAbsAbsAbs.abs\n        val intPartAbsAbsAbsAbsAbsAbsSign = intPartAbsAbsAbsAbsAbsAbs.sign\n        val fracPartAbsAbsAbsAbsAbsAbsSign = fracPartAbsAbsAbsAbsAbsAbs.sign\n        val intPartAbsAbsAbsAbsAbsAbsAbs = intPartAbs\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293215,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplelp_t9l.scala:20:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mintPart\u001b[0m = num.intPart\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value intPart is not a member of Double\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplelp_t9l.scala:21:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mfracPart\u001b[0m = num.fracPart\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value fracPart is not a member of Double\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmplelp_t9l.scala:49:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsShort = num.toShort\n        if (numAsShort.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsByte = num.toByte\n        if (numAsByte.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsLong = num.toLong\n        if (numAsLong.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsInt128 = num.toInt128\n        if (numAsInt128.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsInt256 = num.toInt256\n        if (numAsInt256.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsInt512 = num.toInt512\n        if (numAsInt512.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsInt1024 = num.toInt1024\n        if (numAsInt1024.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293217,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9cwczamf.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9cwczamf.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9cwczamf.scala:34:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9cwczamf.scala:38:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInteger\u001b[0m = num.toBigInteger\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigInteger is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9cwczamf.scala:43:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mif\u001b[0m (numAsShort.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Short.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsShort)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9cwczamf.scala:47:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m        \u001b[33mif\u001b[0m (numAsByte.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsChar = num.toChar\n        val numAsByte = num.toByte\n        val numAsShort = num.toShort\n        val numAsLong = num.toLong\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimalInt = num.toBigDecimalInt\n        val numAsBigDecimalLong = num.toBigDecimalLong\n        val numAsBigDecimalShort = num.toBigDecimalShort\n        val numAsBigDecimalByte = num.toBigDecimalByte\n        val numAsBigDecimalChar = num.toBigDecimalChar\n        val numAsBigDecimalFloat = num.toBigDecimalFloat\n        val numAsBigDecimalDouble = num.toBigDecimalDouble\n        val numAsBigDecimalString = num.toBigDecimalString\n        val numAsBigDecimalStringInt = num.toBigDecimalStringInt\n        val numAsBigDecimalStringLong = num.toBigDecimalStringLong\n        val numAsBigDecimalStringShort = num.toBigDecimalStringShort\n        val numAsBigDecimalStringByte = num.toBigDecimalStringByte\n        val numAsBigDecimalStringChar = num.toBigDecimalStringChar\n        val numAsBigDecimalStringFloat = num.toBigDecimalStringFloat\n        val numAsBigDecimalStringDouble = num.toBigDecimalStringDouble\n        val numAsBigDecimalStringString = num.toBigDecimalStringString\n        val numAsBigDecimalStringStringInt = num.toBigDecimalStringStringInt\n        val numAsBigDecimalStringStringLong = num.toBigDecimalStringStringLong\n        val numAsBigDecimalStringStringShort = num.toBigDecimalStringStringShort\n        val numAsBigDecimalStringStringByte = num.toBigDecimalStringStringByte\n        val numAsBigDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpy6keorlr.scala:52:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy6keorlr.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy6keorlr.scala:29:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy6keorlr.scala:30:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy6keorlr.scala:31:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalInt\u001b[0m = num.toBigDecimalInt\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value toBigDecimalInt is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy6keorlr.scala:32:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalLong\u001b[0m = num.toBigDecimalLong\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val nearest = abs.div(scala.math.BigInt(10)).floorDiv(scala.math.BigInt(10))\n            val diff = abs.subtract(nearest).div(scala.math.BigInt(10))\n            if (diff.abs().compareTo(scala.math.BigInt(0)) < 0) {\n                return nearest.subtract(scala.math.BigInt(1)).toLong\n            } else {\n                return nearest.toLong\n            }\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293217,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0ixlkg40.scala:21:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnearest\u001b[0m = abs.div(scala.math.BigInt(\u001b[31m10\u001b[0m)).floorDiv(scala.math.BigInt(\u001b[31m10\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0ixlkg40.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdiff\u001b[0m = abs.subtract(nearest).div(scala.math.BigInt(\u001b[31m10\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value subtract is not a member of Long\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            throw new RuntimeException(\"Invalid input: \" + value)\n        }\n        val numAsInt = num.intValue\n        val numAsFloat = num.floatValue\n        val numAsDouble = num.doubleValue\n        val numAsBigInt = num.bigInt\n        val numAsBigDecimal = num.bigDecimal\n        val numAsBigDecimalUnscaled = num.bigDecimalUnscaled\n        val numAsBigDecimalScale = num.bigDecimalScale\n        val numAsBigDecimalUnscaledAsDouble = num.bigDecimalUnscaledAsDouble\n        val numAsBigDecimalUnscaledAsFloat = num.bigDecimalUnscaledAsFloat\n        val numAsBigDecimalUnscaledAsInt = num.bigDecimalUnscaledAsInt\n        val numAsBigDecimalUnscaledAsLong = num.bigDecimalUnscaledAsLong\n        val numAsBigDecimalUnscaledAsShort = num.bigDecimalUnscaledAsShort\n        val numAsBigDecimalUnscaledAsString = num.bigDecimalUnscaledAsString\n        val numAsBigDecimalUnscaledAsBigInt = num.bigDecimalUnscaledAsBigInt\n        val numAsBigDecimalUnscaledAsBigDecimal = num.bigDecimalUnscaledAsBigDecimal\n        val numAsBigDecimalUnscaledAsBigDecimalUnscaled = num.bigDecimalUnscaledAsBigDecimalUnscaled\n        val numAsBigDecimalUnscaledAsBigDecimalScale = num.bigDecimalUnscaledAsBigDecimalScale\n        val numAsBigDecimalUnscaledAsBigDecimalUnscaledAsDouble = num.bigDecimalUnscaledAsBigDecimalUnscaledAsDouble\n        val numAsBigDecimalUnscaledAsBigDecimalUnscaledAsFloat = num.bigDecimalUnscaledAsBigDecimalUnscaledAsFloat\n        val numAsBigDecimalUnscaledAsBigDecimalUnscaledAsInt = num.bigDecimalUnscaledAsBigDecimalUnscaledAsInt\n        val numAs\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmppjj5llja.scala:43:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppjj5llja.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppjj5llja.scala:25:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.bigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value bigInt is not a member of Long - did you mean num.toInt?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppjj5llja.scala:26:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.bigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue bigDecimal is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppjj5llja.scala:27:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalUnscaled\u001b[0m = num.bigDecimalUnscaled\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value bigDecimalUnscaled is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppjj5llja.scala:28:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalScale\u001b[0m = num.bigDecimalScale\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val abs = num.abs\n        if (abs.isNaN) {\n            return 0l\n        }\n        val abs_int = abs.toInt\n        if (abs_int.isNaN) {\n            return 0l\n        }\n        val abs_long = abs_int.toLong\n        if (abs_long.isNaN) {\n            return 0l\n        }\n        val abs_float = abs_long.toFloat\n        if (abs_float.isNaN) {\n            return 0l\n        }\n        val abs_double = abs_float.toDouble\n        if (abs_double.isNaN) {\n            return 0l\n        }\n        val abs_big_int = abs_double.toBigInt\n        if (abs_big_int.isNaN) {\n            return 0l\n        }\n        val abs_big_long = abs_big_int.toBigLong\n        if (abs_big_long.isNaN) {\n            return 0l\n        }\n        val abs_big_float = abs_big_long.toBigFloat\n        if (abs_big_float.isNaN) {\n            return 0l\n        }\n        val abs_big_double = abs_big_float.toBigDouble\n        if (abs_big_double.isNaN) {\n            return 0l\n        }\n        val abs_big_big_int = abs_big_double.toBigInt\n        if (abs_big_big_int.isNaN) {\n            return 0l\n        }\n        val abs_big_big_long = abs_big_big_int.toBigLong\n        if (abs_big_big_long.isNaN) {\n            return 0l\n        }\n        val abs_big_big_float = abs_big_big_long.toBigFloat\n        if (abs_big_big_float.isNaN) {\n            return 0l\n        }\n        val abs_big_big_double = abs_big_big_float.toBigDouble\n\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293190,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj_kr5y5v.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj_kr5y5v.scala:23:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (abs.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(abs)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj_kr5y5v.scala:27:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mif\u001b[0m (abs_int.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(abs_int)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj_kr5y5v.scala:31:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mif\u001b[0m (abs_long.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(abs_long)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj_kr5y5v.scala:42:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mabs_big_int\u001b[0m = abs_double.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Double, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDeci",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            return numAsInt\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return numAsFloat\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return numAsDouble\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return numAsBigDecimal\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            return numAsBigInteger\n        }\n        val numAsLong = num.toLong\n        if (numAsLong.isNaN) {\n            return numAsLong\n        }\n        val numAsIntAsLong = numAsInt.toLong\n        if (numAsIntAsLong.isNaN) {\n            return numAsIntAsLong\n        }\n        val numAsFloatAsLong = numAsFloat.toLong\n        if (numAsFloatAsLong.isNaN) {\n            return numAsFloatAsLong\n        }\n        val numAsDoubleAsLong = numAsDouble.toLong\n        if (numAsDoubleAsLong.isNaN) {\n            return numAsDoubleAsLong\n        }\n        val numAsBigDecimalAsLong = numAsBigDecimal.toLong\n        if (numAsBigDecimalAsLong.isNaN) {\n            return numAsBigDecimalAsLong\n        }\n        val numAsBigIntegerAsLong = numAsBigInteger.toLong\n        if (numAsBigIntegerAsLong.isNaN) {\n            return numAsBigIntegerAsLong\n        }\n        val numAsLongAsLong = numAsLong.toLong\n        if (numAsLongAsLong.isNaN) {\n            return numAsLongAsLong\n        }\n        val numAsIntAsLongAsLong = numAsIntAsLong.\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293208,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpupqz3feg.scala:71:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpupqz3feg.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpupqz3feg.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(numAsInt)\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpupqz3feg.scala:28:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsFloat\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsFloat : Float)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpupqz3feg.scala:32:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsDouble\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsDouble : Double)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpupqz3feg.scala:34:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsDouble = num.toDouble\n        val numAsFloat = num.toFloat\n        val numAsShort = num.toShort\n        val numAsByte = num.toByte\n        val numAsChar = num.toChar\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpx291hn45.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpx291hn45.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpx291hn45.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpx291hn45.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpx291hn45.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimalWithScale = num.toBigDecimal(2)\n        val numAsBigDecimalWithScaleAndPrecision = num.toBigDecimal(2, 2)\n        val numAsBigDecimalWithPrecision = num.toBigDecimal(2)\n        val numAsBigDecimalWithPrecisionAndScale = num.toBigDecimal(2, 2)\n        val numAsBigDecimalWithScaleAndPrecisionAndRoundingMode = num.toBigDecimal(2, 2, RoundingMode.HALF_UP)\n        val numAsBigDecimalWithPrecisionAndRoundingMode = num.toBigDecimal(2, RoundingMode.HALF_UP)\n        val numAsBigDecimalWithScaleAndRoundingMode = num.toBigDecimal(2, RoundingMode.HALF_UP)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingMode = num.toBigDecimal(2, 2, RoundingMode.HALF_UP)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingModeAndOption = num.toBigDecimal(2, 2, RoundingMode.HALF_UP, Option.empty)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingModeAndOption = num.toBigDecimal(2, 2, RoundingMode.HALF_UP, Option.empty)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingModeAndOption = num.toBigDecimal(2, 2, RoundingMode.HALF_UP, Option.empty)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingModeAndOption = num.toBigDecimal(2, 2, RoundingMode.HALF_UP, Option.empty)\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfrmqkhrr.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalWithPrecisionAndScaleAndRoundingModeAndOption\u001b[0m = num.toBigDecimal(\u001b[31m2\u001b[0m, \u001b[31m2\u001b[0m, RoundingMode.HALF_UP, Option.empty)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimalWithPrecisionAndScaleAndRoundingModeAndOption is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimalWithPrecisionAndScaleAndRoundingModeAndOption\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfrmqkhrr.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalWithPrecisionAndScaleAndRoundingModeAndOption\u001b[0m = num.toBigDecimal(\u001b[31m2\u001b[0m, \u001b[31m2\u001b[0m, RoundingMode.HALF_UP, Option.empty)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimalWithPrecisionAndScaleAndRoundingModeAndOption is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimalWithPrecisionAndScaleAndRoundingModeAndOption\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfrmqkhrr.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalWithPrecisionAndScaleAndRoundingModeAndOption\u001b[0m = num.toBigDecimal(\u001b[31m2\u001b[0m, \u001b[31m2\u001b[0m, RoundingMode.HALF_UP, Option.empty)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimalWithPrecisionAndScaleAndRoundingModeAndOption is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimalWithP",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            return -num\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpp5jr_wxg.scala:18)\n\tat Problem$.main(tmpp5jr_wxg.scala:27)\n\tat Problem.main(tmpp5jr_wxg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val abs = num.abs\n        val rounded = abs.round(10)\n        if (abs.equals(rounded)) {\n            return rounded.toLong\n        } else {\n            return abs.toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293215,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqtsmo658.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpqtsmo658.scala:23:26 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrounded\u001b[0m = abs.round(\u001b[31m10\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 \u001b[33mmethod\u001b[0m \u001b[35mround\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mRichLong\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimalWithScale = num.toBigDecimal(2)\n        val numAsBigDecimalWithScale2 = num.toBigDecimal(2, 2)\n        val numAsBigDecimalWithScale3 = num.toBigDecimal(2, 2, 2)\n        val numAsBigDecimalWithScale4 = num.toBigDecimal(2, 2, 2, 2)\n        val numAsBigDecimalWithScale5 = num.toBigDecimal(2, 2, 2, 2, 2)\n        val numAsBigDecimalWithScale6 = num.toBigDecimal(2, 2, 2, 2, 2, 2)\n        val numAsBigDecimalWithScale7 = num.toBigDecimal(2, 2, 2, 2, 2, 2, 2)\n        val numAsBigDecimalWithScale8 = num.toBigDecimal(2, 2, 2, 2, 2, 2, 2, 2)\n        val numAsBigDecimalWithScale9 = num.toBigDecimal(2, 2, 2, 2, 2, 2, 2, 2, 2)\n        val numAsBigDecimalWithScale10 = num.toBigDecimal(2, 2, 2, 2, 2, 2, 2, 2, 2, 2)\n        val numAsBigDecimalWithScale11 = num.toBigDecimal(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2)\n        val numAsBigDecimalWithScale12 = num.toBigDecimal(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2)\n        val numAsBigDecimalWithScale13 = num.toBigDecimal(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293188,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpffqb5fgy.scala:40:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpffqb5fgy.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpffqb5fgy.scala:25:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpffqb5fgy.scala:26:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpffqb5fgy.scala:27:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalWithScale\u001b[0m = num.toBigDecimal(\u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpffqb5fgy.scala:28:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalWithScale2\u001b[0m = num.toBigDecimal(\u001b[31m2\u001b[0m, \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^^^^^^^^\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val intPart = abs.intPart\n            val fracPart = abs.fracPart\n            val frac = fracPart.toDouble\n            val rounded = intPart + frac\n            val diff = abs.subtract(rounded)\n            if (diff.compareTo(frac) < 0) {\n                return rounded\n            } else {\n                return rounded.add(1)\n            }\n        } else {\n            val abs = Math.abs(num)\n            val intPart = abs.intPart\n            val fracPart = abs.fracPart\n            val frac = fracPart.toDouble\n            val rounded = intPart + frac\n            val diff = abs.subtract(rounded)\n            if (diff.compareTo(frac) < 0) {\n                return rounded\n            } else {\n                return rounded.subtract(1)\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp33huu48k.scala:21:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mintPart\u001b[0m = abs.intPart\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value intPart is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp33huu48k.scala:22:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfracPart\u001b[0m = abs.fracPart\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value fracPart is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp33huu48k.scala:25:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdiff\u001b[0m = abs.subtract(rounded)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp33huu48k.scala:33:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mintPart\u001b[0m = abs.intPart\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value intPart is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp33huu48k.scala:34:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfracPart\u001b[0m = abs.fracPart\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value fracPart is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp33huu48k.scala:37:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdiff\u001b[0m = abs.subtract(rounded)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value subtract is not a member of Long\n6 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(1)\n            val ceil = abs.ceilDiv(1)\n            val diff = abs.subtract(floor).abs\n            if (diff.compareTo(ceil) < 0)\n                return num.subtract(floor)\n            else\n                return num.subtract(ceil)\n        } else {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(1)\n            val ceil = abs.ceilDiv(1)\n            val diff = abs.subtract(floor).abs\n            if (diff.compareTo(ceil) < 0)\n                return num.add(floor)\n            else\n                return num.add(ceil)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprz7ooat4.scala:21:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprz7ooat4.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceilDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprz7ooat4.scala:23:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdiff\u001b[0m = abs.subtract(floor).abs\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprz7ooat4.scala:25:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                \u001b[33mreturn\u001b[0m num.subtract(floor)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprz7ooat4.scala:27:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                \u001b[33mreturn\u001b[0m num.subtract(ceil)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprz7ooat4.scala:30:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprz7ooat4.scala:31:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m              ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val abs = num.abs\n        val floor = num.floor\n        val ceil = num.ceil\n        val diff = abs.subtract(floor).abs\n        if (diff.isNaN) {\n            return floor\n        }\n        val half = diff.div(2).toInt\n        if (half.isNaN) {\n            return floor\n        }\n        val diff2 = abs.subtract(ceil).abs\n        if (diff2.isNaN) {\n            return ceil\n        }\n        val half2 = diff2.div(2).toInt\n        if (half2.isNaN) {\n            return ceil\n        }\n        if (half2.toInt > half.toInt) {\n            return floor\n        } else {\n            return ceil\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293220,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm4o5v03y.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm4o5v03y.scala:23:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = num.floor\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value floor is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          floatWrapper(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm4o5v03y.scala:24:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = num.ceil\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value ceil is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          floatWrapper(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm4o5v03y.scala:25:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mdiff\u001b[0m = abs.subtract(floor).abs\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm4o5v03y.scala:33:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mdiff2\u001b[0m = abs.subtract(ceil).abs\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value subtract is not a member of Long\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            return -num\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpp5jr_wxg.scala:18)\n\tat Problem$.main(tmpp5jr_wxg.scala:27)\n\tat Problem.main(tmpp5jr_wxg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val max = abs.max\n            val min = abs.min\n            val diff = max - min\n            val diffAbs = diff.abs\n            val diffAbsMin = diffAbs.min\n            val diffAbsMax = diffAbs.max\n            val diffAbsMinMax = diffAbsMin.max\n            val diffAbsMaxMin = diffAbsMax.min\n            val diffAbsMaxMinMax = diffAbsMaxMin.max\n            val diffAbsMaxMinMaxMin = diffAbsMaxMinMax.min\n            val diffAbsMaxMinMaxMinMax = diffAbsMaxMinMaxMin.max\n            val diffAbsMaxMinMaxMinMaxMin = diffAbsMaxMinMaxMinMax.min\n            val diffAbsMaxMinMaxMinMaxMinMax = diffAbsMaxMinMaxMinMaxMin.max\n            val diffAbsMaxMinMaxMinMaxMinMaxMin = diffAbsMaxMinMaxMinMaxMinMax.min\n            val diffAbsMaxMinMaxMinMaxMinMaxMinMax = diffAbsMaxMinMaxMinMaxMinMaxMin.max\n            val diffAbsMaxMinMaxMinMaxMinMaxMinMaxMin = diffAbsMaxMinMaxMinMaxMinMaxMinMax.min\n            val diffAbsMaxMinMaxMinMaxMinMaxMinMaxMinMax = diffAbsMaxMinMaxMinMaxMinMaxMinMaxMin.max\n            val diffAbsMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = diffAbsMaxMinMaxMinMaxMinMaxMinMaxMinMax.min\n            val diffAbsMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = diffAbsMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin.max\n            val diffAbsMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = diffAbsMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax.min\n            val diffAbsMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = diffAbsMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin.max\n            val diffAbsMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = diffAbsMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin.min\n            val diffAbsMaxMinMaxMinMaxMinMax\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4mk9azry.scala:44:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4mk9azry.scala:54:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4mk9azry.scala:23:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdiff\u001b[0m = max - min\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue - is not a member of Long => Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4mk9azry.scala:53:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmp4mk9azry.scala:45:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m45 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return num\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            return numAsInt\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return numAsFloat\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return numAsDouble\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return numAsBigDecimal\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            return numAsBigInteger\n        }\n        val numAsLong = num.toLong\n        if (numAsLong.isNaN) {\n            return numAsLong\n        }\n        val numAsIntAsLong = numAsInt.toLong\n        if (numAsIntAsLong.isNaN) {\n            return numAsIntAsLong\n        }\n        val numAsFloatAsLong = numAsFloat.toLong\n        if (numAsFloatAsLong.isNaN) {\n            return numAsFloatAsLong\n        }\n        val numAsDoubleAsLong = numAsDouble.toLong\n        if (numAsDoubleAsLong.isNaN) {\n            return numAsDoubleAsLong\n        }\n        val numAsBigDecimalAsLong = numAsBigDecimal.toLong\n        if (numAsBigDecimalAsLong.isNaN) {\n            return numAsBigDecimalAsLong\n        }\n        val numAsBigIntegerAsLong = numAsBigInteger.toLong\n        if (numAsBigIntegerAsLong.isNaN) {\n            return numAsBigIntegerAsLong\n        }\n        val numAsLongAsLong = numAsLong.toLong\n        if (numAsLongAsLong.isNaN) {\n            return numAsLongAsLong\n        }\n        val numAsIntAsLongAsLong = numAsIntAsLong.to\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmqoxf0jd.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmqoxf0jd.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsInt)\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmqoxf0jd.scala:28:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsFloat\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsFloat : Float)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmqoxf0jd.scala:32:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsDouble\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsDouble : Double)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmqoxf0jd.scala:34:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmqoxf0jd.scala:38:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsLong = num.toLong\n        if (numAsLong.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsIntAsLong = numAsInt.toLong\n        if (numAsIntAsLong.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsFloatAsLong = numAsFloat.toLong\n        if (numAsFloatAsLong.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsDoubleAsLong = numAsDouble.toLong\n        if (numAsDoubleAsLong.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimalAsLong = numAsBigDecimal.toLong\n        if (numAsBigDecimalAsLong.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigIntegerAsLong = numAsBigInteger.toLong\n        if (numAsBigIntegerAsLong.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsLongAsInt = numAsLong.\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293215,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpebxepf2t.scala:67:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpebxepf2t.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpebxepf2t.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpebxepf2t.scala:34:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpebxepf2t.scala:38:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInteger\u001b[0m = num.toBigInteger\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigInteger is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpebxepf2t.scala:43:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mif\u001b[0m (numAsLong.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numA",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        val abs = Math.abs(num)\n        val intPart = num / abs\n        val fracPart = num % abs\n        val rounded = intPart + (fracPart > 0.5 ? 1 : 0)\n        return rounded\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6wbkq911.scala:22:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrounded\u001b[0m = intPart + (fracPart > \u001b[31m0.5\u001b[0m ? \u001b[31m1\u001b[0m : \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       value ? is not a member of Double\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            return -num\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpp5jr_wxg.scala:18)\n\tat Problem$.main(tmpp5jr_wxg.scala:27)\n\tat Problem.main(tmpp5jr_wxg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsLong = num.toLong\n        if (numAsLong.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsShort = num.toShort\n        if (numAsShort.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsByte = num.toByte\n        if (numAsByte.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsFloatWrapper = num.toFloatWrapper\n        if (numAsFloatWrapper.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsDoubleWrapper = num.toDoubleWrapper\n        if (numAsDoubleWrapper.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimalWrapper = num.toBigDecimalWrapper\n        if (numAsBigDecimalWrapper.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigIntegerWrapper = num.toBigIntegerWrapper\n        if (numAsBigIntegerWrapper.\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqw74h4ut.scala:68:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqw74h4ut.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqw74h4ut.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(numAsInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqw74h4ut.scala:34:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqw74h4ut.scala:38:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInteger\u001b[0m = num.toBigInteger\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigInteger is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqw74h4ut.scala:43:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mif\u001b[0m (numAsLong.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Doubl",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimalWithScale = num.toBigDecimal(2)\n        val numAsBigDecimalWithScale2 = num.toBigDecimal(2, 2)\n        val numAsBigDecimalWithScale3 = num.toBigDecimal(2, 2, 2)\n        val numAsBigDecimalWithScale4 = num.toBigDecimal(2, 2, 2, 2)\n        val numAsBigDecimalWithScale5 = num.toBigDecimal(2, 2, 2, 2, 2)\n        val numAsBigDecimalWithScale6 = num.toBigDecimal(2, 2, 2, 2, 2, 2)\n        val numAsBigDecimalWithScale7 = num.toBigDecimal(2, 2, 2, 2, 2, 2, 2)\n        val numAsBigDecimalWithScale8 = num.toBigDecimal(2, 2, 2, 2, 2, 2, 2, 2)\n        val numAsBigDecimalWithScale9 = num.toBigDecimal(2, 2, 2, 2, 2, 2, 2, 2, 2)\n        val numAsBigDecimalWithScale10 = num.toBigDecimal(2, 2, 2, 2, 2, 2, 2, 2, 2, 2)\n        val numAsBigDecimalWithScale11 = num.toBigDecimal(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2)\n        val numAsBigDecimalWithScale12 = num.toBigDecimal(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2)\n        val numAsBigDecimalWithScale13 = num.toBigDecimal(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293188,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpffqb5fgy.scala:40:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpffqb5fgy.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpffqb5fgy.scala:25:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpffqb5fgy.scala:26:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpffqb5fgy.scala:27:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalWithScale\u001b[0m = num.toBigDecimal(\u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpffqb5fgy.scala:28:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalWithScale2\u001b[0m = num.toBigDecimal(\u001b[31m2\u001b[0m, \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^^^^^^^^\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val abs = num.abs\n        if (abs.isNaN) {\n            return 0l\n        }\n        val absInt = abs.toInt\n        if (absInt.isNaN) {\n            return 0l\n        }\n        val absIntPlusOne = absInt + 1\n        if (absIntPlusOne.isNaN) {\n            return 0l\n        }\n        val absIntMinusOne = absInt - 1\n        if (absIntMinusOne.isNaN) {\n            return 0l\n        }\n        val absIntPlusOneHalf = absIntPlusOne / 2\n        if (absIntPlusOneHalf.isNaN) {\n            return 0l\n        }\n        val absIntMinusOneHalf = absIntMinusOne / 2\n        if (absIntMinusOneHalf.isNaN) {\n            return 0l\n        }\n        if (num.compareTo(absIntPlusOneHalf) < 0) {\n            return absIntMinusOneHalf\n        } else {\n            return absIntPlusOneHalf\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplqvant2f.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplqvant2f.scala:23:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (abs.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(abs)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplqvant2f.scala:27:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mif\u001b[0m (absInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(absInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplqvant2f.scala:31:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mif\u001b[0m (absIntPlusOne.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(absIntPlusOne)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplqvant2f.scala:35:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mif\u001b[0m (absIntMinusOne.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(absIntMinusOne)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val max = Math.max(abs, 1)\n            val min = Math.min(abs, 1)\n            val diff = max - min\n            val diff2 = diff / 2\n            val diff3 = diff2 / 2\n            val diff4 = diff3 / 2\n            val diff5 = diff4 / 2\n            val diff6 = diff5 / 2\n            val diff7 = diff6 / 2\n            val diff8 = diff7 / 2\n            val diff9 = diff8 / 2\n            val diff10 = diff9 / 2\n            val diff11 = diff10 / 2\n            val diff12 = diff11 / 2\n            val diff13 = diff12 / 2\n            val diff14 = diff13 / 2\n            val diff15 = diff14 / 2\n            val diff16 = diff15 / 2\n            val diff17 = diff16 / 2\n            val diff18 = diff17 / 2\n            val diff19 = diff18 / 2\n            val diff20 = diff19 / 2\n            val diff21 = diff20 / 2\n            val diff22 = diff21 / 2\n            val diff23 = diff22 / 2\n            val diff24 = diff23 / 2\n            val diff25 = diff24 / 2\n            val diff26 = diff25 / 2\n            val diff27 = diff26 / 2\n            val diff28 = diff27 / 2\n            val diff29 = diff28 / 2\n            val diff30 = diff29 / 2\n            val diff31 = diff30 / 2\n            val diff32 = diff31 / 2\n            val diff33 = diff32 / 2\n            val diff34 = diff33 / 2\n            val diff35 = diff34 / 2\n            val diff36 = diff35 / 2\n            val diff37 = diff36 / 2\n            val diff38 = diff37 / 2\n            val diff39 = diff38 / 2\n            val diff40 = diff39 / 2\n            val diff41 = diff40 / 2\n            val diff42 = diff41 / 2\n            val diff43 = diff42 / 2\n            val diff44 = diff43 / 2\n            val diff45 = diff44 / 2\n            val diff46 = diff45 / 2\n\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpixb3ukz7.scala:80:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpixb3ukz7.scala:79:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpixb3ukz7.scala:71:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m71 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            return -num\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpp5jr_wxg.scala:18)\n\tat Problem$.main(tmpp5jr_wxg.scala:27)\n\tat Problem.main(tmpp5jr_wxg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            return num\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return num\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return num\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return num\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            return num\n        }\n        val numAsBigDecimalAsBigInteger = num.toBigDecimal.toBigInteger\n        if (numAsBigDecimalAsBigInteger.isNaN) {\n            return num\n        }\n        val numAsBigIntegerAsBigDecimal = num.toBigInteger.toBigDecimal\n        if (numAsBigIntegerAsBigDecimal.isNaN) {\n            return num\n        }\n        val numAsBigIntegerAsBigInteger = num.toBigInteger.toBigInteger\n        if (numAsBigIntegerAsBigInteger.isNaN) {\n            return num\n        }\n        val numAsBigIntegerAsBigIntegerAsBigDecimal = num.toBigInteger.toBigInteger.toBigDecimal\n        if (numAsBigIntegerAsBigIntegerAsBigDecimal.isNaN) {\n            return num\n        }\n        val numAsBigIntegerAsBigIntegerAsBigInteger = num.toBigInteger.toBigInteger.toBigInteger\n        if (numAsBigIntegerAsBigIntegerAsBigInteger.isNaN) {\n            return num\n        }\n        val numAsBigIntegerAsBigIntegerAsBigIntegerAsBigDecimal = num.toBigInteger.toBigInteger.toBigInteger.toBigDecimal\n        if (numAsBigIntegerAsBigIntegerAsBigIntegerAsBigDecimal.isNaN) {\n            return num\n        }\n        val numAs\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293227,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpi6telcpf.scala:67:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi6telcpf.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi6telcpf.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(numAsInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi6telcpf.scala:34:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi6telcpf.scala:38:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInteger\u001b[0m = num.toBigInteger\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigInteger is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi6telcpf.scala:42:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalAsBigInteger\u001b[0m = num.toBigDecimal.toBigInteger\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val abs = num.abs\n        if (abs.isNaN) {\n            return 0l\n        }\n        val absInt = abs.toInt\n        if (absInt.isNaN) {\n            return 0l\n        }\n        val absIntPlusOne = absInt + 1\n        if (absIntPlusOne.isNaN) {\n            return 0l\n        }\n        val absIntMinusOne = absInt - 1\n        if (absIntMinusOne.isNaN) {\n            return 0l\n        }\n        val absIntPlusOneHalf = absIntPlusOne / 2\n        if (absIntPlusOneHalf.isNaN) {\n            return 0l\n        }\n        val absIntMinusOneHalf = absIntMinusOne / 2\n        if (absIntMinusOneHalf.isNaN) {\n            return 0l\n        }\n        val absIntPlusOneHalfInt = absIntPlusOneHalf.toInt\n        if (absIntPlusOneHalfInt.isNaN) {\n            return 0l\n        }\n        val absIntMinusOneHalfInt = absIntMinusOneHalf.toInt\n        if (absIntMinusOneHalfInt.isNaN) {\n            return 0l\n        }\n        val absIntPlusOneHalfIntPlusOne = absIntPlusOneHalfInt + 1\n        if (absIntPlusOneHalfIntPlusOne.isNaN) {\n            return 0l\n        }\n        val absIntMinusOneHalfIntMinusOne = absIntMinusOneHalfInt - 1\n        if (absIntMinusOneHalfIntMinusOne.isNaN) {\n            return 0l\n        }\n        val absIntPlusOneHalfIntPlusOneHalf = absIntPlusOneHalfInt + 1 / 2\n        if (absIntPlusOneHalfIntPlusOneHalf.isNaN) {\n            return 0l\n        }\n        val absIntMinusOneHalfIntMinusOneHalf = absIntMinusOneHalfInt - 1 / 2\n        if (absIntMinusOneHalfIntMinusOneHalf.isNaN\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293170,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzk3wz97g.scala:68:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzk3wz97g.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzk3wz97g.scala:23:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (abs.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(abs)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzk3wz97g.scala:27:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mif\u001b[0m (absInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(absInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzk3wz97g.scala:31:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mif\u001b[0m (absIntPlusOne.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(absIntPlusOne)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzk3wz97g.scala:35:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mif\u001b[0m (absIntMinusOne.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            return -num\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpp5jr_wxg.scala:18)\n\tat Problem$.main(tmpp5jr_wxg.scala:27)\n\tat Problem.main(tmpp5jr_wxg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            throw new IllegalArgumentException(\"Invalid number: \" + value)\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigInteger = num.toBigInteger\n        val numAsByte = num.toByte\n        val numAsShort = num.toShort\n        val numAsInteger = num.toInt\n        val numAsLong = num.toLong\n        val numAsFloatAsDouble = num.toFloat.toDouble\n        val numAsFloatAsBigDecimal = num.toFloat.toBigDecimal\n        val numAsFloatAsBigInteger = num.toFloat.toBigInteger\n        val numAsFloatAsByte = num.toFloat.toByte\n        val numAsFloatAsShort = num.toFloat.toShort\n        val numAsFloatAsInteger = num.toFloat.toInt\n        val numAsFloatAsLong = num.toFloat.toLong\n        val numAsDoubleAsBigDecimal = num.toDouble.toBigDecimal\n        val numAsDoubleAsBigInteger = num.toDouble.toBigInteger\n        val numAsDoubleAsByte = num.toDouble.toByte\n        val numAsDoubleAsShort = num.toDouble.toShort\n        val numAsDoubleAsInteger = num.toDouble.toInt\n        val numAsDoubleAsLong = num.toDouble.toLong\n        val numAsBigDecimalAsBigInteger = num.toBigDecimal.toBigInteger\n        val numAsBigDecimalAsByte = num.toBigDecimal.toByte\n        val numAsBigDecimalAsShort = num.toBigDecimal.toShort\n        val numAsBigDecimalAsInteger = num.toBigDecimal.toInt\n        val numAsBigDecimalAsLong = num.toBigDecimal.toLong\n        val numAsBigIntegerAsBigDecimal = num.toBigInteger.toBigDecimal\n        val numAsBigIntegerAsByte = num.toBigInteger.toByte\n        val numAsBigInteger\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293229,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgd7e5_kl.scala:52:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgd7e5_kl.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgd7e5_kl.scala:25:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgd7e5_kl.scala:26:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInteger\u001b[0m = num.toBigInteger\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigInteger is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgd7e5_kl.scala:32:49 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsFloatAsBigDecimal\u001b[0m = num.toFloat.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             value toBigDecimal is not a member of Float\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgd7e5_kl.scala:33:49 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsFloatAsBigInteger\u001b[0m = num.toFloat.toBigInteger\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             value toBigInteger is not a member of Float\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgd7e5_kl.scala:38:51 ---------------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimalUnscaled = num.toBigDecimalUnscaled\n        val numAsBigDecimalScale = num.toBigDecimalScale\n        val numAsBigDecimalString = num.toBigDecimalString\n        val numAsBigDecimalStringUnscaled = num.toBigDecimalStringUnscaled\n        val numAsBigDecimalStringScale = num.toBigDecimalStringScale\n        val numAsBigDecimalStringUnscaledFraction = num.toBigDecimalStringUnscaledFraction\n        val numAsBigDecimalStringScaleFraction = num.toBigDecimalStringScaleFraction\n        val numAsBigDecimalStringUnscaledFractionFraction = num.toBigDecimalStringUnscaledFractionFraction\n        val numAsBigDecimalStringScaleFractionFraction = num.toBigDecimalStringScaleFractionFraction\n        val numAsBigDecimalStringUnscaledFractionFractionFraction = num.toBigDecimalStringUnscaledFractionFractionFraction\n        val numAsBigDecimalStringScaleFractionFractionFraction = num.toBigDecimalStringScaleFractionFractionFraction\n        val numAsBigDecimalStringUnscaledFractionFractionFractionFraction = num.toBigDecimalStringUnscaledFractionFractionFractionFraction\n        val numAsBigDecimalStringScaleFractionFractionFractionFraction = num.toBigDecimalStringScaleFractionFractionFractionFraction\n        val numAsBigDecimalStringUnscaledFractionFractionFractionFractionFraction = num.toBigDecimalStringUnscaledFractionFractionFractionFractionFraction\n        val numAsBigDecimalStringScaleFractionFractionFractionFractionFraction = num.toBigDecimalStringScaleFractionFractionFractionF\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293233,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqnc3kegu.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqnc3kegu.scala:25:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqnc3kegu.scala:26:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqnc3kegu.scala:27:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalUnscaled\u001b[0m = num.toBigDecimalUnscaled\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value toBigDecimalUnscaled is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqnc3kegu.scala:28:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalScale\u001b[0m = num.toBigDecimalScale\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         value toBigDecimalScale is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqnc3kegu.scala:29:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsChar = num.toChar\n        val numAsShort = num.toShort\n        val numAsByte = num.toByte\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimalInt = num.toBigDecimalInt\n        val numAsBigDecimalLong = num.toBigDecimalLong\n        val numAsBigDecimalShort = num.toBigDecimalShort\n        val numAsBigDecimalByte = num.toBigDecimalByte\n        val numAsBigDecimalChar = num.toBigDecimalChar\n        val numAsBigDecimalFloat = num.toBigDecimalFloat\n        val numAsBigDecimalDouble = num.toBigDecimalDouble\n        val numAsBigDecimalString = num.toBigDecimalString\n        val numAsBigDecimalStringInt = num.toBigDecimalStringInt\n        val numAsBigDecimalStringLong = num.toBigDecimalStringLong\n        val numAsBigDecimalStringShort = num.toBigDecimalStringShort\n        val numAsBigDecimalStringByte = num.toBigDecimalStringByte\n        val numAsBigDecimalStringChar = num.toBigDecimalStringChar\n        val numAsBigDecimalStringFloat = num.toBigDecimalStringFloat\n        val numAsBigDecimalStringDouble = num.toBigDecimalStringDouble\n        val numAsBigDecimalStringString = num.toBigDecimalStringString\n        val numAsBigDecimalStringStringInt = num.toBigDecimalStringStringInt\n        val numAsBigDecimalStringStringLong = num.toBigDecimalStringStringLong\n        val numAsBigDecimalStringStringShort = num.toBigDecimalStringStringShort\n        val numAsBigDecimalStringStringByte = num.toBigDecimalStringStringByte\n        val numAsBigDecimalStringStringChar = num.toBigDecimalString\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293235,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2nq49hys.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2nq49hys.scala:28:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2nq49hys.scala:29:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2nq49hys.scala:30:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalInt\u001b[0m = num.toBigDecimalInt\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value toBigDecimalInt is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2nq49hys.scala:31:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalLong\u001b[0m = num.toBigDecimalLong\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value toBigDecimalLong is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2nq49hys.scala:32:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDeci",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (num.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsInt.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsDouble.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsFloat.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsShort = num.toShort\n        if (numAsShort.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsShort.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsByte = num.toByte\n        if (numAsByte.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsByte.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsChar = num.toChar\n        if (numAsChar.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsChar.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsBigInt = num.toBigInt\n        if (numAsBigInt.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsBigInt.isInfinite) {\n            throw new NumberFormatException(\"Inf\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293223,
      "stdout": "error while checking \u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[31mnull\u001b[0m)\nerror while checking \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[31mnull\u001b[0m)\nerror while checking {\n  \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[31mnull\u001b[0m)\n}\nerror while checking \u001b[33mif \u001b[0m(numAsBigInt.isInfinite) \n  {\n    \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[31mnull\u001b[0m)\n  }\nerror while checking {\n  \u001b[33mval\u001b[0m \u001b[36mnum\u001b[0m = value.toLong\n  \u001b[33mif \u001b[0m(num.isNaN) \n    {\n      \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[32m\"NaN\"\u001b[0m)\n    }\n  \u001b[33mif \u001b[0m(num.isInfinite) \n    {\n      \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[32m\"Infinity\"\u001b[0m)\n    }\n  \u001b[33mval\u001b[0m \u001b[36mnumAsInt\u001b[0m = num.toInt\n  \u001b[33mif \u001b[0m(numAsInt.isNaN) \n    {\n      \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[32m\"NaN\"\u001b[0m)\n    }\n  \u001b[33mif \u001b[0m(numAsInt.isInfinite) \n    {\n      \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[32m\"Infinity\"\u001b[0m)\n    }\n  \u001b[33mval\u001b[0m \u001b[36mnumAsDouble\u001b[0m = num.toDouble\n  \u001b[33mif \u001b[0m(numAsDouble.isNaN) \n    {\n      \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[32m\"NaN\"\u001b[0m)\n    }\n  \u001b[33mif \u001b[0m(numAsDouble.isInfinite) \n    {\n      \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[32m\"Infinity\"\u001b[0m)\n    }\n  \u001b[33mval\u001b[0m \u001b[36mnumAsFloat\u001b[0m = num.toFloat\n  \u001b[33mif \u001b[0m(numAsFloat.isNaN) \n    {\n      \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[32m\"NaN\"\u001b[0m)\n    }\n  \u001b[33mif \u001b[0m(numAsFloat.isInfinite) \n    {\n      \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[32m\"Infinity\"\u001b[0m)\n    }\n  \u001b[33mval\u001b[0m \u001b[36mnumAsShort\u001b[0m = num.toShort\n  \u001b[33mif \u001b[0m(numAsShort.isNaN) \n    {\n      \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[32m\"NaN\"\u001b[0m)\n    }\n  \u001b[33mif \u001b[0m(numAsShort.isInfinite) \n    {\n      \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[32m\"Infinity\"\u001b[0m)\n    }\n  \u001b[33mval\u001b[0m \u001b[36mnumAsByte\u001b[0m = num.toByte\n  \u001b[33mif \u001b[0m(n",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpnf2dufpy.scala:72:44 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m            \u001b[33mthrow\u001b[0m \u001b[33mnew\u001b[0m \u001b[35mNumberFormatException\u001b[0m(\"Inf\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            unclosed string literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmpnf2dufpy.scala:74:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 end of statement expected but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpnf2dufpy.scala:83:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\nexception occurred while parser /tmp/tmpnf2dufpy.scala\nexception occurred while compiling /tmp/tmpnf2dufpy.scala\nException in thread \"main\" java.lang.AssertionError: assertion failed: position error, parent span does not contain child span\nparent      = \u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[31mnull\u001b[0m) # -1,\nparent span = <2522..2552>,\nchild       = \u001b[31mnull\u001b[0m # -1,\nchild span  = [2548..2557..2557]\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:8)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:172)\n\tat dotty.tools.dotc.ast.Positioned.check$1$$anonfun$3(Positioned.scala:202)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)\n\tat scala.collection.immutable.List.foreach(List.scala:333)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:202)\n\tat dotty.tools.dotc.ast.Positioned.checkPos(Positioned.scala:223)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:197)\n\tat dotty.tools.dotc.ast.Positioned.checkPos(Positioned.scala:223)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:197)\n\tat dotty.tools.dotc.ast.Positioned.checkPos",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            throw new NumberFormatException(\"Invalid number\")\n        }\n        val numAsInt = num.intValue\n        val numAsFloat = num.floatValue\n        if (numAsFloat.isNaN) {\n            throw new NumberFormatException(\"Invalid number\")\n        }\n        val numAsDouble = num.doubleValue\n        if (numAsDouble.isNaN) {\n            throw new NumberFormatException(\"Invalid number\")\n        }\n        val numAsBigDecimal = num.bigDecimal\n        if (numAsBigDecimal.isNaN) {\n            throw new NumberFormatException(\"Invalid number\")\n        }\n        if (numAsInt == numAsFloat) {\n            return numAsInt\n        }\n        if (numAsInt == numAsDouble) {\n            return numAsInt\n        }\n        if (numAsInt == numAsBigDecimal) {\n            return numAsInt\n        }\n        val numAsBigInt = num.bigInteger\n        if (numAsBigInt.isNaN) {\n            throw new NumberFormatException(\"Invalid number\")\n        }\n        val numAsLong = num.longValue\n        if (numAsLong.isNaN) {\n            throw new NumberFormatException(\"Invalid number\")\n        }\n        val numAsShort = num.shortValue\n        if (numAsShort.isNaN) {\n            throw new NumberFormatException(\"Invalid number\")\n        }\n        val numAsByte = num.byteValue\n        if (numAsByte.isNaN) {\n            throw new NumberFormatException(\"Invalid number\")\n        }\n        val numAsFloatAsInt = numAsFloat.intValue\n        if (numAsFloatAsInt.isNaN) {\n            throw new NumberFormatException(\"Invalid number\")\n        }\n        val numAsFloatAsLong = numAsFloat.longValue\n        if (numAsFloatAsLong.isNaN) {\n            throw new NumberFormatException(\"Invalid number\")\n        }\n        val numAsFloatAsShort = numAsFloat.shortValue\n        if (numAsFloatAsShort.isNaN) {\n            throw new NumberFormatException(\"Invalid\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293223,
      "stdout": "error while checking \u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[31mnull\u001b[0m)\nerror while checking \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[31mnull\u001b[0m)\nerror while checking {\n  \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[31mnull\u001b[0m)\n}\nerror while checking \u001b[33mif \u001b[0m(numAsFloatAsShort.isNaN) \n  {\n    \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[31mnull\u001b[0m)\n  }\nerror while checking {\n  \u001b[33mval\u001b[0m \u001b[36mnum\u001b[0m = value.toLong\n  \u001b[33mif \u001b[0m(num.isNaN) \n    {\n      \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[32m\"Invalid number\"\u001b[0m)\n    }\n  \u001b[33mval\u001b[0m \u001b[36mnumAsInt\u001b[0m = num.intValue\n  \u001b[33mval\u001b[0m \u001b[36mnumAsFloat\u001b[0m = num.floatValue\n  \u001b[33mif \u001b[0m(numAsFloat.isNaN) \n    {\n      \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[32m\"Invalid number\"\u001b[0m)\n    }\n  \u001b[33mval\u001b[0m \u001b[36mnumAsDouble\u001b[0m = num.doubleValue\n  \u001b[33mif \u001b[0m(numAsDouble.isNaN) \n    {\n      \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[32m\"Invalid number\"\u001b[0m)\n    }\n  \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.bigDecimal\n  \u001b[33mif \u001b[0m(numAsBigDecimal.isNaN) \n    {\n      \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[32m\"Invalid number\"\u001b[0m)\n    }\n  \u001b[33mif \u001b[0m(numAsInt == numAsFloat) \n    {\n      \u001b[33mreturn\u001b[0m numAsInt\n    }\n  \u001b[33mif \u001b[0m(numAsInt == numAsDouble) \n    {\n      \u001b[33mreturn\u001b[0m numAsInt\n    }\n  \u001b[33mif \u001b[0m(numAsInt == numAsBigDecimal) \n    {\n      \u001b[33mreturn\u001b[0m numAsInt\n    }\n  \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.bigInteger\n  \u001b[33mif \u001b[0m(numAsBigInt.isNaN) \n    {\n      \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[32m\"Invalid number\"\u001b[0m)\n    }\n  \u001b[33mval\u001b[0m \u001b[36mnumAsLong\u001b[0m = num.longValue\n  \u001b[33mif \u001b[0m(numAsLong.isNaN) \n    {\n      \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[32m\"Invalid number\"\u001b[0m)\n    }\n  \u001b[33mval\u001b[0m \u001b[36mnumAsShort\u001b[0m = num.shortValue\n  \u001b[33mif \u001b[0m(numAsShort.isNaN) \n    {\n      \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[32m\"I",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp9x6ktlqf.scala:70:44 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m70 |\u001b[0m            \u001b[33mthrow\u001b[0m \u001b[33mnew\u001b[0m \u001b[35mNumberFormatException\u001b[0m(\"Invalid\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            unclosed string literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmp9x6ktlqf.scala:72:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 end of statement expected but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9x6ktlqf.scala:81:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\nexception occurred while parser /tmp/tmp9x6ktlqf.scala\nexception occurred while compiling /tmp/tmp9x6ktlqf.scala\nException in thread \"main\" java.lang.AssertionError: assertion failed: position error, parent span does not contain child span\nparent      = \u001b[33mnew \u001b[0m\u001b[35mNumberFormatException\u001b[0m(\u001b[31mnull\u001b[0m) # -1,\nparent span = <2581..2615>,\nchild       = \u001b[31mnull\u001b[0m # -1,\nchild span  = [2607..2620..2620]\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:8)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:172)\n\tat dotty.tools.dotc.ast.Positioned.check$1$$anonfun$3(Positioned.scala:202)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)\n\tat scala.collection.immutable.List.foreach(List.scala:333)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:202)\n\tat dotty.tools.dotc.ast.Positioned.checkPos(Positioned.scala:223)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:197)\n\tat dotty.tools.dotc.ast.Positioned.checkPos(Positioned.scala:223)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:197)\n\tat dotty.tools.dotc.ast.Positioned.chec",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsChar = num.toChar\n        val numAsByte = num.toByte\n        val numAsShort = num.toShort\n        val numAsLong = num.toLong\n        val numAsFloat32 = num.toFloat32\n        val numAsFloat64 = num.toFloat64\n        val numAsFloat128 = num.toFloat128\n        val numAsInt32 = num.toInt32\n        val numAsInt64 = num.toInt64\n        val numAsInt128 = num.toInt128\n        val numAsChar32 = num.toChar32\n        val numAsChar64 = num.toChar64\n        val numAsChar128 = num.toChar128\n        val numAsByte32 = num.toByte32\n        val numAsByte64 = num.toByte64\n        val numAsByte128 = num.toByte128\n        val numAsShort32 = num.toShort32\n        val numAsShort64 = num.toShort64\n        val numAsShort128 = num.toShort128\n        val numAsInt256 = num.toInt256\n        val numAsInt512 = num.toInt512\n        val numAsLong256 = num.toLong256\n        val numAsLong512 = num.toLong512\n        val numAsFloat256 = num.toFloat256\n        val numAsFloat512 = num.toFloat512\n        val numAsDouble256 = num.toDouble256\n        val numAsDouble512 = num.toDouble512\n        val numAsBigInt256 = num.toBigInt256\n        val numAsBigInt512 = num.toBigInt512\n        val numAsBigDecimal256 = num.toBigDecimal256\n        val numAsBigDecimal512 = num.toBigDecimal512\n        val numAsChar256 = num.toChar256\n        val num\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293238,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_u83idae.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_u83idae.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_u83idae.scala:25:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_u83idae.scala:26:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_u83idae.scala:31:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsFloat32\u001b[0m = num.toFloat32\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m     value toFloat32 is not a member of Long - did you mean num.toFloat?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_u83idae.scala:32:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsFloat64\u001b[0m = num.toFloat64\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m     value toFloat64 is not a member of Long - did you mean num.toFloat?\n\u001b[31m\u001b[31",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            return numAsInt\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return numAsFloat\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return numAsDouble\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return numAsBigDecimal\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            return numAsBigInteger\n        }\n        val numAsLong = num.toLong\n        if (numAsLong.isNaN) {\n            return numAsLong\n        }\n        val numAsIntAsLong = numAsInt.toLong\n        if (numAsIntAsLong.isNaN) {\n            return numAsIntAsLong\n        }\n        val numAsFloatAsLong = numAsFloat.toLong\n        if (numAsFloatAsLong.isNaN) {\n            return numAsFloatAsLong\n        }\n        val numAsDoubleAsLong = numAsDouble.toLong\n        if (numAsDoubleAsLong.isNaN) {\n            return numAsDoubleAsLong\n        }\n        val numAsBigDecimalAsLong = numAsBigDecimal.toLong\n        if (numAsBigDecimalAsLong.isNaN) {\n            return numAsBigDecimalAsLong\n        }\n        val numAsBigIntegerAsLong = numAsBigInteger.toLong\n        if (numAsBigIntegerAsLong.isNaN) {\n            return numAsBigIntegerAsLong\n        }\n        val numAsLongAsLong = numAsLong.toLong\n        if (numAsLongAsLong.isNaN) {\n            return numAsLongAsLong\n        }\n        val numAsIntAsLongAsLong = numAsIntAsLong.\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293208,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpupqz3feg.scala:71:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpupqz3feg.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpupqz3feg.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(numAsInt)\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpupqz3feg.scala:28:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsFloat\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsFloat : Float)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpupqz3feg.scala:32:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsDouble\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsDouble : Double)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpupqz3feg.scala:34:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            return -num\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpp5jr_wxg.scala:18)\n\tat Problem$.main(tmpp5jr_wxg.scala:27)\n\tat Problem.main(tmpp5jr_wxg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            return num\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return num\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return num\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return num\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            return num\n        }\n        val numAsShort = num.toShort\n        if (numAsShort.isNaN) {\n            return num\n        }\n        val numAsByte = num.toByte\n        if (numAsByte.isNaN) {\n            return num\n        }\n        val numAsChar = num.toChar\n        if (numAsChar.isNaN) {\n            return num\n        }\n        val numAsFloatWrapper = num.toFloatWrapper\n        if (numAsFloatWrapper.isNaN) {\n            return num\n        }\n        val numAsDoubleWrapper = num.toDoubleWrapper\n        if (numAsDoubleWrapper.isNaN) {\n            return num\n        }\n        val numAsBigDecimalWrapper = num.toBigDecimalWrapper\n        if (numAsBigDecimalWrapper.isNaN) {\n            return num\n        }\n        val numAsBigIntegerWrapper = num.toBigIntegerWrapper\n        if (numAsBigIntegerWrapper.isNaN) {\n            return num\n        }\n        val numAsShortWrapper = num.toShortWrapper\n        if (numAsShortWrapper.isNaN) {\n            return num\n        }\n        val numAsByteWrapper = num.toByteWrapper\n        if (numAsByteWrapper.isNaN) {\n            return num\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293235,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp502s93v9.scala:87:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp502s93v9.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp502s93v9.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp502s93v9.scala:34:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp502s93v9.scala:38:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInteger\u001b[0m = num.toBigInteger\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigInteger is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp502s93v9.scala:43:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mif\u001b[0m (numAsShort.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Short.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsShort)\n\u001b[31m\u001b[31m--",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val nearest = abs.div(abs.div(2)).floorDiv(2)\n            return nearest\n        } else {\n            val abs = Math.abs(num)\n            val nearest = abs.div(abs.div(2)).floorDiv(2)\n            return -nearest\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293233,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_piq3mb1.scala:21:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnearest\u001b[0m = abs.div(abs.div(\u001b[31m2\u001b[0m)).floorDiv(\u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_piq3mb1.scala:21:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnearest\u001b[0m = abs.div(abs.div(\u001b[31m2\u001b[0m)).floorDiv(\u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_piq3mb1.scala:25:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnearest\u001b[0m = abs.div(abs.div(\u001b[31m2\u001b[0m)).floorDiv(\u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_piq3mb1.scala:25:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnearest\u001b[0m = abs.div(abs.div(\u001b[31m2\u001b[0m)).floorDiv(\u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  value div is not a member of Long\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val abs = num.abs\n        if (abs.isNaN) {\n            return 0l\n        }\n        val abs_int = abs.toInt\n        if (abs_int.isNaN) {\n            return 0l\n        }\n        val abs_long = abs_int.toLong\n        if (abs_long.isNaN) {\n            return 0l\n        }\n        val abs_long_int = abs_long.toInt\n        if (abs_long_int.isNaN) {\n            return 0l\n        }\n        val abs_long_long = abs_long_int.toLong\n        if (abs_long_long.isNaN) {\n            return 0l\n        }\n        val abs_long_long_int = abs_long_long.toInt\n        if (abs_long_long_int.isNaN) {\n            return 0l\n        }\n        val abs_long_long_long = abs_long_long_int.toLong\n        if (abs_long_long_long.isNaN) {\n            return 0l\n        }\n        val abs_long_long_long_int = abs_long_long_long.toInt\n        if (abs_long_long_long_int.isNaN) {\n            return 0l\n        }\n        val abs_long_long_long_long = abs_long_long_long_int.toLong\n        if (abs_long_long_long_long.isNaN) {\n            return 0l\n        }\n        val abs_long_long_long_long_int = abs_long_long_long_long.toInt\n        if (abs_long_long_long_long_int.isNaN) {\n            return 0l\n        }\n        val abs_long_long_long_long_long = abs_long_long_long_long_int.toLong\n        if (abs_long_long_long_long_long.isNaN) {\n            return 0l\n        }\n        val abs_long_long\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp1r4fozgy.scala:67:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1r4fozgy.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1r4fozgy.scala:23:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (abs.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(abs)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1r4fozgy.scala:27:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mif\u001b[0m (abs_int.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(abs_int)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1r4fozgy.scala:31:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mif\u001b[0m (abs_long.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(abs_long)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1r4fozgy.scala:35:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mif\u001b[0m (abs_long_int.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimalScaled = num.scaleByPowerOfTen(2)\n        if (numAsBigDecimalScaled.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimalScaledAsInt = numAsBigDecimalScaled.toInt\n        if (numAsBigDecimalScaledAsInt.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimalScaledAsLong = numAsBigDecimalScaled.toLong\n        if (numAsBigDecimalScaledAsLong.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimalScaledAsFloat = numAsBigDecimalScaled.toFloat\n        if (numAsBigDecimalScaledAsFloat.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimalScaledAsDouble = numAsBigDecimalScaled.toDouble\n        if (numAsBigDecimalScaledAsDouble.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val num\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293236,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp1748bx8o.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1748bx8o.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1748bx8o.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1748bx8o.scala:34:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1748bx8o.scala:38:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInteger\u001b[0m = num.toBigInteger\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigInteger is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1748bx8o.scala:42:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalScaled\u001b[0m = num.scaleByPowerOfTen(\u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         value scaleByPowerOfTen is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            return numAsInt\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return numAsFloat\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return numAsDouble\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return numAsBigDecimal\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            return numAsBigInteger\n        }\n        val numAsShort = num.toShort\n        if (numAsShort.isNaN) {\n            return numAsShort\n        }\n        val numAsByte = num.toByte\n        if (numAsByte.isNaN) {\n            return numAsByte\n        }\n        val numAsLong = num.toLong\n        if (numAsLong.isNaN) {\n            return numAsLong\n        }\n        val numAsInteger = num.toInt\n        if (numAsInteger.isNaN) {\n            return numAsInteger\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return numAsFloat\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return numAsDouble\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return numAsBigDecimal\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            return numAsBigInteger\n        }\n        val numAsShort = num.toShort\n        if (numAsShort.isNaN) {\n            return numAsShort\n        \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293239,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpil1c_lrg.scala:88:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpil1c_lrg.scala:58:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsFloat\u001b[0m = num.toFloat\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsFloat is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsFloat\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpil1c_lrg.scala:62:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsDouble\u001b[0m = num.toDouble\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsDouble is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsDouble\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpil1c_lrg.scala:66:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m66 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpil1c_lrg.scala:70:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m70 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInteger\u001b[0m = num.toBigInteger\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigInteger is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigInteger\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpil1c_lrg.scala:74:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsChar = num.toChar\n        val numAsShort = num.toShort\n        val numAsByte = num.toByte\n        val numAsFloat32 = num.toFloat32\n        val numAsFloat64 = num.toFloat64\n        val numAsFloat128 = num.toFloat128\n        val numAsInt32 = num.toInt32\n        val numAsInt64 = num.toInt64\n        val numAsInt128 = num.toInt128\n        val numAsLong = num.toLong\n        val numAsShort32 = num.toShort32\n        val numAsShort64 = num.toShort64\n        val numAsShort128 = num.toShort128\n        val numAsByte32 = num.toByte32\n        val numAsByte64 = num.toByte64\n        val numAsByte128 = num.toByte128\n        val numAsChar32 = num.toChar32\n        val numAsChar64 = num.toChar64\n        val numAsChar128 = num.toChar128\n        val numAsShort32Char = num.toShort32Char\n        val numAsShort64Char = num.toShort64Char\n        val numAsShort128Char = num.toShort128Char\n        val numAsByte32Char = num.toByte32Char\n        val numAsByte64Char = num.toByte64Char\n        val numAsByte128Char = num.toByte128Char\n        val numAsInt32Char = num.toInt32Char\n        val numAsInt64Char = num.toInt64Char\n        val numAsInt128Char = num.toInt128Char\n        val numAsLongChar = num.toLongChar\n        val numAsShort32Long = num.toShort32Long\n        val numAsShort64Long = num.toShort64Long\n        val numAsShort128\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293241,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8no8lkl7.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8no8lkl7.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8no8lkl7.scala:25:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8no8lkl7.scala:26:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8no8lkl7.scala:30:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsFloat32\u001b[0m = num.toFloat32\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m     value toFloat32 is not a member of Long - did you mean num.toFloat?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8no8lkl7.scala:31:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsFloat64\u001b[0m = num.toFloat64\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m     value toFloat64 is not a member of Long - did you mean num.toFloat?\n\u001b[31m\u001b[31",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val max = abs.max\n            val min = abs.min\n            val diff = max - min\n            val mid = (max + min) / 2\n            val diff2 = mid - min\n            val diff3 = max - mid\n            val diff4 = mid - max\n            val diff5 = min - mid\n            val diff6 = mid - min\n            val diff7 = max - mid\n            val diff8 = mid - max\n            val diff9 = min - mid\n            val diff10 = mid - min\n            val diff11 = max - mid\n            val diff12 = mid - max\n            val diff13 = min - mid\n            val diff14 = max - mid\n            val diff15 = mid - min\n            val diff16 = max - mid\n            val diff17 = mid - max\n            val diff18 = min - mid\n            val diff19 = max - mid\n            val diff20 = mid - min\n            val diff21 = max - mid\n            val diff22 = mid - max\n            val diff23 = min - mid\n            val diff24 = max - mid\n            val diff25 = mid - min\n            val diff26 = max - mid\n            val diff27 = mid - max\n            val diff28 = min - mid\n            val diff29 = max - mid\n            val diff30 = mid - min\n            val diff31 = max - mid\n            val diff32 = mid - max\n            val diff33 = min - mid\n            val diff34 = max - mid\n            val diff35 = mid - min\n            val diff36 = max - mid\n            val diff37 = mid - max\n            val diff38 = min - mid\n            val diff39 = max - mid\n            val diff40 = mid - min\n            val diff41 = max - mid\n            val diff42 = mid - max\n            val diff43 = min - mid\n            val diff44 = max - mid\n            val diff45 = mid - min\n            val diff46 = max - mid\n            val diff47 = mid - max\n            val diff48 = min - mid\n            val diff49 = max - mid\n            val diff50 = mid - min\n            val diff51 = max\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293241,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpchfxvva1.scala:85:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpchfxvva1.scala:23:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdiff\u001b[0m = max - min\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue - is not a member of Long => Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpchfxvva1.scala:24:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mmid\u001b[0m = (max + min) / \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of Long => Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpchfxvva1.scala:26:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdiff3\u001b[0m = max - mid\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue - is not a member of Long => Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val nearest = abs / 2\n            val result = nearest + (abs % 2)\n            return result\n        } else {\n            val abs = Math.abs(num)\n            val nearest = abs / 2\n            val result = nearest - (abs % 2)\n            return result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293237,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp93hpv4te.scala:32)\n\tat Problem.main(tmp93hpv4te.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            return -num\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpp5jr_wxg.scala:18)\n\tat Problem$.main(tmpp5jr_wxg.scala:27)\n\tat Problem.main(tmpp5jr_wxg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        val abs = num.abs\n        val sign = num.signum\n        val intPart = abs.floorDiv(scala.math.BigInteger(\"1\"))\n        val fracPart = abs.subtract(intPart)\n        val frac = fracPart.toBigDecimal\n        val intPartAsLong = intPart.toLong\n        val fracAsLong = fracPart.toLong\n        val intPartAsInt = intPartAsLong.intValue\n        val fracAsInt = fracAsLong.intValue\n        val intPartAsInt2 = intPartAsInt.intValue\n        val fracAsInt2 = fracAsInt.intValue\n        val intPartAsInt3 = intPartAsInt2.intValue\n        val fracAsInt3 = fracAsInt2.intValue\n        val intPartAsInt4 = intPartAsInt3.intValue\n        val fracAsInt4 = fracAsInt3.intValue\n        val intPartAsInt5 = intPartAsInt4.intValue\n        val fracAsInt5 = fracAsInt4.intValue\n        val intPartAsInt6 = intPartAsInt5.intValue\n        val fracAsInt6 = fracAsInt5.intValue\n        val intPartAsInt7 = intPartAsInt6.intValue\n        val fracAsInt7 = fracAsInt6.intValue\n        val intPartAsInt8 = intPartAsInt7.intValue\n        val fracAsInt8 = fracAsInt7.intValue\n        val intPartAsInt9 = intPartAsInt8.intValue\n        val fracAsInt9 = fracAsInt8.intValue\n        val intPartAsInt10 = intPartAsInt9.intValue\n        val fracAsInt10 = fracAsInt9.intValue\n        val intPartAsInt11 = intPartAsInt10.intValue\n        val fracAsInt11 = fracAsInt10.intValue\n        val intPartAsInt12 = intPartAsInt11.intValue\n        val fracAsInt12 = fracAsInt11.intValue\n        val intPartAsInt\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293238,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpodp7_85p.scala:51:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpodp7_85p.scala:21:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mintPart\u001b[0m = abs.floorDiv(scala.math.BigInteger(\u001b[31m\"1\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpodp7_85p.scala:21:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mintPart\u001b[0m = abs.floorDiv(scala.math.BigInteger(\u001b[31m\"1\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                value BigInteger is not a member of math\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpodp7_85p.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mfracPart\u001b[0m = abs.subtract(intPart)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpodp7_85p.scala:51:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val abs = num.abs\n        if (abs.isNaN) {\n            return 0l\n        }\n        val absInt = abs.toInt\n        if (absInt.isNaN) {\n            return 0l\n        }\n        val absIntPlusOne = absInt.add(1)\n        if (absIntPlusOne.isNaN) {\n            return 0l\n        }\n        val absIntMinusOne = absInt.subtract(1)\n        if (absIntMinusOne.isNaN) {\n            return 0l\n        }\n        val absIntPlusOneHalf = absIntPlusOne.div(2)\n        if (absIntPlusOneHalf.isNaN) {\n            return 0l\n        }\n        val absIntMinusOneHalf = absIntMinusOne.div(2)\n        if (absIntMinusOneHalf.isNaN) {\n            return 0l\n        }\n        val absIntPlusOneHalfPlusOne = absIntPlusOneHalf.add(1)\n        if (absIntPlusOneHalfPlusOne.isNaN) {\n            return 0l\n        }\n        val absIntMinusOneHalfPlusOne = absIntMinusOneHalf.add(1)\n        if (absIntMinusOneHalfPlusOne.isNaN) {\n            return 0l\n        }\n        val absIntPlusOneHalfPlusOneHalf = absIntPlusOneHalfPlusOne.div(2)\n        if (absIntPlusOneHalfPlusOneHalf.isNaN) {\n            return 0l\n        }\n        val absIntMinusOneHalfPlusOneHalf = absIntMinusOneHalfPlusOne.div(2)\n        if (absIntMinusOneHalfPlusOneHalf.isNaN) {\n            return 0l\n        }\n        val absIntPlusOneHalfPlusOneHalfPlusOne = absIntPlusOneHalfPlusOneHalf.add(1)\n        if (absIntPlusOneHalfPlusOneHalfPlusOne.isNaN) {\n            return 0l\n        }\n        val absIntMinusOneHalfPlusOneHalf\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293239,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpn9mf6gk4.scala:67:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpn9mf6gk4.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpn9mf6gk4.scala:23:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (abs.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(abs)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpn9mf6gk4.scala:27:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mif\u001b[0m (absInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(absInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpn9mf6gk4.scala:30:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mabsIntPlusOne\u001b[0m = absInt.add(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            value add is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpn9mf6gk4.scala:34:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mabsIntMinusOne\u001b[0m = absInt.subtract(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             value subtract is not a member of Int\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val abs = num.abs\n        if (abs.isNaN) {\n            return 0l\n        }\n        val absInt = abs.toInt\n        if (absInt.isNaN) {\n            return 0l\n        }\n        val absIntPlusOne = absInt + 1\n        if (absIntPlusOne.isNaN) {\n            return 0l\n        }\n        val absIntMinusOne = absInt - 1\n        if (absIntMinusOne.isNaN) {\n            return 0l\n        }\n        val absIntPlusOneHalf = absIntPlusOne / 2\n        if (absIntPlusOneHalf.isNaN) {\n            return 0l\n        }\n        val absIntMinusOneHalf = absIntMinusOne / 2\n        if (absIntMinusOneHalf.isNaN) {\n            return 0l\n        }\n        val absIntPlusOneHalfPlusOne = absIntPlusOneHalf + 1\n        if (absIntPlusOneHalfPlusOne.isNaN) {\n            return 0l\n        }\n        val absIntMinusOneHalfPlusOne = absIntMinusOneHalf + 1\n        if (absIntMinusOneHalfPlusOne.isNaN) {\n            return 0l\n        }\n        val absIntPlusOneHalfMinusOne = absIntPlusOneHalf - 1\n        if (absIntPlusOneHalfMinusOne.isNaN) {\n            return 0l\n        }\n        val absIntMinusOneHalfMinusOne = absIntMinusOneHalf - 1\n        if (absIntMinusOneHalfMinusOne.isNaN) {\n            return 0l\n        }\n        val absIntPlusOneHalfMinusOneHalf = absIntPlusOneHalfMinusOne / 2\n        if (absIntPlusOneHalfMinusOneHalf.isNaN) {\n            return 0l\n        }\n        val absIntMinusOneHalfMinusOneHalf = absIntMinusOneHalfMinusOne / 2\n        if (absIntMinusOneHalfMinusOneHalf.isNaN) {\n            \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293239,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpslljrp7p.scala:79:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpslljrp7p.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpslljrp7p.scala:23:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (abs.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(abs)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpslljrp7p.scala:27:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mif\u001b[0m (absInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(absInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpslljrp7p.scala:31:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mif\u001b[0m (absIntPlusOne.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(absIntPlusOne)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpslljrp7p.scala:35:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mif\u001b[0m (absIntMinusOne.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val max = abs.max\n            val min = abs.min\n            val diff = max - min\n            val diffAbs = diff.abs\n            val diffAbsHalf = diffAbs / 2\n            val diffAbsHalfAbs = diffAbsHalf.abs\n            val diffAbsHalfAbsHalf = diffAbsHalfAbs / 2\n            val diffAbsHalfAbsHalfHalf = diffAbsHalfAbsHalf / 2\n            val diffAbsHalfAbsHalfHalfHalf = diffAbsHalfAbsHalfHalf / 2\n            val diffAbsHalfAbsHalfHalfHalfHalf = diffAbsHalfAbsHalfHalfHalf / 2\n            val diffAbsHalfAbsHalfHalfHalfHalfHalf = diffAbsHalfAbsHalfHalfHalfHalf / 2\n            val diffAbsHalfAbsHalfHalfHalfHalfHalfHalf = diffAbsHalfAbsHalfHalfHalfHalfHalf / 2\n            val diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalf = diffAbsHalfAbsHalfHalfHalfHalfHalfHalf / 2\n            val diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalf = diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalf / 2\n            val diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalf = diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalf / 2\n            val diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalfHalf = diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalf / 2\n            val diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalf = diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalfHalf / 2\n            val diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalf = diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalf / 2\n            val diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalf = diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalf / 2\n            val diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalf = diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalf / 2\n            val diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalf = diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalf\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293240,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzoq1jv7r.scala:52:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzoq1jv7r.scala:23:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdiff\u001b[0m = max - min\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue - is not a member of Long => Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzoq1jv7r.scala:51:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpzoq1jv7r.scala:43:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m43 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(1)\n            val ceil = abs.ceilDiv(1)\n            if (abs.subtract(floor).abs().min() < abs.subtract(ceil).abs().min())\n                return -floor\n            else\n                return -ceil\n        } else {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(1)\n            val ceil = abs.ceilDiv(1)\n            if (abs.subtract(floor).abs().min() < abs.subtract(ceil).abs().min())\n                return floor\n            else\n                return ceil\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293239,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzlstx49x.scala:21:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzlstx49x.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceilDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzlstx49x.scala:23:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m (abs.subtract(floor).abs().min() < abs.subtract(ceil).abs().min())\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzlstx49x.scala:29:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzlstx49x.scala:30:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceilDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzlstx49x.scala:31:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mif\u001b[0m (abs.subtract(floor).abs().min() < abs.subtract(ceil).abs().min())\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value subtract is not a member of Long\n6 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigInt = num.toBigInt\n        if (numAsBigInt.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimalToBigInt = num.toBigDecimal.toBigInt\n        if (numAsBigDecimalToBigInt.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimalToBigIntToInt = num.toBigDecimal.toBigInt.toInt\n        if (numAsBigDecimalToBigIntToInt.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimalToBigIntToIntToLong = num.toBigDecimal.toBigInt.toInt.toLong\n        if (numAsBigDecimalToBigIntToIntToLong.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimalToBigIntToIntToLongToFloat = num.toBigDecimal.toBigInt.toInt.toLong.toFloat\n        if (numAsBigDecimalToBigIntToIntToLongToFloat.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimalToBigIntToIntToLongToFloatToDouble = num.\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293241,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpnf0wijt7.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnf0wijt7.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnf0wijt7.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnf0wijt7.scala:34:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnf0wijt7.scala:38:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnf0wijt7.scala:42:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalToBigInt\u001b[0m = num.toBigDecimal.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                             ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            return numAsInt\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return numAsFloat\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return numAsDouble\n        }\n        val numAsBigInt = num.toBigInt\n        if (numAsBigInt.isNaN) {\n            return numAsBigInt\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return numAsBigDecimal\n        }\n        val numAsBigDecimalInt = numAsBigDecimal.toBigInteger\n        if (numAsBigDecimalInt.isNaN) {\n            return numAsBigDecimalInt\n        }\n        val numAsBigDecimalLong = numAsBigDecimal.toBigInteger\n        if (numAsBigDecimalLong.isNaN) {\n            return numAsBigDecimalLong\n        }\n        val numAsBigDecimalIntAsLong = numAsBigDecimalInt.longValue\n        if (numAsBigDecimalIntAsLong.isNaN) {\n            return numAsBigDecimalIntAsLong\n        }\n        val numAsBigDecimalIntAsInt = numAsBigDecimalInt.intValue\n        if (numAsBigDecimalIntAsInt.isNaN) {\n            return numAsBigDecimalIntAsInt\n        }\n        val numAsBigDecimalIntAsShort = numAsBigDecimalInt.shortValue\n        if (numAsBigDecimalIntAsShort.isNaN) {\n            return numAsBigDecimalIntAsShort\n        }\n        val numAsBigDecimalIntAsByte = numAsBigDecimalInt.byteValue\n        if (numAsBigDecimalIntAsByte.isNaN) {\n            return numAsBigDecimalIntAsByte\n        }\n        \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293241,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptpz83g9c.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptpz83g9c.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(numAsInt)\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptpz83g9c.scala:28:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsFloat\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsFloat : Float)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptpz83g9c.scala:32:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsDouble\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsDouble : Double)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptpz83g9c.scala:34:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDe",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val intPart = abs % 1\n            val fracPart = abs - intPart\n            val result = num + (1 - fracPart)\n            if (result == 0) {\n                result = 1\n            }\n            return result\n        } else {\n            val abs = Math.abs(num)\n            val intPart = abs % 1\n            val fracPart = abs - intPart\n            val result = num - (1 - fracPart)\n            if (result == 0) {\n                result = -1\n            }\n            return result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293235,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp5xnm2w41.scala:25:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                result = \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp5xnm2w41.scala:34:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                result = -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293183,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpojhx9q1v.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (num.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        if (num.isZero) {\n            return 0l\n        }\n        val abs = num.abs\n        val absInt = abs.toInt\n        val absFrac = abs.subtract(absInt).toDouble\n        val absFracInt = absFrac.toInt\n        val absFracFrac = absFrac.subtract(absFracInt).toDouble\n        val absFracFracFrac = absFracFrac.subtract(absFracFrac).toDouble\n        if (absFracFracFrac.isZero) {\n            return absFracInt\n        }\n        if (absFracFracFrac.isNegative) {\n            return absFracInt.subtract(1)\n        }\n        return absFracInt.add(1)\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293241,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl8u2bof9.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl8u2bof9.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mif\u001b[0m (num.isInfinite) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isInfinite is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl8u2bof9.scala:25:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mif\u001b[0m (num.isZero) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value isZero is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl8u2bof9.scala:30:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mabsFrac\u001b[0m = abs.subtract(absInt).toDouble\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value subtract is not a member of Long\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(abs.div(abs.sub(1)))\n            val ceil = abs.ceilDiv(abs.div(abs.sub(1)))\n            val diff = abs.sub(floor).sub(ceil)\n            if (diff.abs > 0.5) {\n                return ceil\n            } else {\n                return floor\n            }\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293242,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_en6gof1.scala:21:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(abs.div(abs.sub(\u001b[31m1\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_en6gof1.scala:21:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(abs.div(abs.sub(\u001b[31m1\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_en6gof1.scala:21:49 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(abs.div(abs.sub(\u001b[31m1\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       value sub is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_en6gof1.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(abs.div(abs.sub(\u001b[31m1\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceilDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_en6gof1.scala:22:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(abs.div(abs.sub(\u001b[31m1\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_en6gof1.scala:22:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(abs.div(abs.sub(\u001b[31m1\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       value sub is not a mem",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            return -num\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpp5jr_wxg.scala:18)\n\tat Problem$.main(tmpp5jr_wxg.scala:27)\n\tat Problem.main(tmpp5jr_wxg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigInteger = num.toBigInteger\n        val numAsByte = num.toByte\n        val numAsShort = num.toShort\n        val numAsInteger = num.toInt\n        val numAsLong = num.toLong\n        val numAsFloatAsDouble = num.toFloat.toDouble\n        val numAsFloatAsFloat = num.toFloat.toFloat\n        val numAsFloatAsDoubleAsDouble = num.toFloat.toDouble.toDouble\n        val numAsFloatAsDoubleAsFloat = num.toFloat.toDouble.toFloat\n        val numAsDoubleAsDouble = num.toDouble.toDouble\n        val numAsDoubleAsFloat = num.toDouble.toFloat\n        val numAsFloatAsDoubleAsDouble = num.toFloat.toDouble.toDouble\n        val numAsFloatAsDoubleAsFloat = num.toFloat.toDouble.toFloat\n        val numAsDoubleAsFloatAsDouble = num.toDouble.toFloat.toDouble\n        val numAsDoubleAsFloatAsFloat = num.toDouble.toFloat.toFloat\n        val numAsFloatAsDoubleAsDoubleAsDouble = num.toFloat.toDouble.toDouble.toDouble\n        val numAsFloatAsDoubleAsDoubleAsFloat = num.toFloat.toDouble.toDouble.toFloat\n        val numAsDoubleAsDoubleAsFloatAsDouble = num.toDouble.toDouble.toFloat.toDouble\n        val numAsDoubleAsFloatAsDoubleAsFloat = num.toDouble.toFloat.toDouble.toFloat\n        val numAsDoubleAsFloatAsDoubleAsDoubleAsDouble = num.toDouble.toFloat.toDouble.toDouble.toDouble\n        val numAsDoubleAsFloatAsDoubleAsDoubleAsFloatAsDouble = num.toDouble.toFloat.toDouble.toDouble.toFloat.toDouble\n        val numAsDoubleAsFloatAsDoubleAsDoubleAsFloatAsFloatAsDouble =\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293244,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpsxeed603.scala:47:70 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsDoubleAsFloatAsDoubleAsDoubleAsFloatAsFloatAsDouble\u001b[0m =\n\u001b[31m\u001b[31m   |\u001b[0m                                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpsxeed603.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsFloatAsDoubleAsDouble\u001b[0m = num.toFloat.toDouble.toDouble\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsFloatAsDoubleAsDouble is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsFloatAsDoubleAsDouble\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpsxeed603.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsFloatAsDoubleAsFloat\u001b[0m = num.toFloat.toDouble.toFloat\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsFloatAsDoubleAsFloat is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsFloatAsDoubleAsFloat\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsxeed603.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsxeed603.scala:25:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n        val num_int = num.int\n        val num_fract = num.remainder(1.0)\n        val num_int_fract = num_int + num_fract\n        val num_int_fract_int = num_int_fract.int\n        val num_int_fract_int_fract = num_int_fract_int + num_fract\n        val num_int_fract_int_fract_int = num_int_fract_int_fract.int\n        val num_int_fract_int_fract_int_fract = num_int_fract_int_fract_int + num_fract\n        val num_int_fract_int_fract_int_fract_int = num_int_fract_int_fract_int_fract.int\n        val num_int_fract_int_fract_int_fract_int_fract = num_int_fract_int_fract_int_fract_int + num_fract\n        val num_int_fract_int_fract_int_fract_int_fract_int = num_int_fract_int_fract_int_fract_int_fract.int\n        val num_int_fract_int_fract_int_fract_int_fract_int_fract = num_int_fract_int_fract_int_fract_int_fract_int + num_fract\n        val num_int_fract_int_fract_int_fract_int_fract_int_fract_int = num_int_fract_int_fract_int_fract_int_fract_int_fract.int\n        val num_int_fract_int_fract_int_fract_int_fract_int_fract_int_fract = num_int_fract_int_fract_int_fract_int_fract_int_fract_int + num_fract\n        val num_int_fract_int_fract_int_f\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293246,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7gj3v_k4.scala:33:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7gj3v_k4.scala:19:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnum_int\u001b[0m = num.int\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value int is not a member of Double\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7gj3v_k4.scala:20:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnum_fract\u001b[0m = num.remainder(\u001b[31m1.0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue remainder is not a member of Double, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.double2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7gj3v_k4.scala:33:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        } else {\n            return num.round(scala.math.BigDecimal.ROUND_HALF_UP)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293248,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt9ytitdf.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt9ytitdf.scala:22:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mreturn\u001b[0m num.round(scala.math.BigDecimal.ROUND_HALF_UP)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m     value ROUND_HALF_UP is not a member of object scala.math.BigDecimal\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpt9ytitdf.scala:22:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mreturn\u001b[0m num.round(scala.math.BigDecimal.ROUND_HALF_UP)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 \u001b[33mmethod\u001b[0m \u001b[35mround\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mRichLong\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (num.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsInt.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsFloat.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsDouble.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsBigDecimal.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsBigInteger.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsShort = num.toShort\n        if (numAsShort.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsShort.isInfinite) {\n            throw new NumberFormatException(\"Infinity\")\n        }\n        val numAsByte = num.toByte\n        if (numAsByte.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        if (numAsByte.isInfinite) {\n\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293250,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpadcs_h_w.scala:83:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpadcs_h_w.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpadcs_h_w.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mif\u001b[0m (num.isInfinite) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isInfinite is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpadcs_h_w.scala:26:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpadcs_h_w.scala:29:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isInfinite) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isInfinite is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpadcs_h_w.scala:46:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m         ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n        val intPart = num.intPart\n        val fracPart = num.fracPart\n        val intPartAsLong = intPart.toLong\n        val fracPartAsLong = fracPart.toLong\n        val fracPartAsDouble = fracPartAsLong.toDouble\n        val diff = num - intPartAsLong\n        val diffAsLong = diff.toLong\n        val diffAsDouble = diffAsLong.toDouble\n        val diffAsDoubleAbs = diffAsDouble.abs\n        val diffAsDoubleAbsPlusOne = diffAsDoubleAbs + 1\n        val diffAsDoubleAbsMinusOne = diffAsDoubleAbs - 1\n        val diffAsDoubleAbsPlusOneHalf = diffAsDoubleAbsPlusOne / 2\n        val diffAsDoubleAbsMinusOneHalf = diffAsDoubleAbsMinusOne / 2\n        val diffAsDoubleAbsPlusOneHalfSquared = diffAsDoubleAbsPlusOneHalf * diffAsDoubleAbsPlusOneHalf\n        val diffAsDoubleAbsMinusOneHalfSquared = diffAsDoubleAbsMinusOneHalf * diffAsDoubleAbsMinusOneHalf\n        val diffAsDoubleAbsPlusOneHalfSquaredMinusOne = diffAsDoubleAbsPlusOneHalfSquared - 1\n        val diffAsDoubleAbsMinusOneHalfSquaredMinusOne = diffAsDoubleAbsMinusOneHalfSquared - 1\n        val diffAsDoubleAbsPlusOneHalfSquaredMinusOneHalf = diffAsDoubleAbsPlusOneHalfSquaredMinusOne / 2\n        val diffAsDoubleAbsMinusOneHalfSquaredMinusOneHalf = diffAsDoubleAbsMinusOneHalfSquaredMinusOne / 2\n        val diffAsDoubleAbsPlusOneHalfSquaredMinusOneHalfSquared = diffAsDoubleAbsPlusOneHalfSquaredMinusOneHalf * diffAsDoubleAbsPlusOneHalfSquaredMinusOneHalf\n        val diffAsDoubleAbsMinusOneHalfSquaredMinusOneHalfSquared = diffAsDoubleAbsMinusOneHalfSquaredMinusOneHalf * diffAsDoubleAbsMinusOneHalfSquaredMinusOneHalf\n        val diffAsDoubleAbsPlusOneHalfSquaredMinusOneHalfSquaredMinusOne = diffAsDoubleAbsPlusOneHalfSquaredMinusOneHalfSquared - 1\n        val diff\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293250,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7cjb9nf6.scala:42:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7cjb9nf6.scala:19:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mintPart\u001b[0m = num.intPart\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value intPart is not a member of Double\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7cjb9nf6.scala:20:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mfracPart\u001b[0m = num.fracPart\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value fracPart is not a member of Double\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7cjb9nf6.scala:42:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimalWithScale = num.toBigDecimal(20)\n        val numAsBigDecimalWithScaleAndPrecision = num.toBigDecimal(20, 20)\n        val numAsBigDecimalWithPrecision = num.toBigDecimal(20)\n        val numAsBigDecimalWithPrecisionAndScale = num.toBigDecimal(20, 20)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingMode = num.toBigDecimal(20, 20, RoundingMode.HALF_UP)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingMode = num.toBigDecimal(20, 20, RoundingMode.HALF_UP)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingMode = num.toBigDecimal(20, 20, RoundingMode.HALF_UP)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingMode = num.toBigDecimal(20, 20, RoundingMode.HALF_UP)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingMode = num.toBigDecimal(20, 20, RoundingMode.HALF_UP)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingMode = num.toBigDecimal(20, 20, RoundingMode.HALF_UP)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingMode = num.toBigDecimal(20, 20, RoundingMode.HALF_UP)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingMode = num.toBigDecimal(20, 20, RoundingMode.HALF_UP)\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingMode = num.to\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpal0pznli.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalWithPrecisionAndScaleAndRoundingMode\u001b[0m = num.toBigDecimal(\u001b[31m20\u001b[0m, \u001b[31m20\u001b[0m, RoundingMode.HALF_UP)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimalWithPrecisionAndScaleAndRoundingMode is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimalWithPrecisionAndScaleAndRoundingMode\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpal0pznli.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalWithPrecisionAndScaleAndRoundingMode\u001b[0m = num.toBigDecimal(\u001b[31m20\u001b[0m, \u001b[31m20\u001b[0m, RoundingMode.HALF_UP)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimalWithPrecisionAndScaleAndRoundingMode is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimalWithPrecisionAndScaleAndRoundingMode\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpal0pznli.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalWithPrecisionAndScaleAndRoundingMode\u001b[0m = num.toBigDecimal(\u001b[31m20\u001b[0m, \u001b[31m20\u001b[0m, RoundingMode.HALF_UP)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimalWithPrecisionAndScaleAndRoundingMode is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimalWithPrecisionAndScaleAndRoundingMode\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E16",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        if (numAsInt.isNaN) {\n            return numAsInt\n        }\n        if (numAsFloat.isNaN) {\n            return numAsFloat\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return numAsDouble\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return numAsBigDecimal\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            return numAsBigInteger\n        }\n        val numAsLong = num.toLong\n        if (numAsLong.isNaN) {\n            return numAsLong\n        }\n        val numAsIntAsInt = numAsInt.toInt\n        val numAsFloatAsFloat = numAsFloat.toFloat\n        val numAsDoubleAsDouble = numAsDouble.toDouble\n        val numAsBigDecimalAsBigDecimal = numAsBigDecimal.toBigDecimal\n        val numAsBigIntegerAsBigInteger = numAsBigInteger.toBigInteger\n        val numAsLongAsLong = numAsLong.toLong\n        val numAsIntAsIntAsInt = numAsIntAsInt.toInt\n        val numAsFloatAsFloatAsFloat = numAsFloatAsFloat.toFloat\n        val numAsDoubleAsDoubleAsDouble = numAsDoubleAsDouble.toDouble\n        val numAsBigDecimalAsBigDecimalAsBigDecimal = numAsBigDecimalAsBigDecimal.toBigDecimal\n        val numAsBigIntegerAsBigIntegerAsBigInteger = numAsBigIntegerAsBigInteger.toBigInteger\n        val numAsLongAsLongAsLong = numAsLongAsLong.toLong\n        val numAsIntAsIntAsIntAsInt = numAsIntAsIntAsInt.toInt\n        val numAsFloatAsFloatAsFloatAsFloat = numAsFloatAsFloat\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293251,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzbr6mb5v.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzbr6mb5v.scala:24:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsInt)\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzbr6mb5v.scala:28:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsFloat\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsFloat : Float)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzbr6mb5v.scala:32:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsDouble\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsDouble : Double)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzbr6mb5v.scala:34:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzbr6mb5v.scala:38:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsChar = num.toChar\n        val numAsByte = num.toByte\n        val numAsShort = num.toShort\n        val numAsLong = num.toLong\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAs\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293205,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp65iz75zc.scala:57:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp65iz75zc.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp65iz75zc.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp65iz75zc.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp65iz75zc.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val abs = num.abs\n        val intPart = abs.floor\n        val fracPart = abs.subtract(intPart)\n        val frac = fracPart.toDouble\n        if (frac.isNaN) {\n            return intPart\n        }\n        val rounded = intPart + (fracPart.div(scala.math.scalajs.js.scala_scalajs_runtime_Long().fromDouble(scala.math.scalajs.js.scala_scalajs_runtime_RuntimeString$.MODULE$.fromString(\"1e\"))))\n        if (rounded.toDouble.isNaN) {\n            return intPart\n        }\n        if (abs.isNaN) {\n            return 0l\n        }\n        if (rounded.toLong.isNaN) {\n            return 0l\n        }\n        if (abs.toLong.isNaN) {\n            return 0l\n        }\n        if (abs.toLong.equals(rounded.toLong)) {\n            return rounded.toLong\n        }\n        return rounded.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293252,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7sd9prsi.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7sd9prsi.scala:23:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mintPart\u001b[0m = abs.floor\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value floor is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          doubleWrapper(abs)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7sd9prsi.scala:24:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mfracPart\u001b[0m = abs.subtract(intPart)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7sd9prsi.scala:33:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mif\u001b[0m (abs.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(abs)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7sd9prsi.scala:39:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mif\u001b[0m (abs.toLong.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(abs.toLong)\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            throw new NumberFormatException(\"Not a number\")\n        }\n        val abs = num.abs\n        val sign = num.signum\n        if (abs.isInfinite) {\n            throw new NumberFormatException(\"Infinite\")\n        }\n        if (abs.isZero) {\n            throw new NumberFormatException(\"Zero\")\n        }\n        if (sign == 0) {\n            throw new NumberFormatException(\"Negative zero\")\n        }\n        if (sign == 1) {\n            return num\n        }\n        val abs_num = num.abs\n        val abs_num_int = abs_num.toInt\n        val abs_num_long = abs_num.toLong\n        val abs_num_float = abs_num.toFloat\n        val abs_num_double = abs_num.toDouble\n        val abs_num_big_int = abs_num.toBigInt\n        val abs_num_big_decimal = abs_num.toBigDecimal\n        val abs_num_big_float = abs_num.toBigFloat\n        val abs_num_big_double = abs_num.toBigDouble\n        val abs_num_big_big_int = abs_num.toBigBigInt\n        val abs_num_big_big_decimal = abs_num.toBigBigDecimal\n        val abs_num_big_big_float = abs_num.toBigBigFloat\n        val abs_num_big_big_double = abs_num.toBigBigDouble\n        val abs_num_big_big_big_int = abs_num.toBigBigBigInt\n        val abs_num_big_big_big_decimal = abs_num.toBigBigBigDecimal\n        val abs_num_big_big_big_float = abs_num.toBigBigBigFloat\n        val abs_num_big_big_big_double = abs_num.toBigBigBigDouble\n        val abs_num_big_big_big_big_int = abs_num.toBigBigBigBigInt\n        val abs_num_big_big_big_big_decimal =\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293256,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpm364e82z.scala:54:45 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mabs_num_big_big_big_big_decimal\u001b[0m =\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm364e82z.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm364e82z.scala:24:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mif\u001b[0m (abs.isInfinite) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isInfinite is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(abs)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm364e82z.scala:27:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mif\u001b[0m (abs.isZero) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value isZero is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm364e82z.scala:41:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mabs_num_big_int\u001b[0m = abs_num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm364e82z.scala:42:42 ---------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val max = abs.max\n            val min = abs.min\n            val diff = max - min\n            val diffAbs = diff.abs\n            val diffAbsMin = diffAbs.min\n            val diffAbsMax = diffAbs.max\n            val diffAbsMinMax = diffAbsMin.max\n            val diffAbsMaxMin = diffAbsMax.min\n            val diffAbsMaxMinMax = diffAbsMaxMin.max\n            val diffAbsMaxMinMaxMin = diffAbsMaxMinMax.min\n            val diffAbsMaxMinMaxMinMax = diffAbsMaxMinMaxMin.max\n            val diffAbsMaxMinMaxMinMaxMin = diffAbsMaxMinMaxMinMax.min\n            val diffAbsMaxMinMaxMinMaxMinMax = diffAbsMaxMinMaxMinMaxMin.max\n            val diffAbsMaxMinMaxMinMaxMinMaxMin = diffAbsMaxMinMaxMinMaxMinMax.min\n            val diffAbsMaxMinMaxMinMaxMinMaxMinMax = diffAbsMaxMinMaxMinMaxMinMaxMin.max\n            val diffAbsMaxMinMaxMinMaxMinMaxMinMaxMin = diffAbsMaxMinMaxMinMaxMinMaxMinMax.min\n            val diffAbsMaxMinMaxMinMaxMinMaxMinMaxMinMax = diffAbsMaxMinMaxMinMaxMinMaxMinMaxMin.max\n            val diffAbsMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = diffAbsMaxMinMaxMinMaxMinMaxMinMaxMinMax.min\n            val diffAbsMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = diffAbsMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin.max\n            val diffAbsMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = diffAbsMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax.min\n            val diffAbsMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = diffAbsMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin.max\n            val diffAbsMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = diffAbsMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin.min\n            val diffAbsMaxMinMaxMinMaxMinMax\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4mk9azry.scala:44:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4mk9azry.scala:54:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4mk9azry.scala:23:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdiff\u001b[0m = max - min\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue - is not a member of Long => Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4mk9azry.scala:53:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmp4mk9azry.scala:45:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m45 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            return numAsInt\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return numAsFloat\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return numAsDouble\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return numAsBigDecimal\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            return numAsBigInteger\n        }\n        val numAsLong = num.toLong\n        if (numAsLong.isNaN) {\n            return numAsLong\n        }\n        val numAsIntAsLong = numAsInt.toLong\n        if (numAsIntAsLong.isNaN) {\n            return numAsIntAsLong\n        }\n        val numAsFloatAsLong = numAsFloat.toLong\n        if (numAsFloatAsLong.isNaN) {\n            return numAsFloatAsLong\n        }\n        val numAsDoubleAsLong = numAsDouble.toLong\n        if (numAsDoubleAsLong.isNaN) {\n            return numAsDoubleAsLong\n        }\n        val numAsBigDecimalAsLong = numAsBigDecimal.toLong\n        if (numAsBigDecimalAsLong.isNaN) {\n            return numAsBigDecimalAsLong\n        }\n        val numAsBigIntegerAsLong = numAsBigInteger.toLong\n        if (numAsBigIntegerAsLong.isNaN) {\n            return numAsBigIntegerAsLong\n        }\n        val numAsLongAsLong = numAsLong.toLong\n        if (numAsLongAsLong.isNaN) {\n            return numAsLongAsLong\n        }\n        val numAsIntAsLongAsLong = numAsIntAsLong.\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293208,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpupqz3feg.scala:71:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpupqz3feg.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpupqz3feg.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(numAsInt)\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpupqz3feg.scala:28:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsFloat\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsFloat : Float)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpupqz3feg.scala:32:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsDouble\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsDouble : Double)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpupqz3feg.scala:34:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(1)\n            val ceil = abs.ceilDiv(1)\n            if (num.equals(floor)) {\n                return floor\n            } else if (num.equals(ceil)) {\n                return ceil\n            } else {\n                return num\n            }\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293252,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8vkjwj7s.scala:21:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8vkjwj7s.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceilDiv is not a member of Long\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            return 0l\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return 0l\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return 0l\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return 0l\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            return 0l\n        }\n        val numAsShort = num.toShort\n        if (numAsShort.isNaN) {\n            return 0l\n        }\n        val numAsByte = num.toByte\n        if (numAsByte.isNaN) {\n            return 0l\n        }\n        val numAsLong = num.toLong\n        if (numAsLong.isNaN) {\n            return 0l\n        }\n        val numAsInteger = num.toInt\n        if (numAsInteger.isNaN) {\n            return 0l\n        }\n        val numAsFloatAsInt = numAsInt.toFloat\n        if (numAsFloatAsInt.isNaN) {\n            return 0l\n        }\n        val numAsDoubleAsInt = numAsInt.toDouble\n        if (numAsDoubleAsInt.isNaN) {\n            return 0l\n        }\n        val numAsBigDecimalAsInt = numAsInt.toBigDecimal\n        if (numAsBigDecimalAsInt.isNaN) {\n            return 0l\n        }\n        val numAsBigIntegerAsInt = numAsInt.toBigInteger\n        if (numAsBigIntegerAsInt.isNaN) {\n            return 0l\n        }\n        val numAsShortAsInt = numAsInt.toShort\n        if (numAsShortAsInt.isNa\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293255,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpt8zfd6bw.scala:76:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt8zfd6bw.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt8zfd6bw.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt8zfd6bw.scala:34:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt8zfd6bw.scala:38:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInteger\u001b[0m = num.toBigInteger\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigInteger is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt8zfd6bw.scala:43:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mif\u001b[0m (numAsShort.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Short.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsShort)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(abs.div(abs.sub(1)))\n            val ceil = abs.ceilDiv(abs.div(abs.sub(1)))\n            if (num.compareTo(floor) < 0) {\n                return floor\n            } else {\n                return ceil\n            }\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpoaewrj6k.scala:21:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(abs.div(abs.sub(\u001b[31m1\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpoaewrj6k.scala:21:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(abs.div(abs.sub(\u001b[31m1\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpoaewrj6k.scala:21:49 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(abs.div(abs.sub(\u001b[31m1\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       value sub is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpoaewrj6k.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(abs.div(abs.sub(\u001b[31m1\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceilDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpoaewrj6k.scala:22:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(abs.div(abs.sub(\u001b[31m1\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpoaewrj6k.scala:22:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(abs.div(abs.sub(\u001b[31m1\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       value sub is not a mem",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val nearest = abs.div(abs.div(2)).toInt\n            if (abs.mod(nearest).isZero) {\n                return nearest\n            } else {\n                return nearest - 1\n            }\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293254,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp41by61gp.scala:21:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnearest\u001b[0m = abs.div(abs.div(\u001b[31m2\u001b[0m)).toInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp41by61gp.scala:21:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnearest\u001b[0m = abs.div(abs.div(\u001b[31m2\u001b[0m)).toInt\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp41by61gp.scala:22:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (abs.mod(nearest).isZero) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue mod is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.long2bigInt\n\u001b[31m   |\u001b[0m\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            return -num\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpp5jr_wxg.scala:18)\n\tat Problem$.main(tmpp5jr_wxg.scala:27)\n\tat Problem.main(tmpp5jr_wxg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n        val intPart = num.intPart\n        val fracPart = num.fracPart\n        val intPartAsLong = intPart.toLong\n        val fracPartAsLong = fracPart.toLong\n        val intPartAsDouble = intPartAsLong.toDouble\n        val fracPartAsDouble = fracPartAsLong.toDouble\n        val intPartAsFloat = intPartAsDouble.toFloat\n        val fracPartAsFloat = fracPartAsDouble.toFloat\n        val intPartAsInt = intPartAsFloat.toInt\n        val fracPartAsInt = fracPartAsFloat.toInt\n        val intPartAsShort = intPartAsInt.toShort\n        val fracPartAsShort = fracPartAsInt.toShort\n        val intPartAsByte = intPartAsShort.toByte\n        val fracPartAsByte = fracPartAsShort.toByte\n        val intPartAsChar = intPartAsByte.toChar\n        val fracPartAsChar = fracPartAsByte.toChar\n        val intPartAsBoolean = intPartAsChar.toBoolean\n        val fracPartAsBoolean = fracPartAsChar.toBoolean\n        val intPartAsString = intPartAsBoolean.toString\n        val fracPartAsString = fracPartAsBoolean.toString\n        val intPartAsInt = intPartAsString.toInt\n        val fracPartAsInt = fracPartAsString.toInt\n        val intPartAsShort = intPartAsInt.toShort\n        val fracPartAsShort = fracPartAsInt.toShort\n        val intPartAsByte = intPartAsShort.toByte\n        val fracPartAsByte = fracPartAsShort.toByte\n        val intPartAsChar = intPartAsByte.toChar\n        val fracPartAsChar = fracPartAsByte.toChar\n        val intPartAsBoolean = intPartAsChar.toBoolean\n        val fracPartAsBoolean = fracPartAsChar.toBoolean\n        val intPartAsString = intPartAsBoolean.toString\n        val fracPartAsString = fracPartAs\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293189,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8tj7o5np.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mintPartAsInt\u001b[0m = intPartAsString.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mintPartAsInt is already defined as \u001b[33mvalue\u001b[0m \u001b[35mintPartAsInt\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8tj7o5np.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mfracPartAsInt\u001b[0m = fracPartAsString.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mfracPartAsInt is already defined as \u001b[33mvalue\u001b[0m \u001b[35mfracPartAsInt\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8tj7o5np.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mintPartAsShort\u001b[0m = intPartAsInt.toShort\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mintPartAsShort is already defined as \u001b[33mvalue\u001b[0m \u001b[35mintPartAsShort\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8tj7o5np.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mfracPartAsShort\u001b[0m = fracPartAsInt.toShort\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mfracPartAsShort is already defined as \u001b[33mvalue\u001b[0m \u001b[35mfracPartAsShort\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8tj7o5np.scala:43:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mintPartAsByte\u001b[0m = intPartAsShort.toByte\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(1)\n            val ceil = abs.ceilDiv(1)\n            if (num.equals(floor))\n                return num\n            else if (num.equals(ceil))\n                return num.subtract(1)\n            else\n                return num.subtract(floor).add(1)\n        } else {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(1)\n            val ceil = abs.ceilDiv(1)\n            if (num.equals(floor))\n                return num\n            else if (num.equals(ceil))\n                return num.subtract(1)\n            else\n                return num.subtract(floor).add(1)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293254,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqhhr9k0x.scala:21:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqhhr9k0x.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceilDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqhhr9k0x.scala:26:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mreturn\u001b[0m num.subtract(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqhhr9k0x.scala:28:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                \u001b[33mreturn\u001b[0m num.subtract(floor).add(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqhhr9k0x.scala:31:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqhhr9k0x.scala:32:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceilDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqhhr9k0x.scala:36:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                \u001b[33mreturn\u001b[0m num.subtract(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            return numAsInt\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return numAsFloat\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return numAsDouble\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return numAsBigDecimal\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            return numAsBigInteger\n        }\n        val numAsLong = num.toLong\n        if (numAsLong.isNaN) {\n            return numAsLong\n        }\n        val numAsIntAsBigDecimal = numAsInt.toBigDecimal\n        if (numAsIntAsBigDecimal.isNaN) {\n            return numAsIntAsBigDecimal\n        }\n        val numAsIntAsBigInteger = numAsInt.toBigInteger\n        if (numAsIntAsBigInteger.isNaN) {\n            return numAsIntAsBigInteger\n        }\n        val numAsIntAsLong = numAsInt.toLong\n        if (numAsIntAsLong.isNaN) {\n            return numAsIntAsLong\n        }\n        val numAsIntAsDouble = numAsInt.toDouble\n        if (numAsIntAsDouble.isNaN) {\n            return numAsIntAsDouble\n        }\n        val numAsIntAsFloat = numAsInt.toFloat\n        if (numAsIntAsFloat.isNaN) {\n            return numAsIntAsFloat\n        }\n        val numAsIntAsBigIntegerAsLong = numAsIntAsBigInteger.toLong\n        if (numAsIntAsBigIntegerAsLong.isNaN) {\n            return numAsIntAsBigIntegerAsLong\n        }\n        val numAs\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293257,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfigykakv.scala:71:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfigykakv.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfigykakv.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsInt)\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfigykakv.scala:28:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsFloat\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsFloat : Float)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfigykakv.scala:32:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsDouble\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsDouble : Double)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfigykakv.scala:34:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val v = value.toLowerCase()\n        val num = v.replaceAll(\"[^0-9]\", \"\")\n        val num_int = Long.parseLong(num)\n        val num_int_abs = Math.abs(num_int)\n        val num_int_abs_floor = num_int_abs.floor()\n        val num_int_abs_ceil = num_int_abs.ceil()\n        val num_int_abs_floor_abs = Math.abs(num_int_abs_floor)\n        val num_int_abs_ceil_abs = Math.abs(num_int_abs_ceil)\n        val num_int_abs_floor_abs_plus_one = num_int_abs_floor_abs + 1\n        val num_int_abs_ceil_abs_minus_one = num_int_abs_ceil_abs - 1\n        val num_int_abs_floor_abs_plus_one_abs = Math.abs(num_int_abs_floor_abs_plus_one)\n        val num_int_abs_ceil_abs_minus_one_abs = Math.abs(num_int_abs_ceil_abs_minus_one)\n        val num_int_abs_floor_abs_plus_one_abs_plus_one = num_int_abs_floor_abs_plus_one_abs + 1\n        val num_int_abs_ceil_abs_minus_one_abs_minus_one = num_int_abs_ceil_abs_minus_one_abs - 1\n        val num_int_abs_floor_abs_plus_one_abs_plus_one_abs = Math.abs(num_int_abs_floor_abs_plus_one_abs_plus_one)\n        val num_int_abs_ceil_abs_minus_one_abs_minus_one_abs = Math.abs(num_int_abs_ceil_abs_minus_one_abs_minus_one)\n        val num_int_abs_floor_abs_plus_one_abs_plus_one_abs_plus_one = Math.abs(num_int_abs_floor_abs_plus\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293254,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpd1pdh5u9.scala:35:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpd1pdh5u9.scala:20:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnum_int\u001b[0m = Long.parseLong(num)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value parseLong is not a member of object Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd1pdh5u9.scala:34:80 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnum_int_abs_floor_abs_plus_one_abs_plus_one_abs_plus_one\u001b[0m = Math.abs(num_int_abs_floor_abs_plus\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: num_int_abs_floor_abs_plus\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpd1pdh5u9.scala:35:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsDouble = num.toDouble\n        val numAsFloat = num.toFloat\n        val numAsShort = num.toShort\n        val numAsByte = num.toByte\n        val numAsChar = num.toChar\n        val numAsLong = num.toLong\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAs\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293257,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpkg5zrjsr.scala:57:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpkg5zrjsr.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpkg5zrjsr.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpkg5zrjsr.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpkg5zrjsr.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val abs = num.abs\n        if (abs.isNaN) {\n            return 0l\n        }\n        val absInt = abs.toInt\n        if (absInt.isNaN) {\n            return 0l\n        }\n        val absIntPlusOne = absInt + 1\n        if (absIntPlusOne.isNaN) {\n            return 0l\n        }\n        val absIntMinusOne = absInt - 1\n        if (absIntMinusOne.isNaN) {\n            return 0l\n        }\n        val absIntPlusOneHalf = absIntPlusOne / 2\n        if (absIntPlusOneHalf.isNaN) {\n            return 0l\n        }\n        val absIntMinusOneHalf = absIntMinusOne / 2\n        if (absIntMinusOneHalf.isNaN) {\n            return 0l\n        }\n        val absIntPlusOneHalfPlusOne = absIntPlusOneHalf + 1\n        if (absIntPlusOneHalfPlusOne.isNaN) {\n            return 0l\n        }\n        val absIntMinusOneHalfPlusOne = absIntMinusOneHalf + 1\n        if (absIntMinusOneHalfPlusOne.isNaN) {\n            return 0l\n        }\n        val absIntPlusOneHalfPlusOneHalf = absIntPlusOneHalfPlusOne / 2\n        if (absIntPlusOneHalfPlusOneHalf.isNaN) {\n            return 0l\n        }\n        val absIntMinusOneHalfPlusOneHalf = absIntMinusOneHalfPlusOne / 2\n        if (absIntMinusOneHalfPlusOneHalf.isNaN) {\n            return 0l\n        }\n        val absIntPlusOneHalfPlusOneHalfPlusOne = absIntPlusOneHalfPlusOneHalf + 1\n        if (absIntPlusOneHalfPlusOneHalfPlusOne.isNaN) {\n            return 0l\n        }\n        val absIntMinusOneHalfPlusOneHalfPlusOne = absIntMinusOneHalfPlusOneHalf + 1\n        if (absIntMinusOneHalfPlusOneHalfPlusOne\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293256,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpkw0rpv5e.scala:68:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkw0rpv5e.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkw0rpv5e.scala:23:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (abs.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(abs)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkw0rpv5e.scala:27:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mif\u001b[0m (absInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(absInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkw0rpv5e.scala:31:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mif\u001b[0m (absIntPlusOne.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(absIntPlusOne)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkw0rpv5e.scala:35:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mif\u001b[0m (absIntMinusOne.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val floor = abs.floor\n            val ceil = abs.ceiling\n            val diff = abs.subtract(floor)\n            val diff2 = diff.div(2)\n            val diff3 = diff2.div(2)\n            val diff4 = diff3.div(2)\n            val diff5 = diff4.div(2)\n            val diff6 = diff5.div(2)\n            val diff7 = diff6.div(2)\n            val diff8 = diff7.div(2)\n            val diff9 = diff8.div(2)\n            val diff10 = diff9.div(2)\n            val diff11 = diff10.div(2)\n            val diff12 = diff11.div(2)\n            val diff13 = diff12.div(2)\n            val diff14 = diff13.div(2)\n            val diff15 = diff14.div(2)\n            val diff16 = diff15.div(2)\n            val diff17 = diff16.div(2)\n            val diff18 = diff17.div(2)\n            val diff19 = diff18.div(2)\n            val diff20 = diff19.div(2)\n            val diff21 = diff20.div(2)\n            val diff22 = diff21.div(2)\n            val diff23 = diff22.div(2)\n            val diff24 = diff23.div(2)\n            val diff25 = diff24.div(2)\n            val diff26 = diff25.div(2)\n            val diff27 = diff26.div(2)\n            val diff28 = diff27.div(2)\n            val diff29 = diff28.div(2)\n            val diff30 = diff29.div(2)\n            val diff31 = diff30.div(2)\n            val diff32 = diff31.div(2)\n            val diff33 = diff32.div(2)\n            val diff34 = diff33.div(2)\n            val diff35 = diff34.div(2)\n            val diff36 = diff35.div(2\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293257,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfh505gan.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfh505gan.scala:69:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfh505gan.scala:21:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floor\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value floor is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          doubleWrapper(abs)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfh505gan.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceiling\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceiling is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfh505gan.scala:23:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdiff\u001b[0m = abs.subtract(floor)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfh505gan.scala:68:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpfh505gan.scala:60:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m60 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n6 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            return num\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return num\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return num\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return num\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            return num\n        }\n        val numAsShort = num.toShort\n        if (numAsShort.isNaN) {\n            return num\n        }\n        val numAsByte = num.toByte\n        if (numAsByte.isNaN) {\n            return num\n        }\n        val numAsChar = num.toChar\n        if (numAsChar.isNaN) {\n            return num\n        }\n        val numAsFloatChar = num.toFloatChar\n        if (numAsFloatChar.isNaN) {\n            return num\n        }\n        val numAsDoubleChar = num.toDoubleChar\n        if (numAsDoubleChar.isNaN) {\n            return num\n        }\n        val numAsBigDecimalChar = num.toBigDecimalChar\n        if (numAsBigDecimalChar.isNaN) {\n            return num\n        }\n        val numAsBigIntegerChar = num.toBigIntegerChar\n        if (numAsBigIntegerChar.isNaN) {\n            return num\n        }\n        val numAsShortChar = num.toShortChar\n        if (numAsShortChar.isNaN) {\n            return num\n        }\n        val numAsByteChar = num.toByteChar\n        if (numAsByteChar.isNaN) {\n            return num\n        }\n        val numAsCharChar = num.toCharChar\n        \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293258,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe9kkcex6.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe9kkcex6.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe9kkcex6.scala:34:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe9kkcex6.scala:38:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInteger\u001b[0m = num.toBigInteger\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigInteger is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe9kkcex6.scala:43:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mif\u001b[0m (numAsShort.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Short.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(numAsShort)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe9kkcex6.scala:47:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m        \u001b[33mif\u001b[0m (numAsByte.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val res = abs / 2\n            if (abs % 2 == 1) res += 1\n            return res\n        } else {\n            val abs = Math.abs(num)\n            val res = abs / 2\n            if (abs % 2 == 1) res -= 1\n            return res\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293256,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2f88l5zd.scala:22:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (abs % \u001b[31m2\u001b[0m == \u001b[31m1\u001b[0m) res += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value += is not a member of Long - did you mean res.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2f88l5zd.scala:27:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m (abs % \u001b[31m2\u001b[0m == \u001b[31m1\u001b[0m) res -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value -= is not a member of Long - did you mean res.!=?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val max = Math.max(abs, 1)\n            val min = Math.min(abs, 1)\n            val diff = max - min\n            val result = num / diff\n            return result * diff\n        } else {\n            val abs = Math.abs(num)\n            val max = Math.max(abs, 1)\n            val min = Math.min(abs, 1)\n            val diff = max - min\n            val result = num / diff\n            return result * diff\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293257,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptb_xkxkr.scala:36)\n\tat Problem.main(tmptb_xkxkr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            return numAsInt\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return numAsFloat\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return numAsDouble\n        }\n        val numAsBigInt = num.toBigInt\n        if (numAsBigInt.isNaN) {\n            return numAsBigInt\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return numAsBigDecimal\n        }\n        val numAsBigDecimalWithScale = num.toBigDecimalWithScale\n        if (numAsBigDecimalWithScale.isNaN) {\n            return numAsBigDecimalWithScale\n        }\n        val numAsBigDecimalWithScaleAndPrecision = num.toBigDecimalWithScaleAndPrecision\n        if (numAsBigDecimalWithScaleAndPrecision.isNaN) {\n            return numAsBigDecimalWithScaleAndPrecision\n        }\n        val numAsBigDecimalWithPrecision = num.toBigDecimalWithPrecision\n        if (numAsBigDecimalWithPrecision.isNaN) {\n            return numAsBigDecimalWithPrecision\n        }\n        val numAsBigDecimalWithPrecisionAndScale = num.toBigDecimalWithPrecisionAndScale\n        if (numAsBigDecimalWithPrecisionAndScale.isNaN) {\n            return numAsBigDecimalWithPrecisionAndScale\n        }\n        val numAsBigDecimalWithPrecisionAndScaleAndRoundingMode = num.toBigDecimalWithPrecisionAndScaleAndRoundingMode\n        if (numAsBigDecimalWithPrecisionAndScaleAndRoundingMode.isNaN) {\n            return numAsBigDecimalWithPrecisionAndScaleAndRoundingMode\n        }\n        val numAsBigDec\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293177,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5at8uvxl.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5at8uvxl.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5at8uvxl.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(numAsInt)\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5at8uvxl.scala:28:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsFloat\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsFloat : Float)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5at8uvxl.scala:32:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mreturn\u001b[0m numAsDouble\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (numAsDouble : Double)\n\u001b[31m   |\u001b[0m                   Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5at8uvxl.scala:34:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(1)\n            val ceil = abs.ceilDiv(1)\n            if (num.equals(floor)) {\n                return -floor\n            } else if (num.equals(ceil)) {\n                return -ceil\n            } else {\n                return -abs\n            }\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293259,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpprt0s63y.scala:21:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpprt0s63y.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceilDiv is not a member of Long\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(abs.div(10))\n            val ceil = abs.ceilDiv(abs.div(10))\n            if (abs.sub(floor).div(abs.sub(ceil)).toInt < 0) {\n                return abs.sub(floor).div(abs.sub(ceil)).toInt\n            } else {\n                return abs.sub(ceil).div(abs.sub(floor)).toInt\n            }\n        } else {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(abs.div(10))\n            val ceil = abs.ceilDiv(abs.div(10))\n            if (abs.sub(floor).div(abs.sub(ceil)).toInt > 0) {\n                return abs.sub(floor).div(abs.sub(ceil)).toInt\n            } else {\n                return abs.sub(ceil).div(abs.sub(floor)).toInt\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293262,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpk4k6jptu.scala:21:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(abs.div(\u001b[31m10\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpk4k6jptu.scala:21:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(abs.div(\u001b[31m10\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpk4k6jptu.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(abs.div(\u001b[31m10\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceilDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpk4k6jptu.scala:22:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(abs.div(\u001b[31m10\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpk4k6jptu.scala:23:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m (abs.sub(floor).div(abs.sub(ceil)).toInt < \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value sub is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpk4k6jptu.scala:24:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                \u001b[33mreturn\u001b[0m abs.sub(floor).div(abs.sub(ceil)).toInt\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value sub is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpk4k6jptu.scala:26:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val max = abs.max\n            val min = abs.min\n            val diff = max - min\n            val diffAbs = diff.abs\n            val diffAbsHalf = diffAbs / 2\n            val diffAbsHalfAbs = diffAbsHalf.abs\n            val diffAbsHalfAbsHalf = diffAbsHalfAbs / 2\n            val diffAbsHalfAbsHalfHalf = diffAbsHalfAbsHalf / 2\n            val diffAbsHalfAbsHalfHalfHalf = diffAbsHalfAbsHalfHalf / 2\n            val diffAbsHalfAbsHalfHalfHalfHalf = diffAbsHalfAbsHalfHalfHalf / 2\n            val diffAbsHalfAbsHalfHalfHalfHalfHalf = diffAbsHalfAbsHalfHalfHalfHalf / 2\n            val diffAbsHalfAbsHalfHalfHalfHalfHalfHalf = diffAbsHalfAbsHalfHalfHalfHalfHalf / 2\n            val diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalf = diffAbsHalfAbsHalfHalfHalfHalfHalfHalf / 2\n            val diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalf = diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalf / 2\n            val diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalf = diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalf / 2\n            val diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalfHalf = diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalf / 2\n            val diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalf = diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalfHalf / 2\n            val diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalf = diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalf / 2\n            val diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalf = diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalf / 2\n            val diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalf = diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalf / 2\n            val diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalf = diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalfHalf /\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293263,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpl62oq0v8.scala:41:149 --------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdiffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalfHalf\u001b[0m = diffAbsHalfAbsHalfHalfHalfHalfHalfHalfHalfHalfHalfHalf /\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpl62oq0v8.scala:52:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl62oq0v8.scala:23:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdiff\u001b[0m = max - min\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue - is not a member of Long => Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl62oq0v8.scala:51:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpl62oq0v8.scala:43:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m43 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warnin",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val v = value.toLowerCase.replaceAll(\"[^0-9]\", \"\")\n        if (v.length == 0) {\n            return 0l\n        }\n        val v_int = Int.parseInt(v)\n        val v_float = Float.parseFloat(v)\n        if (v_int == v_float) {\n            return v_int\n        }\n        val v_float_rounded = v_float.round(2)\n        val v_int_rounded = v_int.round(2)\n        if (v_float_rounded == v_int_rounded) {\n            return v_int_rounded\n        } else {\n            return v_float_rounded\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293262,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp34ohhdi9.scala:22:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mv_int\u001b[0m = Int.parseInt(v)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value parseInt is not a member of object Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp34ohhdi9.scala:23:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mv_float\u001b[0m = Float.parseFloat(v)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value parseFloat is not a member of object Float\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val max = abs.max\n            val min = abs.min\n            val diff = max - min\n            val mid = (max + min) / 2\n            val diff2 = diff / 2\n            val diff3 = diff2 / 2\n            val diff4 = diff3 / 2\n            val diff5 = diff4 / 2\n            val diff6 = diff5 / 2\n            val diff7 = diff6 / 2\n            val diff8 = diff7 / 2\n            val diff9 = diff8 / 2\n            val diff10 = diff9 / 2\n            val diff11 = diff10 / 2\n            val diff12 = diff11 / 2\n            val diff13 = diff12 / 2\n            val diff14 = diff13 / 2\n            val diff15 = diff14 / 2\n            val diff16 = diff15 / 2\n            val diff17 = diff16 / 2\n            val diff18 = diff17 / 2\n            val diff19 = diff18 / 2\n            val diff20 = diff19 / 2\n            val diff21 = diff20 / 2\n            val diff22 = diff21 / 2\n            val diff23 = diff22 / 2\n            val diff24 = diff23 / 2\n            val diff25 = diff24 / 2\n            val diff26 = diff25 / 2\n            val diff27 = diff26 / 2\n            val diff28 = diff27 / 2\n            val diff29 = diff28 / 2\n            val diff30 = diff29 / 2\n            val diff31 = diff30 / 2\n            val diff32 = diff31 / 2\n            val diff33 = diff32 / 2\n            val diff34 = diff33 / 2\n            val diff35 = diff34 / 2\n            val diff36 = diff35 / 2\n            val diff37 = diff36 / 2\n            val diff38 = diff37 / 2\n            val diff39 = diff38 / 2\n            val diff40 = diff39 / 2\n            val diff41 = diff40 / 2\n            val diff42 = diff41 / 2\n            val diff43 = diff42 / 2\n            val diff44 = diff43 / 2\n            val diff45 = diff44 / 2\n            val diff46 = diff45 /\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293264,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpgr5ytv5m.scala:69:33 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdiff46\u001b[0m = diff45 /\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgr5ytv5m.scala:80:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgr5ytv5m.scala:23:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdiff\u001b[0m = max - min\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue - is not a member of Long => Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgr5ytv5m.scala:24:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mmid\u001b[0m = (max + min) / \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of Long => Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgr5ytv5m.scala:79:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val abs_int = abs.toInt\n            val abs_long = abs.toLong\n            val abs_float = abs.toFloat\n            val abs_double = abs.toDouble\n            val abs_big_int = abs.toBigInt\n            val abs_big_decimal = abs.toBigDecimal\n            val abs_big_float = abs.toBigFloat\n            val abs_big_double = abs.toBigDouble\n            val abs_big_big_int = abs.toBigBigInt\n            val abs_big_big_decimal = abs.toBigBigDecimal\n            val abs_big_big_float = abs.toBigBigFloat\n            val abs_big_big_double = abs.toBigBigDouble\n            val abs_big_big_big_int = abs.toBigBigBigInt\n            val abs_big_big_big_decimal = abs.toBigBigBigDecimal\n            val abs_big_big_big_float = abs.toBigBigBigFloat\n            val abs_big_big_big_double = abs.toBigBigBigDouble\n            val abs_big_big_big_big_int = abs.toBigBigBigBigInt\n            val abs_big_big_big_big_decimal = abs.toBigBigBigBigDecimal\n            val abs_big_big_big_big_float = abs.toBigBigBigBigFloat\n            val abs_big_big_big_big_double = abs.toBigBigBigBigDouble\n            val abs_big_big_big_big_big_int = abs.toBigBigBigBigBigInt\n            val abs_big_big_big_big_big_decimal = abs.toBigBigBigBigBigDecimal\n            val abs_big_big_big_big_big_float = abs.toBigBigBigBigBigFloat\n            val abs_big_big_big_big_big_double = abs.toBigBigBigBigBigDouble\n            val abs_big_big_big_big_big_big_int = abs.toBigBigBigBigBigBigInt\n\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293178,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpl6bc1nw3.scala:57:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl6bc1nw3.scala:25:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mabs_big_int\u001b[0m = abs.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl6bc1nw3.scala:26:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mabs_big_decimal\u001b[0m = abs.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl6bc1nw3.scala:27:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mabs_big_float\u001b[0m = abs.toBigFloat\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value toBigFloat is not a member of Long - did you mean abs.toFloat?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl6bc1nw3.scala:28:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mabs_big_double\u001b[0m = abs.toBigDouble\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m  value toBigDouble is not a member of Long - did you mean abs.toDouble?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl6bc1nw3.scala:29:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mabs_big_big_int\u001b[0m = abs.toBigBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               value toBigBigInt is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Foun",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            return -num\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpp5jr_wxg.scala:18)\n\tat Problem$.main(tmpp5jr_wxg.scala:27)\n\tat Problem.main(tmpp5jr_wxg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsChar = num.toChar\n        val numAsShort = num.toShort\n        val numAsByte = num.toByte\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAs\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293264,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5qj_b_nw.scala:55:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5qj_b_nw.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5qj_b_nw.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5qj_b_nw.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5qj_b_nw.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsLong = num.toLong\n        if (numAsLong.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsShort = num.toShort\n        if (numAsShort.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsByte = num.toByte\n        if (numAsByte.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsFloatWrapper = num.toFloatWrapper\n        if (numAsFloatWrapper.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsDoubleWrapper = num.toDoubleWrapper\n        if (numAsDoubleWrapper.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigDecimalWrapper = num.toBigDecimalWrapper\n        if (numAsBigDecimalWrapper.isNaN) {\n            throw new NumberFormatException(\"NaN\")\n        }\n        val numAsBigIntegerWrapper = num.toBigIntegerWrapper\n        if (numAsBigIntegerWrapper.\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293224,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqw74h4ut.scala:68:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqw74h4ut.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqw74h4ut.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(numAsInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqw74h4ut.scala:34:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqw74h4ut.scala:38:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInteger\u001b[0m = num.toBigInteger\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigInteger is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqw74h4ut.scala:43:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mif\u001b[0m (numAsLong.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Doubl",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            return -num\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpp5jr_wxg.scala:18)\n\tat Problem$.main(tmpp5jr_wxg.scala:27)\n\tat Problem.main(tmpp5jr_wxg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            return -num\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpp5jr_wxg.scala:18)\n\tat Problem$.main(tmpp5jr_wxg.scala:27)\n\tat Problem.main(tmpp5jr_wxg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsChar = num.toChar\n        val numAsByte = num.toByte\n        val numAsShort = num.toShort\n        val numAsLong = num.toLong\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimal = num.toBigDecimal\n        val numAs\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293205,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp65iz75zc.scala:57:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp65iz75zc.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp65iz75zc.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp65iz75zc.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp65iz75zc.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumAsBigDecimal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumAsBigDecimal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(abs.div(10))\n            val ceil = abs.ceilDiv(abs.div(10))\n            val diff = abs.sub(floor).div(abs.div(10)).toInt\n            if (diff == 0) {\n                return floor\n            } else if (diff == 1) {\n                return ceil\n            } else {\n                return num\n            }\n        } else {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(abs.div(10))\n            val ceil = abs.ceilDiv(abs.div(10))\n            val diff = abs.sub(floor).div(abs.div(10)).toInt\n            if (diff == 0) {\n                return floor\n            } else if (diff == 1) {\n                return ceil\n            } else {\n                return num\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293264,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvwbr5ft8.scala:21:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(abs.div(\u001b[31m10\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvwbr5ft8.scala:21:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(abs.div(\u001b[31m10\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvwbr5ft8.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(abs.div(\u001b[31m10\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceilDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvwbr5ft8.scala:22:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(abs.div(\u001b[31m10\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   value div is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvwbr5ft8.scala:23:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdiff\u001b[0m = abs.sub(floor).div(abs.div(\u001b[31m10\u001b[0m)).toInt\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value sub is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvwbr5ft8.scala:33:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(abs.div(\u001b[31m10\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvwbr5ft8.scala:33:41 -------------------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsChar = num.toChar\n        val numAsShort = num.toShort\n        val numAsByte = num.toByte\n        val numAsBigInt = num.toBigInt\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigDecimalInt = num.toBigDecimalInt\n        val numAsBigDecimalLong = num.toBigDecimalLong\n        val numAsBigDecimalShort = num.toBigDecimalShort\n        val numAsBigDecimalByte = num.toBigDecimalByte\n        val numAsBigDecimalChar = num.toBigDecimalChar\n        val numAsBigDecimalFloat = num.toBigDecimalFloat\n        val numAsBigDecimalDouble = num.toBigDecimalDouble\n        val numAsBigDecimalString = num.toBigDecimalString\n        val numAsBigDecimalStringInt = num.toBigDecimalStringInt\n        val numAsBigDecimalStringLong = num.toBigDecimalStringLong\n        val numAsBigDecimalStringShort = num.toBigDecimalStringShort\n        val numAsBigDecimalStringByte = num.toBigDecimalStringByte\n        val numAsBigDecimalStringChar = num.toBigDecimalStringChar\n        val numAsBigDecimalStringFloat = num.toBigDecimalStringFloat\n        val numAsBigDecimalStringDouble = num.toBigDecimalStringDouble\n        val numAsBigDecimalStringString = num.toBigDecimalStringString\n        val numAsBigDecimalStringStringInt = num.toBigDecimalStringStringInt\n        val numAsBigDecimalStringStringLong = num.toBigDecimalStringStringLong\n        val numAsBigDecimalStringStringShort = num.toBigDecimalStringStringShort\n        val numAsBigDecimalStringStringByte = num.toBigDecimalStringStringByte\n        val numAsBigDecimalStringStringChar = num.toBigDecimalString\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293235,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2nq49hys.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2nq49hys.scala:28:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInt\u001b[0m = num.toBigInt\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toBigInt is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.long2bigDecimal\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2nq49hys.scala:29:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2nq49hys.scala:30:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalInt\u001b[0m = num.toBigDecimalInt\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value toBigDecimalInt is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2nq49hys.scala:31:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimalLong\u001b[0m = num.toBigDecimalLong\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value toBigDecimalLong is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2nq49hys.scala:32:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDeci",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(1)\n            val ceil = abs.ceilDiv(1)\n            if (abs.subtract(floor).compareTo(ceil.subtract(abs)) > 0)\n                return abs.subtract(floor).add(1)\n            else\n                return abs.subtract(ceil).subtract(1)\n        } else {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(1)\n            val ceil = abs.ceilDiv(1)\n            if (abs.subtract(floor).compareTo(ceil.subtract(abs)) > 0)\n                return abs.subtract(floor)\n            else\n                return abs.subtract(ceil)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293264,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy4ihr6ta.scala:21:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy4ihr6ta.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceilDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy4ihr6ta.scala:23:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m (abs.subtract(floor).compareTo(ceil.subtract(abs)) > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy4ihr6ta.scala:24:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                \u001b[33mreturn\u001b[0m abs.subtract(floor).add(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy4ihr6ta.scala:26:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mreturn\u001b[0m abs.subtract(ceil).subtract(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy4ihr6ta.scala:29:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy4ihr6ta.scala:30:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilD",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            return -num\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpp5jr_wxg.scala:18)\n\tat Problem$.main(tmpp5jr_wxg.scala:27)\n\tat Problem.main(tmpp5jr_wxg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val max = Math.max(abs, 1)\n            val min = Math.min(abs, 1)\n            val diff = max - min\n            val res = max - diff\n            if (diff == 0) {\n                res = max\n            }\n            return res\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293261,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpot6j1gz_.scala:26:20 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                res = max\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val res\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            return -num\n        } else {\n            return num\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpp5jr_wxg.scala:18)\n\tat Problem$.main(tmpp5jr_wxg.scala:27)\n\tat Problem.main(tmpp5jr_wxg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n        val intPart = num.intPart\n        val fracPart = num.fracPart\n        val abs = num.abs\n        val sign = num.signum\n        val intPartAsLong = intPart.toLong\n        val fracPartAsLong = fracPart.toLong\n        val absAsLong = abs.toLong\n        val signAsLong = sign.toLong\n        val intPartAsLongPlusOne = intPartAsLong + 1\n        val intPartAsLongMinusOne = intPartAsLong - 1\n        val fracPartAsLongPlusOne = fracPartAsLong + 1\n        val fracPartAsLongMinusOne = fracPartAsLong - 1\n        val absAsLongPlusOne = absAsLong + 1\n        val absAsLongMinusOne = absAsLong - 1\n        val signAsLongPlusOne = signAsLong + 1\n        val signAsLongMinusOne = signAsLong - 1\n        val intPartAsLongPlusOneFracPartAsLong = intPartAsLongPlusOne * fracPartAsLong\n        val intPartAsLongMinusOneFracPartAsLong = intPartAsLongMinusOne * fracPartAsLong\n        val intPartAsLongPlusOneAbs = intPartAsLongPlusOne * abs\n        val intPartAsLongMinusOneAbs = intPartAsLongMinusOne * abs\n        val intPartAsLongPlusOneAbsFracPartAsLong = intPartAsLongPlusOneAbs * fracPartAsLong\n        val intPartAsLongMinusOneAbsFracPartAsLong = intPartAsLongMinusOneAbs * fracPartAsLong\n        val intPartAsLongPlusOneAbsFracPartAsLongPlusOne = intPartAsLongPlusOneAbsFracPartAsLong + 1\n        val intPartAsLongMinusOneAbsFracPartAsLongMinusOne = intPartAsLongMinusOneAbsFracPartAsLong - 1\n        val intPartAsLongPlusOneAbsFracPartAsLongMinusOne = intPartAsLongPlusOneAbsFracPartAsLong - 1\n        val intPartAsLongMinusOneAbsFracPartAsLongPlusOne = intPartAsLongMinusOneAbsFracPartAsLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293265,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmrl7mb52.scala:19:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mintPart\u001b[0m = num.intPart\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value intPart is not a member of Double\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmrl7mb52.scala:20:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mfracPart\u001b[0m = num.fracPart\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value fracPart is not a member of Double\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmrl7mb52.scala:45:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        val numAsFloat = num.toFloat\n        val numAsDouble = num.toDouble\n        val numAsBigDecimal = num.toBigDecimal\n        val numAsBigInteger = num.toBigInteger\n        val numAsShort = num.toShort\n        val numAsByte = num.toByte\n        val numAsChar = num.toChar\n        val numAsFloatWrapper = num.toFloatWrapper\n        val numAsDoubleWrapper = num.toDoubleWrapper\n        val numAsBigDecimalWrapper = num.toBigDecimalWrapper\n        val numAsBigIntegerWrapper = num.toBigIntegerWrapper\n        val numAsShortWrapper = num.toShortWrapper\n        val numAsByteWrapper = num.toByteWrapper\n        val numAsCharWrapper = num.toCharWrapper\n        val numAsFloatArray = num.toFloatArray\n        val numAsDoubleArray = num.toDoubleArray\n        val numAsBigDecimalArray = num.toBigDecimalArray\n        val numAsBigIntegerArray = num.toBigIntegerArray\n        val numAsShortArray = num.toShortArray\n        val numAsByteArray = num.toByteArray\n        val numAsCharArray = num.toCharArray\n        val numAsFloatWrapperArray = num.toFloatWrapperArray\n        val numAsDoubleWrapperArray = num.toDoubleWrapperArray\n        val numAsBigDecimalWrapperArray = num.toBigDecimalWrapperArray\n        val numAsBigIntegerWrapperArray = num.toBigIntegerWrapperArray\n        val numAsShortWrapperArray = num.toShortWrapperArray\n        val numAsByteWrapperArray = num.toByteWrapperArray\n        val numAsCharWrapperArray = num.toCharWrapperArray\n        val numAsFloatArrayWrapper = num.toFloatArrayWrapper\n        val numAsDoubleArrayWrapper = num.toDoubleArrayWrapper\n        val numAsBigDecimalArrayWrapper = num.toBigDecimalArrayWrapper\n        val\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293266,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpxhgx64ws.scala:54:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m        \u001b[33mval\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxhgx64ws.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxhgx64ws.scala:25:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxhgx64ws.scala:26:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInteger\u001b[0m = num.toBigInteger\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigInteger is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxhgx64ws.scala:30:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsFloatWrapper\u001b[0m = num.toFloatWrapper\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            value toFloatWrapper is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxhgx64ws.scala:31:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsDoubleWrapper\u001b[0m = num.toDoubleWrapper\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value toDoubleWrapper is not a member of Long\n\u001b[31m\u001b[31m-- [E00",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n        val abs = num.abs\n        val intPart = num.floor\n        val fracPart = num.subtract(intPart)\n        val frac = fracPart.abs\n        val intPartAsLong = intPart.toLong\n        val fracAsLong = fracPart.toLong\n        val absAsLong = abs.toLong\n        val diff = absAsLong - intPartAsLong\n        val diffAsLong = diff.abs\n        val diffAsInt = diff.toInt\n        val diffAsFrac = diff.subtract(diffAsInt)\n        val diffAsFracAsLong = diffAsFrac.toLong\n        val diffAsFracAsInt = diffAsFrac.toInt\n        val diffAsFracAsFrac = diffAsFrac.subtract(diffAsFracAsInt)\n        val diffAsFracAsFracAsLong = diffAsFracAsFrac.toLong\n        val diffAsFracAsFracAsInt = diffAsFracAsFrac.toInt\n        val diffAsFracAsFracAsFrac = diffAsFracAsFrac.subtract(diffAsFracAsFracAsInt)\n        val diffAsFracAsFracAsFracAsLong = diffAsFracAsFracAsFrac.toLong\n        val diffAsFracAsFracAsFracAsInt = diffAsFracAsFracAsFrac.toInt\n        val diffAsFracAsFracAsFracAsFrac = diffAsFracAsFracAsFracAsInt.subtract(diffAsFracAsFracAsFracAsInt)\n        val diffAsFracAsFracAsFracAsFracAsLong = diffAsFracAsFracAsFracAsFracAsInt.toLong\n        val diffAsFracAsFracAsFracAsFracAsInt = diffAsFracAsFracAsFracAsFracAsFrac.toInt\n        val diffAsFracAsFracAsFracAsFracAsFrac = diffAsFracAsFracAsFracAsFracAsFracAsInt.subtract(diffAsFrac\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293265,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpl_76pr4d.scala:42:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl_76pr4d.scala:21:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mfracPart\u001b[0m = num.subtract(intPart)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value subtract is not a member of Double\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl_76pr4d.scala:29:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mdiffAsFrac\u001b[0m = diff.subtract(diffAsInt)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl_76pr4d.scala:41:49 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mdiffAsFracAsFracAsFracAsFracAsFrac\u001b[0m = diffAsFracAsFracAsFracAsFracAsFracAsInt.subtract(diffAsFrac\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: diffAsFracAsFracAsFracAsFracAsFracAsInt\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl_76pr4d.scala:42:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(1)\n            val ceil = abs.ceilDiv(1)\n            if (abs.subtract(floor).compareTo(ceil.subtract(abs)) > 0)\n                return -floor\n            else\n                return -ceil\n        } else {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(1)\n            val ceil = abs.ceilDiv(1)\n            if (abs.subtract(floor).compareTo(ceil.subtract(abs)) > 0)\n                return floor\n            else\n                return ceil\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293191,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo4jky9lb.scala:21:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo4jky9lb.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceilDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo4jky9lb.scala:23:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m (abs.subtract(floor).compareTo(ceil.subtract(abs)) > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo4jky9lb.scala:29:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo4jky9lb.scala:30:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceilDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo4jky9lb.scala:31:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mif\u001b[0m (abs.subtract(floor).compareTo(ceil.subtract(abs)) > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value subtract is not a member of Long\n6 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val abs = num.abs\n        val intPart = abs.floor\n        val fracPart = abs.subtract(intPart)\n        val frac = fracPart.toDouble\n        val intPartAsLong = intPart.toLong\n        val fracAsLong = frac.toLong\n        val result = intPartAsLong + (fracAsLong / Math.pow(10, Math.floor(Math.log10(fracAsLong))))\n        if (fracAsLong % Math.pow(10, Math.floor(Math.log10(fracAsLong))) != 0) {\n            result = result + 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293265,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_inrt82f.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          float2Float(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_inrt82f.scala:23:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mintPart\u001b[0m = abs.floor\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value floor is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          doubleWrapper(abs)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_inrt82f.scala:24:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mfracPart\u001b[0m = abs.subtract(intPart)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp_inrt82f.scala:30:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            result = result + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num.isNaN) {\n            return 0l\n        }\n        val numAsInt = num.toInt\n        if (numAsInt.isNaN) {\n            return 0l\n        }\n        val numAsFloat = num.toFloat\n        if (numAsFloat.isNaN) {\n            return 0l\n        }\n        val numAsDouble = num.toDouble\n        if (numAsDouble.isNaN) {\n            return 0l\n        }\n        val numAsBigDecimal = num.toBigDecimal\n        if (numAsBigDecimal.isNaN) {\n            return 0l\n        }\n        val numAsBigInteger = num.toBigInteger\n        if (numAsBigInteger.isNaN) {\n            return 0l\n        }\n        val numAsLong = num.toLong\n        if (numAsLong.isNaN) {\n            return 0l\n        }\n        val numAsIntAsLong = numAsInt.toLong\n        if (numAsIntAsLong.isNaN) {\n            return 0l\n        }\n        val numAsFloatAsLong = numAsFloat.toLong\n        if (numAsFloatAsLong.isNaN) {\n            return 0l\n        }\n        val numAsDoubleAsLong = numAsDouble.toLong\n        if (numAsDoubleAsLong.isNaN) {\n            return 0l\n        }\n        val numAsBigDecimalAsLong = numAsBigDecimal.toLong\n        if (numAsBigDecimalAsLong.isNaN) {\n            return 0l\n        }\n        val numAsBigIntegerAsLong = numAsBigInteger.toLong\n        if (numAsBigIntegerAsLong.isNaN) {\n            return 0l\n        }\n        val numAsLongAsInt = numAsLong.toInt\n        if (numAsLongAsInt.isNaN) {\n            return 0l\n        }\n        val numAsLongAsFloat = numAsLong.toFloat\n        if (numAsLongAsFloat.isNaN) {\n            return 0l\n        }\n        val numAsLongAsDouble =\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293265,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpmoyxk24p.scala:74:31 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsLongAsDouble\u001b[0m =\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmoyxk24p.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (num.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Long.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(num)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmoyxk24p.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (numAsInt.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value isNaN is not a member of Int.\n\u001b[31m   |\u001b[0m      An extension method was tried, but could not be fully constructed:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          double2Double(numAsInt)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmoyxk24p.scala:34:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigDecimal\u001b[0m = num.toBigDecimal\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigDecimal is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmoyxk24p.scala:38:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumAsBigInteger\u001b[0m = num.toBigInteger\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value toBigInteger is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmoyxk24p.scala:43:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mif\u001b[0m (numAsLong.isNaN) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^\u001b[0m\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Create a function that takes a value (string) representing a number\n    // and returns the closest integer to it. If the number is equidistant\n    // from two integers, round it away from zero.\n    // Examples\n    // >>> closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the given number is equidistant\n    // from two integers, the one you should return is the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n        if (num < 0) {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(1)\n            val ceil = abs.ceilDiv(1)\n            if (abs.subtract(floor).abs().min() < abs.subtract(ceil).abs().min())\n                return num.subtract(floor).toLong\n            else\n                return num.subtract(ceil).toLong\n        } else {\n            val abs = Math.abs(num)\n            val floor = abs.floorDiv(1)\n            val ceil = abs.ceilDiv(1)\n            if (abs.subtract(floor).abs().min() < abs.subtract(ceil).abs().min())\n                return num.add(floor).toLong\n            else\n                return num.add(ceil).toLong\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n",
      "timestamp": 1664293265,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9qftsoz_.scala:21:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9qftsoz_.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ceilDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9qftsoz_.scala:23:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m (abs.subtract(floor).abs().min() < abs.subtract(ceil).abs().min())\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9qftsoz_.scala:24:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                \u001b[33mreturn\u001b[0m num.subtract(floor).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9qftsoz_.scala:26:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mreturn\u001b[0m num.subtract(ceil).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value subtract is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9qftsoz_.scala:29:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mfloor\u001b[0m = abs.floorDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value floorDiv is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9qftsoz_.scala:30:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mceil\u001b[0m = abs.ceilDiv(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}