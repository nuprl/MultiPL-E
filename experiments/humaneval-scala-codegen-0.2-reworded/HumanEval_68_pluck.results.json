{
  "name": "HumanEval_68_pluck",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "results": [
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) return arr\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        var index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < smallest_even_value) {\n                    smallest_even_value = i\n                    smallest_index = index\n                }\n            }\n            index += 1\n        }\n        return arr.map(x => [x, smallest_index])\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpjuifjft3.scala:43:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mreturn\u001b[0m arr.map(\u001b[36mx\u001b[0m => [x, smallest_index])\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '=>' expected, but ')' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjuifjft3.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) \u001b[33mreturn\u001b[0m arr\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val result = mutable.List[Long]()\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty()) {\n            return result\n        }\n        val smallest = evens.minBy(x => x)\n        val index = arr.indexOf(smallest)\n        result = result.append(smallest)\n        result = result.append(index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292589,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpme_njoj3.scala:30:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpme_njoj3.scala:32:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mif\u001b[0m (evens.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpme_njoj3.scala:37:15 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        result = result.append(smallest)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpme_njoj3.scala:38:15 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        result = result.append(index)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        var min_even_index = 0\n        var even_count = 0\n        for(i <- arr.size) {\n            if(arr.apply(i).toLong % 2 == 0) {\n                even_count += 1\n                if(even_count == 1) {\n                    min_even = arr.apply(i)\n                    min_even_index = i\n                } else if(even_count > 1) {\n                    if(arr.apply(i).toLong < min_even.toLong) {\n                        min_even = arr.apply(i)\n                        min_even_index = i\n                    }\n                }\n            }\n        }\n        if(even_count == 0) {\n            return res\n        }\n        for(i <- arr.size) {\n            if(arr.apply(i).toLong == min_even.toLong) {\n                res = res.append(arr.apply(i))\n                res = res.append(i)\n                return res\n            }\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptd3sb9nk.scala:35:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- arr.size) {\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value foreach is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptd3sb9nk.scala:52:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- arr.size) {\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value foreach is not a member of Int\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var smallest_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (arr.head.toLong % 2 == 0) {\n                if (arr.head.toLong < smallest_value) {\n                    smallest_value = arr.head.toLong\n                    smallest_index = i\n                }\n            }\n        }\n        res = res.append(smallest_value)\n        res = res.append(smallest_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkauchfyb.scala:37:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    smallest_index = i\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long @uncheckedVariance)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkauchfyb.scala:41:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        res = res.append(smallest_value)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkauchfyb.scala:42:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        res = res.append(smallest_index)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.minBy(x => x % 2 == 0)._1\n        var min_index = arr.indexOf(min_even)\n        if (min_even == 0) {\n            res = List[Long](min_even, min_index)\n        } else {\n            res = List[Long](min_even)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292591,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm853_x3t.scala:31:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = arr.minBy(\u001b[36mx\u001b[0m => x % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m)._1\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value _1 is not a member of Long\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        var min_even_index = 0\n        for (i <- arr.size - 1) {\n            if (arr.apply(i).toLong % 2 == 0) {\n                if (arr.apply(i).toLong < min_even) {\n                    min_even = arr.apply(i).toLong\n                    min_even_index = i\n                }\n            }\n        }\n        if (min_even_index == 0) {\n            res = arr.apply(min_even_index)\n        } else {\n            res = arr.apply(min_even_index).toLong\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp52mytx2k.scala:34:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- arr.size - \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp52mytx2k.scala:43:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m            res = arr.apply(min_even_index)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Found:    Long\n\u001b[31m   |\u001b[0m                  Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mLong\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp52mytx2k.scala:45:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m            res = arr.apply(min_even_index).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Found:    Long\n\u001b[31m   |\u001b[0m                  Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mLong\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < min_even) {\n                    min_even = i\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        res = res.append(min_even)\n        res = res.append(min_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyi12rnyz.scala:41:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        res = res.append(min_even)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyi12rnyz.scala:42:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        res = res.append(min_index)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even_value = arr.head\n        var min_index = 0\n        for(i <- arr.size - 1) {\n            if(arr.apply(i).toLong % 2 == 0) {\n                if(arr.apply(i).toLong < min_even_value) {\n                    min_even_value = arr.apply(i).toLong\n                    min_index = i\n                }\n            }\n        }\n        res = List[Long](min_even_value, min_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292591,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv7s0_f4o.scala:33:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- arr.size - \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value foreach is not a member of Int\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head.toLong\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i.toLong % 2 == 0) {\n                if (i.toLong < min_even) {\n                    min_even = i.toLong\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        if (min_even == 0) {\n            res = arr.take(min_index)\n        } else {\n            res = arr.take(min_index).append(min_even)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292591,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpouvgibi9.scala:44:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m            res = arr.take(min_index).append(min_even)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_even_value = arr.head()\n        var smallest_index = 0\n        for (i <- arr.tail()) {\n            if (i % 2 == 0) {\n                if (i < smallest_even_value) {\n                    smallest_even_value = i\n                    smallest_index = arr.indexOf(i)\n                }\n            }\n        }\n        result = result.append(smallest_even_value)\n        result = result.append(smallest_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpk449ef4v.scala:31:38 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36msmallest_even_value\u001b[0m = arr.head()\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               \u001b[33mmethod\u001b[0m \u001b[35mhead\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpk449ef4v.scala:33:26 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- arr.tail()) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): Long @uncheckedVariance\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpk449ef4v.scala:41:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        result = result.append(smallest_even_value)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpk449ef4v.scala:42:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        result = result.append(smallest_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        for(i <- arr.tail) {\n            if(i % 2 == 0) {\n                if(i < smallest_even_value) {\n                    smallest_even_value = i\n                    smallest_index = arr.indexOf(i)\n                }\n            }\n        }\n        result = result.append(smallest_even_value)\n        result = result.append(smallest_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3e0i22_d.scala:41:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        result = result.append(smallest_even_value)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3e0i22_d.scala:42:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        result = result.append(smallest_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var smallest_value = arr.head\n        var smallest_index = 0\n        var index = 0\n        for(i <- arr.tail) {\n            if(arr.head.even()) {\n                if(arr.head.value < smallest_value.value) {\n                    smallest_value = arr.head\n                    smallest_index = index\n                }\n            }\n            index += 1\n        }\n        return smallest_value, smallest_index\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292591,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp6xfk_khk.scala:42:29 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mreturn\u001b[0m smallest_value, smallest_index\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             end of statement expected but ',' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6xfk_khk.scala:34:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m(arr.head.even()) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               value even is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6xfk_khk.scala:35:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m(arr.head.value < smallest_value.value) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value value is not a member of Long\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val result = mutable.List[Long]()\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty()) {\n            return result\n        }\n        val smallestEven = evens.minBy(x => x)\n        val index = arr.indexOf(smallestEven)\n        result = result.append(smallestEven)\n        result = result.append(index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsrx08g1w.scala:30:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpsrx08g1w.scala:32:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mif\u001b[0m (evens.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpsrx08g1w.scala:37:15 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        result = result.append(smallestEven)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpsrx08g1w.scala:38:15 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        result = result.append(index)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val res = mutable.List[Long]()\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty()) {\n            return res\n        }\n        val smallest_even = evens.minBy(x => x)\n        val smallest_index = evens.indexOf(smallest_even)\n        res.append(smallest_even)\n        res.append(smallest_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwzz289we.scala:30:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpwzz289we.scala:32:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mif\u001b[0m (evens.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.minBy(x => x % 2 == 0)._1\n        var min_index = arr.indexOf(min_even)\n        if (min_even == 0) {\n            res = arr.take(min_index)\n        } else {\n            res = arr.take(min_index + 1)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292591,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppydep6el.scala:31:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = arr.minBy(\u001b[36mx\u001b[0m => x % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m)._1\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value _1 is not a member of Long\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        var i = 0\n        while(i < arr.size) {\n            if(arr.apply(i).toLong % 2 == 0) {\n                if(arr.apply(i).toLong < smallest_even_value) {\n                    smallest_even_value = arr.apply(i).toLong\n                    smallest_index = i\n                }\n            }\n            i = i + 1\n        }\n        result = result.append(smallest_even_value)\n        result = result.append(smallest_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1lrnwl2_.scala:43:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        result = result.append(smallest_even_value)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1lrnwl2_.scala:44:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        result = result.append(smallest_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) return arr\n        var smallest_value = arr.head\n        var smallest_index = 0\n        var index = 0\n        for (i <- arr.tail) {\n            if (arr.head.toLong % 2 == 0 && arr.head.toLong < i.toLong) {\n                smallest_value = arr.head\n                smallest_index = index\n            }\n            if (arr.head.toLong < i.toLong) {\n                smallest_value = i\n                smallest_index = index\n            }\n            index += 1\n        }\n        return (List[Long](smallest_value, smallest_index))\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292589,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpkyj8f8mn.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) \u001b[33mreturn\u001b[0m arr\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) {\n            return arr\n        }\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (i.toLong % 2 == 0) {\n                if (i.toLong < smallest_even_value) {\n                    smallest_even_value = i.toLong\n                    smallest_index = arr.indexOf(i)\n                }\n            }\n        }\n        return (List[Long](smallest_even_value, smallest_index))\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292589,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp0_fbu_r5.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val result = mutable.List[Long]()\n        val smallest_even = arr.filter(x => x % 2 == 0).minBy[Long](x => x)\n        if (smallest_even != null) {\n            result.append(smallest_even)\n            result.append(arr.indexOf(smallest_even))\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292591,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp07yndps7.scala:30:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp07yndps7.scala:32:12 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mif\u001b[0m (smallest_even != \u001b[31mnull\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          Values of types Long and Null cannot be compared with == or !=\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = Long.MAX_VALUE\n        var min_index = -1\n        for (i <- 0 until arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        if (min_index != -1) {\n            res = List[Long](min_even, min_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292591,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpz7l2tw87.scala:31:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = Long.MAX_VALUE\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value MAX_VALUE is not a member of object Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz7l2tw87.scala:34:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz7l2tw87.scala:35:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < min_even) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz7l2tw87.scala:36:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) {\n            return List[Long]()\n        }\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        var index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < smallest_even_value) {\n                    smallest_even_value = i\n                    smallest_index = index\n                }\n            }\n            index += 1\n        }\n        return List[Long](smallest_even_value, smallest_index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp8nt__y93.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) {\n            return arr\n        }\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < smallest_even_value) {\n                    smallest_even_value = i\n                    smallest_index = arr.indexOf(i)\n                }\n            }\n        }\n        return arr.take(smallest_index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp_fdvxbiq.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < min_even) {\n                    min_even = i\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        result = List[Long](min_even, min_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpokrcvb2f.scala:46)\n\tat Problem.main(tmpokrcvb2f.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long](arr.size)\n        var min_even = -1\n        var min_index = -1\n        for (i <- 0 until arr.size) {\n            if (arr[i] % 2 == 0) {\n                if (min_even == -1) {\n                    min_even = arr[i]\n                    min_index = i\n                } else if (arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        if (min_even == -1) {\n            result = List[Long]()\n        } else {\n            result = List[Long](min_even, min_index)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfb7tytla.scala:34:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfb7tytla.scala:36:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfb7tytla.scala:38:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (arr[i] < min_even) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfb7tytla.scala:39:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        var min_even_index = 0\n        for (i <- arr.size - 1) {\n            if (arr.apply(i).toLong % 2 == 0) {\n                if (arr.apply(i).toLong < min_even) {\n                    min_even = arr.apply(i).toLong\n                    min_even_index = i\n                }\n            } else {\n                if (arr.apply(i).toLong < min_even) {\n                    min_even = arr.apply(i).toLong\n                    min_even_index = i\n                }\n            }\n        }\n        if (min_even_index == 0) {\n            res = List[Long](min_even, min_index)\n        } else {\n            res = List[Long](min_even, min_even_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuafk63o7.scala:34:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- arr.size - \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        var i = 0\n        while(i < arr.size) {\n            if(arr.apply(i).toInt % 2 == 0) {\n                if(arr.apply(i).toInt < smallest_even_value.toInt) {\n                    smallest_even_value = arr.apply(i)\n                    smallest_index = i\n                }\n            }\n            i = i + 1\n        }\n        result = result.append(smallest_even_value)\n        result = result.append(smallest_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292601,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9rveun9p.scala:43:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        result = result.append(smallest_even_value)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9rveun9p.scala:44:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        result = result.append(smallest_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val result = mutable.List[Long]()\n        val evens = arr.filter(x -> x % 2 == 0)\n        if (evens.isEmpty()) {\n            return result\n        }\n        val smallestEven = evens.minBy(x -> x)\n        val smallestEvenIndex = evens.indexOf(smallestEven)\n        result.append(smallestEven)\n        result.append(smallestEvenIndex)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292597,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8hiyr08i.scala:30:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8hiyr08i.scala:31:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mevens\u001b[0m = arr.filter(x -> x % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: x\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp8hiyr08i.scala:32:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mif\u001b[0m (evens.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8hiyr08i.scala:35:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msmallestEven\u001b[0m = evens.minBy(x -> x)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: x\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp8hiyr08i.scala:35:46 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msmallestEven\u001b[0m = evens.minBy(x -> x)\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mBigInt\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[B] of parameter cmp of \u001b[33mmet",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i.toLong % 2 == 0) {\n                if (i.toLong < min_even) {\n                    min_even = i.toLong\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        result = result.append(min_even)\n        result = result.append(min_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292601,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp58jz1fqg.scala:41:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        result = result.append(min_even)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp58jz1fqg.scala:42:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        result = result.append(min_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val res = mutable.List[Long]()\n        val evens = arr.filter(x -> x % 2 == 0)\n        if (evens.isEmpty()) {\n            return res\n        }\n        val smallest_even = evens.minBy(x -> x)\n        val smallest_index = arr.indexOf(smallest_even)\n        res.append(smallest_even)\n        res.append(smallest_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292596,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8hcvkbsr.scala:30:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8hcvkbsr.scala:31:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mevens\u001b[0m = arr.filter(x -> x % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: x\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp8hcvkbsr.scala:32:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mif\u001b[0m (evens.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8hcvkbsr.scala:35:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msmallest_even\u001b[0m = evens.minBy(x -> x)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Not found: x\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp8hcvkbsr.scala:35:47 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msmallest_even\u001b[0m = evens.minBy(x -> x)\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mShort\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[B] of parameter cmp of \u001b[33mmethod\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        var i = 0\n        while (i < arr.size) {\n            if (arr.apply(i).toLong % 2 == 0) {\n                if (arr.apply(i).toLong < smallest_even_value) {\n                    smallest_even_value = arr.apply(i).toLong\n                    smallest_index = i\n                }\n            }\n            i = i + 1\n        }\n        result = result.append(smallest_even_value)\n        result = result.append(smallest_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292600,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbrrp41jn.scala:43:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        result = result.append(smallest_even_value)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbrrp41jn.scala:44:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        result = result.append(smallest_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) return arr\n        val smalest_value = arr.head()\n        val smalest_index = 0\n        for (i <- arr.tail()) {\n            if (i % 2 == 0) {\n                if (i < smalest_value) {\n                    smalest_value = i\n                    smalest_index = arr.indexOf(i)\n                }\n            }\n        }\n        return arr.take(smalest_index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292598,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpyxm3kn9s.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) \u001b[33mreturn\u001b[0m arr\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpyxm3kn9s.scala:31:32 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msmalest_value\u001b[0m = arr.head()\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               \u001b[33mmethod\u001b[0m \u001b[35mhead\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpyxm3kn9s.scala:33:26 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- arr.tail()) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): Long @uncheckedVariance\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i.toLong % 2 == 0) {\n                if (i.toLong < min_even) {\n                    min_even = i.toLong\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        if (min_even == 0) {\n            result = arr.take(min_index)\n        } else {\n            result = arr.take(min_index).append(min_even)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxxujdrfx.scala:44:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m            result = arr.take(min_index).append(min_even)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = Long.MAX_VALUE\n        var min_index = 0\n        for (i <- 0 until arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        if (min_even == Long.MAX_VALUE) {\n            return res\n        } else {\n            res = List[Long](min_even, min_index)\n            return res\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpb8jhateu.scala:31:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = Long.MAX_VALUE\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value MAX_VALUE is not a member of object Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb8jhateu.scala:34:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb8jhateu.scala:35:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < min_even) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb8jhateu.scala:36:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even_value = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < min_even_value) {\n                    min_even_value = i\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        res = res.append(min_even_value)\n        res = res.append(min_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292603,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7w8uk1p8.scala:41:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        res = res.append(min_even_value)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7w8uk1p8.scala:42:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        res = res.append(min_index)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even_value = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < min_even_value) {\n                    min_even_value = i\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        res = List[Long](min_even_value, min_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292604,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpzltshn0a.scala:46)\n\tat Problem.main(tmpzltshn0a.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.length == 0) return []\n        var smalest_value = arr[0]\n        var smalest_index = 0\n        for (i <- 1 to arr.length - 1) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < smalest_value) {\n                    smalest_value = arr[i]\n                    smalest_index = i\n                }\n            }\n        }\n        return [smalest_value, smalest_index]\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292598,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpiqwu0z_x.scala:30:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.length == \u001b[31m0\u001b[0m) \u001b[33mreturn\u001b[0m []\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   an identifier expected, but ']' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpiqwu0z_x.scala:31:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36msmalest_value\u001b[0m = arr[\u001b[31m0\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m^^^\u001b[0m\n\u001b[31m   |\u001b[0m'=>' expected, but 'end of statement' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpiqwu0z_x.scala:42:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=>' expected, but '}' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpiqwu0z_x.scala:31:31 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36msmalest_value\u001b[0m = arr[\u001b[31m0\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m does not take type parameters\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiqwu0z_x.scala:34:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiqwu0z_x.scala:35:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < smalest_value) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiqwu0z_x.scala:36:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    smalest_value = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m      ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even_value = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i.toLong % 2 == 0) {\n                if (i.toLong < min_even_value) {\n                    min_even_value = i.toLong\n                    min_index = i\n                }\n            }\n        }\n        res = res.append(min_even_value)\n        res = res.append(min_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292602,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2m72wgou.scala:37:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    min_index = i\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    (i : Long @uncheckedVariance)\n\u001b[31m   |\u001b[0m                                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2m72wgou.scala:41:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        res = res.append(min_even_value)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2m72wgou.scala:42:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        res = res.append(min_index)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < min_even) {\n                    min_even = i\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        res = res.append(min_even)\n        res = res.append(min_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyi12rnyz.scala:41:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        res = res.append(min_even)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyi12rnyz.scala:42:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        res = res.append(min_index)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < min_even) {\n                    min_even = i\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        res = res.append(min_even)\n        res = res.append(min_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyi12rnyz.scala:41:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        res = res.append(min_even)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyi12rnyz.scala:42:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        res = res.append(min_index)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head.toLong\n        var min_index = 0\n        for (i <- arr.tail.toList) {\n            if (i.toLong % 2 == 0) {\n                if (i.toLong < min_even) {\n                    min_even = i.toLong\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        if (min_even == 0) {\n            res = arr.take(min_index + 1)\n        } else {\n            res = arr.take(min_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292604,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpepkyxv47.scala:49)\n\tat Problem.main(tmpepkyxv47.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = Long.MAX_VALUE\n        var min_index = 0\n        var min_value = Long.MAX_VALUE\n        var min_index_value = 0\n        for(i <- 0 until arr.length) {\n            if(arr[i] % 2 == 0) {\n                if(arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_index = i\n                    min_value = arr[i]\n                    min_index_value = i\n                }\n            }\n        }\n        result = List[Long](min_value, min_index_value)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292603,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6ql3zj7u.scala:31:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = Long.MAX_VALUE\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value MAX_VALUE is not a member of object Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6ql3zj7u.scala:33:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_value\u001b[0m = Long.MAX_VALUE\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value MAX_VALUE is not a member of object Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6ql3zj7u.scala:36:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            \u001b[33mif\u001b[0m(arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6ql3zj7u.scala:37:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                \u001b[33mif\u001b[0m(arr[\u001b[35mi\u001b[0m] < min_even) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6ql3zj7u.scala:38:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6ql3zj7u.scala:40:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                    min_value = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explana",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) {\n            return arr\n        }\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (i.toLong % 2 == 0) {\n                if (i.toLong < smallest_even_value) {\n                    smallest_even_value = i.toLong\n                    smallest_index = arr.indexOf(i)\n                }\n            }\n        }\n        return (List[Long](smallest_even_value, smallest_index))\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292589,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp0_fbu_r5.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.length == 0) {\n            return []\n        }\n        var smallest_value = arr[0]\n        var smallest_index = 0\n        for (i <- 1 to arr.length - 1) {\n            if (arr[i] < smallest_value) {\n                smallest_value = arr[i]\n                smallest_index = i\n            }\n        }\n        return [smallest_value, smallest_index]\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292600,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0n26zmlr.scala:31:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mreturn\u001b[0m []\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    an identifier expected, but ']' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0n26zmlr.scala:32:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        '=>' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0n26zmlr.scala:42:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=>' expected, but '}' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmp0n26zmlr.scala:33:32 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36msmallest_value\u001b[0m = arr[\u001b[31m0\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m does not take type parameters\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0n26zmlr.scala:36:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < smallest_value) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0n26zmlr.scala:37:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                smallest_value = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n6 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.length == 0) {\n            return []\n        }\n        var smallest_even_value = arr[0]\n        var smallest_index = 0\n        for (i <- 1 to arr.length - 1) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < smallest_even_value) {\n                    smallest_even_value = arr[i]\n                    smallest_index = i\n                }\n            }\n        }\n        return [smallest_even_value, smallest_index]\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292600,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4tp1ar_5.scala:31:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mreturn\u001b[0m []\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    an identifier expected, but ']' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4tp1ar_5.scala:32:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        '=>' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4tp1ar_5.scala:44:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=>' expected, but '}' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmp4tp1ar_5.scala:33:37 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36msmallest_even_value\u001b[0m = arr[\u001b[31m0\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m does not take type parameters\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4tp1ar_5.scala:36:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4tp1ar_5.scala:37:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < smallest_even_value) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4tp1ar_5.scala:38:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                    smallest_even_value = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) return arr\n        var smallest_value = arr.head()\n        var smallest_index = 0\n        var index = 0\n        for (i <- arr.tail()) {\n            if (i % 2 == 0) {\n                if (i < smallest_value) {\n                    smallest_value = i\n                    smallest_index = index\n                }\n            }\n            index += 1\n        }\n        return arr.take(smallest_index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292600,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpdk49w2o8.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) \u001b[33mreturn\u001b[0m arr\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpdk49w2o8.scala:31:33 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36msmallest_value\u001b[0m = arr.head()\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               \u001b[33mmethod\u001b[0m \u001b[35mhead\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpdk49w2o8.scala:34:26 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- arr.tail()) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): Long @uncheckedVariance\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]().toList\n        var min_even = -1\n        var min_index = -1\n        for(i <- 0 until arr.length) {\n            if(arr[i] % 2 == 0) {\n                if(min_even == -1) {\n                    min_even = arr[i]\n                    min_index = i\n                } else if(arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        if(min_even == -1) {\n            return res\n        } else {\n            res = res.append(min_even)\n            res = res.append(min_index)\n            return res\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292603,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp10lhmt0h.scala:34:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m(arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp10lhmt0h.scala:36:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp10lhmt0h.scala:38:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m(arr[i] < min_even) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp10lhmt0h.scala:39:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp10lhmt0h.scala:47:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m            res = res.append(min_even)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp10lhmt0h.scala:48:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m            res = res.append(min_index)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did yo",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) {\n            return arr\n        }\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (arr.head % 2 == 0 && arr.head < i) {\n                smallest_even_value = arr.head\n                smallest_index = i\n                break\n            }\n        }\n        return (List[Long](smallest_even_value, smallest_index))\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292603,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpejdcz8fa.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpejdcz8fa.scala:38:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                smallest_index = i\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long @uncheckedVariance)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpejdcz8fa.scala:39:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for(i <- arr.tail) {\n            if(arr.head.even()) {\n                if(arr.head.value < min_even.value) {\n                    min_even = arr.head\n                    min_index = i\n                }\n            } else {\n                if(arr.head.value < min_even.value) {\n                    min_even = arr.head\n                    min_index = i\n                }\n            }\n        }\n        res = res.append(min_even)\n        res = res.append(min_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292605,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx9s4dz8b.scala:34:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m(arr.head.even()) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               value even is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx9s4dz8b.scala:35:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m(arr.head.value < min_even.value) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value value is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpx9s4dz8b.scala:37:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    min_index = i\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    (i : Long @uncheckedVariance)\n\u001b[31m   |\u001b[0m                                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx9s4dz8b.scala:40:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                \u001b[33mif\u001b[0m(arr.head.value < min_even.value) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value value is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpx9s4dz8b.scala:42:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m                    min_index = i\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    (i : Long @uncheckedVariance)\n\u001b[31m   |\u001b[0m                                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx9s4dz8b.scala:46:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        res = res.append(min_even)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Fou",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_value = arr.head\n        var smallest_index = 0\n        var i = 1\n        while(i < arr.size) {\n            var even_value = arr.apply(i).toLong % 2\n            if(even_value == 0 && even_value < smallest_value) {\n                smallest_value = even_value\n                smallest_index = i\n            }\n            i = i + 1\n        }\n        result = result.append(smallest_value)\n        result = result.append(smallest_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292605,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxxj5bto0.scala:42:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        result = result.append(smallest_value)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxxj5bto0.scala:43:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        result = result.append(smallest_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) {\n            return []\n        }\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < smallest_even_value) {\n                    smallest_even_value = i\n                    smallest_index = arr.indexOf(i)\n                }\n            }\n        }\n        return (List[Long](smallest_even_value, smallest_index))\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292605,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfj638afj.scala:31:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mreturn\u001b[0m []\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    an identifier expected, but ']' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfj638afj.scala:32:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        '=>' expected, but '}' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfj638afj.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) return arr\n        var smallest_value = arr.head()\n        var smallest_index = 0\n        var index = 0\n        while (index < arr.size()) {\n            if (arr.apply(index).toLong % 2 == 0) {\n                if (arr.apply(index).toLong < smallest_value) {\n                    smallest_value = arr.apply(index).toLong\n                    smallest_index = index\n                }\n            }\n            index += 1\n        }\n        return arr.apply(smallest_index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292608,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpps9wd5ki.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) \u001b[33mreturn\u001b[0m arr\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpps9wd5ki.scala:31:33 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36msmallest_value\u001b[0m = arr.head()\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               \u001b[33mmethod\u001b[0m \u001b[35mhead\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpps9wd5ki.scala:34:27 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mwhile\u001b[0m (index < arr.size()) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpps9wd5ki.scala:43:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mreturn\u001b[0m arr.apply(smallest_index)\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Found:    Long\n\u001b[31m   |\u001b[0m               Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mLong\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.minBy(x => x % 2 == 0)._1\n        var min_index = arr.indexOf(min_even)\n        if (min_even == 0) {\n            res = List[Long](min_even, min_index)\n        } else {\n            res = List[Long](min_even)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292591,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm853_x3t.scala:31:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = arr.minBy(\u001b[36mx\u001b[0m => x % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m)._1\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value _1 is not a member of Long\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        var min_even_index = 0\n        for (i <- arr.size) {\n            if (arr.apply(i).toLong % 2 == 0) {\n                if (arr.apply(i).toLong < min_even) {\n                    min_even = arr.apply(i).toLong\n                    min_even_index = i\n                }\n            } else {\n                if (arr.apply(i).toLong < min_even) {\n                    min_even = arr.apply(i).toLong\n                    min_even_index = i\n                }\n            }\n        }\n        if (min_even_index == 0) {\n            res = List[Long](min_even, min_index)\n        } else {\n            res = List[Long](min_even, min_even_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292609,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgje_co_c.scala:34:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- arr.size) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.length == 0) {\n            return List[Long]()\n        }\n        var smalest_value = arr.head\n        var smalest_index = 0\n        var index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < smalest_value) {\n                    smalest_value = i\n                    smalest_index = index\n                }\n            }\n            index += 1\n        }\n        return List[Long](smalest_value, smalest_index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292611,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp33t62nf2.scala:48)\n\tat Problem.main(tmp33t62nf2.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < smallest_even_value) {\n                    smallest_even_value = i\n                    smallest_index = arr.indexOf(i)\n                }\n            }\n        }\n        if (smallest_even_value == arr.head) {\n            return arr\n        } else {\n            return arr.take(smallest_index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292612,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpco_m9zb6.scala:47)\n\tat Problem.main(tmpco_m9zb6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even_value = arr.head\n        var min_even_index = 0\n        var min_index = 0\n        var min_value = arr.head\n        var min_index = 0\n        var min_value = arr.head\n        var min_index = 0\n        for (i <- arr.size - 1) {\n            if (arr.apply(i).toLong % 2 == 0) {\n                if (arr.apply(i).toLong < min_even_value) {\n                    min_even_value = arr.apply(i).toLong\n                    min_even_index = i\n                }\n            } else {\n                if (arr.apply(i).toLong < min_value) {\n                    min_value = arr.apply(i).toLong\n                    min_index = i\n                }\n            }\n        }\n        if (min_even_value == 0) {\n            result = List[Long](min_even_index, min_even_index)\n        } else {\n            result = List[Long](min_index, min_index)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292611,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3bnncnqb.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_index\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmin_index is already defined as \u001b[33mvariable\u001b[0m \u001b[35mmin_index\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3bnncnqb.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_value\u001b[0m = arr.head\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmin_value is already defined as \u001b[33mvariable\u001b[0m \u001b[35mmin_value\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3bnncnqb.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_index\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmin_index is already defined as \u001b[33mvariable\u001b[0m \u001b[35mmin_index\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3bnncnqb.scala:38:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- arr.size - \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = arr.minBy[0](_ => arr.filter(x => x % 2 == 0).length)._1\n        var min_index = arr.indexOf(min_even)\n        if (min_even == 0) {\n            result = arr.filter(x => x % 2 == 0).take(1)\n        } else {\n            result = arr.filter(x => x % 2 == 0).take(1).append(arr.indexOf(min_even))\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292612,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpearwkr71.scala:31:69 --------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = arr.minBy[\u001b[31m0\u001b[0m](_ => arr.filter(\u001b[36mx\u001b[0m => x % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m).length)._1\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Found:    Int\n\u001b[31m   |\u001b[0m                                         Required: (\u001b[31m0\u001b[0m : Int)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpearwkr71.scala:36:57 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            result = arr.filter(\u001b[36mx\u001b[0m => x % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m).take(\u001b[31m1\u001b[0m).append(arr.indexOf(min_even))\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val res = mutable.List[Long]()\n        for (i <- 0 until arr.length) {\n            if (arr.apply(i).toLong % 2 == 0) {\n                res.append(arr.apply(i))\n                res.append(i)\n                break\n            }\n        }\n        if (res.isEmpty()) {\n            return res\n        } else {\n            val smallest_value = res.head().toLong\n            val smallest_index = res.tail().head().toInt\n            for (i <- 0 until arr.length) {\n                if (arr.apply(i).toLong == smallest_value) {\n                    if (i < smallest_index) {\n                        res.update(i, smallest_index)\n                    }\n                }\n            }\n            return res\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292609,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_v4orkq9.scala:30:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_v4orkq9.scala:35:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even_value = arr.head\n        var min_index = 0\n        var min_even_index = 0\n        for (i <- arr.size) {\n            if (arr.apply(i).even()) {\n                if (arr.apply(i).toLong() < min_even_value.toLong()) {\n                    min_even_value = arr.apply(i)\n                    min_even_index = i\n                }\n            } else {\n                if (arr.apply(i).toLong() < min_even_value.toLong()) {\n                    min_even_value = arr.apply(i)\n                    min_even_index = i\n                }\n            }\n        }\n        if (min_even_value.toLong() == 0) {\n            res = List[Long](min_even_value, min_even_index)\n        } else {\n            res = List[Long](min_even_value, min_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292610,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjixwljzr.scala:34:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- arr.size) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjixwljzr.scala:47:27 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m        \u001b[33mif\u001b[0m (min_even_value.toLong() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35mtoLong\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < min_even) {\n                    min_even = i\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        result = List[Long](min_even, min_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpokrcvb2f.scala:46)\n\tat Problem.main(tmpokrcvb2f.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) {\n            return arr\n        }\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < smallest_even_value) {\n                    smallest_even_value = i\n                    smallest_index = arr.indexOf(i)\n                }\n            }\n        }\n        return arr.take(smallest_index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp_fdvxbiq.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.minBy[Long](_ => _ % 2 == 0)._1\n        var min_index = arr.minBy[Long](_ => _)._1\n        if (min_even == null) {\n            return res\n        }\n        var even_index = arr.indexOf(min_even)\n        res = res.append(min_even)\n        res = res.append(even_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292612,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpj5sa19yh.scala:31:44 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = arr.minBy[\u001b[35mLong\u001b[0m](_ => _ % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m)._1\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$2 of expanded function:\n\u001b[31m   |\u001b[0m   _$2 => _$2 % 2 == 0.\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpj5sa19yh.scala:32:40 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_index\u001b[0m = arr.minBy[\u001b[35mLong\u001b[0m](_ => _)._1\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$3 of expanded function:\n\u001b[31m   |\u001b[0m   _$3 => _$4.\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj5sa19yh.scala:37:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        res = res.append(min_even)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj5sa19yh.scala:38:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        res = res.append(even_index)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        var min_even_index = 0\n        for (i <- arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_even_index = i\n                }\n            } else {\n                if (arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_even_index = i\n                }\n                if (arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_even_index = i\n                }\n            }\n        }\n        result = List[Long](min_even, min_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292612,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa5_wmb9d.scala:34:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- arr.length) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (arr.head % 2 == 0 && arr.head < smallest_even_value) {\n                smallest_even_value = arr.head\n                smallest_index = i\n            }\n        }\n        result = result.append(smallest_even_value)\n        result = result.append(smallest_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292613,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyqziapfi.scala:36:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                smallest_index = i\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long @uncheckedVariance)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyqziapfi.scala:39:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        result = result.append(smallest_even_value)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyqziapfi.scala:40:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        result = result.append(smallest_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        var index = 0\n        for (i <- arr.tail) {\n            if (arr.head % 2 == 0) {\n                if (arr.head < smallest_even_value) {\n                    smallest_even_value = arr.head\n                    smallest_index = index\n                }\n            }\n            index += 1\n        }\n        if (smallest_even_value == arr.head) {\n            return arr.tail.take(smallest_index)\n        } else {\n            return []\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292611,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmppw99rq5m.scala:45:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m            \u001b[33mreturn\u001b[0m []\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    an identifier expected, but ']' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmppw99rq5m.scala:46:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        '=>' expected, but '}' found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < smallest_even_value) {\n                    smallest_even_value = i\n                    smallest_index = arr.indexOf(i)\n                }\n            }\n        }\n        result = result.append(smallest_even_value)\n        result = result.append(smallest_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292615,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4vkvn7i_.scala:41:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        result = result.append(smallest_even_value)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4vkvn7i_.scala:42:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        result = result.append(smallest_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        var min_even_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < min_even) {\n                    min_even = i\n                    min_even_index = i\n                }\n            } else {\n                if (i < min_even) {\n                    min_even = i\n                    min_even_index = i\n                }\n                if (i < min_even) {\n                    min_even = i\n                    min_even_index = i\n                }\n            }\n        }\n        result = result.append(min_even)\n        result = result.append(min_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292614,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvx770zde.scala:38:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                    min_even_index = i\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long @uncheckedVariance)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvx770zde.scala:43:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m                    min_even_index = i\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long @uncheckedVariance)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvx770zde.scala:47:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m                    min_even_index = i\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long @uncheckedVariance)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvx770zde.scala:51:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m        result = result.append(min_even)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvx770zde.scala:52:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m        result = result.append(min_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_value = arr.head\n        var smallest_index = 0\n        var i = 1\n        while (i < arr.size) {\n            if (arr.apply(i).toInt % 2 == 0) {\n                if (arr.apply(i).toInt < smallest_value.toInt) {\n                    smallest_value = arr.apply(i)\n                    smallest_index = i\n                }\n            }\n            i = i + 1\n        }\n        result = List[Long](smallest_value, smallest_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292615,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_khoms8o.scala:48)\n\tat Problem.main(tmp_khoms8o.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        var i = 0\n        while (i < arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < smallest_even_value) {\n                    smallest_even_value = arr[i]\n                    smallest_index = i\n                }\n            }\n            i = i + 1\n        }\n        if (smallest_even_value == 0) {\n            result = arr.take(smallest_index)\n        } else {\n            result = arr.take(smallest_index)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292611,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy8h0y7vb.scala:35:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy8h0y7vb.scala:36:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < smallest_even_value) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy8h0y7vb.scala:37:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    smallest_even_value = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = arr.head.toLong\n        var min_index = 0\n        for (i <- arr.tail.toList) {\n            if (i.toLong % 2 == 0) {\n                if (i.toLong < min_even) {\n                    min_even = i.toLong\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        result = result.append(min_even)\n        result = result.append(min_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292615,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_zkllopo.scala:41:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        result = result.append(min_even)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_zkllopo.scala:42:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        result = result.append(min_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long](arr.size)\n        var index = 0\n        var smallest_value = arr.head\n        var smallest_index = 0\n        for(i <- 0 until arr.size) {\n            if(arr[i] % 2 == 0) {\n                if(arr[i] < smallest_value) {\n                    smallest_value = arr[i]\n                    smallest_index = i\n                }\n            }\n        }\n        result[index] = smallest_value\n        index += 1\n        for(i <- 0 until arr.size) {\n            if(arr[i] % 2 == 0 && arr[i] != smallest_value) {\n                result[index] = arr[i]\n                index += 1\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292612,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpilkko88g.scala:42:22 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        result[\u001b[35mindex\u001b[0m] = smallest_value\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      end of statement expected but '=' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpilkko88g.scala:46:30 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m                result[\u001b[35mindex\u001b[0m] = arr[i]\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              end of statement expected but '=' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpilkko88g.scala:35:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            \u001b[33mif\u001b[0m(arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpilkko88g.scala:36:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                \u001b[33mif\u001b[0m(arr[\u001b[35mi\u001b[0m] < smallest_value) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpilkko88g.scala:37:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    smallest_value = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpilkko88g.scala:42:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        result[\u001b[35mindex\u001b[0m] = smallest_value\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Not found: type index\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.minBy[Int](_ => _ % 2 == 0)._1\n        var min_index = arr.indexOf(min_even)\n        if (min_even == 0) {\n            res = List[Long](min_even, min_index)\n        } else {\n            res = List[Long](min_even, min_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292613,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpjhdf3qf0.scala:31:43 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = arr.minBy[\u001b[35mInt\u001b[0m](_ => _ % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m)._1\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$2 of expanded function:\n\u001b[31m   |\u001b[0m   _$2 => _$2 % 2 == 0.\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) {\n            return []\n        }\n        var smallest_value = arr.head\n        var smallest_index = 0\n        var index = 0\n        for (i <- arr.tail) {\n            if (arr.head.toLong % 2 == 0) {\n                if (arr.head.toLong < smallest_value.toLong) {\n                    smallest_value = arr.head\n                    smallest_index = index\n                }\n            }\n            index += 1\n        }\n        return [smallest_value, smallest_index]\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292613,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmps4w9__71.scala:31:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mreturn\u001b[0m []\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    an identifier expected, but ']' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmps4w9__71.scala:32:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        '=>' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmps4w9__71.scala:46:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=>' expected, but '}' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmps4w9__71.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) {\n            return arr\n        }\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        var index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < smallest_even_value) {\n                    smallest_even_value = i\n                    smallest_index = index\n                }\n            }\n            index += 1\n        }\n        return arr.map(x => (x, smallest_index))\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292616,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjkrlnu94.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjkrlnu94.scala:45:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mreturn\u001b[0m arr.map(\u001b[36mx\u001b[0m => (x, smallest_index))\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    \u001b[1m\u001b[31m(\u001b[0mLong\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mInt\u001b[0m\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m                            Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var smallest_even_value : Long = _\n        var smallest_index : Int = _\n        for (i <- 0 until arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < smallest_even_value) {\n                    smallest_even_value = arr[i]\n                    smallest_index = i\n                }\n            }\n        }\n        if (smallest_even_value == _) {\n            return List[Long]()\n        } else {\n            return List[Long](smallest_even_value, smallest_index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292614,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpoxkhaimd.scala:33:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpoxkhaimd.scala:34:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < smallest_even_value) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpoxkhaimd.scala:35:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                    smallest_even_value = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpoxkhaimd.scala:40:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mif\u001b[0m (smallest_even_value == _) {\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$3 of expanded function:\n\u001b[31m   |\u001b[0m   _$3 => smallest_even_value == _$3.\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        var i = 0\n        for(i = 0; i < arr.length; i++) {\n            if(arr[i] % 2 == 0) {\n                if(arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        if(min_even == 0) {\n            res = arr.take(min_index)\n        } else {\n            res = arr.take(min_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292618,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpcp6ttr21.scala:34:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m(i = \u001b[31m0\u001b[0m; i < arr.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^\u001b[0m\n\u001b[31m   |\u001b[0m              ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpcp6ttr21.scala:34:33 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m(i = \u001b[31m0\u001b[0m; i < arr.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpcp6ttr21.scala:34:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m(i = \u001b[31m0\u001b[0m; i < arr.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcp6ttr21.scala:34:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m(i = \u001b[31m0\u001b[0m; i < arr.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                 ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue foreach is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator asScala\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\u001b[31m   |\u001b[0m  import collection.co",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        var min_even_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < min_even) {\n                    min_even = i\n                    min_even_index = i\n                }\n            } else {\n                if (i < min_even) {\n                    min_even = i\n                    min_even_index = i\n                }\n            }\n        }\n        if (min_even_index != 0) {\n            res = res.append(min_even)\n            res = res.append(min_even_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292620,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkcwu25bg.scala:38:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                    min_even_index = i\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long @uncheckedVariance)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkcwu25bg.scala:43:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m                    min_even_index = i\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long @uncheckedVariance)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkcwu25bg.scala:48:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m            res = res.append(min_even)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkcwu25bg.scala:49:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m            res = res.append(min_even_index)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_value = arr.head\n        var smallest_index = 0\n        var index = 0\n        for(i <- arr.tail) {\n            if(arr.head.even()) {\n                if(arr.head.value < smallest_value) {\n                    smallest_value = arr.head.value\n                    smallest_index = index\n                }\n            }\n            index += 1\n        }\n        result = result.append(smallest_value)\n        result = result.append(smallest_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292621,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdsghsg6b.scala:35:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            \u001b[33mif\u001b[0m(arr.head.even()) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               value even is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdsghsg6b.scala:36:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                \u001b[33mif\u001b[0m(arr.head.value < smallest_value) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value value is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdsghsg6b.scala:37:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    smallest_value = arr.head.value\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     value value is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdsghsg6b.scala:43:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        result = result.append(smallest_value)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdsghsg6b.scala:44:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        result = result.append(smallest_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) return arr\n        var smalest_value = arr.head\n        var smalest_index = 0\n        var index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < smalest_value) {\n                    smalest_value = i\n                    smalest_index = index\n                }\n            }\n            index += 1\n        }\n        return (List[Long](smalest_value, smalest_index))\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292619,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpxro4yia1.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) \u001b[33mreturn\u001b[0m arr\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < smallest_even_value) {\n                    smallest_even_value = i\n                    smallest_index = arr.indexOf(i)\n                }\n            }\n        }\n        result = result.append(smallest_even_value)\n        result = result.append(smallest_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292615,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4vkvn7i_.scala:41:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        result = result.append(smallest_even_value)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4vkvn7i_.scala:42:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        result = result.append(smallest_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) {\n            return arr\n        }\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < smallest_even_value) {\n                    smallest_even_value = i\n                    smallest_index = arr.indexOf(i)\n                }\n            }\n        }\n        return (List[Long](smallest_even_value, smallest_index))\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292618,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpt6eoc6m5.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (arr.head.toLong % 2 == 0) {\n                if (arr.head.toLong < smallest_value.toLong) {\n                    smallest_value = arr.head\n                    smallest_index = i\n                }\n            }\n        }\n        result = result.append(smallest_value)\n        result = result.append(smallest_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292623,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp198umhyy.scala:37:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    smallest_index = i\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long @uncheckedVariance)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp198umhyy.scala:41:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        result = result.append(smallest_value)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp198umhyy.scala:42:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        result = result.append(smallest_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i.toLong % 2 == 0) {\n                if (i.toLong < min_even) {\n                    min_even = i.toLong\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        res = res.append(min_even)\n        res = res.append(min_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292623,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7958xh_0.scala:41:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        res = res.append(min_even)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7958xh_0.scala:42:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        res = res.append(min_index)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < smallest_even_value) {\n                    smallest_even_value = i\n                    smallest_index = arr.indexOf(i)\n                }\n            }\n        }\n        result = List[Long](smallest_even_value, smallest_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292624,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpxww0zore.scala:46)\n\tat Problem.main(tmpxww0zore.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.length == 0) {\n            return []\n        }\n        var smallest_even_value = arr[0]\n        var smallest_index = 0\n        for (i <- 1 to arr.length - 1) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < smallest_even_value) {\n                    smallest_even_value = arr[i]\n                    smallest_index = i\n                }\n            }\n        }\n        return [smallest_even_value, smallest_index]\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292600,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4tp1ar_5.scala:31:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mreturn\u001b[0m []\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    an identifier expected, but ']' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4tp1ar_5.scala:32:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        '=>' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4tp1ar_5.scala:44:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=>' expected, but '}' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmp4tp1ar_5.scala:33:37 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36msmallest_even_value\u001b[0m = arr[\u001b[31m0\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m does not take type parameters\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4tp1ar_5.scala:36:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4tp1ar_5.scala:37:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < smallest_even_value) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4tp1ar_5.scala:38:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                    smallest_even_value = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) return arr\n        var min_even = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (arr.head.even) {\n                if (arr.head.value < min_even.value) {\n                    min_even = arr.head\n                    min_index = i\n                }\n            } else {\n                if (arr.head.value < min_even.value) {\n                    min_even = arr.head\n                    min_index = i\n                }\n            }\n        }\n        return (min_even, min_index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292624,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmprpop1w92.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) \u001b[33mreturn\u001b[0m arr\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprpop1w92.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m (arr.head.even) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value even is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprpop1w92.scala:35:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m (arr.head.value < min_even.value) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value value is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprpop1w92.scala:37:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    min_index = i\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    (i : Long @uncheckedVariance)\n\u001b[31m   |\u001b[0m                                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprpop1w92.scala:40:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                \u001b[33mif\u001b[0m (arr.head.value < min_even.value) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value value is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprpop1w92.scala:42:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m                    min_index = i\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    (i : Long @uncheckedVariance)\n\u001b[31m   |\u001b[0m                       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i.toLong % 2 == 0) {\n                if (i.toLong < min_even) {\n                    min_even = i.toLong\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        res = res.append(min_even)\n        res = res.append(min_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292623,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7958xh_0.scala:41:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        res = res.append(min_even)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7958xh_0.scala:42:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        res = res.append(min_index)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long](arr.size)\n        var min_index = 0\n        var min_value = arr[0]\n        for (i <- 0 until arr.size) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < min_value) {\n                    min_value = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        result[0] = min_value\n        result[1] = min_index\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292620,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpb14x6lz2.scala:41:18 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        result[\u001b[31m0\u001b[0m] = min_value\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  end of statement expected but '=' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpb14x6lz2.scala:42:18 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        result[\u001b[31m1\u001b[0m] = min_index\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  end of statement expected but '=' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpb14x6lz2.scala:32:27 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_value\u001b[0m = arr[\u001b[31m0\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m does not take type parameters\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb14x6lz2.scala:34:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb14x6lz2.scala:35:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < min_value) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb14x6lz2.scala:36:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    min_value = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpb14x6lz2.scala:41:14 ----------------------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i.toLong % 2 == 0) {\n                if (i.toLong < min_even) {\n                    min_even = i.toLong\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        if (min_even == 0) {\n            res = arr.take(min_index + 1)\n        } else {\n            res = arr.take(min_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292626,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmphb7y6lif.scala:49)\n\tat Problem.main(tmphb7y6lif.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = arr.minBy[Long](_ => _ % 2 == 0)\n        var min_index = arr.indexOf(min_even)\n        if (min_even != null) {\n            result = List[Long](min_even, min_index)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292624,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpxl59hlc7.scala:31:44 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = arr.minBy[\u001b[35mLong\u001b[0m](_ => _ % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$2 of expanded function:\n\u001b[31m   |\u001b[0m   _$2 => _$2 % 2 == 0.\n\u001b[31m\u001b[31m-- Error: /tmp/tmpxl59hlc7.scala:33:12 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mif\u001b[0m (min_even != \u001b[31mnull\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          Values of types Long and Null cannot be compared with == or !=\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i.toLong % 2 == 0) {\n                if (i.toLong < min_even) {\n                    min_even = i.toLong\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        result = result.append(min_even)\n        result = result.append(min_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292601,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp58jz1fqg.scala:41:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        result = result.append(min_even)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp58jz1fqg.scala:42:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        result = result.append(min_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = arr.minBy(x => x % 2 == 0)._1\n        var min_index = arr.indexOf(min_even)\n        if (min_even == 0) {\n            result = arr.take(min_index)\n        } else {\n            result = arr.take(min_index + 1)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292624,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzebjzzmg.scala:31:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = arr.minBy(\u001b[36mx\u001b[0m => x % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m)._1\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value _1 is not a member of Long\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val res = mutable.List[Long]()\n        for (i <- 0 until arr.length) {\n            if (arr[i] % 2 == 0) {\n                res = res.append(arr[i])\n                res = res.append(i)\n                break\n            }\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292621,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp22w4_xr9.scala:30:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp22w4_xr9.scala:32:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp22w4_xr9.scala:33:20 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                res = res.append(arr[\u001b[35mi\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val res\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp22w4_xr9.scala:34:20 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                res = res.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val res\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp22w4_xr9.scala:35:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        var min_even_index = 0\n        for (i <- arr.size - 1) {\n            if (arr.apply(i).toLong % 2 == 0) {\n                if (arr.apply(i).toLong < min_even) {\n                    min_even = arr.apply(i).toLong\n                    min_even_index = i\n                }\n            }\n        }\n        if (min_even_index == 0) {\n            res = arr.apply(min_even_index)\n        } else {\n            res = arr.apply(min_even_index).toLong\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp52mytx2k.scala:34:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- arr.size - \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp52mytx2k.scala:43:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m            res = arr.apply(min_even_index)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Found:    Long\n\u001b[31m   |\u001b[0m                  Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mLong\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp52mytx2k.scala:45:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m            res = arr.apply(min_even_index).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Found:    Long\n\u001b[31m   |\u001b[0m                  Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mLong\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) return arr\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < smallest_even_value) {\n                    smallest_even_value = i\n                    smallest_index = arr.indexOf(i)\n                }\n            }\n        }\n        return arr.take(smallest_index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292621,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfbua_kcy.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) \u001b[33mreturn\u001b[0m arr\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i.toLong % 2 == 0) {\n                if (i.toLong < min_even) {\n                    min_even = i.toLong\n                    min_index = i.toLong\n                }\n            }\n        }\n        if (min_even == 0) {\n            for (i <- arr) {\n                if (i.toLong == min_index) {\n                    res = res.append(i)\n                }\n            }\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292626,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpueapmbm8.scala:37:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    min_index = i.toLong\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    Long\n\u001b[31m   |\u001b[0m                                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpueapmbm8.scala:44:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m                    res = res.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < min_even) {\n                    min_even = i\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        result = result.append(min_even)\n        result = result.append(min_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292625,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0eydy_61.scala:41:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        result = result.append(min_even)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0eydy_61.scala:42:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        result = result.append(min_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]().toLong\n        var min_even = arr.head.toLong\n        var min_index = 0\n        for (i <- arr.tail.toLong) {\n            if (arr.head.toLong % 2 == 0) {\n                if (arr.head.toLong < min_even) {\n                    min_even = arr.head.toLong\n                    min_index = i\n                }\n            }\n            arr = arr.tail\n        }\n        res = res.append(min_even)\n        res = res.append(min_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292626,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptuf9jm4r.scala:30:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mres\u001b[0m = List[\u001b[35mLong\u001b[0m]().toLong\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toLong is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptuf9jm4r.scala:33:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- arr.tail.toLong) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toLong is not a member of List[Long @uncheckedVariance], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_value = arr.head\n        var smallest_index = 0\n        var index = 0\n        for(i <- arr.tail) {\n            if(arr.head == i) {\n                result = append(result, arr.head)\n                arr = arr.tail\n                break\n            }\n            if(smallest_value == i) {\n                smallest_index = index\n            }\n            index += 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292623,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmph64q5kof.scala:36:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                result = append(result, arr.head)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: append\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmph64q5kof.scala:37:20 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                arr = arr.tail\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val arr\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmph64q5kof.scala:38:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (i.toLong % 2 == 0) {\n                if (i.toLong < smallest_value) {\n                    smallest_value = i.toLong\n                    smallest_index = i.toLong\n                }\n            }\n        }\n        result = List[Long](smallest_value, smallest_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292626,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1rv2k6rw.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    smallest_index = i.toLong\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    Long\n\u001b[31m   |\u001b[0m                                     Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even_value = arr.head\n        var min_index = 0\n        for(i <- arr.tail) {\n            if(i % 2 == 0) {\n                if(i < min_even_value) {\n                    min_even_value = i\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        res = res.append(min_even_value)\n        res = res.append(min_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292628,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp12di5qg3.scala:41:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        res = res.append(min_even_value)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp12di5qg3.scala:42:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        res = res.append(min_index)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_value = arr.head()\n        var smallest_index = 0\n        var index = 0\n        for(i <- arr.size - 1) {\n            if(arr.apply(i).toLong % 2 == 0) {\n                if(arr.apply(i).toLong < smallest_value) {\n                    smallest_value = arr.apply(i).toLong\n                    smallest_index = index\n                }\n            }\n            index += 1\n        }\n        result = List[Long](smallest_value, smallest_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292627,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp9hxyqezr.scala:31:33 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36msmallest_value\u001b[0m = arr.head()\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               \u001b[33mmethod\u001b[0m \u001b[35mhead\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9hxyqezr.scala:34:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- arr.size - \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value foreach is not a member of Int\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (i.toLong % 2 == 0) {\n                if (i.toLong < smallest_value) {\n                    smallest_value = i.toLong\n                    smallest_index = i.toLong\n                }\n            }\n        }\n        result = result.append(smallest_value)\n        result = result.append(smallest_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292628,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzbnvrumk.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    smallest_index = i.toLong\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    Long\n\u001b[31m   |\u001b[0m                                     Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzbnvrumk.scala:41:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        result = result.append(smallest_value)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzbnvrumk.scala:42:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        result = result.append(smallest_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < smallest_even_value) {\n                    smallest_even_value = i\n                    smallest_index = arr.indexOf(i)\n                }\n            }\n        }\n        result = result.append(smallest_even_value)\n        result = result.append(smallest_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292615,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4vkvn7i_.scala:41:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        result = result.append(smallest_even_value)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4vkvn7i_.scala:42:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        result = result.append(smallest_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = Long.MAX_VALUE\n        var min_index = -1\n        var min_value = Long.MAX_VALUE\n        for (i <- 0 until arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_index = i\n                }\n            } else {\n                if (arr[i] < min_value) {\n                    min_value = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        if (min_index == -1) {\n            result = List[Long](min_value)\n        } else {\n            result = List[Long](min_value, min_index)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292629,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpugxjwmf5.scala:31:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = Long.MAX_VALUE\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value MAX_VALUE is not a member of object Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpugxjwmf5.scala:33:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_value\u001b[0m = Long.MAX_VALUE\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value MAX_VALUE is not a member of object Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpugxjwmf5.scala:35:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpugxjwmf5.scala:36:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < min_even) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpugxjwmf5.scala:37:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpugxjwmf5.scala:41:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < min_value) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation a",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < smallest_even_value) {\n                    smallest_even_value = i\n                    smallest_index = arr.indexOf(i)\n                }\n            }\n        }\n        result = List[Long](smallest_even_value, smallest_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292624,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpxww0zore.scala:46)\n\tat Problem.main(tmpxww0zore.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < smallest_even_value) {\n                    smallest_even_value = i\n                    smallest_index = arr.indexOf(i)\n                }\n            }\n        }\n        result = result.append(smallest_even_value)\n        result = result.append(smallest_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292615,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4vkvn7i_.scala:41:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        result = result.append(smallest_even_value)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4vkvn7i_.scala:42:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        result = result.append(smallest_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even_value = arr.head\n        var min_index = 0\n        var min_even_index = 0\n        for (i <- arr.size) {\n            if (arr.apply(i).mod(2) == 0) {\n                if (arr.apply(i) < min_even_value) {\n                    min_even_value = arr.apply(i)\n                    min_even_index = i\n                }\n            } else {\n                if (arr.apply(i) < min_even_value) {\n                    min_even_value = arr.apply(i)\n                    min_even_index = i\n                }\n            }\n        }\n        if (min_even_index == 0) {\n            result = List[Long](min_even_value, min_index)\n        } else {\n            result = List[Long](min_even_value, min_even_index)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292629,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2pxn9xze.scala:34:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- arr.size) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.length == 0) {\n            return []\n        }\n        var min_even_value = arr[0]\n        var min_index = 0\n        for (i <- 1 to arr.length - 1) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < min_even_value) {\n                    min_even_value = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        return (List[Long](min_even_value, min_index))\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292628,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9bkifp27.scala:31:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mreturn\u001b[0m []\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    an identifier expected, but ']' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9bkifp27.scala:32:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        '=>' expected, but '}' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmp9bkifp27.scala:33:32 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even_value\u001b[0m = arr[\u001b[31m0\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m does not take type parameters\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9bkifp27.scala:36:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9bkifp27.scala:37:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < min_even_value) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9bkifp27.scala:38:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                    min_even_value = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n6 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        var min_even_index = 0\n        for (i <- arr.size - 1) {\n            if (arr.apply(i).toLong % 2 == 0) {\n                if (arr.apply(i).toLong < min_even) {\n                    min_even = arr.apply(i).toLong\n                    min_even_index = i\n                }\n            } else {\n                if (arr.apply(i).toLong < min_even) {\n                    min_even = arr.apply(i).toLong\n                    min_even_index = i\n                }\n            }\n        }\n        if (min_even_index == 0) {\n            res = List[Long](min_even, min_index)\n        } else {\n            res = List[Long](min_even, min_even_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuafk63o7.scala:34:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- arr.size - \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        var i = 0\n        while (i < arr.size) {\n            if (arr.apply(i).toLong % 2 == 0) {\n                if (arr.apply(i).toLong < smallest_even_value) {\n                    smallest_even_value = arr.apply(i).toLong\n                    smallest_index = i\n                }\n            }\n            i = i + 1\n        }\n        result = result.append(smallest_even_value)\n        result = result.append(smallest_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292600,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbrrp41jn.scala:43:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        result = result.append(smallest_even_value)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbrrp41jn.scala:44:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        result = result.append(smallest_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) return arr\n        var smalest_value = arr.head\n        var smalest_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < smalest_value) {\n                    smalest_value = i\n                    smalest_index = arr.indexOf(i)\n                }\n            }\n        }\n        return (List[Long](smalest_value, smalest_index))\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292629,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmplttbw3kn.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) \u001b[33mreturn\u001b[0m arr\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long](arr.size)\n        var i = 0\n        while (i < arr.size) {\n            var smallest_even_value = arr[i]\n            var smallest_index = i\n            var j = i + 1\n            while (j < arr.size && arr[j] % 2 == 0) {\n                if (arr[j] < smallest_even_value) {\n                    smallest_even_value = arr[j]\n                    smallest_index = j\n                }\n                j = j + 1\n            }\n            if (smallest_index != i) {\n                arr[i] = arr[smallest_index]\n                arr[smallest_index] = smallest_even_value\n                res[i] = smallest_index\n                res[smallest_index] = i\n            }\n            i = i + 1\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292629,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpqincwo6n.scala:44:23 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m                arr[\u001b[35mi\u001b[0m] = arr[smallest_index]\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       end of statement expected but '=' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpqincwo6n.scala:45:36 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m                arr[\u001b[35msmallest_index\u001b[0m] = smallest_even_value\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 end of statement expected but '=' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpqincwo6n.scala:46:23 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m                res[\u001b[35mi\u001b[0m] = smallest_index\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       end of statement expected but '=' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpqincwo6n.scala:47:36 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m                res[\u001b[35msmallest_index\u001b[0m] = i\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 end of statement expected but '=' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqincwo6n.scala:33:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36msmallest_even_value\u001b[0m = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqincwo6n.scala:36:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            \u001b[33mwhile\u001b[0m (j < arr.size && arr[\u001b[35mj\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = Long.MAX_VALUE\n        var min_index = 0\n        for (i <- 0 until arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        result = arr.take(min_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292632,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprstxgbxz.scala:31:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = Long.MAX_VALUE\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value MAX_VALUE is not a member of object Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprstxgbxz.scala:34:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprstxgbxz.scala:35:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < min_even) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprstxgbxz.scala:36:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val result = mutable.List[Long]()\n        val evens = arr.filter(x => x % 2 == 0)\n        if (evens.isEmpty()) {\n            return result\n        }\n        val smallestEven = evens.minBy(x => x)\n        val smallestEvenIndex = evens.indexOf(smallestEven)\n        result.append(smallestEven)\n        result.append(smallestEvenIndex)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292630,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpegdmvq90.scala:30:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpegdmvq90.scala:32:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mif\u001b[0m (evens.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = Long.MAX_VALUE\n        var min_index = -1\n        for (i <- 0 until arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        if (min_index == -1) {\n            result = List[Long](min_even)\n        } else {\n            result = List[Long](min_even, min_index)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292633,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp28dlgqjx.scala:31:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = Long.MAX_VALUE\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value MAX_VALUE is not a member of object Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp28dlgqjx.scala:34:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp28dlgqjx.scala:35:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < min_even) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp28dlgqjx.scala:36:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.minBy[0](_ => arr.filter(x => x % 2 == 0).head())\n        var min_index = arr.indexOf(min_even)\n        var min_value = min_even\n        var min_index_arr = List[Long](min_index)\n        for (i <- arr.range(1, arr.length)) {\n            if (arr[i] == min_even) {\n                min_index_arr = List[Long](i)\n            }\n        }\n        res = List[Long](min_value, min_index_arr)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292635,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpl6u8ew53.scala:31:69 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = arr.minBy[\u001b[31m0\u001b[0m](_ => arr.filter(\u001b[36mx\u001b[0m => x % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m).head())\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               \u001b[33mmethod\u001b[0m \u001b[35mhead\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl6u8ew53.scala:35:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- arr.range(\u001b[31m1\u001b[0m, arr.length)) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value range is not a member of List[Long] - did you mean arr.take?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl6u8ew53.scala:40:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        res = List[\u001b[35mLong\u001b[0m](min_value, min_index_arr)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (min_index_arr : List[Long])\n\u001b[31m   |\u001b[0m                                  Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = arr.head.toLong\n        var min_index = 0\n        var index = 0\n        for(i <- arr.tail) {\n            if(i.toLong % 2 == 0) {\n                if(i.toLong < min_even) {\n                    min_even = i.toLong\n                    min_index = index\n                }\n            }\n            index += 1\n        }\n        if(min_even == 0) {\n            result = arr.tail.takeWhile(i -> i.toLong != 0)\n        } else {\n            result = List[Long](min_even, min_index)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292631,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3s2fvxkr.scala:44:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m            result = arr.tail.takeWhile(i -> i.toLong != \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Not found: i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = Long.MAX_VALUE\n        var min_index = -1\n        for (i <- 0 until arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        if (min_index != -1) {\n            res = List[Long](min_even, min_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292591,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpz7l2tw87.scala:31:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = Long.MAX_VALUE\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value MAX_VALUE is not a member of object Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz7l2tw87.scala:34:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz7l2tw87.scala:35:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < min_even) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz7l2tw87.scala:36:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        var min_even_index = 0\n        var even_count = 0\n        for(i <- arr.length) {\n            if(arr[i] % 2 == 0) {\n                even_count += 1\n                if(arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_even_index = i\n                }\n            }\n        }\n        if(even_count > 0) {\n            res = List[Long](min_even, min_even_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292634,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfixdjbp4.scala:35:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- arr.length) {\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value foreach is not a member of Int\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < smallest_even_value) {\n                    smallest_even_value = i\n                    smallest_index = arr.indexOf(i)\n                }\n            }\n        }\n        return (List[Long](smallest_even_value, smallest_index))\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292637,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpxae_3_fy.scala:44)\n\tat Problem.main(tmpxae_3_fy.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.length == 0) {\n            return []\n        }\n        var smallest_value = arr[0]\n        var smallest_index = 0\n        var smallest_even_index = 0\n        var even_index = 0\n        for (i <- 0 until arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < smallest_value) {\n                    smallest_value = arr[i]\n                    smallest_index = i\n                    smallest_even_index = even_index\n                }\n                even_index = i\n            }\n        }\n        if (smallest_even_index == 0) {\n            return arr\n        }\n        return [smallest_value, smallest_index]\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292632,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_ivsj3pb.scala:31:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mreturn\u001b[0m []\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    an identifier expected, but ']' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_ivsj3pb.scala:32:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        '=>' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_ivsj3pb.scala:51:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=>' expected, but '}' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmp_ivsj3pb.scala:33:32 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36msmallest_value\u001b[0m = arr[\u001b[31m0\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m does not take type parameters\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_ivsj3pb.scala:38:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_ivsj3pb.scala:39:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < smallest_value) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_ivsj3pb.scala:40:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                    smallest_value = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = Long.MAX_VALUE\n        var min_index = -1\n        for (i <- 0 until arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        if (min_index == -1) {\n            result = List[Long](min_even)\n        } else {\n            result = List[Long](min_even, min_index)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292633,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp28dlgqjx.scala:31:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = Long.MAX_VALUE\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value MAX_VALUE is not a member of object Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp28dlgqjx.scala:34:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp28dlgqjx.scala:35:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < min_even) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp28dlgqjx.scala:36:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = Long.MAX_VALUE\n        var min_index = -1\n        for(i <- 0 until arr.length) {\n            if(arr[i] % 2 == 0) {\n                if(arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        if(min_index != -1) {\n            result = List[Long](min_even, min_index)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292635,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7z1rdyh4.scala:31:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = Long.MAX_VALUE\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value MAX_VALUE is not a member of object Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7z1rdyh4.scala:34:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m(arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7z1rdyh4.scala:35:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m(arr[\u001b[35mi\u001b[0m] < min_even) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7z1rdyh4.scala:36:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) {\n            return arr\n        }\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        var index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < smallest_even_value) {\n                    smallest_even_value = i\n                    smallest_index = index\n                }\n            }\n            index += 1\n        }\n        return arr.take(smallest_index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292632,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp1k7js76l.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < min_even) {\n                    min_even = i\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        res = res.append(min_even)\n        res = res.append(min_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyi12rnyz.scala:41:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        res = res.append(min_even)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyi12rnyz.scala:42:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        res = res.append(min_index)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < min_even) {\n                    min_even = i\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        result = List[Long](min_even, min_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292593,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpokrcvb2f.scala:46)\n\tat Problem.main(tmpokrcvb2f.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val res = new ArrayList[Long]()\n        val min_even = arr.head\n        val min_index = 0\n        val min_even_index = 0\n        val min_index_arr = new ArrayList[Long]()\n        val even_arr = arr.filter(x -> x % 2 == 0)\n        for (i <- even_arr.size) {\n            val even = even_arr.apply(i)\n            if (even < min_even) {\n                min_even = even\n                min_even_index = i\n            }\n            val index = arr.indexOf(even)\n            if (index < min_index) {\n                min_index = index\n                min_index_arr = new ArrayList[Long]()\n                min_index_arr.add(even)\n                min_index_arr.add(index)\n            } else if (index == min_index) {\n                min_index_arr.add(even)\n                min_index_arr.add(index)\n            }\n        }\n        if (min_index_arr.size == 0) {\n            res.add(min_even)\n        } else {\n            res.add(min_even_index)\n            res.add(min_index_arr.get(1))\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292635,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpclpmge5x.scala:30:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArrayList\u001b[0m[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: type ArrayList\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpclpmge5x.scala:34:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmin_index_arr\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArrayList\u001b[0m[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: type ArrayList\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpclpmge5x.scala:35:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36meven_arr\u001b[0m = arr.filter(x -> x % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: x\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpclpmge5x.scala:36:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- even_arr.size) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) return arr\n        var smallest_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (arr.head.toLong % 2 == 0 && arr.head.toLong < smallest_value) {\n                smallest_value = arr.head.toLong\n                smallest_index = i\n            }\n        }\n        return arr.update(smallest_index, arr.head)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292638,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpeymzo816.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) \u001b[33mreturn\u001b[0m arr\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpeymzo816.scala:36:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                smallest_index = i\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long @uncheckedVariance)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpeymzo816.scala:39:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mreturn\u001b[0m arr.update(smallest_index, arr.head)\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m  value update is not a member of List[Long] - did you mean arr.updated?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var smallest_value = arr.head\n        var smallest_index = 0\n        for(i <- arr.tail) {\n            if(arr.head.even()) {\n                if(arr.head.value < smallest_value.value) {\n                    smallest_value = arr.head\n                    smallest_index = i\n                }\n            }\n        }\n        res = res.append(smallest_value)\n        res = res.append(smallest_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292638,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2rq04m8k.scala:34:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m(arr.head.even()) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               value even is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2rq04m8k.scala:35:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m(arr.head.value < smallest_value.value) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value value is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2rq04m8k.scala:37:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    smallest_index = i\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long @uncheckedVariance)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2rq04m8k.scala:41:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        res = res.append(smallest_value)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2rq04m8k.scala:42:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        res = res.append(smallest_index)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for(i <- arr.tail) {\n            if(arr.head.even) {\n                if(arr.head.value < min_even.value) {\n                    min_even = arr.head\n                    min_index = i\n                }\n            } else {\n                if(arr.head.value < min_even.value) {\n                    min_even = arr.head\n                    min_index = i\n                }\n            }\n        }\n        res = res.append(min_even)\n        res = res.append(min_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292639,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuwbmbs3m.scala:34:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m(arr.head.even) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               value even is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuwbmbs3m.scala:35:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m(arr.head.value < min_even.value) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value value is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuwbmbs3m.scala:37:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    min_index = i\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    (i : Long @uncheckedVariance)\n\u001b[31m   |\u001b[0m                                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuwbmbs3m.scala:40:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                \u001b[33mif\u001b[0m(arr.head.value < min_even.value) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value value is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuwbmbs3m.scala:42:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m                    min_index = i\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    (i : Long @uncheckedVariance)\n\u001b[31m   |\u001b[0m                                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuwbmbs3m.scala:46:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        res = res.append(min_even)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < min_even) {\n                    min_even = i\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        res = res.append(min_even)\n        res = res.append(min_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyi12rnyz.scala:41:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        res = res.append(min_even)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyi12rnyz.scala:42:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        res = res.append(min_index)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) {\n            return arr\n        }\n        var smallest_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (arr.head.toLong % 2 == 0) {\n                if (arr.head.toLong < smallest_value.toLong) {\n                    smallest_value = arr.head\n                    smallest_index = i\n                }\n            }\n        }\n        return (List[Long](smallest_value, smallest_index))\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292638,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp_iixjeg3.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_iixjeg3.scala:39:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                    smallest_index = i\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long @uncheckedVariance)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long](arr.size)\n        var min_even_value = arr.size\n        var min_index = 0\n        for(i <- 0 until arr.size) {\n            if(arr[i] % 2 == 0) {\n                if(arr[i] < min_even_value) {\n                    min_even_value = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        result[0] = min_even_value\n        result[1] = min_index\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292635,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpqysmenvx.scala:41:18 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        result[\u001b[31m0\u001b[0m] = min_even_value\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  end of statement expected but '=' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpqysmenvx.scala:42:18 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        result[\u001b[31m1\u001b[0m] = min_index\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  end of statement expected but '=' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqysmenvx.scala:34:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m(arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqysmenvx.scala:35:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m(arr[\u001b[35mi\u001b[0m] < min_even_value) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqysmenvx.scala:36:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    min_even_value = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpqysmenvx.scala:41:14 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        result[\u001b[31m0\u001b[0m] = min_even_value\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m does not take type parameters\n\u001b[31m\u001b[31m-- Error: /tmp/tmpqysmenvx.scala:42:14 ------------------------------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i.toLong % 2 == 0) {\n                if (i.toLong < min_even) {\n                    min_even = i.toLong\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        if (min_even != 0) {\n            result = List[Long](min_even, min_index)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppdcfg1ox.scala:48)\n\tat Problem.main(tmppdcfg1ox.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        var i = 0\n        while (i < arr.size) {\n            if (arr.apply(i).toLong % 2 == 0) {\n                if (arr.apply(i).toLong < smallest_even_value) {\n                    smallest_even_value = arr.apply(i).toLong\n                    smallest_index = i\n                }\n            }\n            i = i + 1\n        }\n        if (smallest_even_value == 0) {\n            result = arr.apply(smallest_index)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292640,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0q58dcg4.scala:44:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m            result = arr.apply(smallest_index)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Found:    Long\n\u001b[31m   |\u001b[0m                     Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mLong\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val result = mutable.List[Long]()\n        val min_even = arr.minBy[Long](_ => _ % 2 == 0)\n        val min_index = arr.indexOf(min_even)\n        if (min_even == None) {\n            return result\n        }\n        result.append(min_even)\n        result.append(min_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292639,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwpubqy0l.scala:30:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpwpubqy0l.scala:31:44 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmin_even\u001b[0m = arr.minBy[\u001b[35mLong\u001b[0m](_ => _ % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$2 of expanded function:\n\u001b[31m   |\u001b[0m   _$2 => _$2 % 2 == 0.\n\u001b[31m\u001b[31m-- Error: /tmp/tmpwpubqy0l.scala:33:12 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mif\u001b[0m (min_even == None) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m   Values of types Long and object None cannot be compared with == or !=\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        var min_value = 0\n        var min_index_even = 0\n        var min_value_even = 0\n        var i = 0\n        for (i = 0; i < arr.size; i++) {\n            if (arr.apply(i) % 2 == 0) {\n                if (arr.apply(i) < min_even) {\n                    min_even = arr.apply(i)\n                    min_index_even = i\n                }\n            } else {\n                if (arr.apply(i) < min_value) {\n                    min_value = arr.apply(i)\n                    min_index = i\n                }\n            }\n        }\n        if (min_even == 0) {\n            result = List[Long](min_value, min_index)\n        } else {\n            result = List[Long](min_even, min_index_even)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbrsl2agm.scala:37:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mfor\u001b[0m (i = \u001b[31m0\u001b[0m; i < arr.size; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbrsl2agm.scala:37:32 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mfor\u001b[0m (i = \u001b[31m0\u001b[0m; i < arr.size; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpbrsl2agm.scala:37:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mfor\u001b[0m (i = \u001b[31m0\u001b[0m; i < arr.size; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbrsl2agm.scala:37:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mfor\u001b[0m (i = \u001b[31m0\u001b[0m; i < arr.size; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue foreach is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator asScala\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\u001b[31m   |\u001b[0m  import collection.convert",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even_value = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < min_even_value) {\n                    min_even_value = i\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        result = result.append(min_even_value)\n        result = result.append(min_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe199vg8n.scala:41:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        result = result.append(min_even_value)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe199vg8n.scala:42:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        result = result.append(min_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]().toLong\n        var smallest_even_value = arr.head.toLong\n        var smallest_index = 0\n        for(i <- arr.tail.toLong) {\n            if(arr.head.toLong % 2 == 0) {\n                if(arr.head.toLong < smallest_even_value) {\n                    smallest_even_value = arr.head.toLong\n                    smallest_index = i\n                }\n            }\n        }\n        result = result.append(smallest_even_value)\n        result = result.append(smallest_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9m_5zxt7.scala:30:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = List[\u001b[35mLong\u001b[0m]().toLong\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toLong is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9m_5zxt7.scala:33:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- arr.tail.toLong) {\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toLong is not a member of List[Long @uncheckedVariance], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = Long.MAX_VALUE\n        var min_index = 0\n        for (i <- 0 until arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        if (min_even == Long.MAX_VALUE) {\n            return res\n        } else {\n            res = List[Long](min_even, min_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptct43r26.scala:31:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = Long.MAX_VALUE\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value MAX_VALUE is not a member of object Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptct43r26.scala:34:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptct43r26.scala:35:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < min_even) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptct43r26.scala:36:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_index = -1\n        var min_value = -1\n        for (i <- 0 until arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (min_value == -1) {\n                    min_value = arr[i]\n                    min_index = i\n                } else if (arr[i] < min_value) {\n                    min_value = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        if (min_value == -1) {\n            return result\n        } else {\n            result = List[Long](min_value, min_index)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292638,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4dchgzhl.scala:34:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4dchgzhl.scala:36:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    min_value = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4dchgzhl.scala:38:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (arr[i] < min_value) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4dchgzhl.scala:39:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                    min_value = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even_value = arr.head.toLong\n        var min_index = 0\n        var min_even_index = 0\n        var min_index_index = 0\n        for (i <- 0 until arr.length) {\n            if (arr[i].toLong % 2 == 0) {\n                if (arr[i].toLong < min_even_value) {\n                    min_even_value = arr[i].toLong\n                    min_even_index = i\n                }\n            } else {\n                if (arr[i].toLong < min_even_value) {\n                    min_even_value = arr[i].toLong\n                    min_even_index = i\n                }\n                if (arr[i].toLong < min_index_value) {\n                    min_index_value = arr[i].toLong\n                    min_index_index = i\n                }\n            }\n        }\n        if (min_even_value == 0) {\n            result = arr.take(min_index_index)\n        } else {\n            result = arr.take(min_even_index)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292639,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz3zhjngc.scala:36:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m].toLong % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz3zhjngc.scala:37:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m].toLong < min_even_value) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz3zhjngc.scala:38:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                    min_even_value = arr[\u001b[35mi\u001b[0m].toLong\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz3zhjngc.scala:42:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m].toLong < min_even_value) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz3zhjngc.scala:43:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m                    min_even_value = arr[\u001b[35mi\u001b[0m].toLong\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz3zhjngc.scala:46:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m                \u001b[3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]().toSeq()\n        for (i <- 0 until arr.length) {\n            if (arr[i] % 2 == 0) {\n                result = result.append(arr[i])\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpm1kld7v9.scala:30:39 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = List[\u001b[35mLong\u001b[0m]().toSeq()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm1kld7v9.scala:32:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) {\n            return arr\n        }\n        var min_even_value = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < min_even_value) {\n                    min_even_value = i\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        return (List[Long](min_even_value, min_index))\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpcdg68zzz.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = Long.MAX_VALUE\n        var min_index = -1\n        for(i <- 0 until arr.length) {\n            if(arr[i] % 2 == 0) {\n                if(arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        if(min_index == -1) {\n            return res\n        } else {\n            res = List[Long](min_even, min_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmposuaxiex.scala:31:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = Long.MAX_VALUE\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value MAX_VALUE is not a member of object Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmposuaxiex.scala:34:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m(arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmposuaxiex.scala:35:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m(arr[\u001b[35mi\u001b[0m] < min_even) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmposuaxiex.scala:36:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i.toLong % 2 == 0) {\n                if (i.toLong < min_even) {\n                    min_even = i.toLong\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        if (min_even == 0) {\n            res = arr.take(min_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292646,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpz1evf926.scala:47)\n\tat Problem.main(tmpz1evf926.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var smallest_even_value = arr.filter(x => x % 2 == 0).minBy[Long](_ => x)\n        var smallest_index = arr.indexOf(smallest_even_value)\n        var plucked_node = arr.take(smallest_index)\n        return plucked_node\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz9peakvc.scala:30:79 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36msmallest_even_value\u001b[0m = arr.filter(\u001b[36mx\u001b[0m => x % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m).minBy[\u001b[35mLong\u001b[0m](_ => x)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                            Not found: x\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (arr.head.toLong % 2 == 0) {\n                if (arr.head.toLong < smallest_value.toLong) {\n                    smallest_value = arr.head\n                    smallest_index = i\n                }\n            }\n        }\n        result = List[Long](smallest_value, smallest_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292645,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5j7907fv.scala:37:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    smallest_index = i\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long @uncheckedVariance)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val res = mutable.List[Long]()\n        for (i <- 0 until arr.length) {\n            val cur = arr[i]\n            if (cur % 2 == 0) {\n                res.append(cur)\n                res.append(i)\n                break\n            }\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfwhofo_6.scala:30:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfwhofo_6.scala:32:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mcur\u001b[0m = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfwhofo_6.scala:36:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        var min_even_index = 0\n        for (i <- arr.size - 1) {\n            if (arr.apply(i).toLong % 2 == 0) {\n                if (arr.apply(i).toLong < min_even) {\n                    min_even = arr.apply(i).toLong\n                    min_even_index = i\n                }\n            }\n        }\n        if (min_even_index != 0) {\n            res = res.append(min_even)\n            res = res.append(min_even_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292648,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpd9w7i1cd.scala:34:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- arr.size - \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpd9w7i1cd.scala:43:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m            res = res.append(min_even)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpd9w7i1cd.scala:44:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m            res = res.append(min_even_index)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val res = mutable.List[Long]()\n        val min_even = arr.minBy[Int](_ => _ % 2 == 0)._1\n        val min_index = arr.minBy[Int](_ => _ % 2 == 0)._2\n        val min_value = arr.minBy[Int](_ => _ % 2 == 0)._3\n        val min_index_value = arr.minBy[Int](_ => _ % 2 == 0)._4\n        val min_index_value_index = arr.minBy[Int](_ => _ % 2 == 0)._5\n        val min_index_value_index_value = arr.minBy[Int](_ => _ % 2 == 0)._6\n        if (min_even == null) {\n            return res\n        }\n        if (min_index == null) {\n            return res\n        }\n        if (min_value == null) {\n            return res\n        }\n        if (min_index_value == null) {\n            return res\n        }\n        if (min_index_value_index == null) {\n            return res\n        }\n        if (min_index_value_index_value == null) {\n            return res\n        }\n        res.append(min_even)\n        res.append(min_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292645,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp049y0eug.scala:30:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmp049y0eug.scala:31:43 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmin_even\u001b[0m = arr.minBy[\u001b[35mInt\u001b[0m](_ => _ % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m)._1\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$2 of expanded function:\n\u001b[31m   |\u001b[0m   _$2 => _$2 % 2 == 0.\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmp049y0eug.scala:32:44 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmin_index\u001b[0m = arr.minBy[\u001b[35mInt\u001b[0m](_ => _ % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m)._2\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$4 of expanded function:\n\u001b[31m   |\u001b[0m   _$4 => _$4 % 2 == 0.\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmp049y0eug.scala:33:44 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmin_value\u001b[0m = arr.minBy[\u001b[35mInt\u001b[0m](_ => _ % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m)._3\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$6 of expanded function:\n\u001b[31m   |\u001b[0m   _$6 => _$6 % 2 == 0.\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmp049y0eug.scala:34:50 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmin_index_value\u001b[0m = arr.minBy[\u001b[35mInt\u001b[0m](_ => _ % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m)._4\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^\u001b[0m\n\u001b[31m   |\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        var min_even_index = 0\n        for(i <- arr.size) {\n            if(arr.apply(i).toLong % 2 == 0) {\n                if(arr.apply(i).toLong < min_even) {\n                    min_even = arr.apply(i).toLong\n                    min_even_index = i\n                }\n            } else {\n                if(arr.apply(i).toLong < min_even) {\n                    min_even = arr.apply(i).toLong\n                    min_even_index = i\n                }\n            }\n        }\n        if(min_even_index == 0) {\n            res = List[Long](min_even, min_index)\n        } else {\n            res = List[Long](min_even, min_even_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292648,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyjnj04la.scala:34:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- arr.size) {\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value foreach is not a member of Int\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i.toLong % 2 == 0) {\n                if (i.toLong < min_even) {\n                    min_even = i.toLong\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        if (min_even == 0) {\n            result = arr.take(min_index)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292651,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_uoup_j3.scala:47)\n\tat Problem.main(tmp_uoup_j3.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = Long.MAX_VALUE\n        var min_index = -1\n        var i = 0\n        for (i < arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_index = i\n                }\n            }\n            i = i + 1\n        }\n        if (min_index != -1) {\n            result = List[Long](min_even, min_index)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292650,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpff7nkp4_.scala:34:29 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m (i < arr.length) {\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             '<-' expected, but '{' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpff7nkp4_.scala:45:9 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m         ^\u001b[0m\n\u001b[31m   |\u001b[0m         pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpff7nkp4_.scala:31:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = Long.MAX_VALUE\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value MAX_VALUE is not a member of object Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpff7nkp4_.scala:42:9 -------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m         ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator asScala\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.set asScala\n\u001b[31m   |\u001b[0m\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.minBy[0](_ => _.toLong % 2 == 0).toLong\n        var min_index = arr.minBy[1](_ => _.toLong).toLong\n        var min_value = arr.minBy[0](_ => _.toLong).toLong\n        var min_index_value = arr.minBy[1](_ => _.toLong).toLong\n        if (min_even == 0 && min_index == 0) {\n            res = arr.takeWhile[1](_ => _.toLong != min_value).toList\n        } else if (min_even == 0) {\n            res = arr.takeWhile[1](_ => _.toLong != min_value).toList\n        } else if (min_index == 0) {\n            res = arr.takeWhile[1](_ => _.toLong != min_index_value).toList\n        } else {\n            res = arr.takeWhile[1](_ => _.toLong != min_index_value).toList\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292648,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmprftvqd1m.scala:31:41 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = arr.minBy[\u001b[31m0\u001b[0m](_ => _.toLong % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$2 of expanded function:\n\u001b[31m   |\u001b[0m   _$2 => _$2.toLong % 2 == 0.\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmprftvqd1m.scala:32:42 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_index\u001b[0m = arr.minBy[\u001b[31m1\u001b[0m](_ => _.toLong).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$4 of expanded function:\n\u001b[31m   |\u001b[0m   _$4 => _$4.toLong.\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmprftvqd1m.scala:33:42 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_value\u001b[0m = arr.minBy[\u001b[31m0\u001b[0m](_ => _.toLong).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$6 of expanded function:\n\u001b[31m   |\u001b[0m   _$6 => _$6.toLong.\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmprftvqd1m.scala:34:48 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_index_value\u001b[0m = arr.minBy[\u001b[31m1\u001b[0m](_ => _.toLong).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$8 of expanded function:\n\u001b[31m   |\u001b[0m   _$8 => _$8.toLong.\n\u001b[31m\u001b[31m-- Error: /tmp/tmprftvqd1m.scala:36:31 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            res = arr.takeWhile[\u001b[31m1\u001b[0m](_ => _.toLong != min_value).toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var smallest_value = arr.head\n        var smallest_index = 0\n        var index = 0\n        for(i <- arr.tail) {\n            if(arr.head == arr.tail.head) {\n                smallest_value = arr.head\n                smallest_index = index\n            } else if(arr.head < arr.tail.head) {\n                smallest_value = arr.head\n                smallest_index = index\n            } else if(arr.head > arr.tail.head) {\n                smallest_value = arr.tail.head\n                smallest_index = index + 1\n            }\n            index += 1\n        }\n        return (smallest_value, smallest_index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292649,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp026yi8au.scala:46:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mreturn\u001b[0m (smallest_value, smallest_index)\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Found:    (Long, Int)\n\u001b[31m   |\u001b[0m               Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.length == 0) {\n            return []\n        } else {\n            var smallest_even_value = arr[0]\n            var smallest_index = 0\n            for (i <- 1 to arr.length - 1) {\n                if (arr[i] % 2 == 0) {\n                    if (arr[i] < smallest_even_value) {\n                        smallest_even_value = arr[i]\n                        smallest_index = i\n                    }\n                }\n            }\n            return [smallest_even_value, smallest_index]\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292646,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8sejuei8.scala:31:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mreturn\u001b[0m []\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    an identifier expected, but ']' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8sejuei8.scala:32:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        '=>' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8sejuei8.scala:44:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        '=>' expected, but '}' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmp8sejuei8.scala:33:41 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36msmallest_even_value\u001b[0m = arr[\u001b[31m0\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m does not take type parameters\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8sejuei8.scala:36:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8sejuei8.scala:37:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < smallest_even_value) {\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8sejuei8.scala:38:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                        smallest_even_value = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                      ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val res = new ArrayList[Long]()\n        val min_even = arr.minBy(x -> x % 2 == 0)\n        val min_index = arr.indexOf(min_even)\n        if (min_even == null) {\n            return res\n        }\n        val min_even_index = arr.indexOf(min_even)\n        res.add(min_even)\n        res.add(min_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292647,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf2aa0pld.scala:30:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArrayList\u001b[0m[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: type ArrayList\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf2aa0pld.scala:31:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmin_even\u001b[0m = arr.minBy(x -> x % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Not found: x\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpf2aa0pld.scala:31:49 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmin_even\u001b[0m = arr.minBy(x -> x % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mShort\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[B] of parameter cmp of \u001b[33mmethod\u001b[0m \u001b[35mminBy\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOnceOps\u001b[0m\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        var i = 0\n        while (i < arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < smallest_even_value) {\n                    smallest_even_value = arr[i]\n                    smallest_index = i\n                }\n            }\n            i = i + 1\n        }\n        if (smallest_even_value == 0) {\n            result = arr.take(smallest_index)\n        } else {\n            result = arr.take(smallest_index).append(smallest_even_value)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292650,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppwt2d3h3.scala:35:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppwt2d3h3.scala:36:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < smallest_even_value) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppwt2d3h3.scala:37:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    smallest_even_value = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppwt2d3h3.scala:46:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m            result = arr.take(smallest_index).append(smallest_even_value)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = Long.MAX_VALUE\n        var min_index = 0\n        var min_value = Long.MAX_VALUE\n        for (i <- 0 until arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_index = i\n                }\n            } else {\n                if (arr[i] < min_value) {\n                    min_value = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        res = List[Long](min_even, min_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292651,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0t2shi7r.scala:31:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = Long.MAX_VALUE\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value MAX_VALUE is not a member of object Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0t2shi7r.scala:33:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_value\u001b[0m = Long.MAX_VALUE\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value MAX_VALUE is not a member of object Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0t2shi7r.scala:35:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0t2shi7r.scala:36:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < min_even) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0t2shi7r.scala:37:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0t2shi7r.scala:41:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < min_value) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation a",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min = arr.head\n        var min_index = 0\n        for(i <- arr.tail) {\n            if(min.even) {\n                if(i.even) {\n                    if(i.value < min.value) {\n                        min = i\n                        min_index = arr.indexOf(i)\n                    }\n                } else {\n                    if(i.value < min.value) {\n                        min = i\n                        min_index = arr.indexOf(i)\n                    }\n                }\n            } else {\n                if(i.even) {\n                    if(i.value < min.value) {\n                        min = i\n                        min_index = arr.indexOf(i)\n                    }\n                } else {\n                    if(i.value < min.value) {\n                        min = i\n                        min_index = arr.indexOf(i)\n                    }\n                }\n            }\n        }\n        res = List[Long](min.value, min_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292652,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi05b3kuh.scala:34:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m(min.even) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               value even is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi05b3kuh.scala:35:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m(i.even) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value even is not a member of Long @uncheckedVariance\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi05b3kuh.scala:36:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    \u001b[33mif\u001b[0m(i.value < min.value) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value value is not a member of Long @uncheckedVariance\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi05b3kuh.scala:41:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m                    \u001b[33mif\u001b[0m(i.value < min.value) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value value is not a member of Long @uncheckedVariance\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi05b3kuh.scala:47:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m                \u001b[33mif\u001b[0m(i.even) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value even is not a member of Long @uncheckedVariance\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi05b3kuh.scala:48:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m                    \u001b[33mif\u001b[0m(i.value < min.value) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value value is not a member of Long @uncheckedVariance\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi05b3kuh.scala:53:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m                    \u001b[33mif\u001b[0m(i.value < min.value) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value value is not a member of Long @uncheckedVariance",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = Long.MAX_VALUE\n        var min_index = -1\n        for (i <- 0 until arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        if (min_index != -1) {\n            result = List[Long](min_even, min_index)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292651,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4xv1ofuy.scala:31:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = Long.MAX_VALUE\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value MAX_VALUE is not a member of object Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4xv1ofuy.scala:34:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4xv1ofuy.scala:35:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < min_even) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4xv1ofuy.scala:36:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val res = mutable.List[Long]()\n        if (arr.isEmpty()) {\n            return res\n        }\n        val min_even = arr.minBy(x => x % 2 == 0)\n        val min_index = arr.indexOf(min_even)\n        res.append(min_even)\n        res.append(min_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292649,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpswom2mgz.scala:30:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpswom2mgz.scala:31:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i.toLong % 2 == 0) {\n                if (i.toLong < min_even) {\n                    min_even = i.toLong\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        result = result.append(min_even)\n        result = result.append(min_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292601,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp58jz1fqg.scala:41:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        result = result.append(min_even)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp58jz1fqg.scala:42:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        result = result.append(min_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) return arr\n        var smallest_value = arr.head\n        var smallest_index = 0\n        var index = 0\n        for (i <- arr.tail) {\n            if (arr.head == i) {\n                arr = arr.tail\n                return arr\n            }\n            if (arr.head % 2 == 0 && arr.head < i) {\n                smallest_value = arr.head\n                smallest_index = index\n            }\n            if (arr.head % 2 != 0 && arr.head < i) {\n                smallest_value = arr.head\n                smallest_index = index\n            }\n            index += 1\n        }\n        arr = arr.tail\n        return arr\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292649,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpl7r00dec.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) \u001b[33mreturn\u001b[0m arr\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpl7r00dec.scala:36:20 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                arr = arr.tail\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val arr\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpl7r00dec.scala:49:12 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m        arr = arr.tail\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Reassignment to val arr\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        var min_even_index = 0\n        for(i <- arr.length - 1) {\n            if(arr[i] % 2 == 0) {\n                if(arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_even_index = i\n                }\n            } else {\n                if(arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_even_index = i\n                }\n                if(arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_even_index = i\n                }\n            }\n        }\n        if(min_even_index == 0) {\n            res = arr\n        } else {\n            res = List[Long](min_even, min_even_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292651,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4y6fz5dj.scala:34:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- arr.length - \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value foreach is not a member of Int\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < min_even) {\n                    min_even = i\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        res = res.append(min_even)\n        res = res.append(min_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyi12rnyz.scala:41:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        res = res.append(min_even)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyi12rnyz.scala:42:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        res = res.append(min_index)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) return arr\n        var min_even = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i.toLong % 2 == 0) {\n                if (i.toLong < min_even) {\n                    min_even = i.toLong\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        return (min_even, min_index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292653,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp1gzp6qav.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) \u001b[33mreturn\u001b[0m arr\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1gzp6qav.scala:41:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mreturn\u001b[0m (min_even, min_index)\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Found:    (Long, Int)\n\u001b[31m   |\u001b[0m               Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for(i <- arr.tail) {\n            if(i.mod(2) == 0) {\n                if(i < min_even) {\n                    min_even = i\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        res = res.append(min_even)\n        res = res.append(min_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292655,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpla8dv64b.scala:34:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m(i.mod(\u001b[31m2\u001b[0m) == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue mod is not a member of Long @uncheckedVariance, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.long2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpla8dv64b.scala:41:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        res = res.append(min_even)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpla8dv64b.scala:42:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        res = res.append(min_index)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) {\n            return []\n        }\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        var index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < smallest_even_value) {\n                    smallest_even_value = i\n                    smallest_index = index\n                }\n            }\n            index += 1\n        }\n        return [smallest_even_value, smallest_index]\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292652,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_ab9xsmt.scala:31:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mreturn\u001b[0m []\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    an identifier expected, but ']' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_ab9xsmt.scala:32:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        '=>' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_ab9xsmt.scala:46:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=>' expected, but '}' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp_ab9xsmt.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_value = arr.head\n        var smallest_index = 0\n        var i = 0\n        while (i < arr.size) {\n            if (arr.apply(i).toLong % 2 == 0) {\n                if (arr.apply(i).toLong < smallest_value) {\n                    smallest_value = arr.apply(i).toLong\n                    smallest_index = i\n                }\n            }\n            i = i + 1\n        }\n        if (smallest_value == 0) {\n            result = arr.apply(smallest_index)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292655,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpi06p8tus.scala:44:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m            result = arr.apply(smallest_index)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Found:    Long\n\u001b[31m   |\u001b[0m                     Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mLong\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        var min_even_index = 0\n        var min_even_value = 0\n        for (i <- 0 until arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < min_even_value) {\n                    min_even_value = arr[i]\n                    min_even_index = i\n                }\n            } else {\n                if (arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_even_index = i\n                }\n            }\n        }\n        if (min_even_value != 0) {\n            result = List[Long](min_even_value, min_even_index)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292652,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2nq13lw2.scala:36:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2nq13lw2.scala:37:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < min_even_value) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2nq13lw2.scala:38:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                    min_even_value = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2nq13lw2.scala:42:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < min_even) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2nq13lw2.scala:43:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = Long.MAX_VALUE\n        var min_index = 0\n        for (i <- 0 until arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        result = List[Long](min_even, min_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292656,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4ivvvs0f.scala:31:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = Long.MAX_VALUE\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value MAX_VALUE is not a member of object Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4ivvvs0f.scala:34:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4ivvvs0f.scala:35:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < min_even) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4ivvvs0f.scala:36:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = Long.MAX_VALUE\n        var min_index = -1\n        for (i <- 0 until arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        if (min_index != -1) {\n            result = List[Long](min_even, min_index)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292651,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4xv1ofuy.scala:31:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = Long.MAX_VALUE\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value MAX_VALUE is not a member of object Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4xv1ofuy.scala:34:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4xv1ofuy.scala:35:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < min_even) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4xv1ofuy.scala:36:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        var min_even_index = 0\n        var min_index_index = 0\n        var i = 0\n        while (i < arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_even_index = i\n                }\n            } else {\n                if (arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_even_index = i\n                }\n                if (arr[i] < min_index) {\n                    min_index = arr[i]\n                    min_index_index = i\n                }\n            }\n            i = i + 1\n        }\n        if (min_even_index == 0) {\n            result = List[Long](min_index, min_index_index)\n        } else {\n            result = List[Long](min_even, min_even_index)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292653,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgh0nshy8.scala:37:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgh0nshy8.scala:38:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < min_even) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgh0nshy8.scala:39:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgh0nshy8.scala:43:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < min_even) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgh0nshy8.scala:44:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgh0nshy8.scala:47:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < min_index) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = Long.MAX_VALUE\n        var min_index = -1\n        for (i <- 0 until arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        if (min_index != -1) {\n            res = List[Long](min_even, min_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292591,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpz7l2tw87.scala:31:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = Long.MAX_VALUE\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value MAX_VALUE is not a member of object Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz7l2tw87.scala:34:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz7l2tw87.scala:35:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < min_even) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz7l2tw87.scala:36:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < smallest_even_value) {\n                    smallest_even_value = i\n                    smallest_index = arr.indexOf(i)\n                }\n            }\n        }\n        return (List[Long](smallest_even_value, smallest_index))\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292637,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpxae_3_fy.scala:44)\n\tat Problem.main(tmpxae_3_fy.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head.toLong\n        var min_index = 0\n        for (i <- arr.size - 1) {\n            if (arr.apply(i).toLong % 2 == 0) {\n                if (arr.apply(i).toLong < min_even) {\n                    min_even = arr.apply(i).toLong\n                    min_index = i\n                }\n            }\n        }\n        if (min_even == 0) {\n            res = arr.apply(min_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292658,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp40omc7fl.scala:33:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- arr.size - \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp40omc7fl.scala:42:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m            res = arr.apply(min_index)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Found:    Long\n\u001b[31m   |\u001b[0m                  Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mLong\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_even_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < smallest_even_value) {\n                    smallest_even_value = i\n                    smallest_index = arr.indexOf(i)\n                }\n            }\n        }\n        result = result.append(smallest_even_value)\n        result = result.append(smallest_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292615,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4vkvn7i_.scala:41:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        result = result.append(smallest_even_value)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4vkvn7i_.scala:42:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        result = result.append(smallest_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        var min_even_index = 0\n        var i = 0\n        for(i = 0; i < arr.size; i++) {\n            if(arr.apply(i) % 2 == 0) {\n                if(arr.apply(i) < min_even) {\n                    min_even = arr.apply(i)\n                    min_even_index = i\n                }\n            }\n        }\n        if(min_even_index != 0) {\n            res = List[Long](min_even, min_even_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292660,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpk_90exrq.scala:35:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mfor\u001b[0m(i = \u001b[31m0\u001b[0m; i < arr.size; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^\u001b[0m\n\u001b[31m   |\u001b[0m              ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpk_90exrq.scala:35:31 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mfor\u001b[0m(i = \u001b[31m0\u001b[0m; i < arr.size; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpk_90exrq.scala:35:36 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mfor\u001b[0m(i = \u001b[31m0\u001b[0m; i < arr.size; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpk_90exrq.scala:35:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mfor\u001b[0m(i = \u001b[31m0\u001b[0m; i < arr.size; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                 ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue foreach is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator asScala\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitCo",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even_value = arr.head\n        var min_index = 0\n        var i = 0\n        while (i < arr.length) {\n            var curr_even_value = arr[i]\n            if (curr_even_value % 2 == 0) {\n                if (curr_even_value < min_even_value) {\n                    min_even_value = curr_even_value\n                    min_index = i\n                }\n            }\n            i = i + 1\n        }\n        if (min_index == 0) {\n            res = res.append(min_even_value)\n        } else {\n            res = res.append(arr[min_index])\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292658,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphtb65nce.scala:35:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mcurr_even_value\u001b[0m = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphtb65nce.scala:45:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m            res = res.append(min_even_value)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphtb65nce.scala:47:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m            res = res.append(arr[\u001b[35mmin_index\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphtb65nce.scala:47:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m            res = res.append(arr[\u001b[35mmin_index\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Not found: type min_index\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even_value = arr.head\n        var min_index = 0\n        for (i <- arr.size - 1) {\n            if (arr.apply(i).mod(2) == 0) {\n                if (arr.apply(i) < min_even_value) {\n                    min_even_value = arr.apply(i)\n                    min_index = i\n                }\n            }\n        }\n        res = res.append(min_even_value)\n        res = res.append(min_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptk42s39n.scala:33:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- arr.size - \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptk42s39n.scala:41:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        res = res.append(min_even_value)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptk42s39n.scala:42:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        res = res.append(min_index)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.minBy[Int](_ => _ % 2 == 0)\n        var min_index = arr.indexOf(min_even)\n        if (min_even != null) {\n            res = List[Long](min_even, min_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpwpd5jmos.scala:31:43 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = arr.minBy[\u001b[35mInt\u001b[0m](_ => _ % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$2 of expanded function:\n\u001b[31m   |\u001b[0m   _$2 => _$2 % 2 == 0.\n\u001b[31m\u001b[31m-- Error: /tmp/tmpwpd5jmos.scala:33:12 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mif\u001b[0m (min_even != \u001b[31mnull\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          Values of types Long and Null cannot be compared with == or !=\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = arr.head.toLong\n        var min_index = 0\n        for (i <- arr) {\n            if (i.toLong % 2 == 0) {\n                if (i.toLong < min_even) {\n                    min_even = i.toLong\n                    min_index = i.toLong\n                }\n            }\n        }\n        result = result.append(min_even)\n        result = result.append(min_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292660,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2mr2th2t.scala:37:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    min_index = i.toLong\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    Long\n\u001b[31m   |\u001b[0m                                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2mr2th2t.scala:41:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        result = result.append(min_even)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2mr2th2t.scala:42:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        result = result.append(min_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_value = arr.head\n        var smallest_index = 0\n        var index = 0\n        for(i <- arr.tail) {\n            if(arr.head == i) {\n                result = append(result, arr.head)\n                arr = arr.tail\n            } else if(arr.head % 2 == 0 && arr.head < i) {\n                result = append(result, arr.head)\n                arr = arr.tail\n            } else if(arr.head % 2 == 0 && arr.head > i) {\n                result = append(result, arr.head)\n                arr = arr.tail\n            } else if(arr.head < i) {\n                result = append(result, arr.head)\n                arr = arr.tail\n            } else if(arr.head > i) {\n                result = append(result, arr.head)\n                arr = arr.tail\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292658,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprheah1gl.scala:36:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                result = append(result, arr.head)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: append\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmprheah1gl.scala:37:20 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                arr = arr.tail\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val arr\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprheah1gl.scala:39:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                result = append(result, arr.head)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: append\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmprheah1gl.scala:40:20 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                arr = arr.tail\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val arr\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprheah1gl.scala:42:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m                result = append(result, arr.head)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: append\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmprheah1gl.scala:43:20 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m                arr = arr.tail\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val arr\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanatio",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_index = -1\n        var min_value = -1\n        for (i <- 0 until arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (min_value == -1) {\n                    min_value = arr[i]\n                    min_index = i\n                } else if (arr[i] < min_value) {\n                    min_value = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        if (min_value == -1) {\n            return res\n        } else {\n            res = List[Long](min_value, min_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292658,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgsn8as31.scala:34:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgsn8as31.scala:36:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    min_value = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgsn8as31.scala:38:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (arr[i] < min_value) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgsn8as31.scala:39:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                    min_value = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        var min_even_index = 0\n        for (i <- arr.size) {\n            if (arr.apply(i).toInt % 2 == 0) {\n                if (arr.apply(i).toInt < min_even) {\n                    min_even = arr.apply(i).toInt\n                    min_even_index = i\n                }\n            }\n        }\n        if (min_even_index == 0) {\n            res = List[Long](min_even, min_index)\n        } else {\n            res = List[Long](min_even, min_even_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292661,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbaxwxe00.scala:34:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- arr.size) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val res = List[Long]()\n        val evens = arr.filter(x -> x % 2 == 0)\n        if (evens.isEmpty()) {\n            return res\n        }\n        val smallest = evens.minBy(x -> x)\n        val index = arr.indexOf(smallest)\n        res = res.append(smallest)\n        res = res.append(index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292662,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyiuq40eh.scala:31:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mevens\u001b[0m = arr.filter(x -> x % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: x\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpyiuq40eh.scala:32:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mif\u001b[0m (evens.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyiuq40eh.scala:35:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msmallest\u001b[0m = evens.minBy(x -> x)\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: x\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpyiuq40eh.scala:35:42 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msmallest\u001b[0m = evens.minBy(x -> x)\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mShort\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[B] of parameter cmp of \u001b[33mmethod\u001b[0m \u001b[35mminBy\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOnceOps\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyiuq40eh.scala:37:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        res = res.append(smallest)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m value append is not a member of List[Long] - did you mean res.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyiu",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for(i <- arr.tail) {\n            if(arr.head.even()) {\n                if(arr.head.value < min_even.value) {\n                    min_even = arr.head\n                    min_index = i\n                }\n            } else {\n                if(arr.head.value < min_even.value) {\n                    min_even = arr.head\n                    min_index = i\n                }\n            }\n        }\n        res = res.append(min_even)\n        res = res.append(min_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292605,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx9s4dz8b.scala:34:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m(arr.head.even()) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               value even is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx9s4dz8b.scala:35:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m(arr.head.value < min_even.value) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value value is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpx9s4dz8b.scala:37:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    min_index = i\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    (i : Long @uncheckedVariance)\n\u001b[31m   |\u001b[0m                                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx9s4dz8b.scala:40:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                \u001b[33mif\u001b[0m(arr.head.value < min_even.value) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value value is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpx9s4dz8b.scala:42:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m                    min_index = i\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    (i : Long @uncheckedVariance)\n\u001b[31m   |\u001b[0m                                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx9s4dz8b.scala:46:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        res = res.append(min_even)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Fou",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_value = arr.head\n        var smallest_index = 0\n        for (i <- arr.tail) {\n            if (arr.head.even()) {\n                if (arr.head.value < smallest_value) {\n                    smallest_value = arr.head.value\n                    smallest_index = i\n                }\n            } else {\n                result = append(result, arr.head)\n            }\n        }\n        result = append(result, smallest_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292662,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu8tsnmso.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m (arr.head.even()) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value even is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu8tsnmso.scala:35:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m (arr.head.value < smallest_value) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value value is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu8tsnmso.scala:36:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    smallest_value = arr.head.value\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     value value is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu8tsnmso.scala:37:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    smallest_index = i\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (i : Long @uncheckedVariance)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpu8tsnmso.scala:40:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                result = append(result, arr.head)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: append\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpu8tsnmso.scala:43:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        result = append(result, smallest_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Not found: append\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n6 ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        var min_even_index = 0\n        for (i <- arr.length - 1) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_even_index = i\n                }\n            } else {\n                if (arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_even_index = i\n                }\n            }\n        }\n        if (min_even_index == 0) {\n            res = List[Long](min_even, min_index)\n        } else {\n            res = List[Long](min_even, min_even_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292661,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbphx5t_6.scala:34:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- arr.length - \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        val res = mutable.List[Long]()\n        if (arr.isEmpty()) {\n            return res\n        }\n        val smalest_value = arr.head()\n        val smalest_index = arr.indexOf(smalest_value)\n        for (i <- arr.tail()) {\n            if (i % 2 == 0) {\n                if (i < smalest_value) {\n                    smalest_value = i\n                    smalest_index = arr.indexOf(i)\n                }\n            }\n        }\n        res.append(smalest_value)\n        res.append(smalest_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292660,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfwatn634.scala:30:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfwatn634.scala:31:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfwatn634.scala:34:32 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msmalest_value\u001b[0m = arr.head()\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               \u001b[33mmethod\u001b[0m \u001b[35mhead\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpfwatn634.scala:36:26 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- arr.tail()) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): Long @uncheckedVariance\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = Long.MAX_VALUE\n        var min_index = 0\n        for(i <- 0 until arr.length) {\n            if(arr[i] % 2 == 0) {\n                if(arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        if(min_even == Long.MAX_VALUE) {\n            return result\n        }\n        result = List[Long](min_even, min_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292662,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7gypj9it.scala:31:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = Long.MAX_VALUE\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value MAX_VALUE is not a member of object Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7gypj9it.scala:34:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m(arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7gypj9it.scala:35:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m(arr[\u001b[35mi\u001b[0m] < min_even) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7gypj9it.scala:36:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]().toLong\n        var min_index = -1\n        var min_value = -1\n        for (i <- 0 until arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (min_value == -1) {\n                    min_value = arr[i]\n                    min_index = i\n                } else if (arr[i] < min_value) {\n                    min_value = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        if (min_value == -1) {\n            return res\n        } else {\n            return res.update(min_index).update(min_value)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292662,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp57ac0c9i.scala:30:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mres\u001b[0m = List[\u001b[35mLong\u001b[0m]().toLong\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toLong is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp57ac0c9i.scala:34:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp57ac0c9i.scala:36:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    min_value = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp57ac0c9i.scala:38:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (arr[i] < min_value) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp57ac0c9i.scala:39:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                    min_value = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                     ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = arr.head\n        var min_index = 0\n        for (i <- arr.tail) {\n            if (i % 2 == 0) {\n                if (i < min_even) {\n                    min_even = i\n                    min_index = arr.indexOf(i)\n                }\n            }\n        }\n        res = List[Long](min_even, min_index)\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292663,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpae6uztmr.scala:46)\n\tat Problem.main(tmpae6uztmr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var smallest_value = arr.head\n        var smallest_index = 0\n        var i = 0\n        while(i < arr.size) {\n            if(arr.apply(i).toLong % 2 == 0) {\n                if(arr.apply(i).toLong < smallest_value) {\n                    smallest_value = arr.apply(i).toLong\n                    smallest_index = i\n                }\n            }\n            i = i + 1\n        }\n        result = result.append(smallest_value)\n        result = result.append(smallest_index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292662,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnmntrok_.scala:43:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        result = result.append(smallest_value)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnmntrok_.scala:44:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        result = result.append(smallest_index)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        if (arr.isEmpty()) return arr\n        val smallest_value = arr.head()\n        val smallest_index = 0\n        for (i <- arr.tail()) {\n            if (i % 2 == 0) {\n                if (i < smallest_value) {\n                    smallest_value = i\n                    smallest_index = arr.indexOf(i)\n                }\n            }\n        }\n        return arr.take(smallest_index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292661,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpl7ezxfi5.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mif\u001b[0m (arr.isEmpty()) \u001b[33mreturn\u001b[0m arr\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpl7ezxfi5.scala:31:33 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msmallest_value\u001b[0m = arr.head()\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               \u001b[33mmethod\u001b[0m \u001b[35mhead\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpl7ezxfi5.scala:33:26 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- arr.tail()) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): Long @uncheckedVariance\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var result = List[Long]()\n        var min_even = Long.MAX_VALUE\n        var min_index = 0\n        var min_value = Long.MAX_VALUE\n        for (i <- 0 until arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        if (min_even == Long.MAX_VALUE) {\n            result = List[Long](arr)\n        } else {\n            result = List[Long](min_even, min_index)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292663,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpavno0r2l.scala:31:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = Long.MAX_VALUE\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value MAX_VALUE is not a member of object Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpavno0r2l.scala:33:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_value\u001b[0m = Long.MAX_VALUE\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value MAX_VALUE is not a member of object Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpavno0r2l.scala:35:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpavno0r2l.scala:36:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < min_even) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpavno0r2l.scala:37:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpavno0r2l.scala:43:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m            result = List[\u001b[35mLong\u001b[0m](arr)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    (arr : List[Long])\n\u001b[31m   |\u001b[0m                    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // \"Given a list representing a branch of a tree that has non-negative integer nodes\n    // your task is to pluck one of the nodes and return it.\n    // The plucked node should be the node with the smallest even value.\n    // If multiple nodes with the same smallest even value are found return the node that has smallest index.\n    // The plucked node should be returned in a list, [ smalest_value, its index ],\n    // If there are no even values or the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong, 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two zeros,\n    // so we will choose the first zero, which has the smallest index.\n    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr : List[Long]) : List[Long] = {\n        var res = List[Long]()\n        var min_even = Long.MAX_VALUE\n        var min_index = -1\n        for (i <- 0 until arr.length) {\n            if (arr[i] % 2 == 0) {\n                if (arr[i] < min_even) {\n                    min_even = arr[i]\n                    min_index = i\n                }\n            }\n        }\n        if (min_index == -1) {\n            return res\n        } else {\n            res = List[Long](min_even, min_index)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong, 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong, 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n    }\n\n}\n",
      "timestamp": 1664292662,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcx6w8bwi.scala:31:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmin_even\u001b[0m = Long.MAX_VALUE\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value MAX_VALUE is not a member of object Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcx6w8bwi.scala:34:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcx6w8bwi.scala:35:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mif\u001b[0m (arr[\u001b[35mi\u001b[0m] < min_even) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcx6w8bwi.scala:36:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    min_even = arr[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}