name: HumanEval_58_common
language: r
prompt: "# Return sorted unique common elements for two lists.\ncommon <- function(l1,\
  \ l2) {"
tests: "test_humaneval <- function() {\ncandidate <- common\n    if(!identical(candidate(c(1,\
  \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121)), list(1, 5, 653))){quit('no',\
  \ 1)}\n    if(!identical(candidate(c(5, 3, 2, 8), c(3, 2)), list(2, 3))){quit('no',\
  \ 1)}\n    if(!identical(candidate(c(4, 3, 2, 8), c(3, 2, 4)), list(2, 3, 4))){quit('no',\
  \ 1)}\n    if(!identical(candidate(c(4, 3, 2, 8), c()), list())){quit('no', 1)}\n\
  }\ntest_humaneval()"
completions: ["\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work if there are repeated\
    \ elements in the lists.\n<|/ c |>\n<| c |>\nI guess I misunderstood the question.\
    \ I'll edit my answer.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,dataframe,list\
    \ |>\n<| c |>\nThanks so much! This was really helpful.\n<|/ c |>\n<| a tags=r,dataframe,list\
    \ |>\nYou can use the following function to get common elements from two lists:\n\
    <code>", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like your solution, but I wonder if\
    \ there is a way to avoid the sorting step. I mean, is there a way to get the\
    \ unique elements without sorting?\n<|/ c |>\n<| c |>\nYes, you can do `u1 <-\
    \ unique(c(l1, l2))`\n<|/ c |>\n<| c |>\nThanks, I didn't know that `unique` could\
    \ take multiple vectors.\n<|/ c |>\n<| a tags=r,unique,sorting |>\nHere's a solution\
    \ using data.table:\n<code>\nlibrary(data.table)\nsetDT(df)\ndf[, uid := .I]\n\
    df[, uid := .I]\ndf[, uid := .I]\ndf[, uid := .I]\ndf[, uid := .I]\ndf[, uid :=\
    \ .I]\ndf[, uid := .I]\ndf[, uid := .I]\ndf[, uid := .I]\ndf[, uid := .I]\ndf[,\
    \ uid := .I]\ndf[, uid := .I]\ndf[, uid := .I]\ndf[, uid := .I]\ndf[, uid := .I]\n\
    df[, uid := .I]\ndf[, uid := .I]\ndf[, uid := .I]\ndf[, uid := .I]\ndf[, uid :=\
    \ .I]\ndf[, uid := .I]\ndf[, uid := .I]\ndf[, uid := .I]\ndf[, uid := .I]\ndf[,\
    \ uid := .I]\ndf[, uid := .I]\ndf[, uid := .I]\ndf[, uid := .I]\ndf[, uid := .I]\n\
    df[, uid := .I]\ndf[, uid := .I]\ndf[, uid := .I]\ndf[, uid := .I]\ndf[, uid :=\
    \ .I]\ndf[, uid := .I]\ndf[, uid := .I]\ndf[, uid := .I]\ndf[, uid := .I]\ndf[,\
    \ uid := .I]\ndf[, u", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u1 == u2]\n\
    }\n</code>\n<|/ a tags=r,dataframe |>\n<| c |>\nThanks for your answer! I forgot\
    \ to mention that I need the common elements to be in order. For example, if I\
    \ have two lists such as `list1 = c(\"a\",\"b\",\"c\",\"d\",\"e\")` and `list2\
    \ = c(\"a\",\"b\",\"c\",\"e\",\"f\")`, then the output should be `c(\"a\",\"b\"\
    ,\"e\",\"f\")`\n<|/ c |>\n<| c |>\nI edited my answer to include a function that\
    \ will do what you want. Let me know if that works for you.\n<|/ c |>\n<| c |>\n\
    Thanks for your answer! I forgot to mention that I need the common elements to\
    \ be in order. For example, if I have two lists such as `list1 = c(\"a\",\"b\"\
    ,\"c\",\"d\",\"e\")` and `list2 = c(\"a\",\"b\",\"c\",\"e\",\"f\")`, then the\
    \ output should be `c(\"a\",\"b\",\"e\",\"f\")`\n<|/ c |>\n<| c |>\nI edited my\
    \ answer to include a function that will do what you want. Let me know if that\
    \ works for you.\n<|/ c |>\n<| c |>\nThanks for your answer! I forgot to mention\
    \ that I need the common elements to be in order. For example, if I have two lists\
    \ such as `list1 = c(\"a\",\"b\",\"c\",\"d\",\"e\")` and `list2 = c(\"a\",\"b\"\
    ,\"c\",\"e\",\"f\")`, then the output should be `c(\"a\",\"b\",\"e\",\"f\")`\n\
    <|/ c |>\n<| a |>\nWe can use intersect from dplyr\n<code>\nlibrary(dplyr)\nintersect(list1,\
    \ list2)\n</code>\n<|/ a tags=r,dataframe dscore=0 |>\n<| c |>\nThanks for your\
    \ answer! I forgot to mention that I need the common elements to be in order.\
    \ For example, if I have two lists such as `list1 = c(\"a\",\"b\",\"c\",\"d\"\
    ,\"e\")` and `list2 = c(\"a\",\"b\",\"c\",\"e\",\"f\")`, then the output should\
    \ be `c(\"a\",\"b\",\"e\",\"f\")`\n<|/ c |>\n<| a tags=r,dataframe |>\nYou can\
    \ try the code below\n<code>\nlist1 <- c(\"a\",\"b\",\"c\",\"d\",\"e\")\nlist2\
    \ <- c", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThanks for your answer! I actually\
    \ tried this before but for some reason it didn't work. Maybe I did something\
    \ wrong. Anyway, I decided to use your method and I got it working now. Thanks\
    \ again!\n<|/ c |>\n<| c |>\nHappy to help! If this answer or any other one solved\
    \ your issue, please mark it as accepted.\n<|/ c |>\n<| a |>\n<code>\nlibrary(dplyr)\n\
    library(tidyr)\nlibrary(stringr)\nlibrary(purrr)\n\ndf %>% \n  mutate(id = row_number())\
    \ %>% \n  pivot_longer(cols = -id, names_to = \"col\") %>% \n  filter(str_detect(col,\
    \ \"^A\")) %>% \n  group_by(id) %>% \n  summarise(value = paste(sort(value), collapse\
    \ = \",\")) %>% \n  select(-id)\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like this answer because\
    \ it doesn't require a package. Nice work!\n<|/ c |>\n<| c |>\nI like this answer\
    \ because it doesn't require a package. Nice work!\n<|/ c |>\n<| a tags=r,unique,list\
    \ |>\nHere's a solution using base R:\n<code>", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nThis doesn't seem to work. `common(list(c(\"a\", \"b\", \"c\"), c(\"a\"\
    , \"b\", \"c\")), list(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\")))` returns\
    \ `c(\"a\", \"b\", \"c\")`, which is not what OP wants.\n<|/ c |>\n<| c |>\nI\
    \ see what you mean. I've edited my answer to account for this.\n<|/ c |>\n<|\
    \ c |>\nThanks for your answer. Your code works, but it takes too much time for\
    \ my dataset. My dataset has more than 1 million rows and more than 1 million\
    \ columns. I wonder if there is a faster way to do this task.\n<|/ c |>\n<| c\
    \ |>\nI added a faster method using `data.table`\n<|/ c |>\n<| a dscore=1 |>\n\
    Here's a data.table solution:\n<code>\nlibrary(data.table)\ndt <- data.table(list(c(\"\
    a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\")))\ndt[, common := sort(unique(c(...))),\
    \ by = 1:nrow(dt)]\ndt", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,dataframe,list |>\n<| c |>\nThanks for\
    \ your answer! I edited my question to clarify what I'm looking for. Your answer\
    \ doesn't seem to work if there are repeated elements in the lists.\n<|/ c |>\n\
    <| c |>\nI edited my answer to include a function that will do what you want.\n\
    <|/ c |>\n<| c |>\nThanks for your answer! I edited my question to clarify what\
    \ I'm looking for. Your answer doesn't seem to work if there are repeated elements\
    \ in the lists.\n<|/ c |>\n<| c |>\nI edited my answer to include a function that\
    \ will do what you want.\n<|/ c |>\n<| a dscore=0 |>\nYou can try the code below\n\
    <code>\nlibrary(dplyr)\nlibrary(purrr)\n\ndf <- data.frame(\n  a = c(\"a\", \"\
    b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"\
    m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"\
    x\", \"y\", \"z\"),\n  b = c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\",\
    \ \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\"\
    , \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"),\n  c = c(\"a\", \"\
    b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"\
    m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"\
    x\", \"y\", \"z\"),\n  d = c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\",\
    \ \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\"\
    , \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"),\n  e = c(\"a\", \"\
    b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"\
    m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"\
    x\", \"y\", \"z\"),\n  f = c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\",\
    \ \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\"\
    , \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"),\n  g = c(\"a\", \"\
    b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"\
    m\", \"", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis doesn't work if there are repeated elements in\
    \ `l1` or `l2`.\n<|/ c |>\n<| c |>\nIt does work if there are repeated elements.\
    \ Try it with `l1 <- c(\"a\", \"a\", \"b\", \"c\", \"c\"); l2 <- c(\"a\", \"b\"\
    , \"c\", \"d\", \"e\")`.\n<|/ c |>\n<| c |>\nYes, it does. I didn't realize that\
    \ `unique` was being used on `l1` and `l2` separately. Thanks for pointing that\
    \ out.\n<|/ c |>\n<| a dscore=1 |>\nHere's a solution using data.table:\n<code>\n\
    library(data.table)\nsetDT(df)\ndf[, common := unique(c(l1, l2))]\n</code>\n<|/\
    \ a tags=r,unique,list |>\n<| a tags=r,unique,list |>\nAnother option:\n<code>\n\
    x <- c(\"a\", \"b\", \"c\", \"d\")\ny <- c(\"a\", \"b\", \"c\", \"d\")\nx <- unique(x)\n\
    y <- unique(y)\nx <- c(x, y)\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\nx <-\
    \ c(\"a\", \"b\", \"c\", \"d\")\ny <- c(\"a\", \"b\", \"c\", \"d\")\nx <- unique(x)\n\
    y <- unique(y)\nx <- c(x, y)\n</code>\n<|/ a tags=r,unique,list dscore=0 |>\n\
    <| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding why and/or how this code answers the question improves its long-term\
    \ value.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nx <- c(\"a\", \"b\", \"c\", \"d\"\
    )\ny <- c(\"a\", \"b\", \"c\", \"d\")\nx <- unique(x)\ny <- unique(y)\nx <- c(x,\
    \ y)\n</code>\n<|/ a tags=r,unique,list |>\n<| c |>\nWhile this code may answer\
    \ the question, providing additional context regarding why and/or how this code\
    \ answers the question improves its long-term value.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>\nx <- c(\"a\", \"b\", \"c\", \"d\")\ny <- c(\"a\", \"b\", \"c\",\
    \ \"d\")\nx <- unique(x)\ny <- unique(y)\nx <- c(x, y)\n</code>\n<|/ a tags=r,unique,list\
    \ |>\n<| c |>\nWhile this code may answer the question, ", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nThanks for your answer. I'm sorry I didn't specify this in my question,\
    \ but I actually want to keep the order of the lists. I edited my question to\
    \ reflect this.\n<|/ c |>\n<| c |>\nI edited my answer to include a function that\
    \ will do what you want.\n<|/ c |>\n<| c |>\nThanks for your answer. I'm sorry\
    \ I didn't specify this in my question, but I actually want to keep the order\
    \ of the lists. I edited my question to reflect this.\n<|/ c |>\n<| c |>\nI edited\
    \ my answer to include a function that will do what you want.\n<|/ c |>\n<| c\
    \ |>\nThanks for your answer. I'm sorry I didn't specify this in my question,\
    \ but I actually want to keep the order of the lists. I edited my question to\
    \ reflect this.\n<|/ c |>\n<| a dscore=1 |>\nYou can use the following function\
    \ to get the common elements from two lists:\n<code>\nlibrary(dplyr)\n\ncommon_elements\
    \ <- function(list1, list2) {\n  list1 %>% \n    intersect(list2) %>% \n    sort()\
    \ %>% \n    unique()\n}\n</code>\n<|/ a tags=list,r,sorting |>\n<| c |>\nThanks\
    \ for your answer. I'm sorry I didn't specify this in my question, but I actually\
    \ want to keep the order of the lists. I edited my question to reflect this.\n\
    <|/ c |>\n<| a dscore=1 |>\nA base R option with intersect\n<code>\ncommon_elements\
    \ <- function(list1, list2) {\n  list1 <- sort(unique(list1))\n  list2 <- sort(unique(list2))\n\
    \  list1[intersect(list1, list2)]\n}\n\ncommon_elements(list1, list2)", "\n  u1\
    \ <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a tags=r |>\n<| c |>\nThanks so much for the help! I really appreciate it!\n\
    <|/ c |>\n<| c |>\nNo problem. Glad I could help.\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u1 == u2]\n}\n", "\n\
    \  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r\
    \ |>\n<| c |>\nThanks so much for the help! I really appreciate it!\n<|/ c |>\n\
    <| c |>\nNo problem! If this answer solved your problem, please consider marking\
    \ it as accepted by clicking the check mark next to the answer. Thanks!\n<|/ c\
    \ |>\n<| c |>\nHi again, sorry for the late reply. I've been trying to implement\
    \ this into my code but I'm having trouble with it. I've tried using it in a for\
    \ loop and it just gives me the original data frame with all the rows duplicated\
    \ and all the columns duplicated. I've tried using it in a function and just get\
    \ an error saying \"object 'x' not found\". Any ideas?\n<|/ c |>\n<| c |>\nHi\
    \ again, sorry for the late reply. I've been trying to implement this into my\
    \ code but I'm having trouble with it. I've tried using it in a for loop and it\
    \ just gives me the original data frame with all the rows duplicated and all the\
    \ columns duplicated. I've tried using it in a function and just get an error\
    \ saying \"object 'x' not found\". Any ideas?\n<|/ c |>\n<| c |>\nHi again, sorry\
    \ for the late reply. I've been trying to implement this into my code but I'm\
    \ having trouble with it. I've tried using it in a for loop and it just gives\
    \ me the original data frame with all the rows duplicated and all the columns\
    \ duplicated. I've tried using it in a function and just get an error saying \"\
    object 'x' not found\". Any ideas?\n<|/ c |>\n<| a dscore=0 |>\n<code>\nlibrary(dplyr)\n\
    library(tidyr)\nlibrary(purrr)\n\ndf <- data.frame(\n  id = c(\"a\", \"b\", \"\
    c\", \"d\"),\n  x = c(1, 2, 3, 4),\n  y = c(1, 2, 3, 4),\n  z = c(1, 2, 3, 4)\n\
    )\n\ndf %>%\n  gather(key, value, -id) %>%\n  group_by(id) %>%\n  summarise(value\
    \ = list(value[order(value)]))\n</code>\n<|/ a tags=r |>\n<| c |>\nHi again, sorry\
    \ for the late reply. I've been trying to implement this into my code but I'm\
    \ having trouble with it. I've tried using it in a for loop and it just gives\
    \ me the original data frame with all the rows duplicated ", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThis doesn't work if there are duplicates in the list. For example, `common(list(c(1,2,3),\
    \ c(1,2,3)), list(c(1,2,3), c(1,2,3)))` returns `[1]  1  2  3`\n<|/ c |>\n<| c\
    \ |>\nYes, I noticed that and fixed it.  Thanks for pointing it out.\n<|/ c |>\n\
    <| a tags=r |>\nHere is a base R solution:\n<code>\ncommon <- function(l1, l2)\
    \ {\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\nA solution using dplyr and purrr packages:\n\
    <code>\nlibrary(dplyr)\nlibrary(purrr)\n\ncommon <- function(l1, l2) {\n  l1 %>%\
    \ \n    sort() %>% \n    unique() %>% \n    intersect(l2 %>% \n              \
    \  sort() %>% \n                unique())\n}\n</code>\n<|/ a tags=r |>\n<| a dscore=0\
    \ |>\nHere is a base R solution:\n<code>\ncommon <- function(l1, l2) {\n  u1 <-\
    \ sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/\
    \ a tags=r |>\n<| a dscore=0 |>\nHere is a solution using data.table:\n<code>\n\
    library(data.table)\ncommon <- function(l1, l2) {\n  setDT(l1)\n  setDT(l2)\n\
    \  setkey(l1, V1)\n  setkey(l2, V1)\n  l1[l2]\n}\n</code>\n<|/ a tags=r |>\n<|\
    \ a dscore=0 |>\nA solution using dplyr and purrr packages:\n<code>\nlibrary(dplyr)\n\
    library(purrr)\n\ncommon <- function(l1, l2) {\n  l1 %>% \n    sort() %>% \n \
    \   unique() %>% \n    intersect(l2 %>% \n                sort() %>% \n      \
    \          unique())\n}\n</code>\n<|/ a tags=r |>\n<| a dscore=0 |>\nHere is a\
    \ solution using data.table:\n<code>\nlibrary(data.", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a |>\n<| c |>\nI like\
    \ the idea of using setdiff, but I get the following error when I try to use it:\
    \ Error in setdiff(l1, l2) : \n  the difference is not atomic and cannot be ordered\n\
    <|/ c |>\n<| c |>\nI added a version that uses `setdiff` which should work\n<|/\
    \ c |>\n<| c |>\nThanks so much! I ended up using the setdiff version you posted\
    \ and that worked perfectly. Thanks again!\n<|/ c |>\n<| c |>\nI added a version\
    \ using `setdiff` which should work\n<|/ c |>\n<| a dscore=0 |>\nI like to use\
    \ data.table for these kind of things. \n<code>\nlibrary(data.table)\ndt <- data.table(a\
    \ = c(1,2,3,4,5,6,7,8,9), b = c(1,2,3,4,5,6,7,8,9))\ndt[,c(\"a\",\"b\") := .SD[!.SD,.SDcols\
    \ = c(\"a\",\"b\")]]\n</code>\n<|/ a tags=r,subset,list |>\n<| c |>\nThanks for\
    \ the suggestion! I get the following error when I try to use it: Error in setdiff(l1,\
    \ l2) : \n  the difference is not atomic and cannot be ordered\n<|/ c |>\n<| c\
    \ |>\nI added a version using `setdiff` which should work\n<|/ c |>\n<| a dscore=0\
    \ |>\nI like to use dplyr for these kind of things. \n<code>\nlibrary(dplyr)\n\
    df <- data.frame(a = c(1,2,3,4,5,6,7,8,9), b = c(1,2,3,4,5,6,7,8,9))\ndf %>% \n\
    \  mutate(c = setdiff(a, b))\n</code>\n<|/ a tags=r,subset,list |>\n<| c |>\n\
    Thanks for the suggestion! I get the following error when I try to use it: Error\
    \ in setdiff(l1, l2) : \n  the difference is not atomic and cannot be ordered\n\
    <|/ c |>\n<| c |>\nI added a version using `setdiff` which should work\n<|/ c\
    \ |>\n<| a tags=r,subset,list |>\nHere's a base R option:\n<code>\nx <- list(a\
    \ = c(1,2,3,4,5,6,7,8,9), b = c(1,2,3,4,5,6,7,8,9))\ny <- list(a = c(1,2,3,4,5,6,",
  "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=3 |>\n<| c\
    \ |>\nI like this solution, but I wonder if there is a way to avoid the sorting\
    \ step. I wonder if there is a way to do this without sorting the lists.\n<|/\
    \ c |>\n<| c |>\nYes, there is. See my answer for a solution that does not require\
    \ sorting.\n<|/ c |>\n<| a tags=r,sorting,list |>\nHere's a solution using data.table:\n\
    <code>\nlibrary(data.table)\ndt <- data.table(a = c(1,2,3), b = c(4,5,6))\ndt[,\
    \ setdiff(names(dt), c(\"a\", \"b\")), with = FALSE]\n</code>\n<|/ a dscore=3\
    \ |>\n<| a tags=r,sorting,list |>\nHere's a solution using base R:\n<code>", "\n\
    \  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n\
    \  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a tags=r,dataframe |>\n<| c |>\nThanks for your answer. Unfortunately, I cannot\
    \ use your solution because I do not know which columns are common to both dataframes.\
    \ I only know that they have common elements. I edited my question to make it\
    \ clearer.\n<|/ c |>\n<| c |>\nI edited my answer to include a function that will\
    \ find common elements for two dataframes.\n<|/ c |>\n<| c |>\nThanks for your\
    \ answer. Unfortunately, I cannot use your solution because I do not know which\
    \ columns are common to both dataframes. I only know that they have common elements.\
    \ I edited my question to make it clearer.\n<|/ c |>\n<| c |>\nI edited my answer\
    \ to include a function that will find common elements for two dataframes.\n<|/\
    \ c |>\n<| c |>\nThanks for your answer. Unfortunately, I cannot use your solution\
    \ because I do not know which columns are common to both dataframes. I only know\
    \ that they have common elements. I edited my question to make it clearer.\n<|/\
    \ c |>\n<| a tags=r,dataframe |>\n<code>\nlibrary(dplyr)\nlibrary(purrr)\nlibrary(stringr)\n\
    \ndf1 <- data.frame(\n  a = c(\"a\", \"b\", \"c\", \"d\"),\n  b = c(\"a\", \"\
    b\", \"c\", \"d\"),\n  c = c(\"a\", \"b\", \"c\", \"d\"),\n  d = c(\"a\", \"b\"\
    , \"c\", \"d\"),\n  e = c(\"a\", \"b\", \"c\", \"d\"),\n  f = c(\"a\", \"b\",\
    \ \"c\", \"d\"),\n  g = c(\"a\", \"b\", \"c\", \"d\"),\n  h = c(\"a\", \"b\",\
    \ \"c\", \"d\"),\n  i = c(\"a\", \"b\", \"c\", \"d\"),\n  j = c(\"a\", \"b\",\
    \ \"c\", \"d\"),\n  k = c(\"a\", \"b\", \"c\", \"d\"),\n  l = c(\"a\", \"b\",\
    \ \"c\", \"d\"),\n  m = c(\"a\", \"b\", \"c\", \"d\"),\n  n = c(\"a\", \"b\",\
    \ \"c\", \"d\"),\n  o = c(\"a\", \"b\", \"c\", \"d\"),\n  p = c(\"a\", \"b\",\
    \ \"c\", \"d\"),\n  q = c(\"a\", \"b\", \"c\", \"d\"),\n  r = c(\"a\", \"b\",\
    \ \"c\", \"d\"),\n  s = c(\"a\", \"b\", \"c\", \"d\"),\n  t = c(\"a\", \"b\",\
    \ \"c\", \"d\"),\n  u = c(\"a\", \"b\", \"c\", \"d\"),\n  v = c(\"a\", \"b\",\
    \ \"c\", \"d\"),\n  w = c(\"a\", \"", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if\
    \ there are repeated elements in the lists. For example, `common <- function(l1,\
    \ l2) {\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }`\n<|/ c |>\n<| c |>\nYes, it does. Try it with `common <- function(l1, l2) {\n\
    \  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n\n> common(c(1,2,2,3),\
    \ c(1,2,2,3))\n[1] 1 2 3`\n<|/ c |>\n<| c |>\nYes, it does. Try it with `common\
    \ <- function(l1, l2) {\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n\n> common(c(1,2,2,3), c(1,2,2,3))\n[1] 1 2 3`\n<|/ c |>\n\
    <| c |>\nYes, it does. Try it with `common <- function(l1, l2) {\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n\n> common(c(1,2,2,3), c(1,2,2,3))\n\
    [1] 1 2 3`\n<|/ c |>\n<| c |>\nYes, it does. Try it with `common <- function(l1,\
    \ l2) {\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n\n> common(c(1,2,2,3), c(1,2,2,3))\n[1] 1 2 3`\n<|/ c |>\n<| a tags=r,list\
    \ |>\n<code>\n> x <- list(1,2,3)\n> y <- list(1,2,3)\n> x\n[[1]]\n[1] 1\n\n[[2]]\n\
    [1] 2\n\n[[3]]\n[1] 3\n\n> y\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n\n\
    > x <- list(1,2,3)\n> y <- list(1,2,3)\n> x\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n\
    [[3]]\n[1] 3\n\n> y\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=3 |>\n<| c\
    \ |>\nThis doesn't seem to work if there are repeated elements in the lists. For\
    \ example, `common(list(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\")), list(c(\"\
    a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\")))` returns `c(\"a\", \"b\", \"c\")`\
    \ instead of `c(\"a\", \"b\", \"c\", \"a\", \"b\", \"c\")`.\n<|/ c |>\n<| c |>\n\
    I added a fix for that case.\n<|/ c |>\n<| c |>\nThis doesn't seem to work if\
    \ there are repeated elements in the lists. For example, `common(list(c(\"a\"\
    , \"b\", \"c\"), c(\"a\", \"b\", \"c\")), list(c(\"a\", \"b\", \"c\"), c(\"a\"\
    , \"b\", \"c\")))` returns `c(\"a\", \"b\", \"c\")` instead of `c(\"a\", \"b\"\
    , \"c\", \"a\", \"b\", \"c\")`.\n<|/ c |>\n<| c |>\nI added a fix for that case.\n\
    <|/ c |>\n<| c |>\nThis doesn't seem to work if there are repeated elements in\
    \ the lists. For example, `common(list(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\"\
    , \"c\")), list(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\")))` returns `c(\"\
    a\", \"b\", \"c\")` instead of `c(\"a\", \"b\", \"c\", \"a\", \"b\", \"c\")`.\n\
    <|/ c |>\n<| a dscore=2 |>\nA simple and efficient solution is to use setdiff\
    \ and intersect from base R:\n<code>\nsetdiff(list1, list2)\nintersect(list1,\
    \ list2)\n</code>\n<|/ a tags=r,list |>\n<| c |>\nThis doesn't seem to work if\
    \ there are repeated elements in the lists. For example, `setdiff(list1, list2)`\
    \ returns `list2` instead of `list1`.\n<|/ c |>\n<| c |>\nI added a fix for that\
    \ case.\n<|/ c |>\n<| a tags=r,list |>\n<code>\nlist1 <- list(c(\"a\", \"b\",\
    \ \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"))\nlist2 <- list(c(\"\
    a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"))\nlist3 <-\
    \ list(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"))\n\
    list4 <- list(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\",\
    \ \"c\"))\nlist5 <- list", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThis doesn't seem to work\
    \ if there are duplicates in either of the lists. For example, `common(c(\"a\"\
    , \"b\", \"c\"), c(\"a\", \"b\", \"c\", \"d\"))` returns `c(\"a\", \"b\", \"c\"\
    , \"d\")` instead of `c(\"a\", \"b\", \"c\")`.\n<|/ c |>\n<| c |>\nYes, I realized\
    \ that after I posted my comment. I've updated my answer to account for that.\n\
    <|/ c |>\n<| a tags=r |>\nThis should work:\n<code>\ncommon<-function(l1,l2){\n\
    \  u1<-sort(unique(l1))\n  u2<-sort(unique(l2))\n  u1[u1==u2]\n}\n</code>\n<|/\
    \ a dscore=4 |>\n<| a dscore=4 |>\nThe function below will return the common elements\
    \ from two lists.\n<code>\ncommon<-function(l1,l2){\n  u1<-sort(unique(l1))\n\
    \  u2<-sort(unique(l2))\n  u1[u1==u2]\n}\n</code>\n<|/ a tags=r |>\n<| a tags=r\
    \ |>\n<code>\ncommon<-function(l1,l2){\n  u1<-sort(unique(l1))\n  u2<-sort(unique(l2))\n\
    \  u1[u1==u2]\n}\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\n<code>\ncommon<-function(l1,l2){\n\
    \  u1<-sort(unique(l1))\n  u2<-sort(unique(l2))\n  u1[u1==u2]\n}\n</code>\n<|/\
    \ a tags=r |>\n<| a tags=r |>\n<code>\ncommon<-function(l1,l2){\n  u1<-sort(unique(l1))\n\
    \  u2<-sort(unique(l2))\n  u1[u1==u2]\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=r\
    \ |>\n<code>\ncommon<-function(l1,l2){\n  u1<-sort(unique(l1))\n  u2<-sort(unique(l2))\n\
    \  u1[u1==u2]\n}\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\n", "\n  u1 <-\
    \ sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/\
    \ a tags=r,sorting |>\n<| c |>\nThis doesn't seem to work if there are duplicates\
    \ in the lists.\n<|/ c |>\n<| c |>\nIt does work. Try it with `x <- c(\"a\", \"\
    b\", \"c\", \"a\", \"b\", \"c\")` and `y <- c(\"a\", \"b\", \"c\", \"a\", \"b\"\
    , \"c\")`\n<|/ c |>\n<| c |>\nYes, it does. I tested it with `x <- c(\"a\", \"\
    b\", \"c\", \"a\", \"b\", \"c\"); y <- c(\"a\", \"b\", \"c\", \"a\", \"b\", \"\
    c\")` and it returns `[1] \"a\" \"b\" \"c\"`.\n<|/ c |>\n<| c |>\nYes, it does\
    \ work. Try it with `x <- c(\"a\", \"b\", \"c\", \"a\", \"b\", \"c\"); y <- c(\"\
    a\", \"b\", \"c\", \"a\", \"b\", \"c\")` and it returns `[1] \"a\" \"b\" \"c\"\
    `.\n<|/ c |>\n<| c |>\nYes, it does work. Try it with `x <- c(\"a\", \"b\", \"\
    c\", \"a\", \"b\", \"c\"); y <- c(\"a\", \"b\", \"c\", \"a\", \"b\", \"c\")` and\
    \ it returns `[1] \"a\" \"b\" \"c\"`.\n<|/ c |>\n<| a dscore=4 |>\nThe function\
    \ below will return the unique elements of a vector that appear in another vector.\
    \ \n<code>\nunique.in.vector <- function(x, vec) {\n  ux <- sort(unique(x))\n\
    \  uvec <- sort(unique(vec))\n  ux[uvec == ux]\n}\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| c |>\nThis doesn't seem to work if there are duplicates in the lists.\n\
    <|/ c |>\n<| c |>\nThis doesn't seem to work if there are duplicates in the lists.\n\
    <|/ c |>\n<| a dscore=4 |>\n<code>\nunique.in.vector <- function(x, vec) {\n \
    \ ux <- sort(unique(x))\n  uvec <- sort(unique(vec))\n  ux[uvec == ux]\n}\n</code>\n\
    <|/ a tags=r,sorting |>\n<| c |>\nThis doesn't seem to work if there are duplicates\
    \ in the lists.\n<|/ c |>\n<| c |>\nThis doesn't seem to work if there are duplicates\
    \ in the lists.\n<|/ c |>\n<| a tags=r,sorting |>\n<code>\nunique.in.vector <-\
    \ function(x, vec) {\n  ux <- sort(unique(x))\n  uve", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=r |>\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\ndf %>%\n  mutate(id = row_number())\
    \ %>%\n  split(.$id) %>%\n  map(~.x %>%\n        mutate(id = row_number()) %>%\n\
    \        split(.$id) %>%\n        map(~.x %>%\n              mutate(id = row_number())\
    \ %>%\n              split(.$id) %>%\n              map(~.x %>%\n            \
    \        mutate(id = row_number()) %>%\n                    split(.$id) %>%\n\
    \                    map(~.x %>%\n                          mutate(id = row_number())\
    \ %>%\n                          split(.$id) %>%\n                          map(~.x\
    \ %>%\n                                mutate(id = row_number()) %>%\n       \
    \                         split(.$id) %>%\n                                map(~.x\
    \ %>%\n                                      mutate(id = row_number()) %>%\n \
    \                                     split(.$id) %>%\n                      \
    \                map(~.x %>%\n                                            mutate(id\
    \ = row_number()) %>%\n                                            split(.$id)\
    \ %>%\n                                            map(~.x %>%\n             \
    \                                     mutate(id = row_number()) %>%\n        \
    \                                          split(.$id) %>%\n                 \
    \                                 map(~.x %>%\n                              \
    \                          mutate(id = row_number()) %>%\n                   \
    \                                     split(.$id) %>%\n                      \
    \                                  map(~.x %>%\n                             \
    \                                 mutate(id = row_number()) %>%\n            \
    \                                                  split(.$id) %>%\n         \
    \                                                     map(~.x %>%\n          \
    \                                                          mutate(id = row_number())\
    \ %>%\n                                                                    split(.$id)\
    \ %>%\n                                                                    map(~.x\
    \ %>%\n                                                                      \
    \    mutate(id = row_number()) %>%\n                                         \
    \                                 split(.$id) %>%\n                          \
    \                                                map(~.x %>%\n               \
    \                                                                 mutate(id =\
    \ row_number()) %>%\n                                                        \
    \                        split(.$id) %>%\n                                   \
    \                                             map(~.x %>%\n                  \
    \                                                                    mutate(id\
    \ = row_number()) %>%\n                                                      \
    \                                split(.$id) %>%\n                           \
    \                                                           map(~.x %>%\n    \
    \                                                                            \
    \            mutate(id = row_number()) %>%\n                                 \
    \                                                           split(.$id) %>%\n\
    \                                                                            \
    \                map(~.x %>%\n                                               \
    \                                                   mut", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- unique(l1)\n  u2 <-\
    \ unique(l2)\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>\nlibrary(dplyr)\n\
    library(purrr)\n\ndf %>%\n  mutate(\n    common_elements = map(\n      list(\n\
    \        element1 = element1,\n        element2 = element2\n      ),\n      ~setNames(\n\
    \        sort(unique(.x)), \n        paste0(\"common_\", names(.x))\n      )\n\
    \    )\n  ) %>%\n  unnest(common_elements)\n</code>\n<|/ a tags=r,dplyr,purrr\
    \ |>\n<| a tags=r,dplyr,purrr |>\nWe can use map2\n<code>\nlibrary(purrr)\nlibrary(dplyr)\n\
    library(stringr)\nmap2(df1$element1, df1$element2, ~ {\n   sort(unique(c(.x, .y)))\n\
    \  }) %>% \n  reduce(union)\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\nlibrary(dplyr)\n\
    library(purrr)\n\ndf %>% \n  mutate(\n    common_elements = map(\n      list(\n\
    \        element1 = element1,\n        element2 = element2\n      ),\n      ~setNames(\n\
    \        sort(unique(.x)), \n        paste0(\"common_\", names(.x))\n      )\n\
    \    )\n  ) %>%\n  unnest(common_elements)\n</code>\n<|/ a tags=r,dplyr,purrr\
    \ dscore=0 |>\n<| a tags=r,dplyr,purrr |>\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\
    \ndf %>% \n  mutate(\n    common_elements = map(\n      list(\n        element1\
    \ = element1,\n        element2 = element2\n      ),\n      ~setNames(\n     \
    \   sort(unique(.x)), \n        paste0(\"common_\", names(.x))\n      )\n    )\n\
    \  ) %>%\n  unnest(common_elements)\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\nUsing base R:\n<code>\ndf$common_elements <- sapply(\n  split(df, 1:nrow(df)),\n\
    \  function(x) sort(unique(c(x$element1, x$element2)))\n)\n</code>\n<|/ a tags=r,dplyr,purrr\
    \ |>\n<| a tags=r,d", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your answer.\
    \ I'm sorry I didn't make it clear enough in my question. I want to know if there\
    \ is a way to do it without using any packages. I edited my question to make it\
    \ clearer.\n<|/ c |>\n<| c |>\nI edited my answer to show you how to do it without\
    \ using any packages.\n<|/ c |>\n<| c |>\nThanks for your answer. I'm sorry I\
    \ didn't make it clear enough in my question. I want to know if there is a way\
    \ to do it without using any packages. I edited my question to make it clearer.\n\
    <|/ c |>\n<| c |>\nI edited my answer to show you how to do it without using any\
    \ packages.\n<|/ c |>\n<| c |>\nThanks for your answer. I'm sorry I didn't make\
    \ it clear enough in my question. I want to know if there is a way to do it without\
    \ using any packages. I edited my question to make it clearer.\n<|/ c |>\n<| a\
    \ tags=r |>\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=5 |>\n<| c\
    \ |>\nI like this answer because it doesn't require installing any packages. I\
    \ wonder if there is a way to do this without installing any packages?\n<|/ c\
    \ |>\n<| c |>\nI like it because it doesn't require installing any packages. I\
    \ wonder if there is a way to do this without installing any packages?\n<|/ c\
    \ |>\n<| c |>\nI like it because it doesn't require installing any packages. I\
    \ wonder if there is a way to do this without installing any packages?\n<|/ c\
    \ |>\n<| c |>\nI like it because it doesn't require installing any packages. I\
    \ wonder if there is a way to do this without installing any packages?\n<|/ c\
    \ |>\n<| c |>\nI like it because it doesn't require installing any packages. I\
    \ wonder if there is a way to do this without installing any packages?\n<|/ c\
    \ |>\n<| a dscore=5 |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    setDT(df)[, setdiff(names(df), names(df1)[df1]), with = FALSE]\n</code>\n<|/ a\
    \ tags=r,dataframe |>\n<| c |>\nThis solution doesn't work if you have columns\
    \ with same name but different types. For example, if your data frame has columns\
    \ \"a\" and \"b\" but you only want to keep columns \"a\" and \"b\" when df1 has\
    \ columns \"a\" and \"c\", then this solution will remove column \"b\" from df1.\n\
    <|/ c |>\n<| c |>\nThis solution doesn't work if you have columns with same name\
    \ but different types. For example, if your data frame has columns \"a\" and \"\
    b\" but you only want to keep columns \"a\" and \"b\" when df1 has columns \"\
    a\" and \"c\", then this solution will remove column \"b\" from df1.\n<|/ c |>\n\
    <| c |>\nThis solution doesn't work if you have columns with same name but different\
    \ types. For example, if your data frame has columns \"a\" and \"b\" but you only\
    \ want to keep columns \"a\" and \"b\" when df1 has columns \"a\" and \"c\", then\
    \ this solution will remove column \"b\" from df1.\n<|/ c |>\n<| c |>\nThis solution\
    \ doesn't work if you have columns with same name but different types. For example,\
    \ if your data frame has columns \"a\" and \"b\" ", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,dataframe,list\
    \ |>\n<| c |>\nThanks for the answer. I am getting an error `Error in sort.list(y)\
    \ : 'x' must be atomic for 'sort.list'\nHave you called 'sort' on a list?`\n<|/\
    \ c |>\n<| c |>\nI added a reproducible example to my original post. Thanks.\n\
    <|/ c |>\n<| c |>\nI added a reproducible example to my original post. Thanks.\n\
    <|/ c |>\n<| c |>\nI added a reproducible example to my original post. Thanks.\n\
    <|/ c |>\n<| c |>\nI added a reproducible example to my original post. Thanks.\n\
    <|/ c |>\n<| a tags=r,dataframe,list |>\nWe can use Reduce with intersect\n<code>\n\
    Reduce(intersect, lst1)", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,dplyr,dataframe |>\n<| c |>\nThanks\
    \ for your answer! I added a reproducible example to my question. Your solution\
    \ doesn't seem to work if there are duplicates in `df2$id`\n<|/ c |>\n<| c |>\n\
    I added a reproducible example to my question. Your solution doesn't seem to work\
    \ if there are duplicates in `df2$id`\n<|/ c |>\n<| c |>\nI added a reproducible\
    \ example to my question. Your solution doesn't seem to work if there are duplicates\
    \ in `df2$id`\n<|/ c |>\n<| c |>\nI added a reproducible example to my question.\
    \ Your solution doesn't seem to work if there are duplicates in `df2$id`\n<|/\
    \ c |>\n<| c |>\nI added a reproducible example to my question. Your solution\
    \ doesn't seem to work if there are duplicates in `df2$id`\n<|/ c |>\n<| a dscore=0\
    \ |>\nWe can use data.table\n<code>\nlibrary(data.table)\nsetDT(df1)[, id := as.character(id)]\n\
    setDT(df2)[, id := as.character(id)]\ndf1[df2, on = \"id\", allow.cartesian =\
    \ TRUE][, id := NULL][]\n</code>\n<|/ a tags=r,dplyr,dataframe |>\n<| c |>\nThanks\
    \ for your answer! I added a reproducible example to my question. Your solution\
    \ doesn't seem to work if there are duplicates in `df2$id`\n<|/ c |>\n<| c |>\n\
    I added a reproducible example to my question. Your solution doesn't seem to work\
    \ if there are duplicates in `df2$id`\n<|/ c |>\n<| c |>\nI added a reproducible\
    \ example to my question. Your solution doesn't seem to work if there are duplicates\
    \ in `df2$id`\n<|/ c |>\n<| c |>\nI added a reproducible example to my question.\
    \ Your solution doesn't seem to work if there are duplicates in `df2$id`\n<|/\
    \ c |>\n<| c |>\nI added a reproducible example to my question. Your solution\
    \ doesn't seem to work if there are duplicates in `df2$id`\n<|/ c |>\n<| a dscore=0\
    \ |>\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  commons <- intersect(u1,\
    \ u2)\n  return(commons)\n}\n", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u2\
    \ %in% u1]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1\
    \ == u2]\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work if there are\
    \ duplicate values in either list. For example, `common <- function(l1, l2) {\n\
    \  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n\ncommon(c(\"\
    a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\", \"d\"))` returns `c(\"a\", \"b\", \"\
    c\")` instead of `c(\"a\", \"b\", \"c\", \"d\")`.\n<|/ c |>\n<| c |>\nYes, I noticed\
    \ that and fixed it before you commented on it.  Thanks for pointing it out.\n\
    <|/ c |>\n<| a tags=r,list,unique |>\nA simple solution using base R:\n<code>\n\
    common = function(l1, l2){\n  u1 = sort(unique(l1))\n  u2 = sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=r,list,unique |>\n<code>\n\
    common = function(l1, l2){\n  u1 = sort(unique(l1))\n  u2 = sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=r,list,unique |>\n<code>\n\
    common = function(l1, l2){\n  u1 = sort(unique(l1))\n  u2 = sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\ncommon\
    \ = function(l1, l2){\n  u1 = sort(unique(l1))\n  u2 = sort(unique(l2))\n  u1[u1\
    \ == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| a dscore=1 |>\n<code>\n\
    common = function(l1, l2){\n  u1 = sort(unique(l1))\n  u2 = sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nWhile this\
    \ code may answer the question, providing additional context regarding why and/or\
    \ how this code answers the question improves its long-term value.\n<|/ c |>\n\
    <| a tags=r,list,unique |>\n<code>\ncommon = function(l1, l2){\n  u1 = sort(unique(l1))\n\
    \  u2 = ", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n</code>\n<|/ a tags=r,dplyr |>\n<| c |>\nThanks so much for your help. I ran\
    \ the code and it gave me this error: \"Error in UseMethod(\"mutate_\") : \n \
    \ no applicable method for 'mutate_' applied to an object of class \"function\"\
    \"\n<|/ c |>\n<| c |>\nI ran the code again and it gave me this error: \"Error\
    \ in UseMethod(\"mutate_\") : \n  no applicable method for 'mutate_' applied to\
    \ an object of class \"function\"\"\n<|/ c |>\n<| c |>\nI ran the code again and\
    \ it gave me this error: \"Error in UseMethod(\"mutate_\") : \n  no applicable\
    \ method for 'mutate_' applied to an object of class \"function\"\"\n<|/ c |>\n\
    <| c |>\nI ran the code again and it gave me this error: \"Error in UseMethod(\"\
    mutate_\") : \n  no applicable method for 'mutate_' applied to an object of class\
    \ \"function\"\"\n<|/ c |>\n<| c |>\nI ran the code again and it gave me this\
    \ error: \"Error in UseMethod(\"mutate_\") : \n  no applicable method for 'mutate_'\
    \ applied to an object of class \"function\"\"\n<|/ c |>\n<| a tags=r,dplyr |>\n\
    The dplyr package is great for data manipulation, but it is also great for data\
    \ analysis. \nThe dplyr package is great for data manipulation, but it is also\
    \ great for data analysis. \nThe dplyr package is great for data manipulation,\
    \ but it is also great for data analysis. \nThe dplyr package is great for data\
    \ manipulation, but it is also great for data analysis. \nThe dplyr package is\
    \ great for data manipulation, but it is also great for data analysis. \nThe dplyr\
    \ package is great for data manipulation, but it is also great for data analysis.\
    \ \nThe dplyr package is great for data manipulation, but it is also great for\
    \ data analysis. \nThe dplyr package is great for data manipulation, but it is\
    \ also great for data analysis. \nThe dplyr package is great for data manipulation,\
    \ but it is also great for data analysis. \nThe dplyr package is great for data\
    \ manipulation, but it is also great for data analysis. \nThe dplyr package is\
    \ great for data manipulation, but it is also great for data analysis. \n", "\n\
    \  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n\
    \  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nI like this solution, although it does require a little\
    \ more memory than my solution. +1\n<|/ c |>\n<| c |>\nI like this solution as\
    \ well, though it does require a little more memory than my solution. +1\n<|/\
    \ c |>\n<| c |>\nI like this solution as well, although it does require a little\
    \ more memory than my solution. +1\n<|/ c |>\n<| a tags=r,unique,list,sorting\
    \ |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\ndt <-\
    \ data.table(list1 = list(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"\
    a\", \"b\", \"c\")))\ndt[, list2 := list1]\ndt[, list2 := lapply(list2, function(x)\
    \ sort(unique(x))), by = list1]\ndt[, list2 := lapply(list2, function(x) sort(unique(x))),\
    \ by = list1]\ndt[, list2 := lapply(list2, function(x) sort(unique(x))), by =\
    \ list1]\ndt[, list2 := lapply(list2, function(x) sort(unique(x))), by = list1]\n\
    dt[, list2 := lapply(list2, function(x) sort(unique(x))), by = list1]\ndt[, list2\
    \ := lapply(list2, function(x) sort(unique(x))), by = list1]\ndt[, list2 := lapply(list2,\
    \ function(x) sort(unique(x))), by = list1]\ndt[, list2 := lapply(list2, function(x)\
    \ sort(unique(x))), by = list1]\ndt[, list2 := lapply(list2, function(x) sort(unique(x))),\
    \ by = list1]\ndt[, list2 := lapply(list2, function(x) sort(unique(x))), by =\
    \ list1]\ndt[, list2 := lapply(list2, function(x) sort(unique(x))), by = list1]\n\
    dt[, list2 := lapply(list2, function(x) sort(unique(x))), by = list1]\ndt[, list2\
    \ := lapply(list2, function(x) sort(unique(x))), by = list1]\ndt[, list2 := lapply(list2,\
    \ function(x) sort(unique(x))), by = list1]\ndt[, list2 := lapply(list2, function(x)\
    \ sort(unique(x))), by = list1]\ndt[, list2 := lapply(list2, ", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  commons <- intersect(u1, u2)\n  return(commons)\n\
    }\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThanks for the answer. I am not able to get it working.\
    \ I am getting this error `Error in sort(unique(l1)) : argument 1 is not a vector`\n\
    <|/ c |>\n<| c |>\nI added a reproducible example to my answer. Does that work\
    \ for you?\n<|/ c |>\n<| c |>\nThanks for the answer. I am not able to get it\
    \ working. I am getting this error `Error in sort(unique(l1)) : argument 1 is\
    \ not a vector`\n<|/ c |>\n<| c |>\nI added a reproducible example to my answer.\
    \ Does that work for you?\n<|/ c |>\n<| c |>\nThanks for the answer. I am not\
    \ able to get it working. I am getting this error `Error in sort(unique(l1)) :\
    \ argument 1 is not a vector`\n<|/ c |>\n<| a tags=r |>\n<code>\nlibrary(dplyr)\n\
    library(purrr)\nlibrary(stringr)\n\ndf <- data.frame(\n  stringsAsFactors = FALSE,\n\
    \  id = c(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"\
    , \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\"\
    , \"V\", \"W\", \"X\", \"Y\", \"Z\"),\n  stringsAsFactors = FALSE\n)\n\ndf %>%\n\
    \  mutate(\n    letters = str_split(id, \"\"),\n    letters = map(letters, ~sort(unique(.x))),\n\
    \    letters = map(letters, ~sort(unique(.x)))\n  ) %>%\n  unnest(letters)\n",
  "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n\
    \  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,dataframe,list\
    \ |>\n<| a tags=r,dataframe,list |>\nI came up with a solution using purrr::map\
    \ and purrr::keep:\n<code>\nlibrary(purrr)\n", "\n  u1 <- sort(unique(l1))\n \
    \ u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\n\
    This doesn't seem to work. `common(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"\
    c\"))` returns `c(\"a\", \"b\", \"c\")`, which is not what OP wants.\n<|/ c |>\n\
    <| c |>\nYes, I noticed that after I posted my answer. I've updated my answer\
    \ accordingly.\n<|/ c |>\n<| c |>\nThis doesn't work if there are duplicates in\
    \ either of the lists. For example, `common(c(\"a\", \"b\", \"c\"), c(\"a\", \"\
    b\", \"c\", \"d\"))` returns `c(\"a\", \"b\", \"c\", \"d\")`, which is not what\
    \ OP wants.\n<|/ c |>\n<| c |>\nYes, I noticed that after I posted my answer.\
    \ I've updated my answer accordingly.\n<|/ c |>\n<| a dscore=3 |>\nHere's a function\
    \ that will do what you want:\n<code>\ncommon <- function(l1, l2) {\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r |>\n<| a tags=r\
    \ |>\n<code>\ncommon <- function(l1, l2) {\n  u1 <- sort(unique(l1))\n  u2 <-\
    \ sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=r\
    \ |>\n<code>\ncommon <- function(l1, l2) {\n  u1 <- sort(unique(l1))\n  u2 <-\
    \ sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=r\
    \ |>\n<code>\ncommon <- function(l1, l2) {\n  u1 <- sort(unique(l1))\n  u2 <-\
    \ sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=r\
    \ |>\n<code>\ncommon <- function(l1, l2) {\n  u1 <- sort(unique(l1))\n  u2 <-\
    \ sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=r\
    \ |>\n<code>\ncommon <- function(l1, l2) {\n  u1 <- sort(unique(l1))\n  u2 ",
  "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a tags=r,sorting |>\n<| c |>\nThis doesn't seem to work. `common(list(c(1,2,3),\
    \ c(1,3,4)), list(c(1,2,3), c(1,3,4)))` returns `[1] 1 2 3` instead of `[1] 1\
    \ 2 3 4`\n<|/ c |>\n<| c |>\n, thanks for pointing that out. I fixed the code\
    \ in the answer. Now it works.\n<|/ c |>\n<| a tags=r,sorting |>\nHere's a solution\
    \ using data.table:\n<code>\nlibrary(data.table)\nsetDT(list(list(c(1,2,3), c(1,3,4)),\
    \ list(c(1,2,3), c(1,3,4))))", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThis doesn't seem to work.\
    \ `common(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"))` returns `[1] \"c\"\
    ` instead of `[1] \"a\" \"b\"`.\n<|/ c |>\n<| c |>\nI guess I misunderstood the\
    \ question. I've updated my answer to reflect what I think you meant.\n<|/ c |>\n\
    <| c |>\nThanks for your answer. Your code works, but I prefer to use `setdiff`\
    \ as suggested by Roman Lu\u0161trik. Thanks anyway!\n<|/ c |>\n<| a tags=r |>\n\
    <code>\ncommon<-function(l1,l2){\n  u1<-sort(unique(l1))\n  u2<-sort(unique(l2))\n\
    \  u1[u1==u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=r |>\nI guess this is\
    \ what you are looking for:\n<code>\ncommon<-function(l1,l2){\n  u1<-sort(unique(l1))\n\
    \  u2<-sort(unique(l2))\n  u1[u1==u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=r\
    \ |>\n<code>\ncommon<-function(l1,l2){\n  u1<-sort(unique(l1))\n  u2<-sort(unique(l2))\n\
    \  u1[u1==u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=r |>\n<code>\ncommon<-function(l1,l2){\n\
    \  u1<-sort(unique(l1))\n  u2<-sort(unique(l2))\n  u1[u1==u2]\n}\n</code>\n<|/\
    \ a dscore=1 |>\n<| a tags=r |>\n<code>\ncommon<-function(l1,l2){\n  u1<-sort(unique(l1))\n\
    \  u2<-sort(unique(l2))\n  u1[u1==u2]\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\n<code>\ncommon<-function(l1,l2){\n  u1<-sort(unique(l1))\n  u2<-sort(unique(l2))\n\
    \  ", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for your answer! I added a small\
    \ example to my question to clarify what I'm looking for. Your solution does not\
    \ seem to work in this case.\n<|/ c |>\n<| c |>\nI added a solution that should\
    \ work\n<|/ c |>\n<| c |>\nThanks for your answer! I added a small example to\
    \ my question to clarify what I'm looking for. Your solution does not seem to\
    \ work in this case.\n<|/ c |>\n<| c |>\nI added a solution that should work\n\
    <|/ c |>\n<| c |>\nThanks for your answer! I added a small example to my question\
    \ to clarify what I'm looking for. Your solution does not seem to work in this\
    \ case.\n<|/ c |>\n<| a dscore=1 |>\nHere is a solution using data.table:\n<code>\n\
    library(data.table)\nsetDT(df)\ndf[, x := paste0(names(df)[order(-x)], collapse\
    \ = \" \")]\ndf[, y := paste0(names(df)[order(-y)], collapse = \" \")]\ndf[, x\
    \ := gsub(\"\\\\s+\", \" \", x)]\ndf[, y := gsub(\"\\\\s+\", \" \", y)]\ndf[,\
    \ x := trimws(x)]\ndf[, y := trimws(y)]\ndf[, x := paste(x, collapse = \" \")]\n\
    df[, y := paste(y, collapse = \" \")]\ndf[, x := gsub(\"\\\\s+\", \" \", x)]\n\
    df[, y := gsub(\"\\\\s+\", \" \", y)]\ndf[, x := trimws(x)]\ndf[, y := trimws(y)]\n\
    df[, x := paste(x, collapse = \" \")]\ndf[, y := paste(y, collapse = \" \")]\n\
    df[, x := gsub(\"\\\\s+\", \" \", x)]\ndf[, y := gsub(\"\\\\s+\", \" \", y)]\n\
    df[, x := trimws(x)]\ndf[, y := trimws(y)]\ndf[, x := paste(x, collapse = \" \"\
    )]\ndf[, y := paste(y, collapse = \" \")]\ndf[, x := gsub(\"\\\\s+\", \" \", x)]\n\
    df[, y := gsub(\"\\\\s+\", \" \", y)]\ndf[, x := trimws(", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list |>\n\
    <| c |>\nThanks for your answer. Your solution works perfectly for my example\
    \ but unfortunately not for my real data. I edited my question to make it more\
    \ clear.\n<|/ c |>\n<| c |>\nI edited my question to make it more clear.\n<|/\
    \ c |>\n<| c |>\nI edited my question to make it more clear.\n<|/ c |>\n<| c |>\n\
    I edited my question to make it more clear.\n<|/ c |>\n<| c |>\nI edited my question\
    \ to make it more clear.\n<|/ c |>\n<| a dscore=0 |>\nHere's a solution using\
    \ data.table:\n<code>\nlibrary(data.table)\n", "\n  u1 <- sort(unique(l1))\n \
    \ u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nI like your solution, but I believe it can be simplified a bit. `common`\
    \ can be defined as `common <- function(l1, l2) sort(unique(l1)[unique(l1) ==\
    \ unique(l2)])`\n<|/ c |>\n<| c |>\nYes, that is a much better solution. Thank\
    \ you!\n<|/ c |>\n<| a dscore=1 |>\nI like using data.table for this:\n<code>\n\
    library(data.table)\nsetDT(df)\ndf[, common:=sort(unique(c(col1, col2))), by=col]\n\
    </code>\n<|/ a tags=r |>\n<| a dscore=1 |>\nA base R option using ave + sort\n\
    <code>\ndf$common <- with(df, ave(col1, col, FUN = sort))\n</code>\n<|/ a tags=r\
    \ |>\n<| a dscore=1 |>\nUsing dplyr and tidyr\n<code>\nlibrary(dplyr)\nlibrary(tidyr)\n\
    \ndf %>% \n  group_by(col) %>% \n  mutate(common = sort(unique(col))) %>% \n \
    \ ungroup() %>% \n  select(-col)\n", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,dataframe,list |>\n<| c |>\nThanks for\
    \ your answer. Unfortunately this doesn't work as I need the output to be a data\
    \ frame with two columns. One column for the common elements and one column for\
    \ the number of times each element occurs in the list. I've edited my question\
    \ to include an example of the output I'm looking for.\n<|/ c |>\n<| c |>\nOkay,\
    \ I edited my answer to include a function that should do what you want.\n<|/\
    \ c |>\n<| c |>\nThanks for your answer. Unfortunately this doesn't work as I\
    \ need the output to be a data frame with two columns. One column for the common\
    \ elements and one column for the number of times each element occurs in the list.\
    \ I've edited my question to include an example of the output I'm looking for.\n\
    <|/ c |>\n<| c |>\nOkay, I edited my answer to include a function that should\
    \ do what you want.\n<|/ c |>\n<| c |>\nThanks for your answer. Unfortunately\
    \ this doesn't work as I need the output to be a data frame with two columns.\
    \ One column for the common elements and one column for the number of times each\
    \ element occurs in the list. I've edited my question to include an example of\
    \ the output I'm looking for.\n<|/ c |>\n<| a |>\n<code>", "\n  u1 <- unique(l1)\n\
    \  u2 <- unique(l2)\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <-\
    \ sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <-\
    \ sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <-\
    \ sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <-\
    \ sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <-\
    \ sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks\
    \ for your answer! I added some more information to the question, maybe that helps.\n\
    <|/ c |>\n<| c |>\nThanks for your answer! I added some more information to the\
    \ question, maybe that helps.\n<|/ c |>\n<| c |>\nThanks for your answer! I added\
    \ some more information to the question, maybe that helps.\n<|/ c |>\n<| c |>\n\
    Thanks for your answer! I added some more information to the question, maybe that\
    \ helps.\n<|/ c |>\n<| c |>\nThanks for your answer! I added some more information\
    \ to the question, maybe that helps.\n<|/ c |>\n<| a dscore=1 |>\nHere is a solution\
    \ using data.table:\n<code>\nlibrary(data.table)\nsetDT(df)\n\ndf[, \n   .SD[!duplicated(.SD)],\
    \ \n   by = .(group1, group2, group3, group4, group5, group6, group7, group8,\
    \ group9, group10, group11, group12, group13, group14, group15, group16, group17,\
    \ group18, group19, group20, group21, group22, group23, group24, group25, group26,\
    \ group27, group28, group29, group30, group31, group32, group33, group34, group35,\
    \ group36, group37, group38, group39, group40, group41, group42, group43, group44,\
    \ group45, group46, group47, group48, group49, group50, group51, group52, group53,\
    \ group54, group55, group56, group57, group58, group59, group60, group61, group62,\
    \ group63, group64, group65, group66, group67, group68, group69, group70, group71,\
    \ group72, group73, group74, group75, group76, group77, group78, group79, group80,\
    \ group81, group82, group83, group84, group85, group86, group87, group88, group89,\
    \ group90, group91, group92, group93, group94, group95, group96, group97, group98,\
    \ group99, group100, group101, group102, group103, group104, group105, group106,\
    \ group107, group108, group109, group110, group111, group112, group113, group114,\
    \ group115, group116, group117, group118, ", "\n  u1 <- sort(unique(l1))\n  u2\
    \ <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\n\
    Thanks for your answer! I realized that my question was a bit unclear. I've edited\
    \ my question to make it clearer. Sorry for the confusion.\n<|/ c |>\n<| c |>\n\
    I edited my answer to include a function that will do what you want.\n<|/ c |>\n\
    <| c |>\nThanks for your answer! I realized that my question was a bit unclear.\
    \ I've edited my question to make it clearer. Sorry for the confusion.\n<|/ c\
    \ |>\n<| c |>\nThanks for your answer! I realized that my question was a bit unclear.\
    \ I've edited my question to make it clearer. Sorry for the confusion.\n<|/ c\
    \ |>\n<| c |>\nThanks for your answer! I realized that my question was a bit unclear.\
    \ I've edited my question to make it clearer. Sorry for the confusion.\n<|/ c\
    \ |>\n<| a dscore=0 |>\nHere's a solution using dplyr and purrr packages:\n<code>\n\
    library(dplyr)\nlibrary(purrr)\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't seem to\
    \ work. `common(list(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\")), list(c(\"\
    a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\")))` returns `c(\"a\", \"b\", \"c\")`\
    \ instead of `c(\"a\", \"b\", \"c\", \"d\")`.\n<|/ c |>\n<| c |>\nI see what you\
    \ mean. I've updated the answer to fix the problem.\n<|/ c |>\n<| c |>\nThanks\
    \ for the update. I've tested it and it works. I guess I should learn to read\
    \ the code more carefully next time.\n<|/ c |>\n<| a tags=r,list |>\nHere's a\
    \ solution using sapply and intersect:\n<code>\nsapply(list1, function(x) sapply(list2,\
    \ function(y) intersect(x, y)))\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n\
    Here's a solution using purrr::map2\n<code>\nlibrary(purrr)\n\nmap2(list1, list2,\
    \ intersect)\n</code>\n<|/ a tags=r,list |>\n<| a tags=r,list |>\nHere's a solution\
    \ using purrr::map2\n<code>\nlibrary(purrr)\n\nmap2(list1, list2, intersect)\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=r,list |>\n<code>\nlist1 <- list(c(\"a\"\
    , \"b\", \"c\"), c(\"a\", \"b\", \"c\"))\nlist2 <- list(c(\"a\", \"b\", \"c\"\
    ), c(\"a\", \"b\", \"c\"))\n</code>\nYou can use the function Reduce with intersect:\n\
    <code>\nReduce(intersect, list1, list2)\n</code>\n<|/ a dscore=1 |>\n<| a tags=r,list\
    \ |>\n<code>\nlist1 <- list(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"))\n\
    list2 <- list(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"))\n</code>\nWe can\
    \ use mapply with intersect\n<code>\nmapply(intersect, list1, list2)\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\n<code>\nlist1 <- list(c(\"a\", \"b\", \"c\"), c(\"\
    a\", \"b\", \"c\"))\nlist2 <- list(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"\
    c\"))\n</code>\nWe can use mapply with intersect\n<code>\nmapply(intersect, list1,\
    \ list2)\n</code>\n<|/ a ", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for the answer!\
    \ I added a little more information to the question, maybe it helps.\n<|/ c |>\n\
    <| c |>\nI added a solution that should work for your updated question.\n<|/ c\
    \ |>\n<| c |>\nThanks for the answer! I added a little more information to the\
    \ question, maybe it helps.\n<|/ c |>\n<| c |>\nI added a solution that should\
    \ work for your updated question.\n<|/ c |>\n<| c |>\nThanks for the answer! I\
    \ added a little more information to the question, maybe it helps.\n<|/ c |>\n\
    <| a |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\nlibrary(magrittr)\n",
  "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't work if you have duplicates\
    \ in your lists.\n<|/ c |>\n<| c |>\nI added a version that works with duplicates.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have duplicates in your lists.\n<|/\
    \ c |>\n<| c |>\nI added a version that works with duplicates.\n<|/ c |>\n<| a\
    \ tags=r,list,unique |>\nA simple solution is to convert your list to a vector,\
    \ sort it, and remove duplicates:\n<code>\nx <- list(c(\"a\", \"b\"), c(\"c\"\
    , \"d\"), c(\"e\", \"f\"))\nx <- sort(unlist(x))\nx <- x[!duplicated(x)]\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis doesn't work if you have duplicates in your lists.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have duplicates in your lists.\n<|/\
    \ c |>\n<| c |>\nThis doesn't work if you have duplicates in your lists.\n<|/\
    \ c |>\n<| a |>\nA simple solution is to convert your list to a vector, sort it,\
    \ and remove duplicates:\n<code>\nx <- list(c(\"a\", \"b\"), c(\"c\", \"d\"),\
    \ c(\"e\", \"f\"))\nx <- sort(unlist(x))\nx <- x[!duplicated(x)]\n</code>\n<|/\
    \ a tags=r,list,unique dscore=5 |>\n<| c |>\nThis doesn't work if you have duplicates\
    \ in your lists.\n<|/ c |>\n<| c |>\nThis doesn't work if you have duplicates\
    \ in your lists.\n<|/ c |>\n<| c |>\nThis doesn't work if you have duplicates\
    \ in your lists.\n<|/ c |>\n<| a dscore=5 |>\nHere's a solution using purrr::map\n\
    <code>\nx <- list(c(\"a\", \"b\"), c(\"c\", \"d\"), c(\"e\", \"f\"))\npurrr::map(unique(x),\
    \ sort)\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't work if you\
    \ have duplicates in your lists.\n<|/ c |>\n<| c |>\nThis doesn't work if you\
    \ have duplicates in your lists.\n<|/ c |>\n<| c |>\nThis doesn't work if you\
    \ have duplicates in your lists.", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nA solution using\
    \ dplyr and purrr:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\ndf %>%\n  mutate(\n\
    \    common_elements = map(\n      list(\n        elements = elements,\n     \
    \   elements_2 = elements_2\n      ),\n      ~setNames(\n        sort(intersect(.x,\
    \ .y)),\n        paste0(\"common_\", names(.x))\n      )\n    )\n  ) %>%\n  unnest(common_elements)\n\
    </code>\nOutput\n<code>", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThanks for your answer.\
    \ Your code works well for small lists, but it fails for large lists. I get the\
    \ following error message: Error in sort.list(y) : 'x' must be atomic for 'sort.list'\n\
    Have you any idea why this happens?\n<|/ c |>\n<| c |>\nI tested it on a large\
    \ dataset and it works fine. Can you post a sample of your data?\n<|/ c |>\n<|\
    \ c |>\nI added a sample of my data above. Thanks for your help!\n<|/ c |>\n<|\
    \ c |>\nI tested it on a larger dataset and it works fine. Can you post a sample\
    \ of your data?\n<|/ c |>\n<| c |>\nI added a sample of my data above. Thanks\
    \ for your help!\n<|/ c |>\n<| a tags=r |>\nHere is a solution using data.table\n\
    <code>\nlibrary(data.table)\nsetDT(df)[, list(common = intersect(names(df), names(df))),\
    \ by = .(group)]\n</code>\nwhich gives\n<code>\n   group common\n1:     1    \
    \ a\n2:     2     b\n3:     3     c\n4:     4     d\n5:     5     e\n6:     6\
    \     f\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your answer. Your code\
    \ works well for small lists, but it fails for large lists. I get the following\
    \ error message: Error in sort.list(y) : 'x' must be atomic for 'sort.list'\n\
    Have you any idea why this happens?\n<|/ c |>\n<| c |>\nI tested it on a large\
    \ dataset and it works fine. Can you post a sample of your data?\n<|/ c |>\n<|\
    \ c |>\nI added a sample of my data above. Thanks for your help!\n<|/ c |>\n<|\
    \ c |>\nI tested it on a larger dataset and it works fine. Can you post a sample\
    \ of your data?\n<|/ c |>\n<| c |>\nI added a sample of my data above. Thanks\
    \ for your help!\n<|/ c |>\n<| a tags=r |>\nHere is a base R solution:\n<code>",
  "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| a tags=r,list,unique |>\nA base R option with\
    \ intersect\n<code>\n> intersect(list(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\",\
    \ \"d\"), c(\"a\", \"b\", \"e\")), list(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\"\
    , \"d\"), c(\"a\", \"b\", \"e\")))\n[[1]]\n[1] \"a\" \"b\" \"c\"\n\n[[2]]\n[1]\
    \ \"a\" \"b\" \"d\"\n\n[[3]]\n[1] \"a\" \"b\" \"e\"\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=r,list,unique |>\nHere's a base R option\n<code>\n> unique(unlist(list(c(\"\
    a\", \"b\", \"c\"), c(\"a\", \"b\", \"d\"), c(\"a\", \"b\", \"e\"))))\n[1] \"\
    a\" \"b\" \"c\" \"d\" \"e\"\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nHere's\
    \ a base R option\n<code>\n> unique(unlist(list(c(\"a\", \"b\", \"c\"), c(\"a\"\
    , \"b\", \"d\"), c(\"a\", \"b\", \"e\"))))\n[1] \"a\" \"b\" \"c\" \"d\" \"e\"\n\
    </code>\n<|/ a tags=r,list,unique |>\n<| a tags=r,list,unique |>\nA base R option\
    \ with intersect\n<code>\n> intersect(list(c(\"a\", \"b\", \"c\"), c(\"a\", \"\
    b\", \"d\"), c(\"a\", \"b\", \"e\")), list(c(\"a\", \"b\", \"c\"), c(\"a\", \"\
    b\", \"d\"), c(\"a\", \"b\", \"e\")))\n[[1]]\n[1] \"a\" \"b\" \"c\"\n\n[[2]]\n\
    [1] \"a\" \"b\" \"d\"\n\n[[3]]\n[1] \"a\" \"b\" \"e\"\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\n<code>\n> unique(unlist(list(c(\"a\", \"b\", \"c\"), c(\"\
    a\", \"b\", \"d\"), c(\"a\", \"b\", \"e\"))))\n[1] \"a\" \"b\" \"c\" \"d\" \"\
    e\"\n</code>\n<|/ a tags=r,list,unique |>\n<| a dscore=1 |>\n<code>\n> unique(unlist(list(c(\"\
    a\", \"b\", \"c\"), c(\"a\", \"b\", \"d\"), c(\"a\", \"b\", \"e\"))))\n[1] \"\
    a\" \"b\" \"c\" \"d\" \"e\"\n</code>\n<|/ a tags=r,list,unique |>\n<| a tags=r,list,",
  "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,dataframe,list\
    \ |>\n<| c |>\nThanks so much for the response! I ran the code and it returned\
    \ the error \"Error in names(x) <- nm : \n  'names' attribute [2] must be the\
    \ same length as the vector [1]\"\n<|/ c |>\n<| c |>\nI ran it again and it returned\
    \ the error \"Error in names(x) <- nm : \n  'names' attribute [2] must be the\
    \ same length as the vector [1]\"\n<|/ c |>\n<| c |>\nI ran it again and it returned\
    \ the error \"Error in names(x) <- nm : \n  'names' attribute [2] must be the\
    \ same length as the vector [1]\"\n<|/ c |>\n<| c |>\nI ran it again and it returned\
    \ the error \"Error in names(x) <- nm : \n  'names' attribute [2] must be the\
    \ same length as the vector [1]\"\n<|/ c |>\n<| c |>\nI ran it again and it returned\
    \ the error \"Error in names(x) <- nm : \n  'names' attribute [2] must be the\
    \ same length as the vector [1]\"\n<|/ c |>\n<| a tags=r,dataframe,list |>\nI\
    \ used the code below to solve my problem. \n<code>", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list |>\n\
    <| c |>\nThis doesn't seem to work if there are duplicates in the list. For example,\
    \ `common(list(\"a\", \"b\", \"c\"), list(\"a\", \"b\", \"c\"))` returns `[1]\
    \ \"c\"` instead of `[1] \"a\"`\n<|/ c |>\n<| c |>\n, good catch. I've updated\
    \ the answer to account for duplicates.\n<|/ c |>\n<| c |>\nThis doesn't seem\
    \ to work if there are duplicates in the list. For example, `common(list(\"a\"\
    , \"b\", \"c\"), list(\"a\", \"b\", \"c\"))` returns `[1] \"c\"` instead of `[1]\
    \ \"a\"`\n<|/ c |>\n<| c |>\n, that's because `common` doesn't take into account\
    \ the order of the elements. I've updated the answer to account for that.\n<|/\
    \ c |>\n<| c |>\nThis doesn't seem to work if there are duplicates in the list.\
    \ For example, `common(list(\"a\", \"b\", \"c\"), list(\"a\", \"b\", \"c\"))`\
    \ returns `[1] \"c\"` instead of `[1] \"a\"`\n<|/ c |>\n<| a tags=r,list |>\n\
    Here's a solution using purrr::map\n<code>\nlibrary(purrr)\n\ncommon <- function(l1,\
    \ l2) {\n  map(l1, ~sort(unique(.x)) %in% map(l2, ~sort(unique(.x))))\n}\n\ncommon(list(\"\
    a\", \"b\", \"c\"), list(\"a\", \"b\", \"c\"))", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- unique(l1)\n  u2 <-\
    \ unique(l2)\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u1 == u2]\n\
    }\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis doesn't work if there are repeated\
    \ elements in either of the lists.\n<|/ c |>\n<| c |>\nIt works if you use `common`\
    \ instead of `intersect` in the last line.\n<|/ c |>\n<| c |>\nI see what you\
    \ mean. Yes, `common` works fine.\n<|/ c |>\n<| c |>\nI added a version that doesn't\
    \ require `common`.\n<|/ c |>\n<| c |>\nI added a version that doesn't require\
    \ `common`.\n<|/ c |>\n<| a tags=r,sorting |>\nThis should work:\n<code>", "\n\
    \  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a tags=r,dataframe,list |>\n<| c |>\nThis doesn't seem to work if there are\
    \ repeated values in either of the lists.\n<|/ c |>\n<| c |>\nYes, it does. I\
    \ tested it before posting. Try it yourself with `list1 <- list(c(\"a\", \"b\"\
    , \"c\"), c(\"a\", \"b\", \"c\"))` and `list2 <- list(c(\"a\", \"b\", \"c\"),\
    \ c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"))`.\n<|/ c |>\n<| c |>\nOh I see.\
    \ Sorry I misunderstood your answer. Thanks!\n<|/ c |>\n<| a tags=r,dataframe,list\
    \ |>\n<code>", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u1 == u2]\n}\n",
  "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't work if there are repeated elements in the lists.\n\
    <|/ c |>\n<| c |>\nI believe it does. Try it out with your sample data.\n<|/ c\
    \ |>\n<| c |>\nYes, it does. Try it out with your sample data.\n<|/ c |>\n<| c\
    \ |>\nI see what you mean. Yes, it does work. Try it out with your sample data.\n\
    <|/ c |>\n<| c |>\nI see what you mean. Yes, it does work. Try it out with your\
    \ sample data.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\
    \ndf <- data.frame(\n  id = c(1,2,3,4,5,6,7,8,9,10),\n  name = c(\"a\",\"b\",\"\
    c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\")\n)\n\ndf %>% \n  mutate(\n    name_sorted\
    \ = sort(name),\n    name_unique = unique(name),\n    name_common = map(name_unique,\
    \ ~sort(.x, decreasing = TRUE))\n  ) %>% \n  unnest(name_common)\n</code>\n<|/\
    \ a tags=r,dplyr |>\n<| a dscore=0 |>\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\
    \ndf <- data.frame(\n  id = c(1,2,3,4,5,6,7,8,9,10),\n  name = c(\"a\",\"b\",\"\
    c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\")\n)\n\ndf %>% \n  mutate(\n    name_sorted\
    \ = sort(name),\n    name_unique = unique(name),\n    name_common = map(name_unique,\
    \ ~sort(.x, decreasing = TRUE))\n  ) %>% \n  unnest(name_common)\n</code>\n<|/\
    \ a tags=r,dplyr |>\n<| a tags=r,dplyr |>\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\
    \ndf <- data.frame(\n  id = c(1,2,3,4,5,6,7,8,9,10),\n  name = c(\"a\",\"b\",\"\
    c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\")\n)\n\ndf %>% \n  mutate(\n    name_sorted\
    \ = sort(name),\n    name_unique = unique(name),\n    name_", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  commons <- intersect(u1, u2)\n  return(commons)\n\
    }\n", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't work if you have two lists\
    \ with different lengths.\n<|/ c |>\n<| c |>\nThis doesn't work if you have two\
    \ lists with different lengths.\n<|/ c |>\n<| a |>\n<code>", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThis doesn't work if you have two lists with different lengths.\n\
    <|/ c |>\n<| a tags=r,list,unique |>\nHere's a solution using purrr::map2\n<code>\n\
    library(purrr)\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1\
    \ == u2]\n}\n", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u1 == u2]\n}\n\
    </code>\n<|/ a tags=r,sorting |>\n<| c |>\nThanks for the answer. I'm getting\
    \ an error when I try to use this code. `Error in sort.list(y) : 'x' must be atomic\
    \ for 'sort.list'\nHave you called 'sort' on a list?`\n<|/ c |>\n<| c |>\nI added\
    \ a reproducible example to my original post. Thanks for your help!\n<|/ c |>\n\
    <| c |>\nI added a reproducible example to my original post. Thanks for your help!\n\
    <|/ c |>\n<| c |>\nI added a reproducible example to my original post. Thanks\
    \ for your help!\n<|/ c |>\n<| c |>\nI added a reproducible example to my original\
    \ post. Thanks for your help!\n<|/ c |>\n<| a tags=r,sorting |>\nWe can use data.table.\
    \  Convert the 'data.frame' to 'data.table' (setDT(df1)), grouped by 'ID', we\
    \ get the sum of 'value' grouped by 'ID' and then order the rows by 'ID' and the\
    \ sum of 'value'.\n<code>\nlibrary(data.table)\nsetDT(df1)[, sum(value) , ID][order(ID,\
    \ sum(value)), ]\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for the answer.\
    \ I'm getting an error when I try to use this code. `Error in sort.list(y) : 'x'\
    \ must be atomic for 'sort.list'\nHave you called 'sort' on a list?`\n<|/ c |>\n\
    <| c |>\nI added a reproducible example to my original post. Thanks for your help!\n\
    <|/ c |>\n<| c |>\nI added a reproducible example to my original post. Thanks\
    \ for your help!\n<|/ c |>\n<| c |>\nI added a reproducible example to my original\
    \ post. Thanks for your help!\n<|/ c |>\n<| c |>\nI added a reproducible example\
    \ to my original post. Thanks for your help!\n<|/ c |>\n<| a tags=r,sorting |>\n\
    Here's a base R solution:\n<code>\ndf1 <- data.frame(ID = c(1,1,1,2,2,2), value\
    \ = c(2,4,6,2,4,6))\ndf2 <- data.frame(ID = c(1,2,2,3), value = c(4,6,", "\n \
    \ u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a tags=r,dataframe,list |>\n<| a |>\nHere's a solution using dplyr and purrr\
    \ packages.\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ tags=r,sorting |>\n<code>\nlibrary(data.table)\nlibrary(dplyr)\n", "\n  u1 <-\
    \ unique(l1)\n  u2 <- unique(l2)\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- unique(l1)\n  u2 <-\
    \ unique(l2)\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\n\
    I like your solution, but I believe it only works if you have a list of lists.\
    \ If you have a list of vectors, it won't work. For example, `list(c(\"a\", \"\
    b\"), c(\"a\", \"b\"))` will return `list(c(\"a\", \"b\"), c(\"a\", \"b\"))` instead\
    \ of `list(c(\"a\"), c(\"b\"))`.\n<|/ c |>\n<| c |>\nI believe that `list(c(\"\
    a\", \"b\"), c(\"a\", \"b\"))` should return `list(c(\"a\"), c(\"b\"))` because\
    \ `list(c(\"a\", \"b\"), c(\"a\", \"b\"))` has two unique elements. `list(c(\"\
    a\"), c(\"b\"))` has one unique element, so `list(c(\"a\"), c(\"b\"))` should\
    \ be the unique common elements. I believe that `list(c(\"a\", \"b\"), c(\"a\"\
    , \"b\"))` should return `list(c(\"a\"), c(\"b\"))` because `list(c(\"a\", \"\
    b\"), c(\"a\", \"b\"))` has two unique elements. `list(c(\"a\"), c(\"b\"))` has\
    \ one unique element, so `list(c(\"a\"), c(\"b\"))` should be the unique common\
    \ elements.\n<|/ c |>\n<| c |>\nI believe that `list(c(\"a\", \"b\"), c(\"a\"\
    , \"b\"))` should return `list(c(\"a\"), c(\"b\"))` because `list(c(\"a\", \"\
    b\"), c(\"a\", \"b\"))` has two unique elements. `list(c(\"a\"), c(\"b\"))` has\
    \ one unique element, so `list(c(\"a\"), c(\"b\"))` should be the unique common\
    \ elements.\n<|/ c |>\n<| c |>\nI believe that `list(c(\"a\", \"b\"), c(\"a\"\
    , \"b\"))` should return `list(c(\"a\"), c(\"b\"))` because `list(c(\"a\", \"\
    b\"), c(\"a\", \"b\"))` has two unique elements. `list(c(\"a\"), c(\"b\"))` has\
    \ one unique element, so `list(c(\"a\"), c(\"b\"))` should be the unique common\
    \ elements.\n<|/ c |>\n<| c |>\nI believe that `list(c(\"a\", \"b\"), c(\"a\"\
    , \"b\"))` should return `list(c(\"a\"), c(\"b\"))` because `list(c(\"a\", \"\
    b\"), c(\"", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u2 %in% u1]\n}\n\
    </code>\n<|/ a tags=r,list |>\n<| c |>\nThanks for your answer. I am not looking\
    \ for common elements in two lists, I am looking for common elements in two lists\
    \ based on a key (which is present in both lists). For example, I have two lists\
    \ A and B and I want to find common elements based on key 'key'. Key 'key' can\
    \ be present in both lists A and B. So, I want common elements based on key 'key'\
    \ present in both lists A and B. Hope this clarifies my question.\n<|/ c |>\n\
    <| c |>\nI added a solution that does that. Hope it helps.\n<|/ c |>\n<| c |>\n\
    Thanks for your answer. I am not looking for common elements in two lists, I am\
    \ looking for common elements in two lists based on a key (which is present in\
    \ both lists). For example, I have two lists A and B and I want to find common\
    \ elements based on key 'key'. Key 'key' can be present in both lists A and B.\
    \ So, I want common elements based on key 'key' present in both lists A and B.\
    \ Hope this clarifies my question.\n<|/ c |>\n<| c |>\nI added a solution that\
    \ does that. Hope it helps.\n<|/ c |>\n<| c |>\nThanks for your answer. I am not\
    \ looking for common elements in two lists, I am looking for common elements in\
    \ two lists based on a key (which is present in both lists). For example, I have\
    \ two lists A and B and I want to find common elements based on key 'key'. Key\
    \ 'key' can be present in both lists A and B. So, I want common elements based\
    \ on key 'key' present in both lists A and B. Hope this clarifies my question.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u2 %in%\
    \ u1]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't work if\
    \ there are duplicates in either list.\n<|/ c |>\n<| c |>\nIt does work if there\
    \ are duplicates in either list. Try it yourself. It returns `[1] \"a\" \"b\"\
    \ \"c\"` as expected.\n<|/ c |>\n<| c |>\nAh, I see what you're saying. Yes, it\
    \ does work. Sorry, I misunderstood the question. Thanks for pointing that out.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>\n> x <- list(\"a\", \"b\", \"c\", \"a\", \"\
    b\", \"c\")\n> y <- list(\"a\", \"b\", \"c\", \"a\", \"b\", \"c\")\n> x <- unique(x)\n\
    > y <- unique(y)\n> x\n[1] \"a\" \"b\" \"c\"\n> y\n[1] \"a\" \"b\" \"c\"\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| a dscore=2 |>\n<code>\nx <- list(\"a\", \"b\"\
    , \"c\", \"a\", \"b\", \"c\")\ny <- list(\"a\", \"b\", \"c\", \"a\", \"b\", \"\
    c\")\nx <- unique(x)\ny <- unique(y)\n</code>\n<|/ a tags=r,list,unique |>\n<|\
    \ a dscore=2 |>\n<code>\nx <- list(\"a\", \"b\", \"c\", \"a\", \"b\", \"c\")\n\
    y <- list(\"a\", \"b\", \"c\", \"a\", \"b\", \"c\")\nx <- unique(x)\ny <- unique(y)\n\
    </code>\n<|/ a tags=r,list,unique |>\n<| a dscore=2 |>\n<code>\nx <- list(\"a\"\
    , \"b\", \"c\", \"a\", \"b\", \"c\")\ny <- list(\"a\", \"b\", \"c\", \"a\", \"\
    b\", \"c\")\nx <- unique(x)\ny <- unique(y)\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| a dscore=2 |>\n<code>\nx <- list(\"a\", \"b\", \"c\", \"a\", \"b\", \"\
    c\")\ny <- list(\"a\", \"b\", \"c\", \"a\", \"b\", \"c\")\nx <- unique(x)\ny <-\
    \ unique(y)\n</code>\n<|/ a tags=r,list,unique |>\n<| a dscore=2 |>\n<code>\n\
    x <- list(\"a\", \"b\", \"c\", \"a\", \"b\", \"c\")\ny <- list(\"a\", \"b\", \"\
    c\", \"a\", \"b\", \"c\")\nx <- unique(x)\ny <- unique(y)\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| a dscore=1 |>\n<code>\nx <- list(\"a\", \"b\", \"c\", \"a\", \"b\", \"\
    c\")\ny <- list(\"", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n \
    \ u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nI like your\
    \ solution, but I believe it would be more efficient to sort the lists first.\
    \ `u1 <- sort(unique(l1))` and `u2 <- sort(unique(l2))`\n<|/ c |>\n<| c |>\nI\
    \ agree with you. Thank you for your suggestion.\n<|/ c |>\n<| a dscore=2 |>\n\
    <code>\n> x <- list(c(1,2,3), c(4,5,6), c(7,8,9))\n> y <- list(c(1,2,3), c(4,5,6),\
    \ c(7,8,9), c(10,11,12))\n> z <- list(c(1,2,3), c(4,5,6), c(7,8,9), c(10,11,12),\
    \ c(13,14,15))\n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> ", "\n  u1 <- unique(l1)\n\
    \  u2 <- unique(l2)\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <-\
    \ sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <-\
    \ sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis\
    \ does not provide an answer to the question. To critique or request clarification\
    \ from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/27859018)\n\
    <|/ c |>\n<| c |>\nIt does provide an answer to the question, which is \"how do\
    \ I find common elements in two lists?\"\n<|/ c |>\n<| c |>\nI agree with you,\
    \ but this does not provide an answer to the question. As it stands, it should\
    \ be a comment. - [From Review](/review/low-quality-posts/27859018)\n<|/ c |>\n\
    <| c |>\nI agree with you, but this does not provide an answer to the question.\
    \ As it stands, it should be a comment. - [From Review](/review/low-quality-posts/27859018)\n\
    <|/ c |>\n<| c |>\nI agree with you, but this does not provide an answer to the\
    \ question. As it stands, it should be a comment. - [From Review](/review/low-quality-posts/27859018)\n\
    <|/ c |>\n<| a tags=r |>\nWe can use intersect from dplyr\n<code>\nlibrary(dplyr)\n\
    intersect(list1, list2)\n</code>\n<|/ a dscore=1 |>\n<| a tags=r |>\nWe can use\
    \ intersect\n<code>\nintersect(list1, list2)\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ dscore=0 |>\nWe can use setdiff and intersect from base R\n<code>\nsetdiff(list1,\
    \ list2)\n</code>\n<|/ a tags=r |>\n<| a dscore=0 |>\n<code>\nlist1 <- list(c(\"\
    a\", \"b\", \"c\"), c(\"d\", \"e\", \"f\"), c(\"g\", \"h\", \"i\"))\nlist2 <-\
    \ list(c(\"a\", \"b\", \"c\"), c(\"d\", \"e\", \"f\"), c(\"g\", \"h\", \"i\"))\n\
    </code>\nWe can use intersect from dplyr\n<code>\nlibrary(dplyr)\nintersect(list1,\
    \ list2)\n</code>\n<|/ a tags=r |>\n<| a tags=r |>\nWe can use setdiff and intersect\
    \ from base R\n<code>\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your answer.\
    \ Your solution works perfectly for my case. However I still have some questions.\
    \ What is the difference between `setdiff` and `setdiff1`? Why do we need `sort`?\
    \ Why do we need `unique`? Why do we need `length`? Why do we need `lengths`?\
    \ Why do we need `lengths`? Why do we need `lengths`? Why do we need `lengths`?\
    \ Why do we need `lengths`? Why do we need `lengths`? Why do we need `lengths`?\
    \ Why do we need `lengths`? Why do we need `lengths`? Why do we need `lengths`?\
    \ Why do we need `lengths`? Why do we need `lengths`? Why do we need `lengths`?\
    \ Why do we need `lengths`? Why do we need `lengths`? Why do we need `lengths`?\
    \ Why do we need `lengths`? Why do we need `lengths`? Why do we need `lengths`?\
    \ Why do we need `lengths`? Why do we need `lengths`? Why do we need `lengths`?\
    \ Why do we need `lengths`? Why do we need `lengths`? Why do we need `lengths`?\
    \ Why do we need `lengths`? Why do we need `lengths`? Why do we need `lengths`?\
    \ Why do we need `lengths`? Why do we need `lengths`? Why do we need `lengths`?\
    \ Why do we need `lengths`? Why do we need `lengths`? Why do we need `lengths`?\
    \ Why do we need `lengths`? Why do we need `lengths`? Why do we need `lengths`?\
    \ Why do we need `lengths`? Why do we need `lengths`? Why do we need `lengths`?\
    \ Why do we need `lengths`? Why do we need `lengths`? Why do we need `lengths`?\
    \ Why do we need `lengths`? Why do we need `lengths`? Why do we need `lengths`?\
    \ Why do we need `lengths`? Why do we need `lengths`? Why do we need `lengths`?\
    \ Why do we need `lengths`? Why do we need `lengths`? Why do we need `lengths`?\
    \ Why do we need `lengths`? Why do we need `lengths`? Why do we need `lengths`?\
    \ Why do we need `lengths`? Why do we need `lengths`? Why do we need `lengths`?\
    \ Why do we need `lengths`? ", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u2 %in%\
    \ u1]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't work if\
    \ you have a list with duplicate elements. For example, `x <- list(c(1,2,3), c(1,2,3),\
    \ c(1,2,3))` returns `[1] 1 2 3`\n<|/ c |>\n<| c |>\nYes, that's true. I was thinking\
    \ about `intersect` but didn't think about `unique`. Thanks.\n<|/ c |>\n<| a tags=r,list,unique\
    \ |>\nA variation on James' answer that works with lists with duplicate elements:\n\
    <code>", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n</code>\n<|/ a tags=r,dataframe,list |>\n<| c |>\nThanks so much! This worked\
    \ perfectly. I'm new to R and I appreciate your help.\n<|/ c |>\n<| c |>\nGlad\
    \ it helped. Feel free to accept the answer if it solved your problem.\n<|/ c\
    \ |>\n<| c |>\nI did but I'm new and I didn't know I had to click the check mark.\
    \ Thanks again!\n<|/ c |>\n<| c |>\nNo problem. Glad I could help.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>\nlibrary(dplyr)\nlibrary(purrr)\nlibrary(stringr)\n",
  "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n\
    \  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThanks, this works great! I added a second argument\
    \ to `common` to sort by frequency (descending) so I can see which elements appear\
    \ most often.\n<|/ c |>\n<| a dscore=2 |>\nA solution using dplyr and purrr packages:\n\
    <code>\nlibrary(dplyr)\nlibrary(purrr)\n", "\n  u1 <- sort(unique(l1))\n  u2 <-\
    \ sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n\
    \  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis doesn't work if\
    \ you have duplicates in either list. For example, `common(c(1,2,2,3), c(1,2,2,3))`\
    \ returns `[1] 1 2 3` instead of `[1] 1 2 3`.\n<|/ c |>\n<| c |>\nYes, that's\
    \ true. I've added a version that doesn't have this problem.\n<|/ c |>\n<| a tags=r\
    \ |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\nsetDT(df)\n\
    df[, x := .I]\ndf[, y := .I]\ndf[, common := intersect(x, y), by = .(id, x, y)]\n\
    df[, common := unique(common), by = id]\n</code>\n<|/ a dscore=3 |>\n<| a tags=r\
    \ |>\nHere's a solution using dplyr and purrr:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\
    \ndf %>%\n  group_by(id) %>%\n  mutate(common = map2(id, x, ~intersect(.x, .y))\
    \ %>% unlist() %>% unique())\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for your answer.\
    \ Your solution works perfectly for my example, but I forgot to mention that my\
    \ actual data set is much bigger and has many more columns. I edited my question\
    \ to reflect that. Do you think your solution still works in this case?\n<|/ c\
    \ |>\n<| c |>\nYes, it should still work. Just replace `df` with `df1` and `df2`\
    \ with `df2`.\n<|/ c |>\n<| c |>\nThanks again! I edited my question to reflect\
    \ my actual data set. Do you think your solution still works in this case?\n<|/\
    \ c |>\n<| c |>\nYes, it should still work. Just replace `df` with `df1` and `df2`\
    \ with `df2`.\n<|/ c |>\n<| c |>\nThanks again! I edited my question to reflect\
    \ my actual data set. Do you think your solution still works in this case?\n<|/\
    \ c |>\n<| a tags=r,dplyr,dataframe |>\nHere's a solution using dplyr and purrr\
    \ packages:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\ndf %>%\n  mutate(\n   \
    \ common_cols = map(\n      across(\n        everything(),\n        ~sort(unique(.))\n\
    \      ),\n      ~.x[.x == .y]\n    )\n  ) %>%\n  unnest(common_cols)\n</code>\n\
    Output:\n<code>", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u1 == u2]\n\
    }\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your answer. Unfortunately\
    \ this doesn't work. `common(list(c(\"a\",\"b\",\"c\"), c(\"a\",\"b\",\"c\")),\
    \ list(c(\"a\",\"b\",\"c\"), c(\"a\",\"b\",\"c\")))` returns `character(0)`\n\
    <|/ c |>\n<| c |>\nI see what you mean. My example was too simple. I've edited\
    \ the question to include a more complex example.\n<|/ c |>\n<| c |>\nI've edited\
    \ my answer to include a solution that works with your new example.\n<|/ c |>\n\
    <| c |>\nThanks for your answer. Unfortunately this doesn't work. `common(list(c(\"\
    a\",\"b\",\"c\"), c(\"a\",\"b\",\"c\")), list(c(\"a\",\"b\",\"c\"), c(\"a\",\"\
    b\",\"c\")))` returns `character(0)`\n<|/ c |>\n<| c |>\nI see what you mean.\
    \ My example was too simple. I've edited the question to include a more complex\
    \ example.\n<|/ c |>\n<| a tags=r,list |>\nYou can try the code below\n<code>\n\
    common <- function(l1, l2) {\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\ncommon\
    \ <- function(l1, l2) {\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list |>\n<| c |>\nPlease add some explanation\
    \ to your answer such that others can learn from it\n<|/ c |>\n<| c |>\nWhile\
    \ this code may answer the question, providing additional context regarding why\
    \ and/or how this code answers the question improves its long-term value.\n<|/\
    \ c |>\n<| a dscore=0 |>\n<code>\ncommon <- function(l1, l2) {\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list |>\n\
    <| c |>\nPlease add some explanation to your answer ", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,dplyr,data.table\
    \ |>\n<| c |>\nI like the `data.table` solution, but I wonder if there is a way\
    \ to avoid the double `unique` calls. I guess it could be done by `setkey`ing\
    \ `l1` and `l2` first, but that would require a lot of extra work and I'm not\
    \ sure if that would be faster than the double `unique` calls.\n<|/ c |>\n<| c\
    \ |>\nI guess it depends on how often the two lists are being compared.\n<|/ c\
    \ |>\n<| c |>\nI guess it depends on how often the two lists are being compared.\n\
    <|/ c |>\n<| c |>\nI guess it depends on how often the two lists are being compared.\n\
    <|/ c |>\n<| c |>\nI guess it depends on how often the two lists are being compared.\n\
    <|/ c |>\n<| a dscore=2 |>\nA data.table solution:\n<code>\nlibrary(data.table)\n\
    dt <- data.table(\n  a = c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"\
    h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"\
    s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"),\n  b = c(\"a\", \"b\",\
    \ \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\"\
    , \"y\", \"z\"),\n  c = c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"\
    h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"\
    s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"),\n  d = c(\"a\", \"b\",\
    \ \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\"\
    , \"y\", \"z\"),\n  e = c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"\
    h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"\
    s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"),\n  f = c(\"a\", \"b\",\
    \ \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w", "\n  u1\
    \ <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThanks for your answer. I tried your code, but I got\
    \ this error message: Error in sort.list(y) : 'x' must be atomic for 'sort.list'\n\
    Have you called 'sort' on a list?\n<|/ c |>\n<| c |>\nI edited the answer to include\
    \ a function that should work. Let me know if it works.\n<|/ c |>\n<| c |>\nThanks\
    \ for your answer. I tried your code, but I got this error message: Error in sort.list(y)\
    \ : 'x' must be atomic for 'sort.list'\nHave you called 'sort' on a list?\n<|/\
    \ c |>\n<| c |>\nI edited the answer to include a function that should work. Let\
    \ me know if it works.\n<|/ c |>\n<| c |>\nThanks for your answer. I tried your\
    \ code, but I got this error message: Error in sort.list(y) : 'x' must be atomic\
    \ for 'sort.list'\nHave you called 'sort' on a list?\n<|/ c |>\n<| a dscore=0\
    \ |>\nHere is a base R solution:\n<code>", "\n  u1 <- sort(unique(l1))\n  u2 <-\
    \ sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list |>\n<| c |>\n\
    Thanks so much for this. I ended up using something similar to your first solution,\
    \ but I used `setdiff` instead of `setdiff1d` because I wanted the output to include\
    \ only unique elements. I ended up using `setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(setdiff(set",
  "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThanks, this was helpful. I'm still trying to figure out how\
    \ to get it to work with the data frame I'm working with. I'll post my code when\
    \ I figure it out.\n<|/ c |>\n<| c |>\nI added a solution that should work with\
    \ your data.\n<|/ c |>\n<| c |>\nThanks, this was helpful. I'm still trying to\
    \ figure out how to get it to work with the data frame I'm working with. I'll\
    \ post my code when I figure it out.\n<|/ c |>\n<| c |>\nI added a solution that\
    \ should work with your data.\n<|/ c |>\n<| c |>\nThanks, this was helpful. I'm\
    \ still trying to figure out how to get it to work with the data frame I'm working\
    \ with. I'll post my code when I figure it out.\n<|/ c |>\n<| a tags=r,dplyr,dataframe\
    \ |>\nHere is a base R solution:\n<code>", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n\
    \  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list |>\n<| c |>\nThanks, this works\
    \ great! I added a little more to it for my own purposes, but this was the most\
    \ helpful.\n<|/ c |>\n<| c |>\nThis doesn't work if you have a list with NAs.\
    \ `common(list(c(NA,NA), c(NA,NA)), c(NA,NA))` returns `[1] <NA> <NA>` instead\
    \ of `[1] <NA>`.\n<|/ c |>\n<| c |>\n, thanks for pointing that out. I've updated\
    \ the answer to account for NAs.\n<|/ c |>\n<| a tags=r,list |>\nHere is a solution\
    \ using base R:\n<code>", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks, this was very\
    \ helpful.\n<|/ c |>\n<| a tags=r,dplyr |>\nHere is a solution using data.table:\n\
    <code>\nlibrary(data.table)\ndt <- data.table(\n  id = c(1,2,3,4,5,6,7,8,9,10),\n\
    \  value = c(1,2,3,4,5,6,7,8,9,10)\n)\n\ndt[, value := ifelse(value == lag(value),\
    \ NA, value), by = id]\ndt[, value := shift(value, type = \"lead\"), by = id]\n\
    dt[, value := shift(value, type = \"lag\"), by = id]\ndt[, value := shift(value,\
    \ type = \"lag\", fill = NA), by = id]\ndt[, value := shift(value, type = \"lead\"\
    , fill = NA), by = id]\ndt[, value := shift(value, type = \"lead\", fill = NA),\
    \ by = id]\ndt[, value := shift(value, type = \"lag\", fill = NA), by = id]\n\
    dt[, value := shift(value, type = \"lead\", fill = NA), by = id]\ndt[, value :=\
    \ shift(value, type = \"lead\", fill = NA), by = id]\ndt[, value := shift(value,\
    \ type = \"lag\", fill = NA), by = id]\ndt[, value := shift(value, type = \"lead\"\
    , fill = NA), by = id]\ndt[, value := shift(value, type = \"lead\", fill = NA),\
    \ by = id]\ndt[, value := shift(value, type = \"lag\", fill = NA), by = id]\n\
    dt[, value := shift(value, type = \"lead\", fill = NA), by = id]\ndt[, value :=\
    \ shift(value, type = \"lead\", fill = NA), by = id]\ndt[, value := shift(value,\
    \ type = \"lag\", fill = NA), by = id]\ndt[, value := shift(value, type = \"lead\"\
    , fill = NA), by = id]\ndt[, value := shift(value, type = \"lead\", fill = NA),\
    \ by = id]\ndt[, value := shift(value, type = \"lag\", fill = NA), by = id]\n\
    dt[, value := shift(value, type = \"lead\", fill = NA), by = id]\ndt[, value :=\
    \ shift(value, type = \"lead\", fill = NA), by = id]\ndt[, value := shift(value,\
    \ type = \"lag\", fill = NA), by = id]\ndt[, value := shift(value, type = \"lead\"\
    , fill", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u1 == u2]\n}\n", "\n\
    \  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n\
    \  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThank you for your answer! I ran the code and it returned\
    \ a list with one element (a character vector) instead of two vectors. I edited\
    \ my question to show how I ran the code and the result. Do you know why this\
    \ happened?\n<|/ c |>\n<| c |>\nI ran the code again and I got two vectors. I\
    \ edited my question to show how I ran the code and the result. Do you know why\
    \ this happened?\n<|/ c |>\n<| c |>\nI ran the code again and I got two vectors.\
    \ I edited my question to show how I ran the code and the result. Do you know\
    \ why this happened?\n<|/ c |>\n<| c |>\nI ran the code again and I got two vectors.\
    \ I edited my question to show how I ran the code and the result. Do you know\
    \ why this happened?\n<|/ c |>\n<| c |>\nI ran the code again and I got two vectors.\
    \ I edited my question to show how I ran the code and the result. Do you know\
    \ why this happened?\n<|/ c |>\n<| a tags=r |>\nWe can use %in% to create a logical\
    \ vector and use that to subset the 'df'\n<code>\ndf[df$V1 %in% df$V2, ]\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThank you for your answer! I ran the code and it returned\
    \ a list with one element (a character vector) instead of two vectors. I edited\
    \ my question to show how I ran the code and the result. Do you know why this\
    \ happened?\n<|/ c |>\n<| c |>\nI ran the code again and I got two vectors. I\
    \ edited my question to show how I ran the code and the result. Do you know why\
    \ this happened?\n<|/ c |>\n<| c |>\nI ran the code again and I got two vectors.\
    \ I edited my question to show how I ran the code and the result. Do you know\
    \ why this happened?\n<|/ c |>\n<| c |>\nI ran the code again and I got two vectors.\
    \ I edited my question to show how I ran the code and the result. Do you ", "\n\
    \  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nThis doesn't work if there are repeated elements in the lists.\n<|/ c |>\n\
    <| c |>\nYes, it does. `common(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"))`\
    \ returns `c(\"a\", \"b\", \"c\")`.\n<|/ c |>\n<| c |>\nYes, but `common(c(\"\
    a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"))` returns `c(\"a\", \"b\", \"c\")`\
    \ not `c(\"a\", \"b\", \"c\")`\n<|/ c |>\n<| c |>\nI see what you mean. I've updated\
    \ the answer accordingly.\n<|/ c |>\n<| a tags=r,list,unique |>\n<code>\n> x <-\
    \ list(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"))\n\
    > y <- list(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"\
    c\"))\n> z <- list(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"\
    b\", \"c\"))\n> \n> x <- unique(x)\n> y <- unique(y)\n> z <- unique(z)\n> \n>\
    \ x <- list(x)\n> y <- list(y)\n> z <- list(z)\n> \n> x <- unique(x)\n> y <- unique(y)\n\
    > z <- unique(z)\n> \n> x <- list(x)\n> y <- list(y)\n> z <- list(z)\n> \n> x\
    \ <- unique(x)\n> y <- unique(y)\n> z <- unique(z)\n> \n> x <- list(x)\n> y <-\
    \ list(y)\n> z <- list(z)\n> \n> x <- unique(x)\n> y <- unique(y)\n> z <- unique(z)\n\
    > \n> x <- list(x)\n> y <- list(y)\n> z <- list(z)\n> \n> x <- unique(x)\n> y\
    \ <- unique(y)\n> z <- unique(z)\n> \n> x <- list(x)\n> y <- list(y)\n> z <- list(z)\n\
    > \n> x <- unique(x)\n> y <- unique(y)\n> z <- unique(z)\n> \n> x <- list(x)\n\
    > y <- list(y)\n> z <- list(z)\n> \n> x <- unique(x)\n> y <- unique(", "\n  u1\
    \ <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't work if there are repeated\
    \ elements in the lists.\n<|/ c |>\n<| c |>\nYes, it does. Try it with `x <- c(\"\
    a\", \"a\", \"b\", \"b\", \"c\")` and `y <- c(\"a\", \"b\", \"c\", \"d\", \"e\"\
    )`.\n<|/ c |>\n<| c |>\nYes, it does. Try it with `x <- c(\"a\", \"a\", \"b\"\
    , \"b\", \"c\")` and `y <- c(\"a\", \"b\", \"c\", \"d\", \"e\")`.\n<|/ c |>\n\
    <| c |>\nYes, it does. Try it with `x <- c(\"a\", \"a\", \"b\", \"b\", \"c\")`\
    \ and `y <- c(\"a\", \"b\", \"c\", \"d\", \"e\")`.\n<|/ c |>\n<| c |>\nYes, it\
    \ does. Try it with `x <- c(\"a\", \"a\", \"b\", \"b\", \"c\")` and `y <- c(\"\
    a\", \"b\", \"c\", \"d\", \"e\")`.\n<|/ c |>\n<| a tags=r,list,unique |>\n<code>\n\
    x <- list(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"\
    ), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"\
    a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"\
    b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"\
    c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"),\
    \ c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"\
    a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"\
    b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"\
    c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"),\
    \ c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"\
    a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"\
    b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"\
    c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"),\
    \ c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"\
    a\", \"", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThanks for your answer. Your code works perfectly\
    \ for my example, but when I try it on my real data it gives me the following\
    \ error: Error in if (length(x) == 0) return(list(x)) : missing value where TRUE/FALSE\
    \ needed\n<|/ c |>\n<| c |>\nI added a line to handle empty lists.\n<|/ c |>\n\
    <| c |>\nThanks for your answer. Your code works perfectly for my example, but\
    \ when I try it on my real data it gives me the following error: Error in if (length(x)\
    \ == 0) return(list(x)) : missing value where TRUE/FALSE needed\n<|/ c |>\n<|\
    \ c |>\nI added a line to handle empty lists.\n<|/ c |>\n<| a dscore=1 |>\nHere\
    \ is a solution using data.table:\n<code>\nlibrary(data.table)\nsetDT(df)\ndf[,\
    \ list(list(sort(unique(c(sort(V1), sort(V2)))))), by = V1]\n</code>\nwhich gives:\n\
    <code>\n   V1 V2 V3\n1:  1  1  1\n2:  1  2  2\n3:  1  3  3\n4:  2  1  1\n5:  2\
    \  2  2\n6:  2  3  3\n7:  3  1  1\n8:  3  2  2\n9:  3  3  3\n</code>\n<|/ a tags=r,list,sorting\
    \ |>\n<| c |>\nThanks for your answer. Your code works perfectly for my example,\
    \ but when I try it on my real data it gives me the following error: Error in\
    \ if (length(x) == 0) return(list(x)) : missing value where TRUE/FALSE needed\n\
    <|/ c |>\n<| c |>\nI added a line to handle empty lists.\n<|/ c |>\n<| a tags=r,list,sorting\
    \ |>\nHere is a base R solution:\n<code>", "\n  u1 <- sort(unique(l1))\n  u2 <-\
    \ sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <-\
    \ sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <-\
    \ sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,sorting |>\n<| c\
    \ |>\nThis doesn't seem to work. `common(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\"\
    , \"c\", \"d\"))` returns `c(\"a\", \"b\", \"c\")`\n<|/ c |>\n<| c |>\nIt works\
    \ fine for me. `common(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\", \"d\"))`\
    \ returns `c(\"a\", \"b\", \"c\")`\n<|/ c |>\n<| c |>\nI see what you mean. Yes,\
    \ it does work. My mistake. Sorry!\n<|/ c |>\n<| a dscore=2 |>\n<code>\ncommon<-function(x,y){\n\
    \  u<-sort(unique(x))\n  v<-sort(unique(y))\n  u[v==u]\n}\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| a tags=r,sorting |>\n<code>\ncommon<-function(x,y){\n  u<-sort(unique(x))\n\
    \  v<-sort(unique(y))\n  u[v==u]\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1\
    \ |>\n<code>\ncommon<-function(x,y){\n  u<-sort(unique(x))\n  v<-sort(unique(y))\n\
    \  u[v==u]\n}\n</code>\n<|/ a tags=r,sorting |>\n<| a dscore=1 |>\n<code>\ncommon<-function(x,y){\n\
    \  u<-sort(unique(x))\n  v<-sort(unique(y))\n  u[v==u]\n}\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| a |>\n<code>\ncommon<-function(x,y){\n  u<-sort(unique(x))\n  v<-sort(unique(y))\n\
    \  u[v==u]\n}\n</code>\n<|/ a tags=r,sorting dscore=1 |>\n<| a dscore=1 |>\n<code>\n\
    common<-function(x,y){\n  u<-sort(unique(x))\n  v<-sort(unique(y))\n  u[v==u]\n\
    }\n</code>\n<|/ a tags=r,sorting |>\n<| a dscore=1 |>\n<code>\ncommon<-function(x,y){\n\
    \  u<-sort(unique(x))\n  v<-sort(unique(y))\n  u[v==", "\n  u1 <- unique(l1)\n\
    \  u2 <- unique(l2)\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <-\
    \ sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n\
    <| c |>\nThanks so much! This was really helpful.\n<|/ c |>\n<| a dscore=2 |>\n\
    Here is a solution using data.table:\n<code>\nlibrary(data.table)\ndt <- data.table(list1\
    \ = list(c(\"a\", \"b\", \"c\"), c(\"d\", \"e\", \"f\"), c(\"g\", \"h\", \"i\"\
    )), list2 = list(c(\"a\", \"b\", \"c\"), c(\"d\", \"e\", \"f\"), c(\"g\", \"h\"\
    , \"i\")))\ndt[, list1 := lapply(list1, unique), list2]\ndt[, list2 := lapply(list2,\
    \ unique), list1]\ndt[, list1 := lapply(list1, sort), list2]\ndt[, list2 := lapply(list2,\
    \ sort), list1]\ndt[, list1 := lapply(list1, sort), list2]\ndt[, list2 := lapply(list2,\
    \ sort), list1]\ndt[, list1 := lapply(list1, sort), list2]\ndt[, list2 := lapply(list2,\
    \ sort), list1]\ndt[, list1 := lapply(list1, sort), list2]\ndt[, list2 := lapply(list2,\
    \ sort), list1]\ndt[, list1 := lapply(list1, sort), list2]\ndt[, list2 := lapply(list2,\
    \ sort), list1]\ndt[, list1 := lapply(list1, sort), list2]\ndt[, list2 := lapply(list2,\
    \ sort), list1]\ndt[, list1 := lapply(list1, sort), list2]\ndt[, list2 := lapply(list2,\
    \ sort), list1]\ndt[, list1 := lapply(list1, sort), list2]\ndt[, list2 := lapply(list2,\
    \ sort), list1]\ndt[, list1 := lapply(list1, sort), list2]\ndt[, list2 := lapply(list2,\
    \ sort), list1]\ndt[, list1 := lapply(list1, sort), list2]\ndt[, list2 := lapply(list2,\
    \ sort), list1]\ndt[, list1 := lapply(list1, sort), list2]\ndt[, list2 := lapply(list2,\
    \ sort), list1]\ndt[, list1 := lapply(list1, sort), list2]", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| a dscore=2 |>\n<code>\nlibrary(data.table)\nlibrary(dplyr)\n", "\n  u1\
    \ <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1\
    \ <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis doesn't seem to work. `common(list(\"a\", \"\
    b\", \"c\"), list(\"a\", \"b\", \"c\"))` returns `[1] \"a\" \"b\"`\n<|/ c |>\n\
    <| c |>\nI tested it on R 3.2.2 and it works. I guess you have a different version\
    \ of R or different version of data.table. Try `sort(unique(c(\"a\", \"b\", \"\
    c\")))`\n<|/ c |>\n<| c |>\nI tested it on R 3.2.2 and it works. I guess you have\
    \ a different version of R or different version of data.table. Try `sort(unique(c(\"\
    a\", \"b\", \"c\")))`\n<|/ c |>\n<| c |>\nI tested it on R 3.2.2 and it works.\
    \ I guess you have a different version of R or different version of data.table.\
    \ Try `sort(unique(c(\"a\", \"b\", \"c\")))`\n<|/ c |>\n<| c |>\nI tested it on\
    \ R 3.2.2 and it works. I guess you have a different version of R or different\
    \ version of data.table. Try `sort(unique(c(\"a\", \"b\", \"c\")))`\n<|/ c |>\n\
    <| a dscore=0 |>\nI came up with this solution:\n<code>", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nThanks for the answer. Can you please explain how this works?\n<|/ c |>\n\
    <| c |>\nI added some explanation.\n<|/ c |>\n<| c |>\nThanks for the explanation.\
    \ Can you please explain how this works?\n<|/ c |>\n<| c |>\nI added some explanation.\n\
    <|/ c |>\n<| c |>\nThanks for the explanation. Can you please explain how this\
    \ works?\n<|/ c |>\n<| a dscore=1 |>\nHere is a solution using data.table:\n<code>\n\
    library(data.table)", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,dplyr,data.table |>\n<| c |>\nThanks\
    \ for your answer. Your code works fine for small datasets, but it takes too long\
    \ for my dataset. My dataset has more than 1 million rows and more than 1 million\
    \ columns. Do you think it would be possible to speed up the process?\n<|/ c |>\n\
    <| c |>\nI added a data.table solution that should be much faster.\n<|/ c |>\n\
    <| c |>\nThanks for your answer. Your code works fine for small datasets, but\
    \ it takes too long for my dataset. My dataset has more than 1 million rows and\
    \ more than 1 million columns. Do you think it would be possible to speed up the\
    \ process?\n<|/ c |>\n<| c |>\nI added a data.table solution that should be much\
    \ faster.\n<|/ c |>\n<| c |>\nThanks for your answer. Your code works fine for\
    \ small datasets, but it takes too long for my dataset. My dataset has more than\
    \ 1 million rows and more than 1 million columns. Do you think it would be possible\
    \ to speed up the process?\n<|/ c |>\n<| a dscore=1 |>\nHere is a data.table solution:\n\
    <code>\nlibrary(data.table)\ndt <- data.table(\n  id = 1:1e6,\n  a = sample(1:1e6,\
    \ 1e6, replace = TRUE),\n  b = sample(1:1e6, 1e6, replace = TRUE),\n  c = sample(1:1e6,\
    \ 1e6, replace = TRUE),\n  d = sample(1:1e6, 1e6, replace = TRUE),\n  e = sample(1:1e6,\
    \ 1e6, replace = TRUE),\n  f = sample(1:1e6, 1e6, replace = TRUE),\n  g = sample(1:1e6,\
    \ 1e6, replace = TRUE),\n  h = sample(1:1e6, 1e6, replace = TRUE),\n  i = sample(1:1e6,\
    \ 1e6, replace = TRUE),\n  j = sample(1:1e6, 1e6, replace = TRUE),\n  k = sample(1:1e6,\
    \ 1e6, replace = TRUE),\n  l = sample(1:1e6, 1e6, replace = TRUE),\n  m = sample(1:1e6,\
    \ 1e6, replace = TRUE),\n  n = sample(1:1e6, 1e6, replace = TRUE),\n  o = sample(1:1e6,\
    \ 1e6, replace = TRUE),\n  p = sample(1:1e6, 1e6, replace = TRUE),\n  q = sample(1:1e6,\
    \ 1e6, replace = TRUE),\n  ", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work if\
    \ there are duplicate values in either list.\n<|/ c |>\n<| c |>\nYes, it does.\
    \ I tested it before posting it.\n<|/ c |>\n<| c |>\nI tested it before posting\
    \ it, and it does work. Try it yourself.\n<|/ c |>\n<| c |>\nIt does work, but\
    \ it's very inefficient. You're sorting the entire list twice, once to remove\
    \ duplicates, then to find the common elements. Sorting twice is very inefficient.\n\
    <|/ c |>\n<| c |>\nI tested it before posting it, and it does work. Try it yourself.\n\
    <|/ c |>\n<| a dscore=1 |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    setDT(list1)\nsetDT(list2)\nlist1[list2, on=names(list1), nomatch=0]\n</code>\n\
    <|/ a tags=r,list |>\n<| a dscore=0 |>\nHere's a solution using base R:\n<code>\n\
    list1 <- list(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\",\
    \ \"c\"))\nlist2 <- list(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"\
    a\", \"b\", \"c\"))\n\nlist1[list2 %in% names(list1)]\n</code>\n<|/ a tags=r,list\
    \ |>\n<| a tags=r,list |>\nHere's a solution using base R:\n<code>\nlist1 <- list(c(\"\
    a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"))\nlist2 <-\
    \ list(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"))\n\
    \nlist1[list2 %in% names(list1)]\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n\
    Here's a solution using dplyr and purrr:\n<code>\nlist1 <- list(c(\"a\", \"b\"\
    , \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"))\nlist2 <- list(c(\"\
    a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"))\n\nlibrary(dplyr)\n\
    library(purrr)\n\nlist1 %>% \n  map(~setNames(.x, .y) %>% \n          map(", "\n\
    \  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n\
    \  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,sorting |>\n\
    <| c |>\nThis doesn't work if there are duplicates in the lists.\n<|/ c |>\n<|\
    \ c |>\nYes, it does. I added a note about that to the answer.\n<|/ c |>\n<| c\
    \ |>\nI added a note about that to the answer.\n<|/ c |>\n<| c |>\nI added a note\
    \ about that to the answer.\n<|/ c |>\n<| c |>\nI added a note about that to the\
    \ answer.\n<|/ c |>\n<| a dscore=4 |>\n<code>\n> sort(unique(sort(c(1,3,5,7,9))))\n\
    [1] 1 3 5 7 9\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis doesn't work if\
    \ there are duplicates in the lists.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ there are duplicates in the lists.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ there are duplicates in the lists.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ there are duplicates in the lists.\n<|/ c |>\n<| a dscore=4 |>\n<code>\nsort(unique(sort(c(1,3,5,7,9))))\n\
    [1] 1 3 5 7 9\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis doesn't work if\
    \ there are duplicates in the lists.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ there are duplicates in the lists.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ there are duplicates in the lists.\n<|/ c |>\n<| a tags=r,sorting |>\n<code>\n\
    sort(unique(sort(c(1,3,5,7,9))))\n[1] 1 3 5 7 9\n</code>\n<|/ a dscore=4 |>\n\
    <| c |>\nThis doesn't work if there are duplicates in the lists.\n<|/ c |>\n<|\
    \ a dscore=4 |>\n<code>\nsort(unique(sort(c(1,3,5,7,9))))\n[1] 1 3 5 7 9\n</code>\n\
    <|/ a tags=r,sorting |>\n<| c |>\nThis doesn't work if there are duplicates in\
    \ the lists.\n<|/ c |>\n<| a dscore=3 |>\n<code>\nsort(unique(sort(c(1,3,5,7,9))))\n\
    [1] 1 3 5 7 9\n</code>\n<|/ a tags=r,sorting |>\n", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nThis doesn't work if there are duplicates in the lists. For example, `common\
    \ <- function(l1, l2) {\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}` returns `[1] \"a\" \"b\" \"c\"` when `l1 <- c(\"a\", \"b\"\
    , \"a\", \"c\", \"c\")` and `l2 <- c(\"a\", \"b\", \"a\", \"c\", \"c\")`.\n<|/\
    \ c |>\n<| c |>\nYes, that's true. I've added a solution that doesn't require\
    \ duplicates but is less efficient.\n<|/ c |>\n<| a dscore=2 |>\nA solution using\
    \ data.table:\n<code>\nlibrary(data.table)\nsetDT(df1)[, setDT(df2), on=names(df1),\
    \ nomatch=0][, \n    list(common=names(df1[df2==names(df1)])), by=names(df1)]\n\
    </code>\nwhich gives:\n<code>\n   names(df1) common\n1:         a     a\n2:  \
    \       b     b\n3:         c     c\n</code>\n<|/ a tags=r,list,compare |>\n<|\
    \ a dscore=2 |>\nHere's a solution using base R:\n<code>", "\n  u1 <- unique(l1)\n\
    \  u2 <- unique(l2)\n  u1[u2 %in% u1]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2\
    \ <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2\
    \ <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2\
    \ <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't\
    \ seem to work if there are repeated elements in the list. For example, `x <-\
    \ list(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"))`\
    \ returns `[1] \"c\"` instead of `[1] \"a\" \"b\" \"c\"`.\n<|/ c |>\n<| c |>\n\
    Yes, I noticed that and fixed it (now it works). Thanks for pointing that out.\n\
    <|/ c |>\n<| a tags=r,list,unique |>\n<code>\nx <- list(c(\"a\", \"b\", \"c\"\
    ), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"))\ny <- list(c(\"a\", \"b\",\
    \ \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"))\nz <- list(c(\"a\",\
    \ \"b\", \"c\"), c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"c\"))\n</code>\nThe\
    \ first two answers here are correct but they don't work if there are repeated\
    \ elements in the list. For example, x <- list(c(\"a\", \"b\", \"c\"), c(\"a\"\
    , \"b\", \"c\"), c(\"a\", \"b\", \"c\")) returns [1] \"c\" instead of [1] \"a\"\
    \ \"b\" \"c\".\nThe third answer here works but is very slow for large lists.\n\
    <code>", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n</code>\n<|/ a |>\n<| c |>\nI like the `common` function but I think it would\
    \ be better to sort `l1` and `l2` before calling `common` because `common` will\
    \ sort the input vectors anyway.\n<|/ c |>\n<| c |>\nI agree. I just wanted to\
    \ show that `common` can be easily modified to work with unsorted lists.\n<|/\
    \ c |>\n<| a tags=r |>\nA base R option with intersect\n<code>\n> intersect(sort(c(1,3,5,7)),\
    \ sort(c(1,3,5,7)))\n[1] 1 3 5 7\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis should\
    \ be the accepted answer. `intersect` will work with unsorted lists.\n<|/ c |>\n\
    <| a tags=r |>\n<code>\n> x <- c(1,3,5,7)\n> y <- c(1,3,5,7)\n> x[x %in% y]\n\
    [1] 1 3 5 7\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis should be the accepted\
    \ answer. `%in%` will work with unsorted lists.\n<|/ c |>\n<| a dscore=5 |>\n\
    <code>\n> x <- c(1,3,5,7)\n> y <- c(1,3,5,7)\n> x[x %in% y]\n[1] 1 3 5 7\n</code>\n\
    <|/ a tags=r |>\n<| c |>\nThis should be the accepted answer. `%in%` will work\
    \ with unsorted lists.\n<|/ c |>\n<| a tags=r |>\n<code>\nx <- c(1,3,5,7)\ny <-\
    \ c(1,3,5,7)\nx[x %in% y]\n[1] 1 3 5 7\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    This should be the accepted answer. `%in%` will work with unsorted lists.\n<|/\
    \ c |>\n<| a dscore=5 |>\n<code>\nx <- c(1,3,5,7)\ny <- c(1,3,5,7)\nx[x %in% y]\n\
    [1] 1 3 5 7\n</code>\n<|/ a tags=r |>\n<| a tags=r |>\n<code>\nx <- c(1,3,5,7)\n\
    y <- c(1,3,5,7)\nx[x %in% y]\n[1] 1 3 5 7\n", "\n  u1 <- sort(unique(l1))\n  u2\
    \ <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2\
    \ <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\n\
    A solution using data.table:\n<code>\nlibrary(data.table)\ndt <- data.table(\n\
    \  a = c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"\
    , \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\"),\n  b = c(\"a\", \"b\", \"c\", \"d\", \"\
    e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"),\n\
    \  c = c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"\
    , \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\"),\n  d = c(\"a\", \"b\", \"c\", \"d\", \"\
    e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"),\n\
    \  e = c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"\
    , \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\"),\n  f = c(\"a\", \"b\", \"c\", \"d\", \"\
    e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"),\n\
    \  g = c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"\
    , \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\"),\n  h = c(\"a\", \"b\", \"c\", \"d\", \"\
    e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"),\n\
    \  i = c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"\
    , \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\"),\n  j = c(\"a\", \"b\", \"c\", \"d\", \"\
    e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"", "\n \
    \ u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a tags=r,dataframe |>\n<| c |>\nThanks for your answer. However I do not want\
    \ to use any packages. I already have a function which does this but I want to\
    \ know if there is a way to do it without using any packages.\n<|/ c |>\n<| c\
    \ |>\nI added a solution without packages.\n<|/ c |>\n<| c |>\nThanks for your\
    \ answer. However I do not want to use any packages. I already have a function\
    \ which does this but I want to know if there is a way to do it without using\
    \ any packages.\n<|/ c |>\n<| c |>\nI added a solution without packages.\n<|/\
    \ c |>\n<| c |>\nThanks for your answer. However I do not want to use any packages.\
    \ I already have a function which does this but I want to know if there is a way\
    \ to do it without using any packages.\n<|/ c |>\n<| a dscore=1 |>\nWe can use\
    \ data.table.  Convert the 'data.frame' to 'data.table' (setDT(df1)), grouped\
    \ by 'ID', get the unique elements of 'ID' with unique, get the intersection of\
    \ the two 'ID' columns with intersect and get the rows of 'df1' with .SD\n<code>\n\
    library(data.table)\nsetDT(df1)[, list(ID = intersect(ID, unique(ID))) , by =\
    \ ID]\n</code>\n<|/ a tags=r,dataframe |>\n<| a dscore=1 |>\nHere is a solution\
    \ using dplyr and purrr packages:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\n\
    df1 %>%\n  group_by(ID) %>%\n  summarise(ID = intersect(ID, unique(ID)))\n</code>\n\
    Output:\n<code>", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1\
    \ == u2]\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your answer! I actually\
    \ tried this before and got this error: `Error in sort.list(y) : 'x' must be atomic\
    \ for 'sort.list'\nHave you called 'sort' on a list?`\n<|/ c |>\n<| c |>\nI edited\
    \ the answer to include a function that should work. Let me know if it works.\n\
    <|/ c |>\n<| c |>\nThanks for your answer! I tried it but still get the same error:\
    \ `Error in sort.list(y) : 'x' must be atomic for 'sort.list'\nHave you called\
    \ 'sort' on a list?`\n<|/ c |>\n<| c |>\nI edited the answer to include a function\
    \ that should work. Let me know if it works.\n<|/ c |>\n<| c |>\nThanks for your\
    \ answer! I tried it but still get the same error: `Error in sort.list(y) : 'x'\
    \ must be atomic for 'sort.list'\nHave you called 'sort' on a list?`\n<|/ c |>\n\
    <| a dscore=0 |>\nHere is a solution that works on my machine:\n<code>\nlibrary(dplyr)\n",
  "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\nHere is a solution that is more efficient\
    \ than using setdiff and sorting the unique elements. \n<code>", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nThanks for your answer. Could you please explain why you use `sort` here?\
    \ I thought `unique` already sorts the elements?\n<|/ c |>\n<| c |>\n`unique`\
    \ does not sort the elements. `unique` returns a vector with unique elements.\
    \ `sort` sorts the unique elements. `sort` returns a vector with sorted unique\
    \ elements. `unique` returns a vector with unique elements. `sort` returns a vector\
    \ with sorted unique elements.\n<|/ c |>\n<| c |>\nThanks for your explanation.\
    \ Could you please explain why you use `sort` here? I thought `unique` already\
    \ sorts the elements?\n<|/ c |>\n<| c |>\n`sort` sorts the unique elements. `sort`\
    \ returns a vector with sorted unique elements. `unique` returns a vector with\
    \ unique elements. `sort` returns a vector with sorted unique elements.\n<|/ c\
    \ |>\n<| c |>\nThanks for your explanation. Could you please explain why you use\
    \ `sort` here? I thought `unique` already sorts the elements?\n<|/ c |>\n<| a\
    \ dscore=1 |>\nHere is a solution that uses data.table:\n<code>\nlibrary(data.table)\n\
    setDT(df)\ndf[, n := .N, by = .(id, group)]\ndf[, n := n[n > 1], by = .(id, group)]\n\
    df[, n := n[n > 1], by = .(id, group)]\ndf[, n := n[n > 1], by = .(id, group)]\n\
    df[, n := n[n > 1], by = .(id, group)]\ndf[, n := n[n > 1], by = .(id, group)]\n\
    df[, n := n[n > 1], by = .(id, group)]\ndf[, n := n[n > 1], by = .(id, group)]\n\
    df[, n := n[n > 1], by = .(id, group)]\ndf[, n := n[n > 1], by = .(id, group)]\n\
    df[, n := n[n > 1], by = .(id, group)]\ndf[, n := n[n > 1], by = .(id, group)]\n\
    df[, n := n[n > 1], by = .(id, group)]\ndf[, n := n[n > 1], by = .(id, group",
  "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,dplyr,data.table,tidyverse\
    \ |>\n<| c |>\nThanks for your answer! I like your approach of using setdiff to\
    \ find the common elements. However, I believe this approach would not work if\
    \ there are repeated elements in the lists. For example, `common(c(\"a\", \"b\"\
    , \"c\"), c(\"a\", \"b\", \"c\", \"d\"))` would return `c(\"a\", \"b\", \"c\"\
    )` instead of `c(\"a\", \"b\", \"c\", \"d\")`.\n<|/ c |>\n<| c |>\nI see. Thanks\
    \ for pointing that out. I've updated my answer to account for repeated elements.\n\
    <|/ c |>\n<| a tags=r,dplyr,data.table,tidyverse |>\nHere's a data.table approach:\n\
    <code>\nlibrary(data.table)\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your answer!\
    \ I actually tried this before but for some reason it didn't work. Now I tried\
    \ it again and it worked. Thanks again!\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ if there are duplicates in either of the lists.\n<|/ c |>\n<| a dscore=2 |>\n\
    A simple and efficient solution is to use setdiff:\n<code>\nsetdiff(list1, list2)\n\
    </code>\n<|/ a tags=r |>\n<| c |>\nThis doesn't work if there are duplicates in\
    \ either of the lists.\n<|/ c |>\n<| a tags=r |>\nI came up with a solution that\
    \ uses setdiff and lapply.\n<code>", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n\
    \  u1[u1 == u2]\n}\n", "\n  u1 <- unique(l1)\n  u2 <- unique(l2)\n  u1[u1 == u2]\n\
    }\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for your answer. I'm sorry I didn't\
    \ make it clear enough in my question. My question was about how to get the common\
    \ elements between two lists while keeping the order of the lists. I edited my\
    \ question to make it clearer.\n<|/ c |>\n<| c |>\nI edited my answer to include\
    \ a function that should do what you want.\n<|/ c |>\n<| c |>\nThanks for your\
    \ answer. I'm sorry I didn't make it clear enough in my question. My question\
    \ was about how to get the common elements between two lists while keeping the\
    \ order of the lists. I edited my question to make it clearer.\n<|/ c |>\n<| c\
    \ |>\nI edited my answer to include a function that should do what you want.\n\
    <|/ c |>\n<| a tags=r |>\nYou can use the function intersect from the dplyr package:\n\
    <code>\nlibrary(dplyr)\n\nlist1 <- list(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\"\
    , \"d\"), c(\"a\", \"b\", \"e\"))\nlist2 <- list(c(\"a\", \"b\", \"c\"), c(\"\
    a\", \"b\", \"d\"), c(\"a\", \"b\", \"e\"))\n\nintersect(list1, list2)\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThanks for your answer. I'm sorry I didn't make it\
    \ clear enough in my question. My question was about how to get the common elements\
    \ between two lists while keeping the order of the lists. I edited my question\
    \ to make it clearer.\n<|/ c |>\n<| a tags=r |>\nYou can use the function intersect\
    \ from the dplyr package:\n<code>\nlibrary(dplyr)\n\nlist1 <- list(c(\"a\", \"\
    b\", \"c\"), c(\"a\", \"b\", \"d\"), c(\"a\", \"b\", \"e\"))\nlist2 <- list(c(\"\
    a\", \"b\", \"c\"), c(\"a\", \"b\", \"d\"), c(\"a\", \"b\", \"e\"))\n\nintersect(list1,\
    \ list2)\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nWe can use intersect from\
    \ base R\n<code>\nlist1 <- list(c(\"a\", \"b\", \"c\"), c(\"a\", \"b\", \"d\"\
    ), c(\"a\", \"b\", \"e\"))\nlist2 <- list(c(\"a\", \"b\", \"c\"), c(\"a\", \"\
    b\", \"d\"), c(\"a\", \"b\", \"e\"))\nintersect(list1, list2)\n</code>\n<|/ a\
    \ tags=r |>\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1\
    \ == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1\
    \ == u2]\n}\n</code>\n<|/ a tags=r,dplyr |>\n<| c |>\nThis doesn't seem to work\
    \ if there are NA's in the data.\n<|/ c |>\n<| c |>\nI added a solution that doesn't\
    \ require NA's.\n<|/ c |>\n<| a dscore=2 |>\nWe can use data.table\n<code>\nlibrary(data.table)\n\
    setDT(df)[, list(common = sort(unique(unlist(.SD))), .SDcols = patterns(\"^X\"\
    ))]\n</code>\n<|/ a tags=r,dplyr |>\n<| a tags=r,dplyr |>\nWe can use base R function\
    \ intersect\n<code>\ndf$common <- sort(unique(unlist(df)))\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 |>\nWe can use tidyverse to achieve this -\n<code>\nlibrary(dplyr)\n\
    \ndf %>%\n  group_by(X) %>%\n  summarise(common = sort(unique(unlist(.)))) %>%\n\
    \  ungroup()\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1\
    \ == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1\
    \ == u2]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThis doesn't seem to work. `common(list(c(\"\
    a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"\
    n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"),\
    \ c(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"\
    m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"\
    z\")), list(c(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\"\
    ,\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\"\
    ,\"y\",\"z\")))` returns `c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"\
    h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"\
    s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\")` instead of `c(\"a\", \"\
    b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"\
    m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"\
    x\", \"y\", \"z\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"\
    i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"\
    t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\")`\n<|/ c |>\n<| c |>\nI see what\
    \ you mean. `common` should return `c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"\
    , \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"a\", \"b\"\
    , \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\"\
    , \"y\", \"z\")` but instead returns `c(\"a\", \"b\", \"c\", \"d\", \"e\", \"\
    f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"\
    q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"a\", \"\
    b\", \"", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  commons <-\
    \ intersect(u1, u2)\n  return(commons)\n}\n", "\n  u1 <- sort(unique(l1))\n  u2\
    \ <- sort(unique(l2))\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(l1))\n  u2\
    \ <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,dataframe |>\n\
    <| c |>\nThanks so much for this. I used the code above and got this error `Error\
    \ in sort.list(y) : 'x' must be atomic for 'sort.list'\nHave you called 'sort'\
    \ on a list?`\n<|/ c |>\n<| c |>\nI added a line to my answer to fix the error.\n\
    <|/ c |>\n<| c |>\nThanks so much! I ran the code again and got this error `Error\
    \ in sort.list(y) : 'x' must be atomic for 'sort.list'\nHave you called 'sort'\
    \ on a list?`\n<|/ c |>\n<| c |>\nI added a line to my answer to fix the error.\n\
    <|/ c |>\n<| c |>\nThanks so much! I ran the code again and got this error `Error\
    \ in sort.list(y) : 'x' must be atomic for 'sort.list'\nHave you called 'sort'\
    \ on a list?`\n<|/ c |>\n<| a tags=r,dataframe |>\nHere's a solution using dplyr\
    \ and tidyr. \n<code>\nlibrary(dplyr)\nlibrary(tidyr)\n", "\n  u1 <- sort(unique(l1))\n\
    \  u2 <- sort(unique(l2))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\n\
    This doesn't work if there are duplicates in the list. For example, `common <-\
    \ function(l1, l2) {\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1\
    \ == u2]\n}\n\ncommon(c(1,2,3), c(1,2,3))` returns `[1] 1 2 3` instead of `[1]\
    \ 1 3`\n<|/ c |>\n<| c |>\nI see your point. I've edited my answer to account\
    \ for that case.\n<|/ c |>\n<| c |>\nI believe this should now be the accepted\
    \ answer. Thanks for your contribution.\n<|/ c |>\n<| a tags=r |>\n<code>\nlibrary(dplyr)\n\
    library(purrr)\n", "\n  u1 <- sort(unique(l1))\n  u2 <- sort(unique(l2))\n  u1[u1\
    \ == u2]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThanks for your answer! I edited\
    \ my question to make it more clear. Sorry for the confusion.\n<|/ c |>\n<| c\
    \ |>\nI edited my answer to include a solution for your updated question.\n<|/\
    \ c |>\n<| c |>\nThanks for your answer! I edited my question to make it more\
    \ clear. Sorry for the confusion.\n<|/ c |>\n<| c |>\nI edited my answer to include\
    \ a solution for your updated question.\n<|/ c |>\n<| c |>\nThanks for your answer!\
    \ I edited my question to make it more clear. Sorry for the confusion.\n<|/ c\
    \ |>\n<| a tags=r |>\n<code>"]
stop_tokens:
- "\n#"
- "\n```"
