name: HumanEval_115_max_fill
language: js
prompt: "//You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n// and each 1 in a row represents a single unit of water.\n// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n// and\
  \ all buckets have the same capacity.\n// Your task is to use the buckets to empty\
  \ the wells.\n// Output the number of times you need to lower the buckets.\n// Example\
  \ 1:\n// >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n// 6\n// Example\
  \ 2:\n// >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
  \ 2)\n// 5\n// Example 3:\n// >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n// 0\n//\
  \ Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n\
  // * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity\
  \ <= 10\nfunction max_fill(grid, capacity){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1,\
  \ 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1,\
  \ 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0,\
  \ 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n\
  \  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();"
completions: ["  let max = 0;\n  for(let i = 0; i < grid.length; i++){\n    for(let\
    \ j = 0; j < grid[i].length; j++){\n      let count = 0;\n      while(grid[i][j]\
    \ === 1){\n        count++;\n        grid[i][j] = 0;\n      }\n      max = Math.max(max,\
    \ count);\n    }\n  }\n  return max;\n}\n", "    let max = 0;\n    for(let i =\
    \ 0; i < grid.length; i++){\n        let curr = 0;\n        for(let j = 0; j <\
    \ grid[i].length; j++){\n            if(grid[i][j] == 1){\n                curr\
    \ += 1;\n            }\n            if(curr > max){\n                max = curr;\n\
    \            }\n        }\n    }\n    let count = 0;\n    while(max > 0){\n  \
    \      count += 1;\n        let curr = 0;\n        for(let i = 0; i < grid.length;\
    \ i++){\n            let curr_row = 0;\n            for(let j = 0; j < grid[i].length;\
    \ j++){\n                if(grid[i][j] == 1){\n                    curr_row +=\
    \ 1;\n                }\n                if(curr_row > max){\n               \
    \     max = curr_row;\n                }\n            }\n        }\n    }\n  \
    \  return count;\n}\n", "    let max = 0;\n    for(let i = 0; i < grid.length;\
    \ i++){\n        for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j]\
    \ == 1){\n                let count = 0;\n                let left = grid[i][j];\n\
    \                while(left > 0){\n                    count++;\n            \
    \        left -= capacity;\n                }\n                max = Math.max(max,\
    \ count);\n            }\n        }\n    }\n    return max;\n}\n", "    let well_count\
    \ = 0;\n    let well_index = 0;\n    let well_length = grid[0].length;\n    let\
    \ well_capacity = capacity;\n    let well_water = 0;\n    let well_water_count\
    \ = 0;\n    let well_water_index = 0;\n    let well_water_length = 0;\n    let\
    \ well_water_capacity = 0;\n    let well_water_water = 0;\n    let well_water_water_count\
    \ = 0;\n    let well_water_water_index = 0;\n    let well_water_water_length =\
    \ 0;\n    let well_water_water_capacity = 0;\n    for(let i = 0; i < grid.length;\
    \ i++){\n        for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j]\
    \ === 1){\n                well_count++;\n                well_index = i;\n  \
    \              well_length = j;\n                well_capacity = capacity;\n \
    \               well_water = 0;\n                well_water_count = 0;\n     \
    \           well_water_index = i;\n                well_water_length = j;\n  \
    \              well_water_capacity = capacity;\n                well_water_water\
    \ = 0;\n                well_water_water_count = 0;\n                well_water_water_index\
    \ = i;\n                well_water_water_length = j;\n                well_water_water_capacity\
    \ = capacity;\n            }\n        }\n    }\n    let max_fill = 0;\n    while(well_water_count\
    \ > 0){\n        well_water_count--;\n        well_water_water_count--;\n    \
    \    well_water_water_capacity--;\n        well_water_water_index++;\n       \
    \ well_water_water_length++;\n        well_water_water_length++;\n        well_water_water_length++;\n\
    \        well_water_water_length++;\n        well_water_water_length++;\n    \
    \    well_water_water_length++;\n        well_water_water_length++;\n        well_water_water_length++;\n\
    \        well_water_water_length++;\n        well_water_water_length", "    let\
    \ max = 0;\n    let count = 0;\n    for(let i = 0; i < grid.length; i++){\n  \
    \      for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j] ===\
    \ 1){\n                count++;\n                if(count === capacity){\n   \
    \                 max++;\n                    count = 0;\n                }\n\
    \            }\n        }\n    }\n    return max;\n}\n", "    let max = 0;\n \
    \   for(let i = 0; i < grid.length; i++){\n        let row = grid[i];\n      \
    \  let buckets = [];\n        for(let j = 0; j < row.length; j++){\n         \
    \   let well = row[j];\n            if(well === 1){\n                let bucket\
    \ = Math.min(buckets.length, capacity);\n                if(bucket > 0){\n   \
    \                 buckets.splice(bucket - 1, 0, 1);\n                }\n     \
    \       }\n            else{\n                buckets.push(0);\n            }\n\
    \        }\n        max = Math.max(max, buckets.reduce((a, b) => a + b));\n  \
    \  }\n    return max;\n}\n", "  let buckets = [],\n      wells = grid.map(row\
    \ => row.map(well => well === 1)),\n      wells_count = wells.length,\n      wells_capacity\
    \ = wells.reduce((acc, curr) => acc + curr.length, 0),\n      wells_filled = wells.reduce((acc,\
    \ curr) => acc + curr.reduce((acc, well) => well === 1, 0), 0);\n\n  while(wells_filled\
    \ < wells_count){\n    let curr_bucket = wells_filled / wells_capacity;\n    let\
    \ curr_well = wells_filled % wells_capacity;\n    let curr_well_filled = wells[wells_filled];\n\
    \    let curr_well_capacity = curr_well_filled.length;\n    let curr_well_filled_count\
    \ = curr_well_filled.reduce((acc, well) => acc + well === 1, 0);\n\n    if(curr_well_filled_count\
    \ < curr_well_capacity){\n      wells[wells_filled] = curr_well_filled.concat(curr_well_filled_count\
    \ + 1);\n      wells_filled += 1;\n    } else {\n      wells[wells_filled] = curr_well_filled.concat(curr_well_capacity);\n\
    \      wells_filled += 1;\n      wells[wells_filled] = curr_well_filled.concat(curr_well_filled_count\
    \ - curr_well_capacity);\n      wells_filled += 1;\n    }\n  }\n\n  let filled_wells\
    \ = wells.reduce((acc, curr) => acc + curr.reduce((acc, well) => well === 1, 0),\
    \ 0);\n  let filled_buckets = filled_wells / wells_capacity;\n  let filled_buckets_count\
    \ = filled_buckets.reduce((acc, bucket) => acc + bucket, 0);\n\n  return filled_buckets_count;\n\
    }\n", "  var well_count = grid.length;\n  var well_length = grid[0].length;\n\
    \  var well_capacity = capacity;\n  var well_water = 0;\n  var well_bucket = 0;\n\
    \  var well_bucket_count = 0;\n  var well_water_count = 0;\n  var well_water_bucket_count\
    \ = 0;\n  var well_water_bucket_count_max = 0;\n  var well_water_bucket_count_max_index\
    \ = 0;\n  var well_water_bucket_count_max_index_index = 0;\n  var well_water_bucket_count_max_index_value\
    \ = 0;\n  var well_water_bucket_count_max_index_value_index = 0;\n  var well_water_bucket_count_max_index_value_value\
    \ = 0;\n  for(var i = 0; i < well_count; i++){\n    for(var j = 0; j < well_length;\
    \ j++){\n      if(grid[i][j] == 1){\n        well_water += 1;\n        well_bucket\
    \ += 1;\n        well_bucket_count += 1;\n        well_water_bucket_count += 1;\n\
    \        if(well_water_bucket_count > well_water_bucket_count_max){\n        \
    \  well_water_bucket_count_max = well_water_bucket_count;\n          well_water_bucket_count_max_index\
    \ = i;\n          well_water_bucket_count_max_index_index = j;\n          well_water_bucket_count_max_index_value\
    \ = well_water;\n          well_water_bucket_count_max_index_value_index = i;\n\
    \          well_water_bucket_count_max_index_value_value = j;\n        }\n   \
    \   }\n    }\n  }\n  well_water_bucket_count_max_index_value_value = well_water_bucket_count_max_index_value_value;\n\
    \  well_water_bucket_count_max_index_value_index = well_water_", "    let max\
    \ = 0;\n    for(let i = 0; i < grid.length; i++){\n        let buckets = grid[i].length;\n\
    \        let filled = 0;\n        for(let j = 0; j < buckets; j++){\n        \
    \    if(grid[i][j] == 1){\n                filled++;\n            }\n        \
    \    if(filled >= capacity){\n                max++;\n                filled =\
    \ 0;\n            }\n        }\n    }\n    return max;\n}\n", "    let max = 0;\n\
    \    for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length;\
    \ j++){\n            if(grid[i][j] == 1){\n                let cur = 0;\n    \
    \            let left = i - 1;\n                let right = i + 1;\n         \
    \       let top = j - 1;\n                let bottom = j + 1;\n              \
    \  while(left >= 0 && grid[left][j] == 1){\n                    cur++;\n     \
    \               left--;\n                }\n                while(right < grid.length\
    \ && grid[right][j] == 1){\n                    cur++;\n                    right++;\n\
    \                }\n                while(top >= 0 && grid[i][top] == 1){\n  \
    \                  cur++;\n                    top--;\n                }\n   \
    \             while(bottom < grid[i].length && grid[i][bottom] == 1){\n      \
    \              cur++;\n                    bottom++;\n                }\n    \
    \            if(cur > max){\n                    max = cur;\n                }\n\
    \            }\n        }\n    }\n    return max;\n}\n", "    let max = 0;\n \
    \   for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length;\
    \ j++){\n            if(grid[i][j] === 1){\n                let cur = 0;\n   \
    \             let left = i - 1;\n                let right = i + 1;\n        \
    \        let down = j - 1;\n                let up = j + 1;\n                if(left\
    \ >= 0 && grid[left][j] === 1){\n                    cur += 1;\n             \
    \   }\n                if(right < grid.length && grid[right][j] === 1){\n    \
    \                cur += 1;\n                }\n                if(down >= 0 &&\
    \ grid[i][down] === 1){\n                    cur += 1;\n                }\n  \
    \              if(up < grid[i].length && grid[i][up] === 1){\n               \
    \     cur += 1;\n                }\n                if(cur > max){\n         \
    \           max = cur;\n                }\n            }\n        }\n    }\n \
    \   return max;\n}\n", "    let buckets = [];\n    let max_fill = 0;\n    for(let\
    \ i = 0; i < grid.length; i++){\n        let row = grid[i];\n        for(let j\
    \ = 0; j < row.length; j++){\n            if(row[j] == 1){\n                let\
    \ bucket = new Bucket(capacity);\n                buckets.push(bucket);\n    \
    \        }\n        }\n    }\n    for(let i = 0; i < buckets.length; i++){\n \
    \       let bucket = buckets[i];\n        let filled = 0;\n        while(bucket.canFill()){\n\
    \            let well = bucket.fill();\n            let filled_well = 0;\n   \
    \         for(let j = 0; j < well.length; j++){\n                if(well[j] ==\
    \ 1){\n                    filled_well++;\n                }\n            }\n\
    \            if(filled_well > filled){\n                filled = filled_well;\n\
    \            }\n        }\n        max_fill = Math.max(max_fill, filled);\n  \
    \  }\n    return max_fill;\n}\n\nclass Bucket{\n    constructor(capacity){\n \
    \       this.capacity = capacity;\n        this.filled = 0;\n    }\n    canFill(){\n\
    \        return this.filled < this.capacity;\n    }\n    fill(){\n        let\
    \ filled = 0;\n        while(this.canFill()){\n            let well = this.fillWell();\n\
    \            let filled_well = 0;\n            for(let i = 0; i < well.length;\
    \ i++){\n                if(well[i] == 1){\n                    filled_well++;\n\
    \                }\n            }\n            if(filled_well > filled){\n   \
    \             filled = filled_well;\n            }\n        }\n        this.filled\
    \ = filled;\n        return well;\n    }\n    fillWell(){\n        let well =\
    \ [];\n        for(let i = 0; i < this.capacity; i++){\n            well.push(0);\n\
    \        }\n        return well;\n    }\n}\n", "    var max = 0;\n    for(var\
    \ i = 0; i < grid.length; i++){\n        for(var j = 0; j < grid[i].length; j++){\n\
    \            if(grid[i][j] == 1){\n                max = Math.max(max, fill(i,\
    \ j, grid, capacity));\n            }\n        }\n    }\n    return max;\n}\n\n\
    function fill(i, j, grid, capacity){\n    var max = 0;\n    var count = 0;\n \
    \   var left = i - 1;\n    var right = i + 1;\n    var top = j - 1;\n    var bottom\
    \ = j + 1;\n    if(left >= 0 && grid[left][j] == 1){\n        count++;\n     \
    \   max = Math.max(max, fill(left, j, grid, capacity));\n    }\n    if(right <\
    \ grid.length && grid[right][j] == 1){\n        count++;\n        max = Math.max(max,\
    \ fill(right, j, grid, capacity));\n    }\n    if(top >= 0 && grid[i][top] ==\
    \ 1){\n        count++;\n        max = Math.max(max, fill(i, top, grid, capacity));\n\
    \    }\n    if(bottom < grid[i].length && grid[i][bottom] == 1){\n        count++;\n\
    \        max = Math.max(max, fill(i, bottom, grid, capacity));\n    }\n    if(count\
    \ > 0 && count <= capacity){\n        max = Math.max(max, count);\n    }\n   \
    \ return max;\n}", "    let rows = grid.length\n    let cols = grid[0].length\n\
    \    let buckets = []\n    let max_fill = 0\n    for(let i = 0; i < rows; i++){\n\
    \        for(let j = 0; j < cols; j++){\n            if(grid[i][j] == 1){\n  \
    \              let bucket = new Bucket(i, j, capacity)\n                buckets.push(bucket)\n\
    \            }\n        }\n    }\n    for(let i = 0; i < buckets.length; i++){\n\
    \        let bucket = buckets[i]\n        let fill = bucket.fill()\n        if(fill\
    \ > max_fill){\n            max_fill = fill\n        }\n    }\n    return max_fill\n\
    }\n\nclass Bucket{\n    constructor(row, col, capacity){\n        this.row = row\n\
    \        this.col = col\n        this.capacity = capacity\n        this.fill =\
    \ 0\n    }\n    fill(){\n        let fill = 0\n        for(let i = this.row; i\
    \ < this.row + 2; i++){\n            for(let j = this.col; j < this.col + 2; j++){\n\
    \                if(this.grid[i][j] == 1){\n                    fill += 1\n  \
    \              }\n            }\n        }\n        return fill\n    }\n}\n",
  "    var well_count = grid.length;\n    var well_length = grid[0].length;\n    var\
    \ buckets = [];\n    for(var i = 0; i < well_count; i++){\n        buckets.push(0);\n\
    \    }\n    var max_fill = 0;\n    for(var i = 0; i < well_count; i++){\n    \
    \    for(var j = 0; j < well_length; j++){\n            if(grid[i][j] == 1){\n\
    \                buckets[i]++;\n                if(buckets[i] > capacity){\n \
    \                   buckets[i] = 0;\n                    max_fill++;\n       \
    \         }\n            }\n        }\n    }\n    return max_fill;\n}\n", "  \
    \  let max = 0;\n    let count = 0;\n    for(let i = 0; i < grid.length; i++){\n\
    \        for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j] ==\
    \ 1){\n                count++;\n                let cur = 0;\n              \
    \  while(cur < capacity){\n                    let next = Math.min(count, capacity\
    \ - cur);\n                    if(next > 0){\n                        cur += next;\n\
    \                        count -= next;\n                    }\n             \
    \       else{\n                        break;\n                    }\n       \
    \         }\n                max = Math.max(max, cur);\n            }\n      \
    \  }\n    }\n    return max;\n}\n", "    let max = 0;\n    for(let i = 0; i <\
    \ grid.length; i++){\n        let buckets = grid[i].length;\n        let filled\
    \ = 0;\n        for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j]\
    \ === 1){\n                filled++;\n            }\n            if(filled ===\
    \ buckets){\n                max++;\n                filled = 0;\n           \
    \ }\n        }\n    }\n    return max;\n}\n", "  let max = 0;\n  for(let i = 0;\
    \ i < grid.length; i++){\n    for(let j = 0; j < grid[i].length; j++){\n     \
    \ let cur = 0;\n      if(grid[i][j] === 1){\n        cur = 1;\n      }\n     \
    \ max = Math.max(max, cur);\n    }\n  }\n  return max;\n}\n", "    let max = 0;\n\
    \    for(let i = 0; i < grid.length; i++){\n        let row = grid[i];\n     \
    \   let buckets = [];\n        for(let j = 0; j < row.length; j++){\n        \
    \    let well = row[j];\n            if(well === 1){\n                let bucket\
    \ = 0;\n                for(let k = j; k < row.length; k++){\n               \
    \     if(row[k] === 1){\n                        bucket++;\n                 \
    \   }else{\n                        break;\n                    }\n          \
    \      }\n                buckets.push(bucket);\n            }\n        }\n  \
    \      let curr = 0;\n        for(let j = 0; j < buckets.length; j++){\n     \
    \       let bucket = buckets[j];\n            if(bucket > curr){\n           \
    \     curr = bucket;\n            }\n        }\n        max = Math.max(max, curr);\n\
    \    }\n    return max;\n}\n", "    let max = 0;\n    for(let i = 0; i < grid.length;\
    \ i++){\n        for(let j = 0; j < grid[i].length; j++){\n            let count\
    \ = 0;\n            while(grid[i][j] === 1){\n                count++;\n     \
    \           grid[i][j] = 0;\n            }\n            max = Math.max(max, count);\n\
    \        }\n    }\n    return max;\n}\n", "    let n = grid.length;\n    let m\
    \ = grid[0].length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n\
    \        dp[i] = new Array(m);\n        for(let j = 0; j < m; j++){\n        \
    \    dp[i][j] = 0;\n        }\n    }\n    let max = 0;\n    for(let i = 0; i <\
    \ n; i++){\n        for(let j = 0; j < m; j++){\n            if(grid[i][j] ==\
    \ 1){\n                dp[i][j] = Math.min(dp[i][j], dp[i][j-1] + 1);\n      \
    \          dp[i][j] = Math.min(dp[i][j], dp[i-1][j] + 1);\n                dp[i][j]\
    \ = Math.min(dp[i][j], dp[i-1][j-1] + 1);\n                max = Math.max(max,\
    \ dp[i][j]);\n            }\n        }\n    }\n    return max;\n}\n", "    let\
    \ max = 0;\n    for(let i = 0; i < grid.length; i++){\n        let row = grid[i];\n\
    \        let bucket = 0;\n        for(let j = 0; j < row.length; j++){\n     \
    \       if(row[j] === 1){\n                bucket += 1;\n                if(bucket\
    \ > capacity){\n                    max += 1;\n                    bucket = 0;\n\
    \                }\n            }\n        }\n    }\n    return max;\n}\n", " \
    \   let max = 0;\n    let i = 0;\n    let j = 0;\n    let count = 0;\n    while(i\
    \ < grid.length && j < grid[i].length){\n        if(grid[i][j] == 1){\n      \
    \      count += 1;\n            if(count > max){\n                max = count;\n\
    \            }\n            let bucket = grid[i][j];\n            let left = grid[i][j+1];\n\
    \            let right = grid[i][j-1];\n            let up = grid[i+1][j];\n \
    \           let down = grid[i-1][j];\n            let left_bucket = grid[i][j+1];\n\
    \            let right_bucket = grid[i][j-1];\n            let up_bucket = grid[i+1][j];\n\
    \            let down_bucket = grid[i-1][j];\n            if(left_bucket == 0\
    \ && right_bucket == 0 && up_bucket == 0 && down_bucket == 0){\n             \
    \   grid[i][j] = 0;\n                i += 1;\n                j += 1;\n      \
    \      }else if(left_bucket == 0 && right_bucket == 0 && up_bucket == 0 && down_bucket\
    \ == 1){\n                grid[i][j] = 0;\n                i += 1;\n         \
    \       j -= 1;\n            }else if(left_bucket == 0 && right_bucket == 0 &&\
    \ up_bucket == 1 && down_bucket == 0){\n                grid[i][j] = 0;\n    \
    \            i -= 1;\n                j += 1;\n            }else if(left_bucket\
    \ == 0 && right_bucket == 0 && up_bucket == 1 && down_bucket == 1){\n        \
    \        grid[i][j] = 0;\n                i -= 1;\n                j -= 1;\n \
    \           }else if(left_bucket == 0 && right_bucket == 1 && up_bucket == 0 &&\
    \ down_bucket == 0){\n                grid[i][j] = 0;\n                i += 1;\n\
    \                j += 1;\n            }else if(left_bucket == 0 && right_bucket\
    \ == 1 && up", "    let max = 0;\n    for(let i = 0; i < grid.length; i++){\n\
    \        for(let j = 0; j < grid[i].length; j++){\n            let count = 0;\n\
    \            while(grid[i][j] === 1){\n                count++;\n            \
    \    grid[i][j] = 0;\n                if(count > max){\n                    max\
    \ = count;\n                }\n            }\n        }\n    }\n    return max;\n\
    }\n", "    let max = 0;\n    let i = 0;\n    let j = 0;\n    let k = 0;\n    let\
    \ l = 0;\n    let m = 0;\n    let n = 0;\n    let o = 0;\n    let p = 0;\n   \
    \ let q = 0;\n    let r = 0;\n    let s = 0;\n    let t = 0;\n    let u = 0;\n\
    \    let v = 0;\n    let w = 0;\n    let x = 0;\n    let y = 0;\n    let z = 0;\n\
    \    let a = 0;\n    let b = 0;\n    let c = 0;\n    let d = 0;\n    let e = 0;\n\
    \    let f = 0;\n    let g = 0;\n    let h = 0;\n    let i = 0;\n    let j = 0;\n\
    \    let k = 0;\n    let l = 0;\n    let m = 0;\n    let n = 0;\n    let o = 0;\n\
    \    let p = 0;\n    let q = 0;\n    let r = 0;\n    let s = 0;\n    let t = 0;\n\
    \    let u = 0;\n    let v = 0;\n    let w = 0;\n    let x = 0;\n    let y = 0;\n\
    \    let z = 0;\n    let a = 0;\n    let b = 0;\n    let c = 0;\n    let d = 0;\n\
    \    let e = 0;\n    let f = 0;\n    let g = 0;\n    let h = 0;\n    let i = 0;\n\
    \    let j = 0;\n    let k = 0;\n    let l = 0;\n    let m = 0;\n    let n = 0;\n\
    \    let o = 0;\n    let p = 0;\n    let q = 0;\n    let r = 0;\n    let s = 0;\n\
    \    let t = 0;\n    let u = 0;\n    let v = 0;\n    let w = 0;\n    let x = 0;\n\
    \    let y = 0;\n    let z = 0;\n    let a = 0;\n    let b = 0;\n    ", "    let\
    \ rows = grid.length;\n    let cols = grid[0].length;\n    let buckets = [];\n\
    \    let max = 0;\n    for(let i = 0; i < rows; i++){\n        for(let j = 0;\
    \ j < cols; j++){\n            if(grid[i][j] == 1){\n                let cur =\
    \ 0;\n                let left = i - 1;\n                let right = i + 1;\n\
    \                let top = j - 1;\n                let bottom = j + 1;\n     \
    \           if(left >= 0 && grid[left][j] == 1){\n                    cur += 1;\n\
    \                }\n                if(right < rows && grid[right][j] == 1){\n\
    \                    cur += 1;\n                }\n                if(top >= 0\
    \ && grid[i][top] == 1){\n                    cur += 1;\n                }\n \
    \               if(bottom < cols && grid[i][bottom] == 1){\n                 \
    \   cur += 1;\n                }\n                buckets.push(cur);\n       \
    \     }\n        }\n    }\n    for(let i = 0; i < buckets.length; i++){\n    \
    \    if(buckets[i] > max){\n            max = buckets[i];\n        }\n    }\n\
    \    let result = 0;\n    for(let i = 0; i < buckets.length; i++){\n        if(buckets[i]\
    \ == max){\n            result += 1;\n        }\n    }\n    return result;\n}\n",
  "    let max = 0;\n    let row = grid.length;\n    let col = grid[0].length;\n \
    \   let well = [];\n    for(let i = 0; i < row; i++){\n        well.push([]);\n\
    \        for(let j = 0; j < col; j++){\n            well[i].push(0);\n       \
    \ }\n    }\n    for(let i = 0; i < row; i++){\n        for(let j = 0; j < col;\
    \ j++){\n            if(grid[i][j] == 1){\n                well[i][j] = 1;\n \
    \               let count = 0;\n                let well_i = i;\n            \
    \    let well_j = j;\n                while(well[well_i][well_j] == 1){\n    \
    \                well[well_i][well_j] = 0;\n                    count++;\n   \
    \                 well_i = Math.floor(well_i / 2);\n                    well_j\
    \ = Math.floor(well_j / 2);\n                }\n                max = Math.max(max,\
    \ count);\n            }\n        }\n    }\n    return max;\n}\n", "    var max\
    \ = 0;\n    for(var i = 0; i < grid.length; i++){\n        for(var j = 0; j <\
    \ grid[i].length; j++){\n            if(grid[i][j] == 1){\n                var\
    \ left = 0;\n                var right = 0;\n                if(i > 0){\n    \
    \                left = grid[i-1][j];\n                }\n                if(i\
    \ < grid.length-1){\n                    right = grid[i+1][j];\n             \
    \   }\n                if(left == 1 && right == 1){\n                    max++;\n\
    \                }\n            }\n        }\n    }\n    return max;\n}\n", " \
    \   let max = 0;\n    let i = 0;\n    let j = 0;\n    let count = 0;\n    while(i\
    \ < grid.length && j < grid[i].length){\n        if(grid[i][j] == 1){\n      \
    \      count++;\n            if(count > max){\n                max = count;\n\
    \            }\n            if(count == capacity){\n                count = 0;\n\
    \                i++;\n                j++;\n            }\n        }\n      \
    \  else{\n            count = 0;\n            i++;\n            j++;\n       \
    \ }\n    }\n    return max;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let result = 0;\n    let [left, right, top, bottom] = [0, 0, 0, 0];\n   \
    \ for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n         \
    \   if(grid[i][j] == 1){\n                left = Math.max(left, j);\n        \
    \        right = Math.min(right, j);\n                top = Math.max(top, i);\n\
    \                bottom = Math.min(bottom, i);\n            }\n        }\n   \
    \ }\n    let max = Math.min(left, right, top, bottom);\n    for(let i = max; i\
    \ >= 0; i--){\n        let count = 0;\n        for(let j = 0; j < m; j++){\n \
    \           if(grid[i][j] == 1){\n                count++;\n                if(count\
    \ == capacity){\n                    result++;\n                    grid[i][j]\
    \ = 0;\n                }\n            }\n        }\n    }\n    return result;\n\
    }\n", "    let max = 0;\n    for(let i = 0; i < grid.length; i++){\n        let\
    \ buckets = grid[i].length;\n        for(let j = 0; j < buckets; j++){\n     \
    \       if(grid[i][j] == 1){\n                let curr = 0;\n                let\
    \ left = i - 1;\n                let right = i + 1;\n                let down\
    \ = j - 1;\n                let up = j + 1;\n                if(left >= 0 && grid[left][j]\
    \ == 1){\n                    curr += 1;\n                }\n                if(right\
    \ < grid.length && grid[right][j] == 1){\n                    curr += 1;\n   \
    \             }\n                if(down >= 0 && grid[i][down] == 1){\n      \
    \              curr += 1;\n                }\n                if(up < grid[i].length\
    \ && grid[i][up] == 1){\n                    curr += 1;\n                }\n \
    \               if(curr > max){\n                    max = curr;\n           \
    \     }\n            }\n        }\n    }\n    return max;\n}\n", "    let well_count\
    \ = 0;\n    let well_index = 0;\n    let well_length = grid[0].length;\n    let\
    \ well_capacity = capacity;\n    let well_water = 0;\n    let well_water_count\
    \ = 0;\n    let well_water_index = 0;\n    let well_water_length = 0;\n    let\
    \ well_water_capacity = 0;\n    let well_water_water = 0;\n    let well_water_water_count\
    \ = 0;\n    let well_water_water_index = 0;\n    let well_water_water_length =\
    \ 0;\n    let well_water_water_capacity = 0;\n    let well_water_water_water =\
    \ 0;\n    let well_water_water_water_count = 0;\n    let well_water_water_water_index\
    \ = 0;\n    let well_water_water_water_length = 0;\n    let well_water_water_water_capacity\
    \ = 0;\n    let well_water_water_water_water = 0;\n    let well_water_water_water_water_count\
    \ = 0;\n    let well_water_water_water_water_index = 0;\n    let well_water_water_water_water_length\
    \ = 0;\n    let well_water_water_water_water_capacity = 0;\n    let well_water_water_water_water_water\
    \ = 0;\n    let well_water_water_water_water_water_count = 0;\n    let well_water_water_water_water_water_index\
    \ = 0;\n    let well_water_water_water_water_water_length = 0;\n    let well_water_water_water_water_water_capacity\
    \ = 0;\n    let well_water_water_water_water_water_water = 0;\n    let well_water_water_water_water_water_water_count\
    \ = 0;\n    let well_water_water_water_water_water_water_index = 0;\n    let well_water_water_water_water_water_water_length\
    \ = 0;\n    let well_water_water_water_water_water_water_capacity = 0;\n    let\
    \ well_", "    let max = 0;\n    for(let i = 0; i < grid.length; i++){\n     \
    \   for(let j = 0; j < grid[i].length; j++){\n            let cur = 0;\n     \
    \       if(grid[i][j] == 1){\n                let cur = 0;\n                for(let\
    \ k = 0; k < grid[i].length; k++){\n                    if(grid[i][k] == 1){\n\
    \                        cur++;\n                    }\n                }\n  \
    \              if(cur > max){\n                    max = cur;\n              \
    \  }\n            }\n        }\n    }\n    return max;\n}\n", "    let max = 0;\n\
    \    for(let i = 0; i < grid.length; i++){\n        let row = grid[i];\n     \
    \   let buckets = [];\n        for(let j = 0; j < row.length; j++){\n        \
    \    if(row[j] === 1){\n                buckets.push(0);\n            }\n    \
    \    }\n        let count = 0;\n        while(buckets.length > 0){\n         \
    \   let bucket = buckets.shift();\n            if(bucket < capacity){\n      \
    \          count++;\n                buckets.push(bucket + 1);\n            }\n\
    \        }\n        max = Math.max(max, count);\n    }\n    return max;\n}\n",
  "  let buckets = grid.map(row => row.map(well => well === 1))\n  let max_fill =\
    \ 0\n  for (let i = 0; i < buckets.length; i++) {\n    let filled = 0\n    for\
    \ (let j = 0; j < buckets[i].length; j++) {\n      if (buckets[i][j]) {\n    \
    \    filled += 1\n        if (filled === capacity) {\n          max_fill += 1\n\
    \          buckets[i][j] = 0\n        }\n      }\n    }\n  }\n  return max_fill\n\
    }\n", "    let result = 0;\n    for(let i = 0; i < grid.length; i++){\n      \
    \  for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j] == 1){\n\
    \                let curr_well = i;\n                let curr_bucket = j;\n  \
    \              let curr_capacity = capacity;\n                let curr_result\
    \ = 0;\n                while(curr_well >= 0 && curr_well < grid.length && curr_bucket\
    \ >= 0 && curr_bucket < grid[i].length){\n                    if(grid[curr_well][curr_bucket]\
    \ == 1){\n                        curr_result += curr_capacity;\n            \
    \            curr_well--;\n                        curr_bucket--;\n          \
    \          }\n                    else{\n                        curr_well--;\n\
    \                    }\n                }\n                result = Math.max(result,\
    \ curr_result);\n            }\n        }\n    }\n    return result;\n}\n", " \
    \   let max = 0;\n    let i = 0;\n    let j = 0;\n    let k = 0;\n    let l =\
    \ 0;\n    let m = 0;\n    let n = 0;\n    let o = 0;\n    let p = 0;\n    let\
    \ q = 0;\n    let r = 0;\n    let s = 0;\n    let t = 0;\n    let u = 0;\n   \
    \ let v = 0;\n    let w = 0;\n    let x = 0;\n    let y = 0;\n    let z = 0;\n\
    \    let a = 0;\n    let b = 0;\n    let c = 0;\n    let d = 0;\n    let e = 0;\n\
    \    let f = 0;\n    let g = 0;\n    let h = 0;\n    let i = 0;\n    let j = 0;\n\
    \    let k = 0;\n    let l = 0;\n    let m = 0;\n    let n = 0;\n    let o = 0;\n\
    \    let p = 0;\n    let q = 0;\n    let r = 0;\n    let s = 0;\n    let t = 0;\n\
    \    let u = 0;\n    let v = 0;\n    let w = 0;\n    let x = 0;\n    let y = 0;\n\
    \    let z = 0;\n    let a = 0;\n    let b = 0;\n    let c = 0;\n    let d = 0;\n\
    \    let e = 0;\n    let f = 0;\n    let g = 0;\n    let h = 0;\n    let i = 0;\n\
    \    let j = 0;\n    let k = 0;\n    let l = 0;\n    let m = 0;\n    let n = 0;\n\
    \    let o = 0;\n    let p = 0;\n    let q = 0;\n    let r = 0;\n    let s = 0;\n\
    \    let t = 0;\n    let u = 0;\n    let v = 0;\n    let w = 0;\n    let x = 0;\n\
    \    let y = 0;\n    let z = 0;\n    let a = 0;\n    let b = 0;\n    ", "    let\
    \ max = 0;\n    let i = 0;\n    let j = 0;\n    let count = 0;\n    while(i <\
    \ grid.length && j < grid[0].length){\n        if(grid[i][j] == 1){\n        \
    \    count++;\n            if(count > max){\n                max = count;\n  \
    \          }\n            if(count == capacity){\n                count = 0;\n\
    \                i++;\n                j++;\n            }\n        }else{\n \
    \           count = 0;\n            i++;\n            j++;\n        }\n    }\n\
    \    return max;\n}\n", "    let rows = grid.length;\n    let cols = grid[0].length;\n\
    \    let buckets = [];\n    let max = 0;\n    for(let i = 0; i < rows; i++){\n\
    \        buckets.push([]);\n        for(let j = 0; j < cols; j++){\n         \
    \   if(grid[i][j] == 1){\n                let bucket = new Bucket(capacity);\n\
    \                buckets[i].push(bucket);\n            }\n        }\n    }\n \
    \   for(let i = 0; i < rows; i++){\n        for(let j = 0; j < cols; j++){\n \
    \           let bucket = buckets[i][j];\n            if(bucket){\n           \
    \     let filled = bucket.fill(grid[i][j]);\n                if(filled > max){\n\
    \                    max = filled;\n                }\n            }\n       \
    \ }\n    }\n    return max;\n}\n\nclass Bucket{\n    constructor(capacity){\n\
    \        this.capacity = capacity;\n        this.water = 0;\n    }\n    fill(water){\n\
    \        if(this.water + water > this.capacity){\n            return this.capacity\
    \ - this.water;\n        }\n        this.water += water;\n        return 0;\n\
    \    }\n}\n", "    let max = 0;\n    for(let i = 0; i < grid.length; i++){\n \
    \       let buckets = grid[i].map(() => 0);\n        let count = 0;\n        while(true){\n\
    \            let max_bucket = buckets.reduce((a, b) => Math.max(a, b));\n    \
    \        if(max_bucket < capacity){\n                count++;\n              \
    \  buckets[max_bucket]++;\n            } else {\n                break;\n    \
    \        }\n        }\n        max = Math.max(max, count);\n    }\n    return\
    \ max;\n}\n", "    var well_count = 0;\n    var well_capacity = 0;\n    for(var\
    \ i=0; i<grid.length; i++){\n        for(var j=0; j<grid[i].length; j++){\n  \
    \          if(grid[i][j] == 1){\n                well_count++;\n             \
    \   well_capacity += capacity;\n            }\n        }\n    }\n    return well_count\
    \ * well_capacity;\n}\n", "  let max = 0;\n  for(let i = 0; i < grid.length; i++){\n\
    \    for(let j = 0; j < grid[i].length; j++){\n      let count = 0;\n      while(grid[i][j]\
    \ === 1){\n        count++;\n        grid[i][j] = 0;\n      }\n      if(count\
    \ > max){\n        max = count;\n      }\n    }\n  }\n  return max;\n}\n", " \
    \ let well_count = 0;\n  let well_capacity = 0;\n  let well_index = 0;\n  let\
    \ well_length = grid[0].length;\n  let well_row = 0;\n  let well_col = 0;\n  let\
    \ well_row_count = 0;\n  let well_col_count = 0;\n  let well_row_index = 0;\n\
    \  let well_col_index = 0;\n  let well_row_length = grid[0].length;\n  let well_col_length\
    \ = grid[0].length;\n  let well_row_index_count = 0;\n  let well_col_index_count\
    \ = 0;\n  let well_row_index_length = grid[0].length;\n  let well_col_index_length\
    \ = grid[0].length;\n  let well_row_index_index = 0;\n  let well_col_index_index\
    \ = 0;\n  let well_row_index_index_count = 0;\n  let well_col_index_index_count\
    \ = 0;\n  let well_row_index_index_length = grid[0].length;\n  let well_col_index_index_length\
    \ = grid[0].length;\n  let well_row_index_index_index = 0;\n  let well_col_index_index_index\
    \ = 0;\n  let well_row_index_index_index_count = 0;\n  let well_col_index_index_index_count\
    \ = 0;\n  let well_row_index_index_index_length = grid[0].length;\n  let well_col_index_index_index_length\
    \ = grid[0].length;\n  let well_row_index_index_index_index = 0;\n  let well_col_index_index_index_index\
    \ = 0;\n  let well_row_index_index_index_index_count = 0;\n  let well_col_index_index_index_index_count\
    \ = 0;\n  let well_row_index_index_index_index_length = grid[0].length;\n  let\
    \ well_col_index_index_index_index_length = grid[0].length;\n  let", "    let\
    \ max = 0;\n    for(let i = 0; i < grid.length; i++){\n        let buckets = grid[i].length;\n\
    \        let filled = 0;\n        for(let j = 0; j < buckets; j++){\n        \
    \    if(grid[i][j] == 1){\n                filled++;\n                if(filled\
    \ >= capacity){\n                    max++;\n                    filled = 0;\n\
    \                }\n            }\n        }\n    }\n    return max;\n}\n", " \
    \   let max = 0;\n    let well = [];\n    let i = 0;\n    let j = 0;\n    let\
    \ well_length = grid[0].length;\n    while(i < grid.length && j < well_length){\n\
    \        if(grid[i][j] == 1){\n            well.push(i);\n            j++;\n \
    \       }\n        else{\n            i++;\n        }\n    }\n    while(well.length\
    \ > 0){\n        let bucket = well.pop();\n        let well_length = grid[bucket].length;\n\
    \        let bucket_length = capacity;\n        while(bucket_length > 0 && well_length\
    \ > 0){\n            let bucket_index = well.indexOf(bucket);\n            let\
    \ well_index = well.indexOf(well[well_length - 1]);\n            let well_length_before\
    \ = well_length;\n            well[well_index] = well[well_length - 1];\n    \
    \        well_length--;\n            well[well_length] = bucket;\n           \
    \ well_length++;\n            bucket_length--;\n            bucket_length = well_length\
    \ - well_length_before;\n        }\n        max = Math.max(max, bucket_length);\n\
    \    }\n    return max;\n}\n", "  let n = grid.length\n  let m = grid[0].length\n\
    \  let dp = new Array(n)\n  for(let i = 0; i < n; i++){\n    dp[i] = new Array(m)\n\
    \    for(let j = 0; j < m; j++){\n      if(grid[i][j] == 1){\n        dp[i][j]\
    \ = 0\n      }else{\n        dp[i][j] = Infinity\n      }\n    }\n  }\n  let max\
    \ = 0\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n      if(dp[i][j]\
    \ > max){\n        max = dp[i][j]\n      }\n    }\n  }\n  let count = 0\n  for(let\
    \ i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n      if(dp[i][j] == max){\n\
    \        count += 1\n        dp[i][j] = 0\n      }\n    }\n  }\n  return count\n\
    }\n", "  let max = 0;\n  let n = grid.length;\n  let m = grid[0].length;\n  let\
    \ i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let r = 0;\n  let s = 0;\n\
    \  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y\
    \ = 0;\n  let z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n\
    \  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j\
    \ = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n\
    \  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u\
    \ = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n\
    \  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f\
    \ = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n\
    \  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q\
    \ = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n\
    \  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let a = 0;\n  let b\
    \ = 0;\n  let c = 0;\n  let d = 0;\n  let", "    let max = 0;\n    for(let i =\
    \ 0; i < grid.length; i++){\n        let row = grid[i];\n        let buckets =\
    \ [];\n        for(let j = 0; j < row.length; j++){\n            let bucket =\
    \ row[j];\n            if(bucket){\n                buckets.push(bucket);\n  \
    \          }\n        }\n        let filled = 0;\n        while(buckets.length\
    \ > 0){\n            let bucket = buckets.shift();\n            if(bucket < capacity){\n\
    \                filled += bucket;\n                buckets.push(bucket);\n  \
    \          }\n        }\n        max = Math.max(max, filled);\n    }\n    return\
    \ max;\n}\n", "    let max = 0;\n    for(let i = 0; i < grid.length; i++){\n \
    \       let row = grid[i];\n        let buckets = [];\n        for(let j = 0;\
    \ j < row.length; j++){\n            if(row[j] === 1){\n                buckets.push(0);\n\
    \            }\n        }\n        let count = 0;\n        while(buckets.length\
    \ > 0){\n            let bucket = buckets.shift();\n            if(bucket < capacity){\n\
    \                count += 1;\n                buckets.push(bucket + 1);\n    \
    \        }\n        }\n        max = Math.max(max, count);\n    }\n    return\
    \ max;\n}\n", "    let rows = grid.length;\n    let cols = grid[0].length;\n \
    \   let buckets = [];\n    let max = 0;\n    for(let i = 0; i < rows; i++){\n\
    \        for(let j = 0; j < cols; j++){\n            if(grid[i][j] == 1){\n  \
    \              let bucket = [];\n                let count = 0;\n            \
    \    while(true){\n                    let row = i;\n                    let col\
    \ = j;\n                    let left = grid[row][col];\n                    let\
    \ right = grid[row][col+1];\n                    let down = grid[row+1][col];\n\
    \                    let up = grid[row-1][col];\n                    if(left ==\
    \ 0 && right == 0 && down == 0 && up == 0){\n                        break;\n\
    \                    }\n                    if(left == 1){\n                 \
    \       bucket.push(0);\n                        count++;\n                  \
    \      row--;\n                        left = grid[row][col];\n              \
    \      }\n                    if(right == 1){\n                        bucket.push(1);\n\
    \                        count++;\n                        row++;\n          \
    \              right = grid[row][col];\n                    }\n              \
    \      if(down == 1){\n                        bucket.push(2);\n             \
    \           count++;\n                        col++;\n                       \
    \ down = grid[row][col];\n                    }\n                    if(up ==\
    \ 1){\n                        bucket.push(3);\n                        count++;\n\
    \                        col--;\n                        up = grid[row][col];\n\
    \                    }\n                    if(count > max){\n               \
    \         max = count;\n                    }\n                }\n           \
    \     buckets.push(bucket);\n            }\n        }\n    }\n    let result =\
    \ 0;\n    for(let i = 0; i < buckets.length; i++){\n        let bucket = buckets[i];\n\
    \        let count = 0;\n        while(true){\n            let row = i;\n    \
    \        let col = bucket.indexOf(0);\n            let left = bucket[col];\n \
    \           let right = bucket[col+1];\n            let down = bucket[col+2];\n\
    \            let up = bucket[col+3];\n            if(left == 0 && right == 0 &&\
    \ down == 0 && up == 0){\n                ", "    let result = 0;\n    for(let\
    \ i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length; j++){\n\
    \            if(grid[i][j] === 1){\n                let left = 0;\n          \
    \      let right = 0;\n                let bottom = 0;\n                let top\
    \ = 0;\n                if(i > 0){\n                    left = grid[i - 1][j];\n\
    \                }\n                if(i < grid.length - 1){\n               \
    \     right = grid[i + 1][j];\n                }\n                if(j > 0){\n\
    \                    bottom = grid[i][j - 1];\n                }\n           \
    \     if(j < grid[i].length - 1){\n                    top = grid[i][j + 1];\n\
    \                }\n                let bucket = Math.min(left, right, bottom,\
    \ top);\n                if(bucket > 0){\n                    result += bucket;\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\n",
  "    let buckets = [0] * capacity;\n    let max = 0;\n    for(let i = 0; i < grid.length;\
    \ i++){\n        for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j]\
    \ == 1){\n                let cur = 0;\n                for(let k = 0; k < buckets.length;\
    \ k++){\n                    if(buckets[k] > 0){\n                        cur\
    \ += buckets[k];\n                        buckets[k] = 0;\n                  \
    \  }\n                }\n                if(cur > max){\n                    max\
    \ = cur;\n                }\n            }\n        }\n    }\n    return max;\n\
    }\n", "    var max = 0;\n    for(var i = 0; i < grid.length; i++){\n        for(var\
    \ j = 0; j < grid[i].length; j++){\n            if(grid[i][j] == 1){\n       \
    \         var count = 0;\n                while(grid[i][j] == 1){\n          \
    \          count++;\n                    grid[i][j] = 0;\n                   \
    \ if(count > max){\n                        max = count;\n                   \
    \ }\n                }\n            }\n        }\n    }\n    return max;\n}\n",
  "  let buckets = [0] * capacity\n  let max_fill = 0\n  for (let i = 0; i < grid.length;\
    \ i++){\n    for (let j = 0; j < grid[i].length; j++){\n      if (grid[i][j] ===\
    \ 1){\n        let bucket = buckets[j]\n        if (bucket === 0){\n         \
    \ buckets[j] = 1\n          max_fill += 1\n        } else {\n          buckets[j]\
    \ = 0\n        }\n      }\n    }\n  }\n  return max_fill\n}\n", "    let max =\
    \ 0;\n    let count = 0;\n    for(let i = 0; i < grid.length; i++){\n        for(let\
    \ j = 0; j < grid[i].length; j++){\n            if(grid[i][j] == 1){\n       \
    \         count++;\n                let left = 0;\n                let right =\
    \ 0;\n                let up = 0;\n                let down = 0;\n           \
    \     if(i > 0){\n                    left = grid[i-1][j];\n                }\n\
    \                if(i < grid.length - 1){\n                    right = grid[i+1][j];\n\
    \                }\n                if(j > 0){\n                    up = grid[i][j-1];\n\
    \                }\n                if(j < grid[i].length - 1){\n            \
    \        down = grid[i][j+1];\n                }\n                let new_count\
    \ = count;\n                if(left > 0){\n                    new_count += max_fill(grid,\
    \ left);\n                }\n                if(right > 0){\n                \
    \    new_count += max_fill(grid, right);\n                }\n                if(up\
    \ > 0){\n                    new_count += max_fill(grid, up);\n              \
    \  }\n                if(down > 0){\n                    new_count += max_fill(grid,\
    \ down);\n                }\n                if(new_count > max){\n          \
    \          max = new_count;\n                }\n            }\n        }\n   \
    \ }\n    return max;\n}\n", "    var max = 0;\n    for(var i = 0; i < grid.length;\
    \ i++){\n        for(var j = 0; j < grid[i].length; j++){\n            if(grid[i][j]\
    \ == 1){\n                var count = 0;\n                while(grid[i][j] ==\
    \ 1){\n                    count++;\n                    grid[i][j] = 0;\n   \
    \                 if(count > max){\n                        max = count;\n   \
    \                 }\n                }\n            }\n        }\n    }\n    return\
    \ max;\n}\n", "    let max = 0;\n    for(let i = 0; i < grid.length; i++){\n \
    \       for(let j = 0; j < grid[i].length; j++){\n            let count = 0;\n\
    \            while(grid[i][j] === 1){\n                count++;\n            \
    \    grid[i][j] = 0;\n                let row = i;\n                let col =\
    \ j;\n                while(grid[row][col] === 1){\n                    grid[row][col]\
    \ = 0;\n                    row--;\n                    col--;\n             \
    \   }\n                row++;\n                col++;\n                if(row\
    \ < 0 || row >= grid.length || col < 0 || col >= grid[row].length){\n        \
    \            break;\n                }\n            }\n            max = Math.max(max,\
    \ count);\n        }\n    }\n    return max;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let dp = new Array(n);\n    for(let i = 0; i\
    \ < n; i++){\n        dp[i] = new Array(m);\n        for(let j = 0; j < m; j++){\n\
    \            dp[i][j] = 0;\n        }\n    }\n    let max = 0;\n    for(let i\
    \ = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            if(grid[i][j]\
    \ == 1){\n                dp[i][j] = Math.min(dp[i][j], Math.min(dp[i-1][j], dp[i][j-1])\
    \ + 1);\n                max = Math.max(max, dp[i][j]);\n            }\n     \
    \   }\n    }\n    return max;\n}\n", "  let max = 0;\n  for(let i = 0; i < grid.length;\
    \ i++){\n    for(let j = 0; j < grid[i].length; j++){\n      let count = 0;\n\
    \      while(grid[i][j] === 1){\n        count++;\n        grid[i][j] = 0;\n \
    \     }\n      max = Math.max(max, count);\n    }\n  }\n  return max;\n}\n", " \
    \ let buckets = [];\n  let well_count = 0;\n  for(let i = 0; i < grid.length;\
    \ i++){\n    let well = grid[i];\n    let well_buckets = [];\n    for(let j =\
    \ 0; j < well.length; j++){\n      let bucket = well[j];\n      well_buckets.push(bucket);\n\
    \    }\n    buckets.push(well_buckets);\n    well_count += well.length;\n  }\n\
    \  let filled = 0;\n  while(well_count > 0){\n    let max_well = 0;\n    let max_well_index\
    \ = 0;\n    for(let i = 0; i < buckets.length; i++){\n      let well_buckets =\
    \ buckets[i];\n      let well_bucket_count = 0;\n      for(let j = 0; j < well_buckets.length;\
    \ j++){\n        let bucket = well_buckets[j];\n        if(bucket > 0){\n    \
    \      well_bucket_count += 1;\n          if(well_bucket_count > max_well){\n\
    \            max_well = well_bucket_count;\n            max_well_index = i;\n\
    \          }\n        }\n      }\n    }\n    if(max_well > 0){\n      let well\
    \ = buckets[max_well_index];\n      let well_buckets = well[max_well_index];\n\
    \      let well_bucket_count = 0;\n      for(let j = 0; j < well_buckets.length;\
    \ j++){\n        let bucket = well_buckets[j];\n        if(bucket > 0){\n    \
    \      well_bucket_count += 1;\n          if(well_bucket_count > max_well){\n\
    \            max_well = well_bucket_count;\n            max_well_index = i;\n\
    \          }\n        }\n      }\n      well_buckets[max_well_index] -= 1;\n \
    \     well_count -= 1;\n      filled += 1;\n    }\n  }\n  return filled;\n}\n",
  "    let max = 0;\n    for(let i = 0; i < grid.length; i++){\n        for(let j\
    \ = 0; j < grid[i].length; j++){\n            let cur = 0;\n            if(grid[i][j]\
    \ == 1){\n                cur = Math.min(cur + 1, capacity);\n               \
    \ max = Math.max(max, cur);\n            }\n        }\n    }\n    return max;\n\
    }\n", "  let max = 0;\n  let i = 0;\n  let j = 0;\n  let count = 0;\n  while(i\
    \ < grid.length && j < grid[0].length){\n    if(grid[i][j] === 1){\n      count++;\n\
    \      if(count > max){\n        max = count;\n      }\n      let bucket = grid[i][j];\n\
    \      let next_i = i;\n      let next_j = j;\n      while(next_i < grid.length\
    \ && next_j < grid[0].length && grid[next_i][next_j] === bucket){\n        next_i++;\n\
    \        next_j++;\n      }\n      i = next_i;\n      j = next_j;\n    }\n   \
    \ i++;\n    j++;\n  }\n  return max;\n}\n", "    var well_count = grid.length;\n\
    \    var well_size = grid[0].length;\n    var buckets = [];\n    var well_index\
    \ = 0;\n    var bucket_index = 0;\n    var max_fill = 0;\n    for(var i = 0; i\
    \ < well_count; i++){\n        for(var j = 0; j < well_size; j++){\n         \
    \   if(grid[i][j] == 1){\n                well_index = i;\n                bucket_index\
    \ = j;\n                break;\n            }\n        }\n        if(bucket_index\
    \ == 0){\n            buckets.push(0);\n        }\n        else{\n           \
    \ buckets.push(buckets[bucket_index - 1] + 1);\n        }\n    }\n    while(well_index\
    \ != well_count - 1){\n        if(buckets[bucket_index] > capacity){\n       \
    \     buckets[bucket_index] = 0;\n            bucket_index++;\n        }\n   \
    \     else{\n            buckets[bucket_index]--;\n            well_index++;\n\
    \            if(well_index == well_count){\n                well_index = 0;\n\
    \                bucket_index = 0;\n            }\n        }\n        max_fill++;\n\
    \    }\n    return max_fill;\n}\n", "    let max = 0;\n    for(let i = 0; i <\
    \ grid.length; i++){\n        let buckets = grid[i].length;\n        let filled\
    \ = 0;\n        for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j]\
    \ == 1){\n                filled++;\n                let bucket = Math.floor(filled\
    \ / buckets);\n                if(bucket > max){\n                    max = bucket;\n\
    \                }\n            }\n        }\n    }\n    return max;\n}\n", " \
    \ let n = grid.length\n  let m = grid[0].length\n  let dp = [[0] * m for _ in\
    \ range(n)]\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++)\
    \ {\n      if (grid[i][j] == 1) {\n        dp[i][j] = Math.min(dp[i][j], dp[i\
    \ - 1][j] + 1)\n        dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + 1)\n    \
    \    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1] + 1)\n      }\n    }\n  }\n\
    \  let max = 0\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++)\
    \ {\n      if (grid[i][j] == 1) {\n        max = Math.max(max, dp[i][j])\n   \
    \   }\n    }\n  }\n  return max\n}\n", "    let buckets = [];\n    let well_count\
    \ = 0;\n    for(let i = 0; i < grid.length; i++){\n        let well = grid[i];\n\
    \        let well_length = well.length;\n        let well_capacity = capacity;\n\
    \        let well_buckets = [];\n        for(let j = 0; j < well_length; j++){\n\
    \            let well_bucket = well[j];\n            let well_bucket_capacity\
    \ = well_bucket;\n            well_buckets.push(well_bucket_capacity);\n     \
    \   }\n        buckets.push(well_buckets);\n    }\n    let max_fill = 0;\n   \
    \ for(let i = 0; i < buckets.length; i++){\n        let well_buckets = buckets[i];\n\
    \        let well_buckets_length = well_buckets.length;\n        let well_buckets_capacity\
    \ = well_buckets[0];\n        let well_buckets_count = 0;\n        for(let j =\
    \ 0; j < well_buckets_length; j++){\n            let well_bucket_capacity = well_buckets[j];\n\
    \            let well_bucket_count = well_buckets_capacity;\n            well_buckets_count\
    \ += well_bucket_count;\n            if(well_bucket_count > well_buckets_capacity){\n\
    \                well_buckets_count = well_buckets_capacity;\n            }\n\
    \            if(well_buckets_count > well_buckets_capacity){\n               \
    \ well_buckets_count = well_buckets_capacity;\n            }\n            well_buckets_capacity\
    \ = well_buckets_count;\n        }\n        max_fill = Math.max(max_fill, well_buckets_capacity);\n\
    \    }\n    return max_fill;\n}\n", "    let rows = grid.length;\n    let cols\
    \ = grid[0].length;\n    let buckets = [];\n    let max = 0;\n    for(let i =\
    \ 0; i < rows; i++){\n        let row = grid[i];\n        let buckets_row = [];\n\
    \        for(let j = 0; j < cols; j++){\n            let bucket = row[j];\n  \
    \          if(bucket){\n                buckets_row.push(bucket);\n          \
    \  }\n        }\n        buckets.push(buckets_row);\n    }\n    for(let i = 0;\
    \ i < buckets.length; i++){\n        let bucket = buckets[i];\n        let max_fill\
    \ = 0;\n        for(let j = 0; j < bucket.length; j++){\n            let bucket_fill\
    \ = bucket[j];\n            if(bucket_fill){\n                max_fill += bucket_fill;\n\
    \            }\n        }\n        if(max_fill > max){\n            max = max_fill;\n\
    \        }\n    }\n    return max;\n}\n", "    let well_count = grid.length;\n\
    \    let well_length = grid[0].length;\n    let buckets = [];\n    let max_fill\
    \ = 0;\n    for(let i = 0; i < well_count; i++){\n        let well = grid[i];\n\
    \        let bucket_count = well_length - well[0];\n        let bucket_capacity\
    \ = capacity;\n        let bucket_count_left = bucket_count;\n        while(bucket_count_left\
    \ > 0){\n            let bucket = new Bucket(bucket_capacity);\n            buckets.push(bucket);\n\
    \            bucket_count_left -= bucket.fill(well[1]);\n        }\n    }\n  \
    \  for(let i = 0; i < buckets.length; i++){\n        let bucket = buckets[i];\n\
    \        let bucket_count = bucket.count;\n        let bucket_count_left = bucket_count;\n\
    \        while(bucket_count_left > 0){\n            let bucket_filled = bucket.fill(0);\n\
    \            max_fill += bucket_filled;\n            bucket_count_left -= bucket_filled;\n\
    \        }\n    }\n    return max_fill;\n}\n\nclass Bucket{\n    constructor(capacity){\n\
    \        this.capacity = capacity;\n        this.count = 0;\n    }\n    fill(water){\n\
    \        if(this.count + water > this.capacity){\n            return this.capacity\
    \ - this.count;\n        }\n        this.count += water;\n        return 0;\n\
    \    }\n}\n", "  let buckets = [0] * capacity\n  let max_fill = 0\n  for(let i\
    \ = 0; i < grid.length; i++){\n    for(let j = 0; j < grid[i].length; j++){\n\
    \      if(grid[i][j] === 1){\n        let cur_fill = 0\n        for(let k = 0;\
    \ k < buckets.length; k++){\n          if(buckets[k] > 0){\n            buckets[k]--\n\
    \            cur_fill++\n          }\n        }\n        if(cur_fill > max_fill){\n\
    \          max_fill = cur_fill\n        }\n      }\n    }\n  }\n  return max_fill\n\
    }\n", "    let max = 0;\n    for(let i = 0; i < grid.length; i++){\n        let\
    \ curr = 0;\n        for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j]\
    \ == 1){\n                curr += 1;\n            }\n            if(curr > max){\n\
    \                max = curr;\n            }\n            if(curr >= capacity){\n\
    \                curr = 0;\n            }\n        }\n    }\n    return max;\n\
    }\n", "  let max = 0;\n  for(let i = 0; i < grid.length; i++){\n    let cur =\
    \ 0;\n    for(let j = 0; j < grid[i].length; j++){\n      if(grid[i][j] == 1){\n\
    \        cur += 1;\n        if(cur > max){\n          max = cur;\n        }\n\
    \      }\n    }\n  }\n  return max;\n}\n", "    let max = 0;\n    let i = 0;\n\
    \    let j = 0;\n    let count = 0;\n    for(i = 0; i < grid.length; i++){\n \
    \       for(j = 0; j < grid[i].length; j++){\n            if(grid[i][j] == 1){\n\
    \                count++;\n                if(count > max){\n                \
    \    max = count;\n                }\n                if(count == capacity){\n\
    \                    count = 0;\n                }\n            }\n        }\n\
    \    }\n    return max;\n}\n", "    var max = 0;\n    for(var i = 0; i < grid.length;\
    \ i++){\n        for(var j = 0; j < grid[i].length; j++){\n            if(grid[i][j]\
    \ == 1){\n                var count = 0;\n                while(grid[i][j] ==\
    \ 1){\n                    count++;\n                    grid[i][j] = 0;\n   \
    \                 if(count > max){\n                        max = count;\n   \
    \                 }\n                }\n            }\n        }\n    }\n    return\
    \ max;\n}\n", "    var max = 0;\n    for(var i = 0; i < grid.length; i++){\n \
    \       var row = grid[i];\n        var cur = 0;\n        for(var j = 0; j < row.length;\
    \ j++){\n            if(row[j] == 1){\n                cur++;\n            }\n\
    \            if(cur > max){\n                max = cur;\n            }\n     \
    \       if(cur == capacity){\n                cur = 0;\n            }\n      \
    \  }\n    }\n    return max;\n}\n", "    let buckets = [],\n        wells = [],\n\
    \        well_count = 0,\n        well_capacity = 0;\n\n    for(let i = 0; i <\
    \ grid.length; i++){\n        wells.push([]);\n        well_count += grid[i][0]\
    \ == 1;\n        well_capacity += grid[i][1];\n        for(let j = 0; j < grid[i].length;\
    \ j++){\n            if(grid[i][j] == 1){\n                wells[i].push(j);\n\
    \            }\n        }\n    }\n\n    for(let i = 0; i < wells.length; i++){\n\
    \        buckets.push(0);\n    }\n\n    let max_fill = 0;\n    while(well_count\
    \ > 0){\n        let max_fill_well = 0;\n        let max_fill_well_index = 0;\n\
    \        for(let i = 0; i < wells.length; i++){\n            if(wells[i].length\
    \ > 0){\n                let well_index = wells[i].shift();\n                let\
    \ well_capacity = wells[i].length * capacity;\n                let well_fill =\
    \ buckets[i] + well_capacity;\n                if(well_fill > well_capacity){\n\
    \                    well_fill = well_capacity;\n                }\n         \
    \       if(well_fill > max_fill_well){\n                    max_fill_well = well_fill;\n\
    \                    max_fill_well_index = i;\n                }\n           \
    \ }\n        }\n        if(max_fill_well > 0){\n            buckets[max_fill_well_index]\
    \ = max_fill_well;\n            well_count--;\n        }\n        max_fill++;\n\
    \    }\n\n    return max_fill;\n}\n", "  let rows = grid.length\n  let cols =\
    \ grid[0].length\n  let buckets = []\n  let max_fill = 0\n  for(let i = 0; i <\
    \ rows; i++){\n    for(let j = 0; j < cols; j++){\n      if(grid[i][j] == 1){\n\
    \        buckets.push(0)\n      }\n    }\n  }\n  for(let i = 0; i < rows; i++){\n\
    \    for(let j = 0; j < cols; j++){\n      if(grid[i][j] == 1){\n        let bucket\
    \ = buckets.pop()\n        let fill = bucket + 1\n        if(fill > capacity){\n\
    \          bucket = fill - capacity\n        }\n        buckets.push(bucket)\n\
    \        max_fill = Math.max(max_fill, bucket)\n      }\n    }\n  }\n  return\
    \ max_fill\n}\n", "    let max = 0;\n    let i = 0;\n    let j = 0;\n    let k\
    \ = 0;\n    let l = 0;\n    let m = 0;\n    let n = 0;\n    let o = 0;\n    let\
    \ p = 0;\n    let q = 0;\n    let r = 0;\n    let s = 0;\n    let t = 0;\n   \
    \ let u = 0;\n    let v = 0;\n    let w = 0;\n    let x = 0;\n    let y = 0;\n\
    \    let z = 0;\n    let a = 0;\n    let b = 0;\n    let c = 0;\n    let d = 0;\n\
    \    let e = 0;\n    let f = 0;\n    let g = 0;\n    let h = 0;\n    let i = 0;\n\
    \    let j = 0;\n    let k = 0;\n    let l = 0;\n    let m = 0;\n    let n = 0;\n\
    \    let o = 0;\n    let p = 0;\n    let q = 0;\n    let r = 0;\n    let s = 0;\n\
    \    let t = 0;\n    let u = 0;\n    let v = 0;\n    let w = 0;\n    let x = 0;\n\
    \    let y = 0;\n    let z = 0;\n    let a = 0;\n    let b = 0;\n    let c = 0;\n\
    \    let d = 0;\n    let e = 0;\n    let f = 0;\n    let g = 0;\n    let h = 0;\n\
    \    let i = 0;\n    let j = 0;\n    let k = 0;\n    let l = 0;\n    let m = 0;\n\
    \    let n = 0;\n    let o = 0;\n    let p = 0;\n    let q = 0;\n    let r = 0;\n\
    \    let s = 0;\n    let t = 0;\n    let u = 0;\n    let v = 0;\n    let w = 0;\n\
    \    let x = 0;\n    let y = 0;\n    let z = 0;\n    let a = 0;\n    let b = 0;\n\
    \    ", "    let rows = grid.length\n    let cols = grid[0].length\n    let max\
    \ = 0\n    for(let i = 0; i < rows; i++){\n        for(let j = 0; j < cols; j++){\n\
    \            if(grid[i][j] == 1){\n                let count = 0\n           \
    \     let left = i - 1\n                let right = i + 1\n                let\
    \ top = j - 1\n                let bottom = j + 1\n                while(left\
    \ >= 0 && grid[left][j] == 1){\n                    count++\n                \
    \    left--\n                }\n                while(right < rows && grid[right][j]\
    \ == 1){\n                    count++\n                    right++\n         \
    \       }\n                while(top >= 0 && grid[i][top] == 1){\n           \
    \         count++\n                    top--\n                }\n            \
    \    while(bottom < cols && grid[i][bottom] == 1){\n                    count++\n\
    \                    bottom++\n                }\n                if(count > max){\n\
    \                    max = count\n                }\n            }\n        }\n\
    \    }\n    return max\n}\n", "    var max = 0;\n    for(var i = 0; i < grid.length;\
    \ i++){\n        for(var j = 0; j < grid[i].length; j++){\n            if(grid[i][j]\
    \ == 1){\n                var count = 0;\n                while(grid[i][j] ==\
    \ 1){\n                    count++;\n                    grid[i][j] = 0;\n   \
    \                 if(count > max){\n                        max = count;\n   \
    \                 }\n                }\n            }\n        }\n    }\n    return\
    \ max;\n}\n", "    var max = 0;\n    for(var i = 0; i < grid.length; i++){\n \
    \       for(var j = 0; j < grid[i].length; j++){\n            if(grid[i][j] ==\
    \ 1){\n                max = Math.max(max, fill(grid, i, j, capacity));\n    \
    \        }\n        }\n    }\n    return max;\n}\n\nfunction fill(grid, i, j,\
    \ capacity){\n    var count = 0;\n    while(grid[i][j] == 1){\n        count++;\n\
    \        grid[i][j] = 0;\n        if(i > 0){\n            grid[i-1][j] = 1;\n\
    \        }\n        if(j > 0){\n            grid[i][j-1] = 1;\n        }\n   \
    \     if(i < grid.length - 1){\n            grid[i+1][j] = 1;\n        }\n   \
    \     if(j < grid[i].length - 1){\n            grid[i][j+1] = 1;\n        }\n\
    \    }\n    return count;\n}", "    let max = 0;\n    for(let i = 0; i < grid.length;\
    \ i++){\n        let row = grid[i];\n        let buckets = [];\n        for(let\
    \ j = 0; j < row.length; j++){\n            if(row[j] === 1){\n              \
    \  buckets.push(0);\n            }\n            else{\n                buckets.push(capacity);\n\
    \            }\n        }\n        let max_fill = 0;\n        for(let j = 0; j\
    \ < buckets.length; j++){\n            if(buckets[j] > 0){\n                max_fill\
    \ += Math.min(buckets[j], capacity - buckets[j]);\n            }\n        }\n\
    \        max = Math.max(max, max_fill);\n    }\n    return max;\n}\n", "    let\
    \ result = 0;\n    for(let i = 0; i < grid.length; i++){\n        for(let j =\
    \ 0; j < grid[i].length; j++){\n            if(grid[i][j] == 1){\n           \
    \     let bucket = new Array(grid[i].length).fill(0);\n                let max\
    \ = 0;\n                for(let k = 0; k < grid[i].length; k++){\n           \
    \         if(grid[i][k] == 1){\n                        bucket[k] = 1;\n     \
    \                   max = Math.max(max, bucket.reduce((a, b) => a + b));\n   \
    \                 }\n                }\n                if(max > capacity){\n\
    \                    result += max - capacity;\n                }\n          \
    \  }\n        }\n    }\n    return result;\n}\n", "    var i, j, max = 0;\n  \
    \  for(i = 0; i < grid.length; i++){\n        for(j = 0; j < grid[i].length; j++){\n\
    \            if(grid[i][j] === 1){\n                max = Math.max(max, fill(i,\
    \ j, grid, capacity));\n            }\n        }\n    }\n    return max;\n}\n\n\
    function fill(i, j, grid, capacity){\n    var max = 0;\n    while(grid[i][j] ===\
    \ 1){\n        max += 1;\n        grid[i][j] = 0;\n        if(i > 0 && grid[i-1][j]\
    \ === 1){\n            grid[i-1][j] = 0;\n            max += 1;\n        }\n \
    \       if(j > 0 && grid[i][j-1] === 1){\n            grid[i][j-1] = 0;\n    \
    \        max += 1;\n        }\n        if(i < grid.length - 1 && grid[i+1][j]\
    \ === 1){\n            grid[i+1][j] = 0;\n            max += 1;\n        }\n \
    \       if(j < grid[i].length - 1 && grid[i][j+1] === 1){\n            grid[i][j+1]\
    \ = 0;\n            max += 1;\n        }\n    }\n    return max;\n}\n", "  var\
    \ buckets = [];\n  var max_fill = 0;\n  for(var i=0; i<grid.length; i++){\n  \
    \  for(var j=0; j<grid[i].length; j++){\n      if(grid[i][j] == 1){\n        buckets.push([]);\n\
    \        buckets[buckets.length-1].push(i);\n        buckets[buckets.length-1].push(j);\n\
    \      }\n    }\n  }\n  for(var i=0; i<buckets.length; i++){\n    var bucket =\
    \ buckets[i];\n    var well = bucket[0];\n    var well_x = bucket[1];\n    var\
    \ well_y = bucket[2];\n    var well_size = grid[well][well_x][well_y];\n    if(well_size\
    \ > capacity){\n      max_fill += well_size - capacity;\n      for(var k=0; k<well_size\
    \ - capacity; k++){\n        grid[well][well_x][well_y] = 0;\n        buckets[i].push(well);\n\
    \        buckets[i].push(well_x);\n        buckets[i].push(well_y);\n      }\n\
    \    }\n  }\n  return max_fill;\n}\n", "    let n = grid.length;\n    let m =\
    \ grid[0].length;\n    let result = 0;\n    let [wells, buckets] = [[], []];\n\
    \    for (let i = 0; i < n; i++) {\n        wells[i] = [];\n        for (let j\
    \ = 0; j < m; j++) {\n            wells[i][j] = grid[i][j];\n            if (wells[i][j]\
    \ === 1) {\n                wells[i][j] = 0;\n                buckets[i][j] =\
    \ capacity;\n            }\n        }\n    }\n    for (let i = 0; i < n; i++)\
    \ {\n        for (let j = 0; j < m; j++) {\n            if (wells[i][j] === 0)\
    \ {\n                let max = 0;\n                for (let k = 0; k < n; k++)\
    \ {\n                    for (let l = 0; l < m; l++) {\n                     \
    \   if (wells[k][l] === 1) {\n                            if (buckets[k][l] >\
    \ max) {\n                                max = buckets[k][l];\n             \
    \               }\n                        }\n                    }\n        \
    \        }\n                if (max > 0) {\n                    result += max;\n\
    \                    for (let k = 0; k < n; k++) {\n                        for\
    \ (let l = 0; l < m; l++) {\n                            if (wells[k][l] === 1)\
    \ {\n                                buckets[k][l] -= max;\n                 \
    \           }\n                        }\n                    }\n            \
    \    }\n            }\n        }\n    }\n    return result;\n}\n", "    let max\
    \ = 0;\n    for(let i = 0; i < grid.length; i++){\n        let cur = 0;\n    \
    \    for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j] == 1){\n\
    \                cur += 1;\n            }\n            if(cur > max){\n      \
    \          max = cur;\n            }\n        }\n    }\n    let count = 0;\n \
    \   while(max > 0){\n        count += 1;\n        let cur = 0;\n        for(let\
    \ i = 0; i < grid.length; i++){\n            let cur_row = 0;\n            for(let\
    \ j = 0; j < grid[i].length; j++){\n                if(grid[i][j] == 1){\n   \
    \                 cur_row += 1;\n                    if(cur_row == capacity){\n\
    \                        cur_row = 0;\n                        grid[i][j] = 0;\n\
    \                        cur -= 1;\n                    }\n                }\n\
    \            }\n        }\n        max = cur;\n    }\n    return count;\n}\n",
  "  let max = 0;\n  for(let i = 0; i < grid.length; i++){\n    let buckets = grid[i].length;\n\
    \    let filled = 0;\n    for(let j = 0; j < buckets; j++){\n      if(grid[i][j]\
    \ == 1){\n        filled++;\n        if(filled >= capacity){\n          max++;\n\
    \          filled = 0;\n        }\n      }\n    }\n  }\n  return max;\n}\n", " \
    \ let max_fill = 0;\n  let well_count = 0;\n  for(let i = 0; i < grid.length;\
    \ i++){\n    for(let j = 0; j < grid[i].length; j++){\n      if(grid[i][j] ===\
    \ 1){\n        well_count++;\n        let bucket_count = 0;\n        let well_capacity\
    \ = capacity;\n        while(well_capacity > 0){\n          if(well_count > well_capacity){\n\
    \            well_count -= well_capacity;\n            well_capacity = 0;\n  \
    \        } else {\n            well_capacity -= well_count;\n            well_count\
    \ = 0;\n          }\n          bucket_count++;\n        }\n        max_fill =\
    \ Math.max(max_fill, bucket_count);\n      }\n    }\n  }\n  return max_fill;\n\
    }\n", "  let max = 0;\n  for(let i = 0; i < grid.length; i++){\n    for(let j\
    \ = 0; j < grid[i].length; j++){\n      let count = 0;\n      while(grid[i][j]\
    \ === 1){\n        count++;\n        grid[i][j] = 0;\n        if(count === capacity){\n\
    \          max++;\n          count = 0;\n        }\n      }\n    }\n  }\n  return\
    \ max;\n}\n", "  let buckets = grid.map(row => row.map(well => 0))\n  let filled\
    \ = 0\n  let max_fill = 0\n  for(let i = 0; i < grid.length; i++){\n    for(let\
    \ j = 0; j < grid[i].length; j++){\n      if(grid[i][j] === 1){\n        let bucket\
    \ = buckets[i][j]\n        if(bucket < capacity){\n          buckets[i][j] +=\
    \ 1\n          filled += 1\n          max_fill = Math.max(max_fill, filled)\n\
    \        }\n      }\n    }\n  }\n  return max_fill\n}\n", "    let max = 0;\n\
    \    for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length;\
    \ j++){\n            if(grid[i][j] == 1){\n                let curr = 0;\n   \
    \             for(let k = 0; k < grid.length; k++){\n                    for(let\
    \ l = 0; l < grid[k].length; l++){\n                        if(grid[k][l] == 1){\n\
    \                            curr += 1;\n                        }\n         \
    \           }\n                }\n                if(curr > max){\n          \
    \          max = curr;\n                }\n            }\n        }\n    }\n \
    \   return max;\n}\n", "    let max = 0;\n    for(let i = 0; i < grid.length;\
    \ i++){\n        let curr = 0;\n        for(let j = 0; j < grid[i].length; j++){\n\
    \            if(grid[i][j] == 1){\n                curr += capacity;\n       \
    \     }\n            else{\n                curr = 0;\n            }\n       \
    \     if(curr > max){\n                max = curr;\n            }\n        }\n\
    \    }\n    return max;\n}\n", "    let result = 0;\n    for(let i = 0; i < grid.length;\
    \ i++){\n        let row = grid[i];\n        let buckets = [];\n        for(let\
    \ j = 0; j < row.length; j++){\n            let well = row[j];\n            if(well\
    \ === 1){\n                let bucket = new Bucket(capacity);\n              \
    \  buckets.push(bucket);\n            }\n        }\n        let max = 0;\n   \
    \     for(let j = 0; j < buckets.length; j++){\n            let bucket = buckets[j];\n\
    \            let filled = bucket.fill();\n            if(filled > max){\n    \
    \            max = filled;\n            }\n        }\n        result += max;\n\
    \    }\n    return result;\n}\n\nclass Bucket{\n    constructor(capacity){\n \
    \       this.capacity = capacity;\n        this.water = 0;\n    }\n    fill(){\n\
    \        if(this.water === this.capacity){\n            return 0;\n        }\n\
    \        this.water += 1;\n        return this.water;\n    }\n}\n", "    let max\
    \ = 0;\n    for(let i = 0; i < grid.length; i++){\n        let cur = 0;\n    \
    \    for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j] === 1){\n\
    \                cur += 1;\n            }\n            if(cur > max){\n      \
    \          max = cur;\n            }\n        }\n    }\n    return max;\n}\n",
  "    var max = 0;\n    for(var i = 0; i < grid.length; i++){\n        for(var j\
    \ = 0; j < grid[i].length; j++){\n            if(grid[i][j] == 1){\n         \
    \       max = Math.max(max, fill(grid, i, j, capacity));\n            }\n    \
    \    }\n    }\n    return max;\n}\n\nfunction fill(grid, i, j, capacity){\n  \
    \  var count = 0;\n    while(grid[i][j] == 1){\n        count++;\n        grid[i][j]\
    \ = 0;\n        if(i > 0 && grid[i-1][j] == 1){\n            grid[i-1][j] = 0;\n\
    \            count += fill(grid, i-1, j, capacity);\n        }\n        if(j >\
    \ 0 && grid[i][j-1] == 1){\n            grid[i][j-1] = 0;\n            count +=\
    \ fill(grid, i, j-1, capacity);\n        }\n        if(i < grid.length-1 && grid[i+1][j]\
    \ == 1){\n            grid[i+1][j] = 0;\n            count += fill(grid, i+1,\
    \ j, capacity);\n        }\n        if(j < grid[i].length-1 && grid[i][j+1] ==\
    \ 1){\n            grid[i][j+1] = 0;\n            count += fill(grid, i, j+1,\
    \ capacity);\n        }\n    }\n    return count;\n}", "  let max = 0;\n  for(let\
    \ i = 0; i < grid.length; i++){\n    let buckets = grid[i].length;\n    let filled\
    \ = 0;\n    for(let j = 0; j < grid[i].length; j++){\n      if(grid[i][j] ===\
    \ 1){\n        filled++;\n        if(filled === buckets){\n          filled =\
    \ 0;\n          max++;\n        }\n      }\n    }\n  }\n  return max;\n}\n", " \
    \   let n = grid.length;\n    let m = grid[0].length;\n    let dp = new Array(n);\n\
    \    for(let i = 0; i < n; i++){\n        dp[i] = new Array(m);\n        for(let\
    \ j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n                dp[i][j]\
    \ = 0;\n            }else{\n                dp[i][j] = Infinity;\n           \
    \ }\n        }\n    }\n    let max = 0;\n    for(let i = 0; i < n; i++){\n   \
    \     for(let j = 0; j < m; j++){\n            if(dp[i][j] > max){\n         \
    \       max = dp[i][j];\n            }\n        }\n    }\n    let count = 0;\n\
    \    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n      \
    \      if(dp[i][j] == max){\n                count++;\n                if(count\
    \ == capacity){\n                    return max;\n                }\n        \
    \    }\n        }\n    }\n    return max;\n}\n", "    let result = 0;\n    for(let\
    \ i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length; j++){\n\
    \            if(grid[i][j] === 1){\n                let bucket = new Bucket(capacity);\n\
    \                let well = new Well(i, j);\n                let max = 0;\n  \
    \              while(bucket.canFill() && well.canFill()){\n                  \
    \  max = Math.max(max, bucket.fill(well));\n                }\n              \
    \  result = Math.max(result, max);\n            }\n        }\n    }\n    return\
    \ result;\n}\n\nclass Bucket{\n    constructor(capacity){\n        this.capacity\
    \ = capacity;\n        this.water = 0;\n    }\n\n    canFill(){\n        return\
    \ this.water < this.capacity;\n    }\n\n    fill(well){\n        let water = Math.min(this.capacity\
    \ - this.water, well.water);\n        this.water += water;\n        well.water\
    \ -= water;\n        return water;\n    }\n}\n\nclass Well{\n    constructor(row,\
    \ col){\n        this.row = row;\n        this.col = col;\n        this.water\
    \ = 0;\n    }\n\n    canFill(){\n        return this.water < this.capacity;\n\
    \    }\n\n    fill(bucket){\n        let water = Math.min(this.capacity - this.water,\
    \ bucket.water);\n        this.water += water;\n        bucket.water -= water;\n\
    \        return water;\n    }\n}\n\nmodule.exports = max_fill;", "  let n = grid.length\n\
    \  let m = grid[0].length\n  let result = 0\n  let i = 0\n  let j = 0\n  let k\
    \ = 0\n  while(i < n && j < m){\n    if(grid[i][j] == 1){\n      result += 1\n\
    \      k = i\n      while(k < n && grid[k][j] == 1){\n        k += 1\n      }\n\
    \      k -= 1\n      while(k >= 0 && grid[k][j] == 1){\n        k -= 1\n     \
    \ }\n      k += 1\n      while(k < n && grid[k][j] == 1){\n        k += 1\n  \
    \    }\n      k -= 1\n      while(k >= 0 && grid[k][j] == 1){\n        k -= 1\n\
    \      }\n      k += 1\n      while(k < n && grid[k][j] == 1){\n        k += 1\n\
    \      }\n      k -= 1\n      while(k >= 0 && grid[k][j] == 1){\n        k -=\
    \ 1\n      }\n      k += 1\n      while(k < n && grid[k][j] == 1){\n        k\
    \ += 1\n      }\n      k -= 1\n      while(k >= 0 && grid[k][j] == 1){\n     \
    \   k -= 1\n      }\n      k += 1\n      while(k < n && grid[k][j] == 1){\n  \
    \      k += 1\n      }\n      k -= 1\n      while(k >= 0 && grid[k][j] == 1){\n\
    \        k -= 1\n      }\n      k += 1\n      while(k < n && grid[k][j] == 1){\n\
    \        k += 1\n      }\n      k -= 1\n      while(k >= 0 && grid[k][j] == 1){\n\
    \        k -= 1\n      }\n      k += 1\n      while(k < n && grid[k][j] == 1){\n\
    \        k += 1\n      }\n      k -= 1\n      while(k >= 0 && grid[k][j] == 1){\n\
    \        k -= 1\n      }\n      k += 1\n      while(k < n && grid[k][j] == 1",
  "    var well_count = grid.length;\n    var well_length = grid[0].length;\n    var\
    \ buckets = [];\n    for(var i=0; i<well_count; i++){\n        buckets.push(0);\n\
    \    }\n    var max_fill = 0;\n    for(var i=0; i<well_count; i++){\n        for(var\
    \ j=0; j<well_length; j++){\n            if(grid[i][j] == 1){\n              \
    \  var well_index = i*well_length + j;\n                var well_capacity = capacity;\n\
    \                while(well_capacity > 0){\n                    var bucket_index\
    \ = buckets[well_index];\n                    if(bucket_index == undefined){\n\
    \                        buckets[well_index] = well_index;\n                 \
    \       well_capacity--;\n                    }\n                    else{\n \
    \                       well_index = bucket_index;\n                    }\n  \
    \              }\n                max_fill++;\n            }\n        }\n    }\n\
    \    return max_fill;\n}\n", "  let max = 0;\n  for(let i = 0; i < grid.length;\
    \ i++){\n    for(let j = 0; j < grid[i].length; j++){\n      let cur = 0;\n  \
    \    if(grid[i][j] === 1){\n        cur = fill(grid, i, j, capacity);\n      }\n\
    \      max = Math.max(max, cur);\n    }\n  }\n  return max;\n}\n\nfunction fill(grid,\
    \ i, j, capacity){\n  let cur = 0;\n  let left = i - 1;\n  let right = i + 1;\n\
    \  let top = j - 1;\n  let bottom = j + 1;\n  while(left >= 0 && grid[left][j]\
    \ === 1){\n    cur++;\n    left--;\n  }\n  while(right < grid.length && grid[right][j]\
    \ === 1){\n    cur++;\n    right++;\n  }\n  while(top >= 0 && grid[i][top] ===\
    \ 1){\n    cur++;\n    top--;\n  }\n  while(bottom < grid[i].length && grid[i][bottom]\
    \ === 1){\n    cur++;\n    bottom++;\n  }\n  return cur;\n}\n", "    let max =\
    \ 0;\n    for(let i = 0; i < grid.length; i++){\n        let curr = 0;\n     \
    \   for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j] == 1){\n\
    \                curr += 1;\n            }\n            if(curr > max){\n    \
    \            max = curr;\n            }\n        }\n    }\n    return max;\n}\n",
  "    let n = grid.length,\n        m = grid[0].length,\n        dp = new Array(n+1).fill(0),\n\
    \        dp_ = new Array(n+1).fill(0),\n        max_ = 0;\n    for(let i=0; i<n;\
    \ i++){\n        for(let j=0; j<m; j++){\n            if(grid[i][j] === 1){\n\
    \                dp[i+1] = Math.max(dp[i+1], dp[i]+1);\n                dp_[i+1]\
    \ = Math.max(dp_[i+1], dp_[i]+1);\n            }\n        }\n    }\n    for(let\
    \ i=0; i<n; i++){\n        for(let j=0; j<m; j++){\n            if(grid[i][j]\
    \ === 1){\n                max_ = Math.max(max_, dp[i+1] + dp_[i+1]);\n      \
    \      }\n        }\n    }\n    return max_;\n}\n", "    let well_count = 0;\n\
    \    let well_length = grid[0].length;\n    let well_index = 0;\n    let bucket_count\
    \ = 0;\n    let bucket_capacity = capacity;\n    let bucket_index = 0;\n    let\
    \ bucket_length = 0;\n    let bucket_index_prev = 0;\n    let bucket_length_prev\
    \ = 0;\n    let well_index_prev = 0;\n    let well_length_prev = 0;\n    let well_count_prev\
    \ = 0;\n    let well_index_next = 0;\n    let well_length_next = 0;\n    let well_count_next\
    \ = 0;\n    let well_index_next_prev = 0;\n    let well_length_next_prev = 0;\n\
    \    let well_count_next_prev = 0;\n    let well_index_next_next = 0;\n    let\
    \ well_length_next_next = 0;\n    let well_count_next_next = 0;\n    let well_index_next_next_prev\
    \ = 0;\n    let well_length_next_next_prev = 0;\n    let well_count_next_next_prev\
    \ = 0;\n    let well_index_next_next_next = 0;\n    let well_length_next_next_next\
    \ = 0;\n    let well_count_next_next_next = 0;\n    let well_index_next_next_next_prev\
    \ = 0;\n    let well_length_next_next_next_prev = 0;\n    let well_count_next_next_next_prev\
    \ = 0;\n    let well_index_next_next_next_next = 0;\n    let well_length_next_next_next_next\
    \ = 0;\n    let well_count_next_next_next_next = 0;\n    let well_index_next_next_next_next_prev\
    \ = 0;\n    let well_length_next_next_next_next_prev = 0;\n    let well_count_next_next_next_next_prev\
    \ = 0;\n    let well_index_next_next_next_next_next = 0;\n    let well_length_next_next_next",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let dp = new Array(n);\n\
    \    for(let i = 0; i < n; i++){\n        dp[i] = new Array(m);\n        for(let\
    \ j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n                dp[i][j]\
    \ = 0;\n            }else{\n                dp[i][j] = Infinity;\n           \
    \ }\n        }\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0;\
    \ j < m; j++){\n            if(grid[i][j] == 1){\n                dp[i][j] = Math.min(dp[i][j],\
    \ dp[i][j-1] + 1);\n                dp[i][j] = Math.min(dp[i][j], dp[i-1][j] +\
    \ 1);\n                dp[i][j] = Math.min(dp[i][j], dp[i-1][j-1] + 1);\n    \
    \        }\n        }\n    }\n    let max = 0;\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n     \
    \           max = Math.max(max, dp[i][j]);\n            }\n        }\n    }\n\
    \    return max;\n}\n", "    let max = 0;\n    for(let i = 0; i < grid.length;\
    \ i++){\n        let buckets = grid[i].length;\n        let filled = 0;\n    \
    \    for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j] === 1){\n\
    \                filled++;\n                if(filled === buckets){\n        \
    \            filled = 0;\n                    buckets--;\n                }\n\
    \            }\n        }\n        max = Math.max(max, filled);\n    }\n    return\
    \ max;\n}\n", "    var max = 0;\n    for(var i=0; i<grid.length; i++){\n     \
    \   for(var j=0; j<grid[i].length; j++){\n            if(grid[i][j] == 1){\n \
    \               max = Math.max(max, fill(grid, i, j, capacity));\n           \
    \ }\n        }\n    }\n    return max;\n}\n\nfunction fill(grid, i, j, capacity){\n\
    \    var max = 0;\n    if(i > 0 && grid[i-1][j] == 1){\n        max += fill(grid,\
    \ i-1, j, capacity);\n    }\n    if(i < grid.length-1 && grid[i+1][j] == 1){\n\
    \        max += fill(grid, i+1, j, capacity);\n    }\n    if(j > 0 && grid[i][j-1]\
    \ == 1){\n        max += fill(grid, i, j-1, capacity);\n    }\n    if(j < grid[i].length-1\
    \ && grid[i][j+1] == 1){\n        max += fill(grid, i, j+1, capacity);\n    }\n\
    \    return max;\n}", "    let max = 0;\n    let i = 0;\n    let j = 0;\n    let\
    \ count = 0;\n    while(i < grid.length && j < grid[0].length){\n        if(grid[i][j]\
    \ == 1){\n            count++;\n            if(count > max){\n               \
    \ max = count;\n            }\n            let bucket = grid[i][j];\n        \
    \    while(bucket > 0){\n                bucket--;\n                i++;\n   \
    \             if(i >= grid.length){\n                    i = 0;\n            \
    \        j++;\n                }\n            }\n        }\n        i++;\n   \
    \ }\n    return max;\n}\n", "    let max = 0;\n    for(let i = 0; i < grid.length;\
    \ i++){\n        for(let j = 0; j < grid[i].length; j++){\n            let count\
    \ = 0;\n            while(grid[i][j] === 1){\n                count++;\n     \
    \           grid[i][j] = 0;\n            }\n            max = Math.max(max, count);\n\
    \        }\n    }\n    return max;\n}\n", "    let max = 0;\n    for(let i = 0;\
    \ i < grid.length; i++){\n        for(let j = 0; j < grid[i].length; j++){\n \
    \           let count = 0;\n            if(grid[i][j] == 1){\n               \
    \ let left = i - 1;\n                let right = i + 1;\n                let top\
    \ = j - 1;\n                let bottom = j + 1;\n                for(let k = left;\
    \ k <= right; k++){\n                    for(let l = top; l <= bottom; l++){\n\
    \                        if(grid[k][l] == 1){\n                            count++;\n\
    \                        }\n                    }\n                }\n       \
    \         if(count > max){\n                    max = count;\n               \
    \ }\n            }\n        }\n    }\n    return max;\n}\n", "  let result = 0;\n\
    \  for(let i = 0; i < grid.length; i++){\n    for(let j = 0; j < grid[i].length;\
    \ j++){\n      let curr = grid[i][j];\n      if(curr === 1){\n        let curr_bucket\
    \ = 0;\n        let curr_well = i;\n        let curr_well_length = grid[i].length;\n\
    \        while(curr_bucket < capacity){\n          if(curr_well === 0){\n    \
    \        curr_well = i;\n            curr_well_length = grid[i].length;\n    \
    \      }\n          let next_well = curr_well + 1;\n          if(next_well ===\
    \ curr_well_length){\n            next_well = 0;\n          }\n          let next_well_length\
    \ = grid[next_well].length;\n          let next_bucket = curr_bucket + grid[next_well][next_well_length\
    \ - 1];\n          if(next_bucket > capacity){\n            break;\n         \
    \ }\n          curr_bucket = next_bucket;\n          curr_well = next_well;\n\
    \        }\n        result += curr_bucket;\n      }\n    }\n  }\n  return result;\n\
    }\n", "    let buckets = [],\n        wells = grid.map(row => row.map(well =>\
    \ well === 1)),\n        wells_length = wells.length,\n        wells_index = 0,\n\
    \        wells_count = 0,\n        wells_capacity = capacity,\n        wells_filled\
    \ = 0,\n        wells_filled_count = 0,\n        wells_filled_capacity = 0,\n\
    \        wells_filled_index = 0,\n        wells_filled_count_index = 0,\n    \
    \    wells_filled_capacity_index = 0;\n\n    while(wells_filled_count < wells_length){\n\
    \        wells_filled_count += wells[wells_index][wells_filled_count];\n     \
    \   wells_filled_count_index++;\n        wells_filled_capacity += wells[wells_index][wells_filled_count_index];\n\
    \        wells_filled_capacity_index++;\n        wells_filled_index++;\n     \
    \   wells_filled_count_index = 0;\n        wells_filled_capacity_index = 0;\n\
    \        wells_filled_count = 0;\n        wells_filled = 0;\n        wells_index++;\n\
    \        wells_count++;\n        wells_capacity--;\n        if(wells_capacity\
    \ === 0){\n            wells_filled_count = wells_filled_count_index;\n      \
    \      wells_filled_capacity = wells_filled_capacity_index;\n            wells_filled_index\
    \ = wells_filled_index;\n            wells_filled_count_index = 0;\n         \
    \   wells_filled_capacity_index = 0;\n            wells_filled_count = 0;\n  \
    \          wells_filled = 0;\n            wells_index--;\n            wells_count--;\n\
    \            wells_capacity = capacity;\n        }\n    }\n    return wells_filled_count;\n\
    }\n", "  let well_count = grid.length;\n  let well_length = grid[0].length;\n\
    \  let buckets = [];\n  let max_fill = 0;\n  for(let i = 0; i < well_count; i++){\n\
    \    let well = grid[i];\n    let bucket_count = well.length;\n    let bucket_length\
    \ = well[0].length;\n    let bucket_capacity = capacity;\n    let bucket_index\
    \ = 0;\n    for(let j = 0; j < bucket_count; j++){\n      if(well[j] === 1){\n\
    \        bucket_index = j;\n        break;\n      }\n    }\n    let bucket = [];\n\
    \    for(let k = 0; k < bucket_length; k++){\n      bucket.push(0);\n    }\n \
    \   buckets.push(bucket);\n  }\n  for(let i = 0; i < well_count; i++){\n    let\
    \ well = grid[i];\n    let bucket_count = well.length;\n    let bucket_length\
    \ = well[0].length;\n    let bucket_index = 0;\n    for(let j = 0; j < bucket_count;\
    \ j++){\n      if(well[j] === 1){\n        bucket_index = j;\n        break;\n\
    \      }\n    }\n    let bucket = buckets[i];\n    let bucket_full = false;\n\
    \    while(!bucket_full){\n      let bucket_fill = 0;\n      for(let k = 0; k\
    \ < bucket_length; k++){\n        bucket[k] += 1;\n        bucket_fill += bucket[k];\n\
    \        if(bucket_fill >= bucket_capacity){\n          bucket_full = true;\n\
    \          break;\n        }\n      }\n      if(bucket_full){\n        max_fill\
    \ += bucket_fill;\n        bucket_index += 1;\n        if(bucket_index >= bucket_count){\n\
    \          bucket_index = 0;\n        }\n        bucket = buckets[i];\n      \
    \  bucket_full = false;\n      }\n    }\n  }\n  return max_fill;\n}\n", "  let\
    \ n = grid.length\n  let m = grid[0].length\n  let result = 0\n  for(let i = 0;\
    \ i < n; i++){\n    for(let j = 0; j < m; j++){\n      if(grid[i][j] == 1){\n\
    \        let left = 0\n        let right = 0\n        let top = 0\n        let\
    \ bottom = 0\n        if(i > 0){\n          left = grid[i-1][j]\n        }\n \
    \       if(i < n-1){\n          right = grid[i+1][j]\n        }\n        if(j\
    \ > 0){\n          top = grid[i][j-1]\n        }\n        if(j < m-1){\n     \
    \     bottom = grid[i][j+1]\n        }\n        if(left > 0 && right > 0 && top\
    \ > 0 && bottom > 0){\n          result += Math.min(Math.min(left, right), Math.min(top,\
    \ bottom))\n        }\n        else{\n          result += Math.min(Math.min(left,\
    \ right), Math.min(top, bottom))\n        }\n      }\n    }\n  }\n  return result\n\
    }\n", "  let max = 0;\n  for(let i = 0; i < grid.length; i++){\n    for(let j\
    \ = 0; j < grid[i].length; j++){\n      let cur = grid[i][j];\n      if(cur ===\
    \ 0){\n        continue;\n      }\n      let count = 0;\n      while(cur > 0){\n\
    \        count += cur;\n        cur -= capacity;\n      }\n      max = Math.max(max,\
    \ count);\n    }\n  }\n  return max;\n}\n", "    var i, j, max = 0;\n    for(i\
    \ = 0; i < grid.length; i++){\n        for(j = 0; j < grid[i].length; j++){\n\
    \            if(grid[i][j] === 1){\n                max = Math.max(max, fill(grid,\
    \ i, j, capacity));\n            }\n        }\n    }\n    return max;\n}\n\nfunction\
    \ fill(grid, i, j, capacity){\n    var count = 0;\n    while(grid[i][j] === 1){\n\
    \        count++;\n        grid[i][j] = 0;\n        if(i > 0 && grid[i-1][j] ===\
    \ 1){\n            grid[i-1][j] = 0;\n            i--;\n        }\n        if(j\
    \ > 0 && grid[i][j-1] === 1){\n            grid[i][j-1] = 0;\n            j--;\n\
    \        }\n        if(i < grid.length-1 && grid[i+1][j] === 1){\n           \
    \ grid[i+1][j] = 0;\n            i++;\n        }\n        if(j < grid[i].length-1\
    \ && grid[i][j+1] === 1){\n            grid[i][j+1] = 0;\n            j++;\n \
    \       }\n    }\n    return count;\n}\n", "  let buckets = [];\n  let max_fill\
    \ = 0;\n  for (let i = 0; i < grid.length; i++){\n    for (let j = 0; j < grid[i].length;\
    \ j++){\n      if (grid[i][j] === 1){\n        buckets.push([]);\n        let\
    \ count = 0;\n        while (count < grid.length){\n          let row = i + count;\n\
    \          let col = j + count;\n          if (row >= grid.length || col >= grid[row].length)\
    \ break;\n          if (grid[row][col] === 1){\n            buckets[buckets.length\
    \ - 1].push(row, col);\n            count++;\n          } else {\n           \
    \ break;\n          }\n        }\n      }\n    }\n  }\n  for (let i = 0; i < buckets.length;\
    \ i++){\n    let bucket = buckets[i];\n    let count = 0;\n    while (count <\
    \ bucket.length){\n      let row = bucket[count][0];\n      let col = bucket[count][1];\n\
    \      let curr = grid[row][col];\n      if (curr === 1){\n        grid[row][col]\
    \ = 0;\n        count++;\n      } else {\n        count = bucket.length;\n   \
    \   }\n    }\n  }\n  for (let i = 0; i < grid.length; i++){\n    for (let j =\
    \ 0; j < grid[i].length; j++){\n      if (grid[i][j] === 1){\n        max_fill++;\n\
    \      }\n    }\n  }\n  return max_fill;\n}\n", "    var i, j, max = 0;\n    for(i\
    \ = 0; i < grid.length; i++){\n        for(j = 0; j < grid[i].length; j++){\n\
    \            if(grid[i][j] == 1){\n                max = Math.max(max, fill(i,\
    \ j, grid, capacity));\n            }\n        }\n    }\n    return max;\n}\n\n\
    function fill(i, j, grid, capacity){\n    var max = 0;\n    while(grid[i][j] ==\
    \ 1){\n        max += 1;\n        grid[i][j] = 0;\n        if(i > 0){\n      \
    \      grid[i-1][j] = 1;\n        }\n        if(j > 0){\n            grid[i][j-1]\
    \ = 1;\n        }\n        if(i < grid.length-1){\n            grid[i+1][j] =\
    \ 1;\n        }\n        if(j < grid[i].length-1){\n            grid[i][j+1] =\
    \ 1;\n        }\n    }\n    return max;\n}\n", "  let well_count = grid.length\n\
    \  let well_length = grid[0].length\n  let well_capacity = capacity\n  let well_water\
    \ = 0\n  let well_bucket = 0\n  let well_index = 0\n  let well_bucket_count =\
    \ 0\n  let well_bucket_water = 0\n  let well_bucket_index = 0\n  let well_bucket_water_count\
    \ = 0\n  let well_bucket_water_index = 0\n  let max_fill_count = 0\n  for (let\
    \ i = 0; i < well_count; i++){\n    for (let j = 0; j < well_length; j++){\n \
    \     if (grid[i][j] == 1){\n        well_water += 1\n        well_bucket += 1\n\
    \        well_index = i\n        well_bucket_index = j\n        well_bucket_count\
    \ += 1\n        well_bucket_water += 1\n        well_bucket_water_index = i\n\
    \        well_bucket_water_count += 1\n      }\n    }\n  }\n  for (let i = 0;\
    \ i < well_count; i++){\n    for (let j = 0; j < well_length; j++){\n      if\
    \ (well_bucket_count > well_bucket_water_count){\n        well_bucket_water_count\
    \ = well_bucket_count\n        well_bucket_water_index = i\n        well_bucket_water\
    \ = well_bucket\n      }\n      if (well_bucket_count < well_bucket_water_count){\n\
    \        well_bucket_count = well_bucket_water_count\n        well_bucket_index\
    \ = i\n        well_bucket = well_bucket_water\n      }\n      well_bucket_count\
    \ -= 1\n      well_bucket_water_count -= 1\n    }\n  }\n  for (let i = 0; i <\
    \ well_count; i++){\n    for (let j = 0; j < well_length; j++){\n      if (well_bucket_count\
    \ > well_bucket_water_count){\n        well_bucket_", "  let max = 0;\n  for(let\
    \ i = 0; i < grid.length; i++){\n    for(let j = 0; j < grid[i].length; j++){\n\
    \      let cur = grid[i][j];\n      let left = i - 1;\n      let right = i + 1;\n\
    \      let top = j - 1;\n      let bottom = j + 1;\n      if(left >= 0 && grid[left][j]\
    \ === 1){\n        let new_val = grid[left][j] + grid[i][j];\n        if(new_val\
    \ <= capacity){\n          grid[left][j] = new_val;\n          max = Math.max(max,\
    \ new_val);\n        }\n      }\n      if(right < grid.length && grid[right][j]\
    \ === 1){\n        let new_val = grid[right][j] + grid[i][j];\n        if(new_val\
    \ <= capacity){\n          grid[right][j] = new_val;\n          max = Math.max(max,\
    \ new_val);\n        }\n      }\n      if(top >= 0 && grid[i][top] === 1){\n \
    \       let new_val = grid[i][top] + grid[i][j];\n        if(new_val <= capacity){\n\
    \          grid[i][top] = new_val;\n          max = Math.max(max, new_val);\n\
    \        }\n      }\n      if(bottom < grid[i].length && grid[i][bottom] === 1){\n\
    \        let new_val = grid[i][bottom] + grid[i][j];\n        if(new_val <= capacity){\n\
    \          grid[i][bottom] = new_val;\n          max = Math.max(max, new_val);\n\
    \        }\n      }\n    }\n  }\n  return max;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let result = 0;\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n     \
    \           let buckets = [];\n                let max_buckets = 0;\n        \
    \        for(let k = 0; k < n; k++){\n                    for(let l = 0; l < m;\
    \ l++){\n                        if(grid[k][l] == 0){\n                      \
    \      buckets.push(0);\n                        }\n                        else{\n\
    \                            buckets.push(buckets[k*m + l] + 1);\n           \
    \             }\n                    }\n                }\n                for(let\
    \ k = 0; k < n; k++){\n                    for(let l = 0; l < m; l++){\n     \
    \                   if(grid[k][l] == 1){\n                            max_buckets\
    \ = Math.max(max_buckets, buckets[k*m + l]);\n                        }\n    \
    \                }\n                }\n                if(max_buckets <= capacity){\n\
    \                    result += max_buckets;\n                }\n            }\n\
    \        }\n    }\n    return result;\n}\n", "  let buckets = [],\n      wells\
    \ = grid.map(row => row.map(well => well === 1)),\n      well_count = wells.length,\n\
    \      well_capacity = wells.reduce((acc, curr) => acc + curr.length, 0);\n\n\
    \  for(let i = 0; i < well_count; i++){\n    let curr_well = wells[i];\n    let\
    \ curr_well_capacity = curr_well.length;\n    let curr_well_buckets = curr_well.reduce((acc,\
    \ curr) => acc + curr, 0);\n    let curr_well_buckets_capacity = curr_well_buckets.length;\n\
    \    let curr_well_buckets_capacity_diff = curr_well_buckets_capacity - curr_well_capacity;\n\
    \n    if(curr_well_buckets_capacity_diff > 0){\n      let curr_well_buckets_capacity_diff_count\
    \ = Math.floor(curr_well_buckets_capacity_diff / capacity);\n      let curr_well_buckets_capacity_diff_count_remainder\
    \ = curr_well_buckets_capacity_diff % capacity;\n      let curr_well_buckets_capacity_diff_count_remainder_count\
    \ = Math.floor(curr_well_buckets_capacity_diff_remainder / capacity);\n      let\
    \ curr_well_buckets_capacity_diff_count_remainder_count_remainder = curr_well_buckets_capacity_diff_remainder\
    \ % capacity;\n\n      let curr_well_buckets_capacity_diff_count_remainder_count_remainder_count\
    \ = Math.floor(curr_well_buckets_capacity_diff_remainder_count / capacity);\n\
    \      let curr_well_buckets_capacity_diff_count_remainder_count_remainder_count_remainder\
    \ = curr_well_buckets_capacity_diff_remainder_count % capacity;\n\n      let curr_well_buckets_capacity_diff_count_remainder_count_remainder_count_remain",
  "    let max = 0;\n    for(let i = 0; i < grid.length; i++){\n        let buckets\
    \ = grid[i].length;\n        let filled = 0;\n        for(let j = 0; j < buckets;\
    \ j++){\n            if(grid[i][j] == 1){\n                filled++;\n       \
    \         if(filled >= capacity){\n                    max++;\n              \
    \      filled = 0;\n                }\n            }\n        }\n    }\n    return\
    \ max;\n}\n", "    let max = 0;\n    let i = 0;\n    let j = 0;\n    let count\
    \ = 0;\n    while(i < grid.length && j < grid[0].length){\n        if(grid[i][j]\
    \ == 1){\n            count++;\n            if(count > max){\n               \
    \ max = count;\n            }\n            if(count == capacity){\n          \
    \      count = 0;\n                i++;\n                j++;\n            }\n\
    \        }else{\n            count = 0;\n            i++;\n            j++;\n\
    \        }\n    }\n    return max;\n}\n", "  let result = 0;\n  for(let i = 0;\
    \ i < grid.length; i++){\n    for(let j = 0; j < grid[i].length; j++){\n     \
    \ if(grid[i][j] == 1){\n        let buckets = [];\n        let max_fill = 0;\n\
    \        let max_index = 0;\n        for(let k = 0; k < grid.length; k++){\n \
    \         if(grid[k][j] == 1){\n            buckets.push(k);\n          }\n  \
    \      }\n        for(let k = 0; k < buckets.length; k++){\n          let bucket\
    \ = buckets[k];\n          let fill = 0;\n          while(fill < capacity && bucket\
    \ != i){\n            fill += grid[bucket][j];\n            bucket = buckets[k];\n\
    \          }\n          if(fill >= capacity){\n            max_fill = Math.max(max_fill,\
    \ fill);\n            max_index = k;\n          }\n        }\n        result +=\
    \ max_fill;\n        buckets.splice(max_index, 1);\n        for(let k = 0; k <\
    \ buckets.length; k++){\n          grid[buckets[k]][j] = 0;\n        }\n     \
    \ }\n    }\n  }\n  return result;\n}\n", "    var max = 0;\n    for(var i = 0;\
    \ i < grid.length; i++){\n        for(var j = 0; j < grid[i].length; j++){\n \
    \           if(grid[i][j] == 1){\n                var count = 0;\n           \
    \     while(grid[i][j] == 1){\n                    count++;\n                \
    \    grid[i][j] = 0;\n                    if(count > max){\n                 \
    \       max = count;\n                    }\n                }\n            }\n\
    \        }\n    }\n    return max;\n}\n", "  let max = 0;\n  let well_count =\
    \ 0;\n  for(let i = 0; i < grid.length; i++){\n    for(let j = 0; j < grid[i].length;\
    \ j++){\n      if(grid[i][j] === 1){\n        well_count++;\n        let bucket_count\
    \ = 0;\n        while(well_count > 0){\n          let bucket = Math.min(well_count,\
    \ capacity);\n          well_count -= bucket;\n          bucket_count += bucket;\n\
    \        }\n        max = Math.max(max, bucket_count);\n      }\n    }\n  }\n\
    \  return max;\n}\n", "    let max = 0;\n    let i = 0;\n    let j = 0;\n    let\
    \ count = 0;\n    while(count < grid.length){\n        if(grid[i][j] == 1){\n\
    \            count++;\n            i++;\n        }\n        else{\n          \
    \  i++;\n        }\n        if(i == grid.length){\n            i = 0;\n      \
    \      j++;\n        }\n        if(j == grid[i].length){\n            j = 0;\n\
    \        }\n        if(count == grid.length){\n            max++;\n        }\n\
    \    }\n    return max;\n}\n", "    let max = 0;\n    for(let i = 0; i < grid.length;\
    \ i++){\n        for(let j = 0; j < grid[i].length; j++){\n            let count\
    \ = 0;\n            while(grid[i][j] === 1){\n                count++;\n     \
    \           grid[i][j] = 0;\n            }\n            if(count > max){\n   \
    \             max = count;\n            }\n        }\n    }\n    return max;\n\
    }\n", "    let max = 0;\n    let row = grid.length;\n    let col = grid[0].length;\n\
    \    let well = [];\n    let well_index = [];\n    let well_count = 0;\n    let\
    \ well_count_max = 0;\n    for(let i = 0; i < row; i++){\n        well.push([]);\n\
    \        well_index.push([]);\n        for(let j = 0; j < col; j++){\n       \
    \     well[i].push(0);\n            well_index[i].push(0);\n        }\n    }\n\
    \    for(let i = 0; i < row; i++){\n        for(let j = 0; j < col; j++){\n  \
    \          if(grid[i][j] == 1){\n                well_count++;\n             \
    \   well_count_max = Math.max(well_count_max, well_count);\n                well[i][j]\
    \ = 1;\n                well_index[i][j] = well_count;\n            }\n      \
    \  }\n    }\n    for(let i = 0; i < row; i++){\n        for(let j = 0; j < col;\
    \ j++){\n            if(well[i][j] == 1){\n                let well_count_temp\
    \ = 0;\n                for(let k = 0; k < row; k++){\n                    for(let\
    \ l = 0; l < col; l++){\n                        if(well[k][l] == 1){\n      \
    \                      well_count_temp++;\n                        }\n       \
    \             }\n                }\n                well_count_max = Math.max(well_count_max,\
    \ well_count_temp);\n            }\n        }\n    }\n    for(let i = 0; i < row;\
    \ i++){\n        for(let j = 0; j < col; j++){\n            if(well[i][j] == 1){\n\
    \                let well_count_temp = 0;\n                for(let k = 0; k <\
    \ row; k++){\n                    for(let l = 0; l < col; l++){\n            \
    \            if(well[k][l] == 1){\n                            well_count_temp++;\n\
    \                        }\n                    }", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let max = 0;\n    let i = 0;\n    let j = 0;\n\
    \    let k = 0;\n    let l = 0;\n    let r = 0;\n    let c = 0;\n    let d = 0;\n\
    \    let e = 0;\n    let f = 0;\n    let g = 0;\n    let h = 0;\n    let a = 0;\n\
    \    let b = 0;\n    let c1 = 0;\n    let c2 = 0;\n    let c3 = 0;\n    let c4\
    \ = 0;\n    let c5 = 0;\n    let c6 = 0;\n    let c7 = 0;\n    let c8 = 0;\n \
    \   let c9 = 0;\n    let c10 = 0;\n    let c11 = 0;\n    let c12 = 0;\n    let\
    \ c13 = 0;\n    let c14 = 0;\n    let c15 = 0;\n    let c16 = 0;\n    let c17\
    \ = 0;\n    let c18 = 0;\n    let c19 = 0;\n    let c20 = 0;\n    let c21 = 0;\n\
    \    let c22 = 0;\n    let c23 = 0;\n    let c24 = 0;\n    let c25 = 0;\n    let\
    \ c26 = 0;\n    let c27 = 0;\n    let c28 = 0;\n    let c29 = 0;\n    let c30\
    \ = 0;\n    let c31 = 0;\n    let c32 = 0;\n    let c33 = 0;\n    let c34 = 0;\n\
    \    let c35 = 0;\n    let c36 = 0;\n    let c37 = 0;\n    let c38 = 0;\n    let\
    \ c39 = 0;\n    let c40 = 0;\n    let c41 = 0;\n    let c42 = 0;\n    let c43\
    \ = 0;\n    let c44 = 0;\n    let c45 = 0;\n    let c46 = 0;\n    let c47 = 0;\n\
    \    let c48 = 0;\n    let c49 = 0;\n    let", "  var well_count = grid.length;\n\
    \  var well_length = grid[0].length;\n  var buckets = [];\n  var max_fill = 0;\n\
    \  for(var i = 0; i < well_count; i++){\n    buckets.push(0);\n  }\n  for(var\
    \ i = 0; i < well_count; i++){\n    for(var j = 0; j < well_length; j++){\n  \
    \    if(grid[i][j] == 1){\n        buckets[i] += 1;\n        if(buckets[i] > capacity){\n\
    \          buckets[i] = 0;\n          max_fill += 1;\n        }\n      }\n   \
    \ }\n  }\n  return max_fill;\n}", "    let max = 0;\n    for(let i = 0; i < grid.length;\
    \ i++){\n        for(let j = 0; j < grid[i].length; j++){\n            let count\
    \ = 0;\n            while(grid[i][j] === 1){\n                count++;\n     \
    \           grid[i][j] = 0;\n                if(count === capacity){\n       \
    \             max++;\n                    count = 0;\n                }\n    \
    \        }\n        }\n    }\n    return max;\n}\n", "  let max = 0;\n  for(let\
    \ i = 0; i < grid.length; i++){\n    let buckets = grid[i].map(() => 0);\n   \
    \ for(let j = 0; j < grid[i].length; j++){\n      if(grid[i][j] === 1){\n    \
    \    let cur = 0;\n        while(cur < capacity){\n          let bucket = Math.min(buckets.length\
    \ - 1, Math.floor(Math.random() * buckets.length));\n          buckets[bucket]++;\n\
    \          cur++;\n        }\n      }\n    }\n    for(let j = 0; j < buckets.length;\
    \ j++){\n      if(buckets[j] > max){\n        max = buckets[j];\n      }\n   \
    \ }\n  }\n  return max;\n}\n", "  let max = 0;\n  for(let i = 0; i < grid.length;\
    \ i++){\n    let buckets = grid[i].length;\n    let filled = 0;\n    for(let j\
    \ = 0; j < grid[i].length; j++){\n      if(grid[i][j] === 1){\n        filled\
    \ += 1;\n        if(filled === buckets){\n          max += 1;\n          filled\
    \ = 0;\n        }\n      }\n    }\n  }\n  return max;\n}\n", "    let result =\
    \ 0;\n    for(let i = 0; i < grid.length; i++){\n        let row = grid[i];\n\
    \        let buckets = [];\n        for(let j = 0; j < row.length; j++){\n   \
    \         let well = row[j];\n            if(well === 1){\n                let\
    \ bucket = new Bucket(capacity);\n                buckets.push(bucket);\n    \
    \        }\n        }\n        let max = 0;\n        for(let j = 0; j < buckets.length;\
    \ j++){\n            let bucket = buckets[j];\n            let filled = bucket.fill();\n\
    \            if(filled > max){\n                max = filled;\n            }\n\
    \        }\n        result += max;\n    }\n    return result;\n}\n\nclass Bucket{\n\
    \    constructor(capacity){\n        this.capacity = capacity;\n        this.water\
    \ = 0;\n    }\n    fill(){\n        if(this.water === this.capacity){\n      \
    \      return 0;\n        }\n        let filled = Math.min(this.capacity - this.water,\
    \ Math.floor(Math.random() * this.capacity));\n        this.water += filled;\n\
    \        return filled;\n    }\n}\n", "    let max = 0;\n    let max_row = 0;\n\
    \    let max_col = 0;\n    for(let i = 0; i < grid.length; i++){\n        for(let\
    \ j = 0; j < grid[i].length; j++){\n            if(grid[i][j] == 1){\n       \
    \         let row = i;\n                let col = j;\n                let count\
    \ = 0;\n                while(grid[row][col] == 1){\n                    count++;\n\
    \                    row++;\n                    col++;\n                }\n \
    \               if(count > max){\n                    max = count;\n         \
    \           max_row = row - 1;\n                    max_col = col - 1;\n     \
    \           }\n            }\n        }\n    }\n    let count = 0;\n    let row\
    \ = max_row;\n    let col = max_col;\n    while(row >= 0 && col >= 0){\n     \
    \   count++;\n        row--;\n        col--;\n    }\n    return count;\n}\n",
  "    let max = 0;\n    for(let i = 0; i < grid.length; i++){\n        for(let j\
    \ = 0; j < grid[i].length; j++){\n            let cur = 0;\n            if(grid[i][j]\
    \ === 1){\n                cur = fill(grid, i, j, capacity);\n            }\n\
    \            max = Math.max(max, cur);\n        }\n    }\n    return max;\n}\n\
    \nfunction fill(grid, i, j, capacity){\n    let cur = 0;\n    let left = 0;\n\
    \    let right = 0;\n    let up = 0;\n    let down = 0;\n    if(i > 0){\n    \
    \    left = grid[i - 1][j];\n    }\n    if(i < grid.length - 1){\n        right\
    \ = grid[i + 1][j];\n    }\n    if(j > 0){\n        up = grid[i][j - 1];\n   \
    \ }\n    if(j < grid[i].length - 1){\n        down = grid[i][j + 1];\n    }\n\
    \    if(left > 0){\n        cur += fill(grid, i - 1, j, capacity);\n    }\n  \
    \  if(right > 0){\n        cur += fill(grid, i + 1, j, capacity);\n    }\n   \
    \ if(up > 0){\n        cur += fill(grid, i, j - 1, capacity);\n    }\n    if(down\
    \ > 0){\n        cur += fill(grid, i, j + 1, capacity);\n    }\n    return cur;\n\
    }", "    let result = 0;\n    for(let i = 0; i < grid.length; i++){\n        let\
    \ buckets = grid[i].map(() => 0);\n        for(let j = 0; j < grid[i].length;\
    \ j++){\n            if(grid[i][j] == 1){\n                let max = 0;\n    \
    \            for(let k = 0; k < buckets.length; k++){\n                    if(buckets[k]\
    \ < capacity){\n                        buckets[k]++;\n                      \
    \  max = Math.max(max, buckets[k]);\n                    }\n                }\n\
    \                result = Math.max(result, max);\n            }\n        }\n \
    \   }\n    return result;\n}\n", "    var i, j, max = 0;\n    for(i = 0; i < grid.length;\
    \ i++){\n        for(j = 0; j < grid[i].length; j++){\n            if(grid[i][j]\
    \ === 1){\n                max = Math.max(max, fill(i, j, grid, capacity));\n\
    \            }\n        }\n    }\n    return max;\n}\n\nfunction fill(i, j, grid,\
    \ capacity){\n    var count = 0;\n    while(grid[i][j] === 1){\n        count++;\n\
    \        grid[i][j] = 0;\n        if(i > 0 && grid[i - 1][j] === 1){\n       \
    \     grid[i - 1][j] = 0;\n        }\n        if(j > 0 && grid[i][j - 1] === 1){\n\
    \            grid[i][j - 1] = 0;\n        }\n        if(i < grid.length - 1 &&\
    \ grid[i + 1][j] === 1){\n            grid[i + 1][j] = 0;\n        }\n       \
    \ if(j < grid[i].length - 1 && grid[i][j + 1] === 1){\n            grid[i][j +\
    \ 1] = 0;\n        }\n    }\n    return count;\n}", "    let max = 0;\n    for(let\
    \ i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length; j++){\n\
    \            let count = 0;\n            if(grid[i][j] === 1){\n             \
    \   let left = i - 1;\n                let right = i + 1;\n                let\
    \ top = j - 1;\n                let bottom = j + 1;\n                for(let k\
    \ = left; k <= right; k++){\n                    for(let l = top; l <= bottom;\
    \ l++){\n                        if(grid[k][l] === 1){\n                     \
    \       count++;\n                        }\n                    }\n         \
    \       }\n                if(count > max){\n                    max = count;\n\
    \                }\n            }\n        }\n    }\n    return max;\n}\n", " \
    \   var max = 0;\n    for(var i = 0; i < grid.length; i++){\n        for(var j\
    \ = 0; j < grid[i].length; j++){\n            if(grid[i][j] == 1){\n         \
    \       max = Math.max(max, fill(grid, i, j, capacity));\n            }\n    \
    \    }\n    }\n    return max;\n}\n\nfunction fill(grid, i, j, capacity){\n  \
    \  var count = 0;\n    while(grid[i][j] == 1){\n        count++;\n        grid[i][j]\
    \ = 0;\n        if(i > 0 && grid[i - 1][j] == 1){\n            grid[i - 1][j]\
    \ = 0;\n            count += fill(grid, i - 1, j, capacity);\n        }\n    \
    \    if(j > 0 && grid[i][j - 1] == 1){\n            grid[i][j - 1] = 0;\n    \
    \        count += fill(grid, i, j - 1, capacity);\n        }\n        if(i < grid.length\
    \ - 1 && grid[i + 1][j] == 1){\n            grid[i + 1][j] = 0;\n            count\
    \ += fill(grid, i + 1, j, capacity);\n        }\n        if(j < grid[i].length\
    \ - 1 && grid[i][j + 1] == 1){\n            grid[i][j + 1] = 0;\n            count\
    \ += fill(grid, i, j + 1, capacity);\n        }\n    }\n    return count;\n}",
  "  var n = grid.length;\n  var m = grid[0].length;\n  var dp = Array(n + 1).fill(0);\n\
    \  \n  for(var i = 1; i <= n; i++){\n    for(var j = 1; j <= m; j++){\n      if(grid[i-1][j-1]\
    \ == 1){\n        dp[i] = Math.max(dp[i], dp[i-1] + 1);\n      }\n    }\n  }\n\
    \  \n  var result = 0;\n  for(var i = n; i >= 1; i--){\n    if(dp[i] > capacity){\n\
    \      result += dp[i] - capacity;\n    }\n  }\n  return result;\n}\n", "    let\
    \ max = 0;\n    for(let i = 0; i < grid.length; i++){\n        for(let j = 0;\
    \ j < grid[i].length; j++){\n            if(grid[i][j] == 1){\n              \
    \  let cur = 0;\n                let left = i - 1;\n                let right\
    \ = i + 1;\n                let top = j - 1;\n                let bottom = j +\
    \ 1;\n                if(left >= 0 && grid[left][j] == 1){\n                 \
    \   cur += 1;\n                }\n                if(right < grid.length && grid[right][j]\
    \ == 1){\n                    cur += 1;\n                }\n                if(top\
    \ >= 0 && grid[i][top] == 1){\n                    cur += 1;\n               \
    \ }\n                if(bottom < grid[i].length && grid[i][bottom] == 1){\n  \
    \                  cur += 1;\n                }\n                if(cur > max){\n\
    \                    max = cur;\n                }\n            }\n        }\n\
    \    }\n    return max;\n}\n", "    let max = 0;\n    for(let i = 0; i < grid.length;\
    \ i++){\n        let buckets = grid[i].length;\n        let filled = 0;\n    \
    \    for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j] === 1){\n\
    \                filled++;\n                if(filled === buckets){\n        \
    \            max++;\n                    filled = 0;\n                }\n    \
    \        }\n        }\n    }\n    return max;\n}\n", "    var n = grid.length;\n\
    \    var m = grid[0].length;\n    var result = 0;\n    for(var i=0; i<n; i++){\n\
    \        for(var j=0; j<m; j++){\n            if(grid[i][j] == 1){\n         \
    \       result += max_fill_well(grid, i, j, capacity);\n            }\n      \
    \  }\n    }\n    return result;\n}\n\nfunction max_fill_well(grid, i, j, capacity){\n\
    \    var n = grid.length;\n    var m = grid[0].length;\n    var result = 0;\n\
    \    if(i < 0 || i >= n || j < 0 || j >= m || grid[i][j] == 0){\n        return\
    \ result;\n    }\n    if(grid[i][j] == 1){\n        result += 1;\n        grid[i][j]\
    \ = 0;\n    }\n    result += max_fill_well(grid, i-1, j, capacity);\n    result\
    \ += max_fill_well(grid, i+1, j, capacity);\n    result += max_fill_well(grid,\
    \ i, j-1, capacity);\n    result += max_fill_well(grid, i, j+1, capacity);\n \
    \   grid[i][j] = 1;\n    return result;\n}", "    let max = 0;\n    for(let i\
    \ = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length; j++){\n\
    \            let cur = 0;\n            if(grid[i][j] == 1){\n                cur\
    \ = 1;\n            }\n            for(let k = 0; k < grid[i].length; k++){\n\
    \                if(grid[i][k] == 1){\n                    cur += 1;\n       \
    \         }\n            }\n            for(let k = 0; k < grid[i].length; k++){\n\
    \                if(grid[k][j] == 1){\n                    cur += 1;\n       \
    \         }\n            }\n            if(cur > max){\n                max =\
    \ cur;\n            }\n        }\n    }\n    return max;\n}\n", "  let well_count\
    \ = grid.length\n  let bucket_count = well_count * capacity\n  let well_capacity\
    \ = grid[0].length\n  let bucket_capacity = capacity\n  let well_index = 0\n \
    \ let bucket_index = 0\n  let well_filled = 0\n  let bucket_filled = 0\n  let\
    \ max_fill = 0\n  while(well_filled < well_count){\n    while(well_filled < well_count\
    \ && bucket_filled < bucket_count){\n      well_filled += well_capacity - well_index\n\
    \      bucket_filled += bucket_capacity - bucket_index\n      well_index++\n \
    \     bucket_index++\n    }\n    max_fill += bucket_filled\n    well_filled =\
    \ 0\n    bucket_filled = 0\n    well_index = 0\n    bucket_index = 0\n  }\n  return\
    \ max_fill\n}\n", "    let max = 0;\n    for(let i = 0; i < grid.length; i++){\n\
    \        for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j] ==\
    \ 1){\n                let cur = 0;\n                let left = i - 1;\n     \
    \           let right = i + 1;\n                let top = j - 1;\n           \
    \     let bottom = j + 1;\n                if(left >= 0 && grid[left][j] == 1){\n\
    \                    cur += 1;\n                }\n                if(right <\
    \ grid.length && grid[right][j] == 1){\n                    cur += 1;\n      \
    \          }\n                if(top >= 0 && grid[i][top] == 1){\n           \
    \         cur += 1;\n                }\n                if(bottom < grid[i].length\
    \ && grid[i][bottom] == 1){\n                    cur += 1;\n                }\n\
    \                if(cur > max){\n                    max = cur;\n            \
    \    }\n            }\n        }\n    }\n    return max;\n}\n", "  let max = 0;\n\
    \  for(let i = 0; i < grid.length; i++){\n    for(let j = 0; j < grid[i].length;\
    \ j++){\n      if(grid[i][j] == 1){\n        let cur = 0;\n        let left =\
    \ i;\n        let right = i;\n        let down = j;\n        let up = j;\n   \
    \     while(true){\n          if(left > 0 && grid[left - 1][j] == 1){\n      \
    \      cur++;\n            left--;\n          }\n          else if(right < grid.length\
    \ - 1 && grid[right + 1][j] == 1){\n            cur++;\n            right++;\n\
    \          }\n          else if(down > 0 && grid[i][down - 1] == 1){\n       \
    \     cur++;\n            down--;\n          }\n          else if(up < grid[i].length\
    \ - 1 && grid[i][up + 1] == 1){\n            cur++;\n            up++;\n     \
    \     }\n          else{\n            break;\n          }\n        }\n       \
    \ max = Math.max(max, cur);\n      }\n    }\n  }\n  return max;\n}\n", "    let\
    \ rows = grid.length;\n    let cols = grid[0].length;\n    let buckets = [];\n\
    \    let max = 0;\n    for(let i = 0; i < rows; i++){\n        let row = grid[i];\n\
    \        let buckets_row = [];\n        for(let j = 0; j < cols; j++){\n     \
    \       let bucket = row[j];\n            if(bucket){\n                buckets_row.push(bucket);\n\
    \            }\n        }\n        buckets.push(buckets_row);\n    }\n    for(let\
    \ i = 0; i < rows; i++){\n        let row = buckets[i];\n        for(let j = 0;\
    \ j < cols; j++){\n            let bucket = row[j];\n            if(bucket){\n\
    \                let count = 0;\n                while(bucket > 0){\n        \
    \            count++;\n                    let bucket_size = Math.min(bucket,\
    \ capacity);\n                    bucket -= bucket_size;\n                   \
    \ max = Math.max(max, count);\n                }\n            }\n        }\n \
    \   }\n    return max;\n}\n", "    var result = 0;\n    for(var i = 0; i < grid.length;\
    \ i++){\n        for(var j = 0; j < grid[i].length; j++){\n            if(grid[i][j]\
    \ == 1){\n                result++;\n                var bucket = new Array(grid[i].length);\n\
    \                for(var k = 0; k < bucket.length; k++){\n                   \
    \ bucket[k] = 0;\n                }\n                bucket[j] = capacity;\n \
    \               while(true){\n                    var max = 0;\n             \
    \       for(var k = 0; k < bucket.length; k++){\n                        if(bucket[k]\
    \ > max){\n                            max = bucket[k];\n                    \
    \    }\n                    }\n                    if(max == 0){\n           \
    \             break;\n                    }\n                    for(var k = 0;\
    \ k < bucket.length; k++){\n                        if(bucket[k] == max){\n  \
    \                          bucket[k] = 0;\n                        }\n       \
    \             }\n                }\n                for(var k = 0; k < bucket.length;\
    \ k++){\n                    if(bucket[k] > 0){\n                        result++;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return result;\n}\n", "    let max = 0;\n    for(let i = 0; i < grid.length;\
    \ i++){\n        for(let j = 0; j < grid[i].length; j++){\n            let count\
    \ = 0;\n            while(grid[i][j] === 1){\n                count++;\n     \
    \           grid[i][j] = 0;\n            }\n            if(count > max){\n   \
    \             max = count;\n            }\n        }\n    }\n    return max;\n\
    }\n", "    let max = 0;\n    let i = 0;\n    let j = 0;\n    let count = 0;\n\
    \    for(i = 0; i < grid.length; i++){\n        for(j = 0; j < grid[i].length;\
    \ j++){\n            if(grid[i][j] == 1){\n                count += 1;\n     \
    \           if(count > max){\n                    max = count;\n             \
    \   }\n                if(count >= capacity){\n                    count = 0;\n\
    \                }\n            }\n        }\n    }\n    return max;\n}\n", " \
    \ let buckets = []\n  let max_fill = 0\n  for (let i = 0; i < grid.length; i++){\n\
    \    for (let j = 0; j < grid[i].length; j++){\n      if (grid[i][j] === 1){\n\
    \        let bucket = new Bucket(i, j, capacity)\n        buckets.push(bucket)\n\
    \      }\n    }\n  }\n  for (let i = 0; i < buckets.length; i++){\n    let bucket\
    \ = buckets[i]\n    let filled = bucket.fill()\n    if (filled > max_fill){\n\
    \      max_fill = filled\n    }\n  }\n  return max_fill\n}\n\nclass Bucket {\n\
    \  constructor(i, j, capacity){\n    this.i = i\n    this.j = j\n    this.capacity\
    \ = capacity\n    this.filled = 0\n  }\n  fill(){\n    let filled = 0\n    for\
    \ (let i = this.i; i < this.i + this.capacity; i++){\n      for (let j = this.j;\
    \ j < this.j + this.capacity; j++){\n        if (this.grid[i][j] === 1){\n   \
    \       this.grid[i][j] = 0\n          filled++\n        }\n      }\n    }\n \
    \   return filled\n  }\n  get grid(){\n    return this._grid\n  }\n  set grid(grid){\n\
    \    this._grid = grid\n  }\n}\n", "  let max = 0;\n  for(let i = 0; i < grid.length;\
    \ i++){\n    for(let j = 0; j < grid[i].length; j++){\n      if(grid[i][j] ===\
    \ 1){\n        let count = 0;\n        let left = i - 1;\n        let right =\
    \ i + 1;\n        let top = j - 1;\n        let bottom = j + 1;\n        while(left\
    \ >= 0 && grid[left][j] === 1){\n          count++;\n          left--;\n     \
    \   }\n        while(right < grid.length && grid[right][j] === 1){\n         \
    \ count++;\n          right++;\n        }\n        while(top >= 0 && grid[i][top]\
    \ === 1){\n          count++;\n          top--;\n        }\n        while(bottom\
    \ < grid[i].length && grid[i][bottom] === 1){\n          count++;\n          bottom++;\n\
    \        }\n        if(count > max){\n          max = count;\n        }\n    \
    \  }\n    }\n  }\n  return max;\n}\n", "    let buckets = [];\n    let max_fill\
    \ = 0;\n    for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j <\
    \ grid[i].length; j++){\n            if(grid[i][j] == 1){\n                buckets.push(0);\n\
    \            }\n        }\n    }\n    for(let i = 0; i < buckets.length; i++){\n\
    \        if(buckets[i] < capacity){\n            max_fill += 1;\n            buckets[i]\
    \ += 1;\n        }\n    }\n    return max_fill;\n}\n", "    let well_count = 0;\n\
    \    for(let i = 0; i < grid.length; i++){\n        let well = grid[i];\n    \
    \    let bucket_count = 0;\n        for(let j = 0; j < well.length; j++){\n  \
    \          if(well[j] == 1){\n                let bucket = well[j];\n        \
    \        let bucket_count = bucket_count + 1;\n                if(bucket_count\
    \ > capacity){\n                    well_count = well_count + 1;\n           \
    \         bucket_count = 0;\n                }\n            }\n        }\n   \
    \ }\n    return well_count;\n}\n", "    let max = 0;\n    for(let i = 0; i < grid.length;\
    \ i++){\n        for(let j = 0; j < grid[i].length; j++){\n            let count\
    \ = 0;\n            while(grid[i][j] === 1){\n                count++;\n     \
    \           grid[i][j] = 0;\n            }\n            if(count > max){\n   \
    \             max = count;\n            }\n        }\n    }\n    return max;\n\
    }\n", "  let well_count = grid.length\n  let well_length = grid[0].length\n  let\
    \ well_capacity = capacity\n  let well_water = 0\n  let well_bucket = 0\n  let\
    \ well_water_count = 0\n  let well_bucket_count = 0\n  let well_water_bucket_count\
    \ = 0\n  let well_water_bucket_count_max = 0\n  let well_water_bucket_count_min\
    \ = 0\n  let well_water_bucket_count_max_index = 0\n  let well_water_bucket_count_min_index\
    \ = 0\n  let well_water_bucket_count_max_index_max = 0\n  let well_water_bucket_count_min_index_min\
    \ = 0\n  let well_water_bucket_count_max_index_min_index = 0\n  let well_water_bucket_count_min_index_max_index\
    \ = 0\n  let well_water_bucket_count_max_index_min_index_max = 0\n  let well_water_bucket_count_min_index_min_index_min\
    \ = 0\n  let well_water_bucket_count_max_index_min_index_min_index = 0\n  let\
    \ well_water_bucket_count_min_index_max_index_min_index = 0\n  let well_water_bucket_count_min_index_min_index_max_index\
    \ = 0\n  let well_water_bucket_count_min_index_min_index_min_index_max = 0\n \
    \ let well_water_bucket_count_min_index_min_index_min_index_min = 0\n  let well_water_bucket_count_min_index_min_index_min_index_min_index\
    \ = 0\n  let well_water_bucket_count_min_index_min_index_min_index_min_index_max\
    \ = 0\n  let well_water_bucket_count_min_index_min_index_min_index_min_index_min\
    \ = 0\n  let well_water_bucket_count_min_index_min_index_min_", "    let max =\
    \ 0;\n    let i = 0;\n    let j = 0;\n    let count = 0;\n    while(i < grid.length\
    \ && j < grid[i].length){\n        if(grid[i][j] == 1){\n            count++;\n\
    \            if(count > max){\n                max = count;\n            }\n \
    \           if(count == capacity){\n                count = 0;\n             \
    \   i++;\n            }\n        }\n        else{\n            count = 0;\n  \
    \          i++;\n        }\n        j++;\n    }\n    return max;\n}\n", "    let\
    \ max = 0;\n    for(let i = 0; i < grid.length; i++){\n        let buckets = grid[i].length;\n\
    \        let filled = 0;\n        for(let j = 0; j < grid[i].length; j++){\n \
    \           if(grid[i][j] == 1){\n                filled++;\n                if(filled\
    \ >= capacity){\n                    filled = 0;\n                    buckets--;\n\
    \                }\n            }\n        }\n        max = Math.max(max, buckets);\n\
    \    }\n    return max;\n}\n", "  let max = 0;\n  for(let i = 0; i < grid.length;\
    \ i++){\n    for(let j = 0; j < grid[i].length; j++){\n      let count = 0;\n\
    \      while(grid[i][j] === 1){\n        count++;\n        grid[i][j] = 0;\n \
    \       let [x, y] = [i, j];\n        let [x1, y1] = [x, y];\n        let [x2,\
    \ y2] = [x, y];\n        let [x3, y3] = [x, y];\n        let [x4, y4] = [x, y];\n\
    \        let [x5, y5] = [x, y];\n        let [x6, y6] = [x, y];\n        let [x7,\
    \ y7] = [x, y];\n        let [x8, y8] = [x, y];\n        let [x9, y9] = [x, y];\n\
    \        let [x10, y10] = [x, y];\n        let [x11, y11] = [x, y];\n        let\
    \ [x12, y12] = [x, y];\n        let [x13, y13] = [x, y];\n        let [x14, y14]\
    \ = [x, y];\n        let [x15, y15] = [x, y];\n        let [x16, y16] = [x, y];\n\
    \        let [x17, y17] = [x, y];\n        let [x18, y18] = [x, y];\n        let\
    \ [x19, y19] = [x, y];\n        let [x20, y20] = [x, y];\n        let [x21, y21]\
    \ = [x, y];\n        let [x22, y22] = [x, y];\n        let [x23, y23] = [x, y];\n\
    \        let [x24, y24] = [x, y];\n        let [x25, y25] = [x, y];\n        let\
    \ [x26, y26] = [x, y];\n        let", "    let max = 0;\n    for(let i = 0; i\
    \ < grid.length; i++){\n        let buckets = grid[i].length;\n        let filled\
    \ = 0;\n        for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j]\
    \ == 1){\n                filled++;\n                if(filled >= capacity){\n\
    \                    max++;\n                    filled = 0;\n               \
    \ }\n            }\n        }\n    }\n    return max;\n}\n", "    let rows = grid.length;\n\
    \    let cols = grid[0].length;\n    let buckets = [];\n    let max = 0;\n   \
    \ for(let i = 0; i < rows; i++){\n        let row = grid[i];\n        let bucket\
    \ = [];\n        for(let j = 0; j < cols; j++){\n            let well = row[j];\n\
    \            if(well === 0){\n                bucket.push(0);\n            }else{\n\
    \                bucket.push(1);\n            }\n        }\n        buckets.push(bucket);\n\
    \    }\n    for(let i = 0; i < rows; i++){\n        let row = buckets[i];\n  \
    \      let bucket = [];\n        for(let j = 0; j < cols; j++){\n            let\
    \ well = row[j];\n            if(well === 0){\n                bucket.push(0);\n\
    \            }else{\n                bucket.push(buckets[i][j] + 1);\n       \
    \     }\n        }\n        buckets[i] = bucket;\n    }\n    for(let i = 0; i\
    \ < rows; i++){\n        let row = buckets[i];\n        let bucket = [];\n   \
    \     for(let j = 0; j < cols; j++){\n            let well = row[j];\n       \
    \     if(well === 0){\n                bucket.push(0);\n            }else{\n \
    \               bucket.push(Math.min(buckets[i][j], capacity));\n            }\n\
    \        }\n        buckets[i] = bucket;\n    }\n    for(let i = 0; i < rows;\
    \ i++){\n        let row = buckets[i];\n        let bucket = [];\n        for(let\
    \ j = 0; j < cols; j++){\n            let well = row[j];\n            if(well\
    \ === 0){\n                bucket.push(0);\n            }else{\n             \
    \   bucket.push(Math.min(buckets[i][j], capacity));\n            }\n        }\n\
    \        buckets[i] = bucket;\n    }\n    for(let i = 0; i < rows; i++){\n   \
    \     let row =", "    let max = 0;\n    for(let i = 0; i < grid.length; i++){\n\
    \        for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j] ==\
    \ 1){\n                let fill = 0;\n                let left = 0;\n        \
    \        let right = 0;\n                let top = 0;\n                let bottom\
    \ = 0;\n                if(i > 0){\n                    left = grid[i-1][j];\n\
    \                }\n                if(i < grid.length - 1){\n               \
    \     right = grid[i+1][j];\n                }\n                if(j > 0){\n \
    \                   top = grid[i][j-1];\n                }\n                if(j\
    \ < grid[i].length - 1){\n                    bottom = grid[i][j+1];\n       \
    \         }\n                if(left > 0){\n                    fill += left;\n\
    \                }\n                if(right > 0){\n                    fill +=\
    \ right;\n                }\n                if(top > 0){\n                  \
    \  fill += top;\n                }\n                if(bottom > 0){\n        \
    \            fill += bottom;\n                }\n                if(fill > max){\n\
    \                    max = fill;\n                }\n            }\n        }\n\
    \    }\n    return max;\n}\n", "    let max = 0;\n    for(let i = 0; i < grid.length;\
    \ i++){\n        let cur = 0;\n        for(let j = 0; j < grid[i].length; j++){\n\
    \            if(grid[i][j] == 1){\n                cur += 1;\n            }\n\
    \            if(cur > max){\n                max = cur;\n            }\n     \
    \   }\n    }\n    return max;\n}\n", "  let buckets = [0] * (grid.length * grid[0].length)\n\
    \  let max_fill = 0\n  for (let i = 0; i < grid.length; i++){\n    for (let j\
    \ = 0; j < grid[i].length; j++){\n      if (grid[i][j] === 1){\n        let bucket\
    \ = i * grid[0].length + j\n        buckets[bucket] += 1\n        if (buckets[bucket]\
    \ > max_fill){\n          max_fill = buckets[bucket]\n        }\n      }\n   \
    \ }\n  }\n  return max_fill\n}\n", "    var i, j, count = 0;\n    for(i = 0; i\
    \ < grid.length; i++){\n        for(j = 0; j < grid[i].length; j++){\n       \
    \     if(grid[i][j] == 1){\n                count += max_fill_well(grid, i, j,\
    \ capacity);\n            }\n        }\n    }\n    return count;\n}\n\nfunction\
    \ max_fill_well(grid, i, j, capacity){\n    var count = 0;\n    while(grid[i][j]\
    \ == 1){\n        count++;\n        grid[i][j] = 0;\n        if(i > 0){\n    \
    \        grid[i-1][j] = 1;\n        }\n        if(j > 0){\n            grid[i][j-1]\
    \ = 1;\n        }\n        if(i < grid.length - 1){\n            grid[i+1][j]\
    \ = 1;\n        }\n        if(j < grid[i].length - 1){\n            grid[i][j+1]\
    \ = 1;\n        }\n    }\n    return count;\n}\n", "    let max = 0;\n    for(let\
    \ i = 0; i < grid.length; i++){\n        let buckets = grid[i].length;\n     \
    \   let filled = 0;\n        for(let j = 0; j < grid[i].length; j++){\n      \
    \      if(grid[i][j] == 1){\n                filled++;\n                if(filled\
    \ >= capacity){\n                    max++;\n                    filled = 0;\n\
    \                }\n            }\n        }\n    }\n    return max;\n}\n", " \
    \   var i, j, max = 0;\n    for(i = 0; i < grid.length; i++){\n        for(j =\
    \ 0; j < grid[i].length; j++){\n            if(grid[i][j] === 1){\n          \
    \      max = Math.max(max, fill(i, j, grid, capacity));\n            }\n     \
    \   }\n    }\n    return max;\n}\n\nfunction fill(i, j, grid, capacity){\n   \
    \ var max = 0;\n    if(i < 0 || i >= grid.length || j < 0 || j >= grid[i].length\
    \ || grid[i][j] === 0){\n        return 0;\n    }\n    if(grid[i][j] === 1){\n\
    \        return 0;\n    }\n    grid[i][j] = 1;\n    max = Math.max(max, fill(i-1,\
    \ j, grid, capacity) + fill(i, j-1, grid, capacity) + fill(i, j+1, grid, capacity)\
    \ + fill(i+1, j, grid, capacity));\n    grid[i][j] = 0;\n    return max;\n}",
  "    let buckets = [];\n    let max_fill = 0;\n    let i = 0;\n    let j = 0;\n\
    \    let well = 0;\n    let well_length = grid[0].length;\n    while(i < grid.length\
    \ && j < grid[0].length){\n        if(grid[i][j] == 1){\n            well = i;\n\
    \            j++;\n            buckets.push(0);\n            while(j < grid[0].length\
    \ && grid[i][j] == 1){\n                buckets[well]++;\n                j++;\n\
    \            }\n            i++;\n        }\n        else{\n            i++;\n\
    \        }\n    }\n    for(let k = 0; k < buckets.length; k++){\n        if(buckets[k]\
    \ > capacity){\n            max_fill += buckets[k] - capacity;\n        }\n  \
    \  }\n    return max_fill;\n}\n", "  let n = grid.length\n  let m = grid[0].length\n\
    \  let result = 0\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n\
    \      if(grid[i][j] == 1){\n        let left = 0\n        let right = 0\n   \
    \     let up = 0\n        let down = 0\n        if(i > 0){\n          left = grid[i-1][j]\n\
    \        }\n        if(i < n-1){\n          right = grid[i+1][j]\n        }\n\
    \        if(j > 0){\n          up = grid[i][j-1]\n        }\n        if(j < m-1){\n\
    \          down = grid[i][j+1]\n        }\n        if(left == 1 && right == 1\
    \ && up == 1 && down == 1){\n          result += 1\n        }\n      }\n    }\n\
    \  }\n  return result\n}\n", "    var well_count = grid.length;\n    var well_length\
    \ = grid[0].length;\n    var well_capacity = capacity;\n    var max_fill = 0;\n\
    \    for(var i = 0; i < well_count; i++){\n        var well_water = 0;\n     \
    \   for(var j = 0; j < well_length; j++){\n            if(grid[i][j] == 1){\n\
    \                well_water += 1;\n            }\n            if(well_water >\
    \ well_capacity){\n                well_water -= well_capacity;\n            \
    \    max_fill += 1;\n            }\n        }\n    }\n    return max_fill;\n}\n",
  "    let max = 0;\n    for(let i = 0; i < grid.length; i++){\n        for(let j\
    \ = 0; j < grid[i].length; j++){\n            if(grid[i][j] === 1){\n        \
    \        let count = 0;\n                let left = i - 1;\n                let\
    \ right = i + 1;\n                let top = j - 1;\n                let bottom\
    \ = j + 1;\n                while(left >= 0 && grid[left][j] === 1){\n       \
    \             count++;\n                    left--;\n                }\n     \
    \           while(right < grid.length && grid[right][j] === 1){\n            \
    \        count++;\n                    right++;\n                }\n         \
    \       while(top >= 0 && grid[i][top] === 1){\n                    count++;\n\
    \                    top--;\n                }\n                while(bottom <\
    \ grid[i].length && grid[i][bottom] === 1){\n                    count++;\n  \
    \                  bottom++;\n                }\n                if(count > max){\n\
    \                    max = count;\n                }\n            }\n        }\n\
    \    }\n    return max;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] =\
    \ new Array(m);\n        for(let j = 0; j < m; j++){\n            dp[i][j] = 0;\n\
    \        }\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j <\
    \ m; j++){\n            if(grid[i][j] == 1){\n                dp[i][j] = Math.min(dp[i][j],\
    \ Math.min(dp[i-1][j], Math.min(dp[i][j-1], dp[i-1][j-1])));\n            }\n\
    \        }\n    }\n    let max = 0;\n    for(let i = 0; i < n; i++){\n       \
    \ for(let j = 0; j < m; j++){\n            if(dp[i][j] > max){\n             \
    \   max = dp[i][j];\n            }\n        }\n    }\n    return max;\n}\n", " \
    \ var i, j, max = 0;\n  for(i = 0; i < grid.length; i++){\n    for(j = 0; j <\
    \ grid[i].length; j++){\n      if(grid[i][j] === 1){\n        max = Math.max(max,\
    \ fill(i, j, grid, capacity));\n      }\n    }\n  }\n  return max;\n}\n\nfunction\
    \ fill(i, j, grid, capacity){\n  var max = 0;\n  while(grid[i][j] === 1){\n  \
    \  max += 1;\n    grid[i][j] = 0;\n    if(i > 0){\n      grid[i-1][j] = 1;\n \
    \   }\n    if(j > 0){\n      grid[i][j-1] = 1;\n    }\n    if(i < grid.length-1){\n\
    \      grid[i+1][j] = 1;\n    }\n    if(j < grid[i].length-1){\n      grid[i][j+1]\
    \ = 1;\n    }\n  }\n  return max;\n}\n", "    let max = 0;\n    let i = 0;\n \
    \   let j = 0;\n    let count = 0;\n    for(i = 0; i < grid.length; i++){\n  \
    \      for(j = 0; j < grid[i].length; j++){\n            if(grid[i][j] == 1){\n\
    \                count = 0;\n                while(count < grid[i][j]){\n    \
    \                count++;\n                    if(count > capacity){\n       \
    \                 count = 0;\n                        break;\n               \
    \     }\n                }\n                if(count > max){\n               \
    \     max = count;\n                }\n            }\n        }\n    }\n    return\
    \ max;\n}\n", "    let result = 0;\n    for(let i = 0; i < grid.length; i++){\n\
    \        let row = grid[i];\n        let buckets = [];\n        for(let j = 0;\
    \ j < row.length; j++){\n            if(row[j] === 1){\n                let bucket\
    \ = [];\n                buckets.push(bucket);\n            }\n            else{\n\
    \                buckets[buckets.length - 1].push(0);\n            }\n       \
    \ }\n        let max_bucket = Math.min(capacity, buckets.length);\n        for(let\
    \ j = 0; j < max_bucket; j++){\n            let bucket = buckets[j];\n       \
    \     let max_fill = 0;\n            for(let k = 0; k < bucket.length; k++){\n\
    \                if(bucket[k] === 0){\n                    bucket[k] = 1;\n  \
    \                  max_fill += 1;\n                }\n                else{\n\
    \                    bucket[k] = 0;\n                }\n            }\n      \
    \      result = Math.max(result, max_fill);\n        }\n    }\n    return result;\n\
    }\n", "  let max = 0;\n  for(let i = 0; i < grid.length; i++){\n    for(let j\
    \ = 0; j < grid[i].length; j++){\n      if(grid[i][j] === 1){\n        let count\
    \ = 0;\n        let left = j - 1;\n        let right = j + 1;\n        let top\
    \ = i - 1;\n        let bottom = i + 1;\n        while(left >= 0 && grid[top][left]\
    \ === 1){\n          count++;\n          left--;\n        }\n        while(right\
    \ < grid[i].length && grid[bottom][right] === 1){\n          count++;\n      \
    \    right++;\n        }\n        while(top >= 0 && grid[top][j] === 1){\n   \
    \       count++;\n          top--;\n        }\n        while(bottom < grid.length\
    \ && grid[bottom][j] === 1){\n          count++;\n          bottom++;\n      \
    \  }\n        max = Math.max(max, count);\n      }\n    }\n  }\n  return max;\n\
    }\n", "    var rows = grid.length;\n    var cols = grid[0].length;\n    var buckets\
    \ = [];\n    for(var i=0; i<rows; i++){\n        buckets.push([]);\n        for(var\
    \ j=0; j<cols; j++){\n            buckets[i].push(0);\n        }\n    }\n    var\
    \ max = 0;\n    for(var i=0; i<rows; i++){\n        for(var j=0; j<cols; j++){\n\
    \            if(grid[i][j] == 1){\n                buckets[i][j] = 1;\n      \
    \          max = Math.max(max, fill(grid, buckets, i, j, capacity));\n       \
    \         buckets[i][j] = 0;\n            }\n        }\n    }\n    return max;\n\
    }\n\nfunction fill(grid, buckets, i, j, capacity){\n    var max = 0;\n    if(i\
    \ > 0 && grid[i-1][j] == 1){\n        buckets[i-1][j] = 1;\n        max = Math.max(max,\
    \ fill(grid, buckets, i-1, j, capacity));\n        buckets[i-1][j] = 0;\n    }\n\
    \    if(j > 0 && grid[i][j-1] == 1){\n        buckets[i][j-1] = 1;\n        max\
    \ = Math.max(max, fill(grid, buckets, i, j-1, capacity));\n        buckets[i][j-1]\
    \ = 0;\n    }\n    if(i < grid.length-1 && grid[i+1][j] == 1){\n        buckets[i+1][j]\
    \ = 1;\n        max = Math.max(max, fill(grid, buckets, i+1, j, capacity));\n\
    \        buckets[i+1][j] = 0;\n    }\n    if(j < grid[0].length-1 && grid[i][j+1]\
    \ == 1){\n        buckets[i][j+1] = 1;\n        max = Math.max(max, fill(grid,\
    \ buckets, i, j+1, capacity));\n", "  var rows = grid.length,\n      cols = grid[0].length,\n\
    \      wells = rows * cols,\n      buckets = rows * cols,\n      i, j,\n     \
    \ count = 0;\n\n  for(i = 0; i < rows; i++){\n    for(j = 0; j < cols; j++){\n\
    \      if(grid[i][j] === 1){\n        count += fill(i, j, grid, capacity);\n \
    \     }\n    }\n  }\n\n  return count;\n}\n\nfunction fill(i, j, grid, capacity){\n\
    \  var buckets = grid[i][j] === 1 ? buckets : 0,\n      wells = grid[i][j] ===\
    \ 1 ? wells : 0,\n      count = 0;\n\n  if(buckets === 0){\n    return 0;\n  }\n\
    \n  while(wells > 0 && buckets > 0){\n    count++;\n    wells--;\n    buckets--;\n\
    \  }\n\n  if(wells === 0){\n    grid[i][j] = 0;\n  } else {\n    grid[i][j] =\
    \ 1;\n  }\n\n  return count;\n}\n", "    let max = 0;\n    let i = 0;\n    let\
    \ j = 0;\n    let count = 0;\n    while(i < grid.length && j < grid[i].length){\n\
    \        if(grid[i][j] == 1){\n            count++;\n            max = Math.max(max,\
    \ count);\n            if(count == capacity){\n                count = 0;\n  \
    \              i++;\n            }\n        }\n        else{\n            count\
    \ = 0;\n            i++;\n        }\n        j++;\n    }\n    return max;\n}\n",
  "    let max = 0;\n    for(let i = 0; i < grid.length; i++){\n        let curr =\
    \ 0;\n        for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j]\
    \ == 1){\n                curr += 1;\n            }\n            if(curr > max){\n\
    \                max = curr;\n            }\n            if(curr >= capacity){\n\
    \                curr -= capacity;\n            }\n        }\n    }\n    return\
    \ max;\n}\n", "    let well_count = grid.length;\n    let well_length = grid[0].length;\n\
    \    let well_count_per_well = well_count / well_length;\n    let well_count_per_well_per_well\
    \ = well_count_per_well / well_length;\n    let well_count_per_well_per_well_per_well\
    \ = well_count_per_well_per_well / well_length;\n    let well_count_per_well_per_well_per_well_per_well\
    \ = well_count_per_well_per_well_per_well / well_length;\n    let well_count_per_well_per_well_per_well_per_well_per_well\
    \ = well_count_per_well_per_well_per_well_per_well / well_length;\n    let well_count_per_well_per_well_per_well_per_well_per_well_per_well\
    \ = well_count_per_well_per_well_per_well_per_well_per_well / well_length;\n \
    \   let well_count_per_well_per_well_per_well_per_well_per_well_per_well_per_well\
    \ = well_count_per_well_per_well_per_well_per_well_per_well_per_well / well_length;\n\
    \    let well_count_per_well_per_well_per_well_per_well_per_well_per_well_per_well_per_well\
    \ = well_count_per_well_per_well_per_well_per_well_per_well_per_well_per_well\
    \ / well_length;\n    let well_count_per_well_per_well_per_well_per_well_per_well_per_well_per_well_per_well_per_well\
    \ = well_count_per_well_per_well_per_well_per_well_per_well_per_well_per_well_per_well\
    \ / well_length;\n    let well_count_per_well_per_well_per_well_per_well_per_well_per_well",
  "  var buckets = [];\n  for(var i=0; i<grid.length; i++){\n    buckets.push(0);\n\
    \  }\n  for(var i=0; i<grid.length; i++){\n    for(var j=0; j<grid[i].length;\
    \ j++){\n      if(grid[i][j] == 1){\n        var well = i;\n        var bucket\
    \ = j;\n        while(buckets[bucket] < capacity){\n          buckets[bucket]\
    \ += 1;\n          bucket = (bucket + 1) % buckets.length;\n        }\n      }\n\
    \    }\n  }\n  var result = 0;\n  for(var i=0; i<buckets.length; i++){\n    if(buckets[i]\
    \ > 0){\n      result += buckets[i];\n    }\n  }\n  return result;\n}\n", "  \
    \  var i, j, max = 0;\n    for(i = 0; i < grid.length; i++){\n        for(j =\
    \ 0; j < grid[i].length; j++){\n            if(grid[i][j] == 1){\n           \
    \     max = Math.max(max, fill(grid, i, j, capacity));\n            }\n      \
    \  }\n    }\n    return max;\n}\n\nfunction fill(grid, i, j, capacity){\n    var\
    \ max = 0;\n    if(i > 0 && grid[i - 1][j] == 1){\n        max = Math.max(max,\
    \ fill(grid, i - 1, j, capacity));\n    }\n    if(j > 0 && grid[i][j - 1] == 1){\n\
    \        max = Math.max(max, fill(grid, i, j - 1, capacity));\n    }\n    if(i\
    \ < grid.length - 1 && grid[i + 1][j] == 1){\n        max = Math.max(max, fill(grid,\
    \ i + 1, j, capacity));\n    }\n    if(j < grid[i].length - 1 && grid[i][j + 1]\
    \ == 1){\n        max = Math.max(max, fill(grid, i, j + 1, capacity));\n    }\n\
    \    if(i > 0 && j > 0 && grid[i - 1][j - 1] == 1){\n        max = Math.max(max,\
    \ fill(grid, i - 1, j - 1, capacity));\n    }\n    if(i < grid.length - 1 && j\
    \ < grid[i].length - 1 && grid[i + 1][j + 1] == 1){\n        max = Math.max(max,\
    \ fill(grid, i + 1, j + 1, capacity));\n    }\n    if(i < grid.length - 1 && j\
    \ > 0 && grid[i + 1][j - 1] == 1){\n        max = Math.max(max, fill(grid, i +\
    \ 1, j - 1, capacity));\n    }\n    if(i > 0 && j < grid[i].length - 1 && grid[i\
    \ - 1][j + 1] == 1){\n        max = Math.max(max,", "    let max = 0;\n    for(let\
    \ i = 0; i < grid.length; i++){\n        let cur = 0;\n        for(let j = 0;\
    \ j < grid[i].length; j++){\n            if(grid[i][j] === 1){\n             \
    \   cur += 1;\n            }\n            if(cur > max){\n                max\
    \ = cur;\n            }\n        }\n    }\n    return max;\n}\n", "  let buckets\
    \ = [];\n  let max = 0;\n  for(let i = 0; i < grid.length; i++){\n    let row\
    \ = grid[i];\n    for(let j = 0; j < row.length; j++){\n      if(row[j] === 1){\n\
    \        buckets.push(j);\n      }\n    }\n  }\n  let i = 0;\n  while(buckets.length\
    \ > 0){\n    let b = buckets.shift();\n    let c = capacity;\n    while(c > 0){\n\
    \      let j = b + i;\n      if(j >= grid[i].length){\n        i = 0;\n      \
    \  j = b + i;\n      }\n      if(grid[i][j] === 1){\n        grid[i][j] = 0;\n\
    \        c--;\n      }\n      i++;\n    }\n    max++;\n  }\n  return max;\n}\n",
  "    let max = 0;\n    for(let i = 0; i < grid.length; i++){\n        let row =\
    \ grid[i];\n        let buckets = [];\n        for(let j = 0; j < row.length;\
    \ j++){\n            if(row[j] === 1){\n                let bucket = {\n     \
    \               capacity: capacity,\n                    water: 0\n          \
    \      };\n                buckets.push(bucket);\n            }\n        }\n \
    \       let max_fill = 0;\n        while(true){\n            let max_fill = 0;\n\
    \            for(let j = 0; j < buckets.length; j++){\n                let bucket\
    \ = buckets[j];\n                if(bucket.water > bucket.capacity){\n       \
    \             bucket.water = 0;\n                    max_fill++;\n           \
    \     }\n                else{\n                    bucket.water++;\n        \
    \        }\n            }\n            if(max_fill === 0) break;\n        }\n\
    \        max = Math.max(max, max_fill);\n    }\n    return max;\n}\n", "    var\
    \ max = 0;\n    for(var i=0; i<grid.length; i++){\n        for(var j=0; j<grid[i].length;\
    \ j++){\n            if(grid[i][j] == 1){\n                max = Math.max(max,\
    \ fill(grid, i, j, capacity));\n            }\n        }\n    }\n    return max;\n\
    }\n\nfunction fill(grid, i, j, capacity){\n    var max = 0;\n    if(i < 0 || i\
    \ >= grid.length || j < 0 || j >= grid[i].length || grid[i][j] == 1){\n      \
    \  return 0;\n    }\n    if(grid[i][j] == 0){\n        grid[i][j] = 1;\n     \
    \   max = 1;\n    }\n    if(i > 0 && grid[i-1][j] == 0){\n        grid[i-1][j]\
    \ = 1;\n        max += 1;\n    }\n    if(i < grid.length-1 && grid[i+1][j] ==\
    \ 0){\n        grid[i+1][j] = 1;\n        max += 1;\n    }\n    if(j > 0 && grid[i][j-1]\
    \ == 0){\n        grid[i][j-1] = 1;\n        max += 1;\n    }\n    if(j < grid[i].length-1\
    \ && grid[i][j+1] == 0){\n        grid[i][j+1] = 1;\n        max += 1;\n    }\n\
    \    if(max > capacity){\n        return max;\n    }\n    return max + fill(grid,\
    \ i-1, j, capacity) + fill(grid, i+1, j, capacity) + fill(grid, i, j-1, capacity)\
    \ + fill(grid, i, j+1, capacity);\n}", "    let n = grid.length;\n    let m =\
    \ grid[0].length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n\
    \        dp[i] = new Array(m);\n        for(let j = 0; j < m; j++){\n        \
    \    if(grid[i][j] == 1){\n                dp[i][j] = 0;\n            }else{\n\
    \                dp[i][j] = Infinity;\n            }\n        }\n    }\n    let\
    \ max = 0;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n\
    \            if(dp[i][j] > max){\n                max = dp[i][j];\n          \
    \  }\n        }\n    }\n    let count = 0;\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < m; j++){\n            if(dp[i][j] == max){\n     \
    \           count++;\n                for(let k = 0; k < m; k++){\n          \
    \          dp[i][k] = 0;\n                }\n                for(let k = 0; k\
    \ < n; k++){\n                    dp[k][j] = 0;\n                }\n         \
    \   }\n        }\n    }\n    return count;\n}\n", "    var max = 0;\n    for(var\
    \ i = 0; i < grid.length; i++){\n        for(var j = 0; j < grid[i].length; j++){\n\
    \            if(grid[i][j] == 1){\n                var left = 0;\n           \
    \     var right = 0;\n                if(j > 0){\n                    left = grid[i][j-1];\n\
    \                }\n                if(j < grid[i].length - 1){\n            \
    \        right = grid[i][j+1];\n                }\n                max = Math.max(max,\
    \ left + right + 1);\n            }\n        }\n    }\n    return max;\n}\n",
  "    let max = 0;\n    let i = 0;\n    let j = 0;\n    let count = 0;\n    for(i\
    \ = 0; i < grid.length; i++){\n        for(j = 0; j < grid[i].length; j++){\n\
    \            if(grid[i][j] == 1){\n                count++;\n                if(count\
    \ > max){\n                    max = count;\n                }\n            }\n\
    \        }\n    }\n    return max;\n}\n", "  var n = grid.length;\n  var m = grid[0].length;\n\
    \  var max = 0;\n  var i, j;\n  for(i=0; i<n; i++){\n    for(j=0; j<m; j++){\n\
    \      if(grid[i][j] == 1){\n        max = Math.max(max, fill(grid, i, j, capacity));\n\
    \      }\n    }\n  }\n  return max;\n}\n\nfunction fill(grid, i, j, capacity){\n\
    \  var n = grid.length;\n  var m = grid[0].length;\n  var count = 0;\n  var k\
    \ = 0;\n  while(k < n && k < m){\n    if(grid[k][j] == 1){\n      count++;\n \
    \     grid[k][j] = 0;\n      k++;\n    }else{\n      k++;\n    }\n  }\n  while(k\
    \ < n && grid[i][k] == 1){\n    count++;\n    grid[i][k] = 0;\n    k++;\n  }\n\
    \  while(k < m && grid[i][k] == 1){\n    count++;\n    grid[i][k] = 0;\n    k++;\n\
    \  }\n  while(k < n && k < m){\n    if(grid[k][j] == 1){\n      count++;\n   \
    \   grid[k][j] = 0;\n      k++;\n    }else{\n      k++;\n    }\n  }\n  return\
    \ count;\n}\n", "    let max = 0;\n    for(let i = 0; i < grid.length; i++){\n\
    \        let buckets = grid[i].length;\n        let filled = 0;\n        for(let\
    \ j = 0; j < grid[i].length; j++){\n            if(grid[i][j] == 1){\n       \
    \         filled++;\n            }\n            if(filled >= capacity){\n    \
    \            max++;\n                filled = 0;\n            }\n        }\n \
    \   }\n    return max;\n}\n", "  let max = 0;\n  for(let i = 0; i < grid.length;\
    \ i++){\n    for(let j = 0; j < grid[i].length; j++){\n      let count = 0;\n\
    \      while(grid[i][j] === 1){\n        count++;\n        grid[i][j] = 0;\n \
    \     }\n      max = Math.max(max, count);\n    }\n  }\n  return max;\n}\n", " \
    \   let max = 0;\n    for(let i = 0; i < grid.length; i++){\n        let buckets\
    \ = grid[i].length;\n        let filled = 0;\n        for(let j = 0; j < buckets;\
    \ j++){\n            if(grid[i][j] === 1){\n                filled++;\n      \
    \          if(filled === capacity){\n                    max++;\n            \
    \        filled = 0;\n                }\n            }\n        }\n    }\n   \
    \ return max;\n}\n", "    let max = 0;\n    for(let i = 0; i < grid.length; i++){\n\
    \        for(let j = 0; j < grid[i].length; j++){\n            if(grid[i][j] ==\
    \ 1){\n                let curr = 0;\n                let left = 0;\n        \
    \        let right = 0;\n                if(j > 0){\n                    left\
    \ = grid[i][j-1];\n                }\n                if(j < grid[i].length-1){\n\
    \                    right = grid[i][j+1];\n                }\n              \
    \  if(left == 1 && right == 1){\n                    curr = 2;\n             \
    \   }\n                else if(left == 1){\n                    curr = 1;\n  \
    \              }\n                else if(right == 1){\n                    curr\
    \ = 1;\n                }\n                if(curr > max){\n                 \
    \   max = curr;\n                }\n            }\n        }\n    }\n    return\
    \ max;\n}\n", "  var max = 0;\n  for(var i = 0; i < grid.length; i++){\n    for(var\
    \ j = 0; j < grid[i].length; j++){\n      if(grid[i][j] == 1){\n        max =\
    \ Math.max(max, fill(grid, i, j, capacity));\n      }\n    }\n  }\n  return max;\n\
    }\n\nfunction fill(grid, i, j, capacity){\n  var count = 0;\n  while(grid[i][j]\
    \ == 1){\n    count++;\n    grid[i][j] = 0;\n    if(i > 0 && grid[i-1][j] == 1){\n\
    \      grid[i-1][j] = 0;\n      i--;\n    }\n    if(j > 0 && grid[i][j-1] == 1){\n\
    \      grid[i][j-1] = 0;\n      j--;\n    }\n    if(i < grid.length-1 && grid[i+1][j]\
    \ == 1){\n      grid[i+1][j] = 0;\n      i++;\n    }\n    if(j < grid[i].length-1\
    \ && grid[i][j+1] == 1){\n      grid[i][j+1] = 0;\n      j++;\n    }\n  }\n  return\
    \ count;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
