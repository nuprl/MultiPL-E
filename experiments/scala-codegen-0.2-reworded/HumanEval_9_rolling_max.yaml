name: HumanEval_9_rolling_max
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // From a given list of integers, generate a list of rolling maximum element\
  \ found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers\
  \ : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
  \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
  \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
  \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
  \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
  \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
completions: ["        val result = mutable.List[Long]()\n        for (i <- 0 until\
    \ numbers.size) {\n            val max = numbers.apply(i).toLong\n           \
    \ for (j <- i + 1 until numbers.size) {\n                val candidate = numbers.apply(j).toLong\n\
    \                if (candidate > max) {\n                    max = candidate\n\
    \                }\n            }\n            result.append(max)\n        }\n\
    \        return result", "        val result = mutable.List[Long]()\n        for\
    \ (i <- 0 until numbers.size) {\n            val max = numbers.apply(i)\n    \
    \        for (j <- i + 1 until numbers.size) {\n                if (numbers.apply(j)\
    \ > max) {\n                    max = numbers.apply(j)\n                }\n  \
    \          }\n            result = result.append(max)\n        }\n        return\
    \ result\n    }\n\n    // From a given list of integers, generate a list of rolling\
    \ minimum element found until given moment\n    // in the sequence.\n    // >>>\
    \ rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def rollingMin(numbers : List[Long])\
    \ : List[Long] = {\n        val result = mutable.List[Long]()\n        for (i\
    \ <- 0 until numbers.size) {\n            val min = numbers.apply(i)\n       \
    \     for (j <- i + 1 until numbers.size) {\n                if (numbers.apply(j)\
    \ < min) {\n                    min = numbers.apply(j)\n                }\n  \
    \          }\n            result = result.append(min)\n        }\n        return\
    \ result\n    }\n\n    // From a given list of integers, generate a list of rolling\
    \ sum of elements found until given moment\n    // in the sequence.\n    // >>>\
    \ rollingSum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 3l.toLong, 6l.toLong,\
    \ 9l.toLong, 12l.toLong, 15l.toLong, 18l.toLong))\n    def rollingSum(numbers\
    \ : List[Long]) : List[Long] = {\n        val result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var max = numbers[i]\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers[j]\
    \ > max) max = numbers[j]\n            }\n            result[i] = max\n      \
    \  }\n        return result", "        val result = mutable.List[Long]()\n   \
    \     for (i <- 0 until numbers.size) {\n            val max = numbers.apply(i).toLong\n\
    \            for (j <- i + 1 until numbers.size) {\n                val candidate\
    \ = numbers.apply(j).toLong\n                if (candidate > max) {\n        \
    \            max = candidate\n                }\n            }\n            result.append(max)\n\
    \        }\n        return result", "        val result = mutable.List[Long]()\n\
    \        for (i <- 0 until numbers.size) {\n            val max = numbers.apply(i).toLong\n\
    \            for (j <- i + 1 until numbers.size) {\n                val candidate\
    \ = numbers.apply(j).toLong\n                if (candidate > max) {\n        \
    \            max = candidate\n                }\n            }\n            result.append(max)\n\
    \        }\n        return result", "        val result = mutable.List[Long]()\n\
    \        for (i <- 0 until numbers.size()) {\n            val max = numbers.apply(i)\n\
    \            for (j <- i + 1 until numbers.size()) {\n                val candidate\
    \ = numbers.apply(j)\n                if (candidate > max) {\n               \
    \     max = candidate\n                }\n            }\n            result.append(max)\n\
    \        }\n        return result", "        val result = mutable.List[Long]()\n\
    \        for (i <- 0 until numbers.size - 1) {\n            val max = numbers.apply(i)\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers.apply(j)\
    \ > max) {\n                    max = numbers.apply(j)\n                }\n  \
    \          }\n            result.append(max)\n        }\n        return result",
  "        var result = List[Long](numbers.size())\n        for (i <- 0 until numbers.size())\
    \ {\n            var max = numbers[i]\n            for (j <- i + 1 until numbers.size())\
    \ {\n                if (numbers[j] > max) max = numbers[j]\n            }\n \
    \           result[i] = max\n        }\n        return result\n    }\n\n    //\
    \ From a given list of integers, generate a list of rolling minimum element found\
    \ until given moment\n    // in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong))\n    def rollingMin(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = List[Long](numbers.size())\n        for (i <- 0 until numbers.size())\
    \ {\n            var min = numbers[i]\n            for (j <- i + 1 until numbers.size())\
    \ {\n                if (numbers[j] < min) min = numbers[j]\n            }\n \
    \           result[i] = min\n        }\n        return result\n    }\n\n    //\
    \ From a given list of integers, generate a list of rolling sum found until given\
    \ moment\n    // in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 3l.toLong, 6l.toLong, 8l.toLong, 11l.toLong, 14l.toLong,\
    \ 16l.toLong))\n    def rollingSum(numbers : List[Long]) : List[Long] = {\n  \
    \      var result = List[Long](numbers.size())\n        for (i <- 0 until numbers.size())\
    \ {\n            var sum =", "        val result = mutable.List[Long]()\n    \
    \    for (i <- 0 until numbers.size) {\n            val max = numbers.apply(i).toLong\n\
    \            for (j <- i + 1 until numbers.size) {\n                val candidate\
    \ = numbers.apply(j).toLong\n                if (candidate > max) {\n        \
    \            max = candidate\n                }\n            }\n            result.append(max)\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var max = numbers[i]\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers[j]\
    \ > max) max = numbers[j]\n            }\n            result[i] = max\n      \
    \  }\n        return result\n    }\n\n    // From a given list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    // in the sequence.\n\
    \    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def rollingMin(numbers\
    \ : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var min = numbers[i]\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers[j]\
    \ < min) min = numbers[j]\n            }\n            result[i] = min\n      \
    \  }\n        return result\n    }\n\n    // From a given list of integers, generate\
    \ a list of rolling sum found until given moment\n    // in the sequence.\n  \
    \  // >>> rollingSum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 3l.toLong, 6l.toLong,\
    \ 6l.toLong, 9l.toLong, 12l.toLong, 12l.toLong))\n    def rollingSum(numbers :\
    \ List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var sum =", "        val\
    \ result = mutable.List[Long]()\n        for (i <- 0 until numbers.size) {\n \
    \           val max = numbers.apply(i)\n            for (j <- i + 1 until numbers.size)\
    \ {\n                val candidate = numbers.apply(j)\n                if (candidate\
    \ > max) {\n                    max = candidate\n                }\n         \
    \   }\n            result.append(max)\n        }\n        return result", "  \
    \      var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            result = result.updated(i, numbers.apply(i).max(result.apply(i)))\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.max(numbers.take(i).toSeq)\n\
    \        }\n        return result", "        val result = mutable.List[Long]()\n\
    \        for (i <- 0 until numbers.length) {\n            val max = numbers[i]\n\
    \            for (j <- i + 1 until numbers.length) {\n                if (numbers[j]\
    \ > max) {\n                    max = numbers[j]\n                }\n        \
    \    }\n            result = result.append(max)\n        }\n        return result",
  "        var result = mutable.List[Long]()\n        var max = numbers.head\n   \
    \     for (i <- numbers.size - 1) {\n            max = max(max, numbers.apply(i))\n\
    \            result = result.append(max)\n        }\n        return result", " \
    \       var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            result[i] = _.max(numbers.take(i).toList)\n        }\n      \
    \  return result", "        var result = List[Long](numbers.size)\n        for\
    \ (i <- 0 until numbers.size) {\n            result[i] = _.max(numbers.take(i).toList)\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var max = numbers[i]\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers[j]\
    \ > max) {\n                    max = numbers[j]\n                }\n        \
    \    }\n            result[i] = max\n        }\n        return result", "    \
    \    var result = List[Long](numbers.size())\n        for (i <- 0 until numbers.size())\
    \ {\n            result = result.updated(i, numbers.apply(i).max(result.apply(i)))\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    //\
    \ in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def\
    \ rollingMin(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size())\n\
    \        for (i <- 0 until numbers.size()) {\n            result = result.updated(i,\
    \ numbers.apply(i).min(result.apply(i)))\n        }\n        return result\n \
    \   }\n\n    // From a given list of integers, generate a list of rolling sum\
    \ of elements found until given moment\n    // in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 3l.toLong, 6l.toLong, 6l.toLong, 9l.toLong, 12l.toLong,\
    \ 6l.toLong))\n    def rollingSum(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = List[Long](numbers.size())\n        for (i <- 0 until numbers.size())\
    \ {\n            result = result.updated(i, numbers.apply(i).sum(result.apply(i)))\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling product of elements found until given moment\n  \
    \  // in the", "        var result = List[Long](numbers.size)\n        for (i\
    \ <- 0 until numbers.size) {\n            var max = numbers[i]\n            for\
    \ (j <- i + 1 until numbers.size) {\n                if (numbers[j] > max) max\
    \ = numbers[j]\n            }\n            result[i] = max\n        }\n      \
    \  return result", "        var result = mutable.List[Long]()\n        for (i\
    \ <- 0 until numbers.length) {\n            var max = numbers[i]\n           \
    \ for (j <- i + 1 until numbers.length) {\n                if (numbers[j] > max)\
    \ max = numbers[j]\n            }\n            result = result.append(max)\n \
    \       }\n        return result", "        numbers.foldLeft((acc, x) -> {\n \
    \           if (acc == null) {\n                return x\n            } else {\n\
    \                if (x > acc) {\n                    return x\n              \
    \  } else {\n                    return acc\n                }\n            }\n\
    \        })\n    }\n\n    // From a given list of integers, generate a list of\
    \ rolling minimum element found until given moment\n    // in the sequence.\n\
    \    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def rollingMin(numbers\
    \ : List[Long]) : List[Long] = {\n        numbers.foldLeft((acc, x) -> {\n   \
    \         if (acc == null) {\n                return x\n            } else {\n\
    \                if (x < acc) {\n                    return x\n              \
    \  } else {\n                    return acc\n                }\n            }\n\
    \        })\n    }\n\n    // From a given list of integers, generate a list of\
    \ rolling sum found until given moment\n    // in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 3l.toLong, 6l.toLong, 9l.toLong, 12l.toLong, 15l.toLong,\
    \ 18l.toLong))\n    def rollingSum(numbers : List[Long]) : List[Long] = {\n  \
    \      numbers.foldLeft((acc, x) -> {\n            if (acc == null) {\n      \
    \          return x\n            } else {\n                return acc + x\n  \
    \          }\n        })\n    }\n\n    // From a given list of integers, generate\
    \ a list of rolling product found until given moment\n    // in the sequence.\n\
    \    // >>> rollingProduct", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var max = numbers[i]\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers[j]\
    \ > max) max = numbers[j]\n            }\n            result[i] = max\n      \
    \  }\n        return result\n    }\n\n    // From a given list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    // in the sequence.\n\
    \    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def rollingMin(numbers\
    \ : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var min = numbers[i]\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers[j]\
    \ < min) min = numbers[j]\n            }\n            result[i] = min\n      \
    \  }\n        return result\n    }\n\n    // From a given list of integers, generate\
    \ a list of rolling sum found until given moment\n    // in the sequence.\n  \
    \  // >>> rollingSum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 3l.toLong, 6l.toLong,\
    \ 8l.toLong, 11l.toLong, 14l.toLong, 16l.toLong))\n    def rollingSum(numbers\
    \ : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var sum =", "        var\
    \ result = List[Long](numbers.size())\n        for (i <- 0 until numbers.size())\
    \ {\n            result = result.update(i, numbers.apply(i).max(result.apply(i)))\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result = result.updated(i,\
    \ numbers.apply(i).max(result.apply(i)))\n        }\n        return result", " \
    \       var max = numbers.head\n        var maxIndex = 0\n        for (i <- 1\
    \ until numbers.size) {\n            if (numbers[i] > max) {\n               \
    \ max = numbers[i]\n                maxIndex = i\n            }\n        }\n \
    \       var result = numbers.take(maxIndex + 1)\n        result = result.append(max)\n\
    \        return result", "        var result = List[Long](numbers.size)\n    \
    \    for (i <- 0 until numbers.size) {\n            var max = numbers[i]\n   \
    \         for (j <- i + 1 until numbers.size) {\n                if (numbers[j]\
    \ > max) max = numbers[j]\n            }\n            result[i] = max\n      \
    \  }\n        return result", "        var result = List[Long](numbers.size())\n\
    \        for (i <- 0 until numbers.size()) {\n            var max = numbers[i]\n\
    \            for (j <- i + 1 until numbers.size()) {\n                if (numbers[j]\
    \ > max) {\n                    max = numbers[j]\n                }\n        \
    \    }\n            result[i] = max\n        }\n        return result\n    }\n\
    \n    // From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    // in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong))\n    def rollingMin(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = List[Long](numbers.size())\n        for (i <- 0 until numbers.size())\
    \ {\n            var min = numbers[i]\n            for (j <- i + 1 until numbers.size())\
    \ {\n                if (numbers[j] < min) {\n                    min = numbers[j]\n\
    \                }\n            }\n            result[i] = min\n        }\n  \
    \      return result\n    }\n\n    // From a given list of integers, generate\
    \ a list of rolling sum found until given moment\n    // in the sequence.\n  \
    \  // >>> rollingSum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 3l.toLong, 6l.toLong,\
    \ 8l.toLong, 11l.toLong, 14l.toLong, 16l.toLong))\n    def rollingSum(numbers\
    \ : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size())\n\
    \        for (i <-", "        val result = mutable.List[Long]()\n        for (i\
    \ <- 0 until numbers.size - 1) {\n            val max = numbers.apply(i).toLong\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers.apply(j).toLong\
    \ > max) {\n                    max = numbers.apply(j).toLong\n              \
    \  }\n            }\n            result = result.append(max)\n        }\n    \
    \    return result", "        var result = List[Long](numbers.size)\n        for\
    \ (i <- 0 until numbers.size) {\n            result = result.set(i, numbers.apply(i).max(result.apply(i)))\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    //\
    \ in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def\
    \ rollingMin(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result = result.set(i,\
    \ numbers.apply(i).min(result.apply(i)))\n        }\n        return result\n \
    \   }\n\n    // From a given list of integers, generate a list of rolling sum\
    \ found until given moment\n    // in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 3l.toLong, 6l.toLong, 9l.toLong, 12l.toLong, 15l.toLong,\
    \ 18l.toLong))\n    def rollingSum(numbers : List[Long]) : List[Long] = {\n  \
    \      var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            result = result.set(i, result.apply(i) + numbers.apply(i))\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling product found until given moment\n    // in the sequence.\n\
    \    //", "        val result = mutable.List[Long]()\n        for (i <- 0 until\
    \ numbers.size) {\n            val max = numbers.apply(i)\n            for (j\
    \ <- i + 1 until numbers.size) {\n                if (numbers.apply(j) > max)\
    \ {\n                    max = numbers.apply(j)\n                }\n         \
    \   }\n            result = result.append(max)\n        }\n        return result",
  "        val result = mutable.List[Long]()\n        for (i <- 0 until numbers.size)\
    \ {\n            val max = numbers.apply(i).toLong\n            for (j <- i +\
    \ 1 until numbers.size) {\n                if (numbers.apply(j).toLong > max)\
    \ {\n                    max = numbers.apply(j).toLong\n                }\n  \
    \          }\n            result = result.append(max)\n        }\n        return\
    \ result", "        var max = numbers.head\n        var result = List[Long](max)\n\
    \        for (i <- 1 until numbers.size) {\n            max = numbers.apply(i).max(max)\n\
    \            result = result.updated(max)\n        }\n        return result",
  "        var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            result[i] = _.max(numbers.take(i).toSeq)\n        }\n       \
    \ return result", "        var result = List[Long](numbers.size)\n        for\
    \ (i <- 0 until numbers.size) {\n            var max = numbers[i]\n          \
    \  for (j <- i + 1 until numbers.size) {\n                if (numbers[j] > max)\
    \ max = numbers[j]\n            }\n            result[i] = max\n        }\n  \
    \      return result", "        var result = List[Long](numbers.size)\n      \
    \  for (i <- 0 until numbers.size) {\n            result[i] = _.max(numbers.take(i).toSeq)\n\
    \        }\n        return result", "        var result = List[Long](numbers.size())\n\
    \        for (i <- 0 until numbers.size()) {\n            result = result.updated(i,\
    \ numbers.apply(i).max(result.apply(i)))\n        }\n        return result", " \
    \       val result = mutable.List[Long]()\n        for (i <- 0 until numbers.size)\
    \ {\n            val max = numbers.apply(i)\n            for (j <- i + 1 until\
    \ numbers.size) {\n                if (numbers.apply(j) > max) {\n           \
    \         max = numbers.apply(j)\n                }\n            }\n         \
    \   result.append(max)\n        }\n        return result", "        var result\
    \ = List[Long](numbers.size)\n        for (i <- 0 until numbers.size) {\n    \
    \        var max = numbers[i]\n            for (j <- i + 1 until numbers.size)\
    \ {\n                if (numbers[j] > max) max = numbers[j]\n            }\n \
    \           result[i] = max\n        }\n        return result\n    }\n\n    //\
    \ From a given list of integers, generate a list of rolling minimum element found\
    \ until given moment\n    // in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong))\n    def rollingMin(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            var min = numbers[i]\n            for (j <- i + 1 until numbers.size)\
    \ {\n                if (numbers[j] < min) min = numbers[j]\n            }\n \
    \           result[i] = min\n        }\n        return result\n    }\n\n    //\
    \ From a given list of integers, generate a list of rolling sum found until given\
    \ moment\n    // in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 3l.toLong, 6l.toLong, 6l.toLong, 9l.toLong, 12l.toLong,\
    \ 12l.toLong))\n    def rollingSum(numbers : List[Long]) : List[Long] = {\n  \
    \      var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            var sum =", "        val result = mutable.List[Long]()\n    \
    \    for (i <- 0 until numbers.size) {\n            val max = numbers.apply(i).toLong\n\
    \            for (j <- i + 1 until numbers.size) {\n                val candidate\
    \ = numbers.apply(j).toLong\n                if (candidate > max) {\n        \
    \            max = candidate\n                }\n            }\n            result.append(max)\n\
    \        }\n        return result", "        val result = mutable.List[Long]()\n\
    \        for (i <- 0 until numbers.size) {\n            val max = numbers.apply(i)\n\
    \            for (j <- i + 1 until numbers.size) {\n                val candidate\
    \ = numbers.apply(j)\n                if (candidate > max) {\n               \
    \     max = candidate\n                }\n            }\n            result.append(max)\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result = result.update(i,\
    \ numbers.apply(i).max)\n        }\n        return result", "        val result\
    \ = mutable.List[Long]()\n        for (i <- 0 until numbers.size - 1) {\n    \
    \        val max = numbers.apply(i).toLong\n            for (j <- i + 1 until\
    \ numbers.size) {\n                if (numbers.apply(j).toLong > max) {\n    \
    \                max = numbers.apply(j).toLong\n                }\n          \
    \  }\n            result = result.append(max)\n        }\n        return result",
  "        val result = mutable.List[Long]()\n        for (i <- 0 until numbers.size)\
    \ {\n            val max = numbers.apply(i).toLong\n            for (j <- i +\
    \ 1 until numbers.size) {\n                if (numbers.apply(j).toLong > max)\
    \ {\n                    max = numbers.apply(j).toLong\n                }\n  \
    \          }\n            result = result.append(max)\n        }\n        return\
    \ result", "        var result = List[Long](numbers.size)\n        for (i <- 0\
    \ until numbers.size) {\n            result[i] = _.max(numbers.take(i).toList)\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    //\
    \ in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def\
    \ rollingMin(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.min(numbers.take(i).toList)\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling sum of elements found until given moment\n    //\
    \ in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 6l.toLong, 6l.toLong, 9l.toLong, 12l.toLong, 12l.toLong))\n    def\
    \ rollingSum(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.sum(numbers.take(i).toList)\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling product of elements found until given moment\n  \
    \  // in the sequence.\n    // >>> rollingProduct((", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size - 1) {\n            result[i + 1] = _.max(numbers[i\
    \ : i + 1])\n        }\n        return result\n    }\n\n    // From a given list\
    \ of integers, generate a list of rolling minimum element found until given moment\n\
    \    // in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def\
    \ rollingMin(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size - 1) {\n            result[i + 1] = _.min(numbers[i\
    \ : i + 1])\n        }\n        return result\n    }\n\n    // From a given list\
    \ of integers, generate a list of rolling sum of elements found until given moment\n\
    \    // in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 6l.toLong, 6l.toLong, 9l.toLong, 12l.toLong, 6l.toLong))\n    def\
    \ rollingSum(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size - 1) {\n            result[i + 1] = _.sum(numbers[i\
    \ : i + 1])\n        }\n        return result\n    }\n\n    // From a given list\
    \ of integers, generate a list of rolling product of elements found until given\
    \ moment\n    // in the", "        var max = numbers.head\n        var result\
    \ = List[Long](max)\n        for (i <- 1 until numbers.length) {\n           \
    \ max = max(numbers.apply(i))\n            result = result.updated(max)\n    \
    \    }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var max = numbers[i]\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers[j]\
    \ > max) max = numbers[j]\n            }\n            result[i] = max\n      \
    \  }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.max(numbers.take(i).toList)\n\
    \        }\n        return result", "        var result = List[Long](numbers.size())\n\
    \        for (i <- 0 until numbers.size()) {\n            var max = numbers[i]\n\
    \            for (j <- i + 1 until numbers.size()) {\n                if (numbers[j]\
    \ > max) max = numbers[j]\n            }\n            result[i] = max\n      \
    \  }\n        return result\n    }\n\n    // From a given list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    // in the sequence.\n\
    \    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def rollingMin(numbers\
    \ : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size())\n\
    \        for (i <- 0 until numbers.size()) {\n            var min = numbers[i]\n\
    \            for (j <- i + 1 until numbers.size()) {\n                if (numbers[j]\
    \ < min) min = numbers[j]\n            }\n            result[i] = min\n      \
    \  }\n        return result\n    }\n\n    // From a given list of integers, generate\
    \ a list of rolling sum found until given moment\n    // in the sequence.\n  \
    \  // >>> rollingSum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 3l.toLong, 6l.toLong,\
    \ 6l.toLong, 9l.toLong, 12l.toLong, 12l.toLong))\n    def rollingSum(numbers :\
    \ List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size())\n\
    \        for (i <- 0 until numbers.size()) {\n            var sum =", "      \
    \  var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            var max = numbers[i]\n            for (j <- i + 1 until numbers.size)\
    \ {\n                if (numbers[j] > max) max = numbers[j]\n            }\n \
    \           result[i] = max\n        }\n        return result\n    }\n\n    //\
    \ From a given list of integers, generate a list of rolling minimum element found\
    \ until given moment\n    // in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong))\n    def rollingMin(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            var min = numbers[i]\n            for (j <- i + 1 until numbers.size)\
    \ {\n                if (numbers[j] < min) min = numbers[j]\n            }\n \
    \           result[i] = min\n        }\n        return result\n    }\n\n    //\
    \ From a given list of integers, generate a list of rolling sum found until given\
    \ moment\n    // in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 3l.toLong, 6l.toLong, 6l.toLong, 9l.toLong, 12l.toLong,\
    \ 12l.toLong))\n    def rollingSum(numbers : List[Long]) : List[Long] = {\n  \
    \      var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            var sum =", "        val result = mutable.List[Long]()\n    \
    \    for (i <- 0 until numbers.size) {\n            val max = numbers.apply(i).toLong\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers.apply(j).toLong\
    \ > max) {\n                    max = numbers.apply(j).toLong\n              \
    \  }\n            }\n            result.append(max)\n        }\n        return\
    \ result", "        var result = List[Long](numbers.size)\n        for (i <- 0\
    \ until numbers.size) {\n            var max = numbers[i]\n            for (j\
    \ <- i + 1 until numbers.size) {\n                if (numbers[j] > max) max =\
    \ numbers[j]\n            }\n            result[i] = max\n        }\n        return\
    \ result", "        var result = List[Long](numbers.size)\n        for (i <- 0\
    \ until numbers.size) {\n            var max = numbers[i]\n            for (j\
    \ <- i + 1 until numbers.size) {\n                if (numbers[j] > max) max =\
    \ numbers[j]\n            }\n            result[i] = max\n        }\n        return\
    \ result", "        var result = List[Long](numbers.size)\n        for (i <- 0\
    \ until numbers.size) {\n            result[i] = _.max(numbers.take(i).toSeq)\n\
    \        }\n        return result", "        var max = numbers.head\n        var\
    \ result = List[Long](max)\n        for (i <- 1 until numbers.size) {\n      \
    \      max = max(numbers.apply(i).toLong, max)\n            result = result.updated(max)\n\
    \        }\n        return result", "        var result = List[Long](numbers.size())\n\
    \        for (i <- 0 until numbers.size()) {\n            var max = numbers[i]\n\
    \            for (j <- i + 1 until numbers.size()) {\n                if (numbers[j]\
    \ > max) {\n                    max = numbers[j]\n                }\n        \
    \    }\n            result[i] = max\n        }\n        return result\n    }\n\
    \n    // From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    // in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong))\n    def rollingMin(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = List[Long](numbers.size())\n        for (i <- 0 until numbers.size())\
    \ {\n            var min = numbers[i]\n            for (j <- i + 1 until numbers.size())\
    \ {\n                if (numbers[j] < min) {\n                    min = numbers[j]\n\
    \                }\n            }\n            result[i] = min\n        }\n  \
    \      return result\n    }\n\n    // From a given list of integers, generate\
    \ a list of rolling sum of elements found until given moment\n    // in the sequence.\n\
    \    // >>> rollingSum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](3l.toLong, 6l.toLong,\
    \ 9l.toLong, 6l.toLong, 9l.toLong, 12l.toLong, 6l.toLong))\n    def rollingSum(numbers\
    \ : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size())\n\
    \        for (", "        var result = List[Long](numbers.size)\n        for (i\
    \ <- 0 until numbers.size) {\n            var max = numbers[i]\n            for\
    \ (j <- i + 1 until numbers.size) {\n                if (numbers[j] > max) max\
    \ = numbers[j]\n            }\n            result[i] = max\n        }\n      \
    \  return result", "        val result = mutable.List[Long]()\n        for (i\
    \ <- 0 until numbers.size) {\n            val max = numbers.apply(i)\n       \
    \     for (j <- i + 1 until numbers.size) {\n                if (numbers.apply(j)\
    \ > max) {\n                    max = numbers.apply(j)\n                }\n  \
    \          }\n            result.append(max)\n        }\n        return result",
  "        var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            var max = numbers[i]\n            for (j <- i + 1 until numbers.size)\
    \ {\n                if (numbers[j] > max) {\n                    max = numbers[j]\n\
    \                }\n            }\n            result[i] = max\n        }\n  \
    \      return result", "        var result = List[Long](numbers.size)\n      \
    \  for (i <- 0 until numbers.size) {\n            result = result.update(i, numbers.apply(i).max(result.apply(i)))\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    //\
    \ in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def\
    \ rollingMin(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result = result.update(i,\
    \ numbers.apply(i).min(result.apply(i)))\n        }\n        return result\n \
    \   }\n\n    // From a given list of integers, generate a list of rolling sum\
    \ of elements found until given moment\n    // in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 3l.toLong, 6l.toLong, 6l.toLong, 9l.toLong, 12l.toLong,\
    \ 6l.toLong))\n    def rollingSum(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            result = result.update(i, numbers.apply(i).sum(result.apply(i)))\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling product of elements found until given moment\n  \
    \  // in the", "        val result = mutable.List[Long]()\n        for (i <- 0\
    \ until numbers.size) {\n            val max = numbers.apply(i)\n            for\
    \ (j <- i + 1 until numbers.size) {\n                val candidate = numbers.apply(j)\n\
    \                if (candidate > max) {\n                    max = candidate\n\
    \                }\n            }\n            result.append(max)\n        }\n\
    \        return result", "        var result = List[Long](numbers.size)\n    \
    \    for (i <- 0 until numbers.size) {\n            result[i] = _.max(numbers.take(i).toList)\n\
    \        }\n        return result", "        val result = mutable.List[Long]()\n\
    \        for (i <- 0 until numbers.size) {\n            val max = numbers.apply(i).toLong\n\
    \            for (j <- i + 1 until numbers.size) {\n                val candidate\
    \ = numbers.apply(j).toLong\n                if (candidate > max) {\n        \
    \            max = candidate\n                }\n            }\n            result\
    \ = result.append(max)\n        }\n        return result", "        var result\
    \ = List[Long](numbers.size)\n        for (i <- 0 until numbers.size) {\n    \
    \        var max = numbers[i]\n            for (j <- i + 1 until numbers.size)\
    \ {\n                if (numbers[j] > max) {\n                    max = numbers[j]\n\
    \                }\n            }\n            result[i] = max\n        }\n  \
    \      return result", '        numbers.reduce((a, b) -> a > b ? a : b)', "  \
    \      var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            var max = numbers[i]\n            for (j <- i + 1 until numbers.size)\
    \ {\n                if (numbers[j] > max) {\n                    max = numbers[j]\n\
    \                }\n            }\n            result[i] = max\n        }\n  \
    \      return result\n    }\n\n    // From a given list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    // in the sequence.\n\
    \    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def rollingMin(numbers\
    \ : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var min = numbers[i]\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers[j]\
    \ < min) {\n                    min = numbers[j]\n                }\n        \
    \    }\n            result[i] = min\n        }\n        return result\n    }\n\
    \n    // From a given list of integers, generate a list of rolling sum of elements\
    \ found until given moment\n    // in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](3l.toLong, 6l.toLong, 9l.toLong, 6l.toLong, 9l.toLong, 12l.toLong,\
    \ 6l.toLong))\n    def rollingSum(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = List[Long](numbers.size)\n        for (", "        var result\
    \ = List[Long](numbers.size())\n        for (i <- 0 until numbers.size()) {\n\
    \            result = result.update(i, numbers.apply(i).max(result.apply(i)))\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    //\
    \ in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def\
    \ rollingMin(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size())\n\
    \        for (i <- 0 until numbers.size()) {\n            result = result.update(i,\
    \ numbers.apply(i).min(result.apply(i)))\n        }\n        return result\n \
    \   }\n\n    // From a given list of integers, generate a list of rolling sum\
    \ found until given moment\n    // in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 3l.toLong, 6l.toLong, 9l.toLong, 12l.toLong, 15l.toLong,\
    \ 18l.toLong))\n    def rollingSum(numbers : List[Long]) : List[Long] = {\n  \
    \      var result = List[Long](numbers.size())\n        for (i <- 0 until numbers.size())\
    \ {\n            result = result.update(i, numbers.apply(i).sum(result.apply(i)))\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling product found until given moment\n    // in the sequence.\n\
    \    ", "        val result = mutable.List[Long]()\n        for (i <- 0 until\
    \ numbers.size - 1) {\n            val max = numbers.apply(i).toLong\n       \
    \     for (j <- i + 1 until numbers.size) {\n                if (numbers.apply(j).toLong\
    \ > max) {\n                    max = numbers.apply(j).toLong\n              \
    \  }\n            }\n            result = result.append(max)\n        }\n    \
    \    return result", "        val result = mutable.List[Long]()\n        for (i\
    \ <- 0 until numbers.size) {\n            val max = numbers.apply(i)\n       \
    \     for (j <- i + 1 until numbers.size) {\n                if (numbers.apply(j)\
    \ > max) {\n                    max = numbers.apply(j)\n                }\n  \
    \          }\n            result.append(max)\n        }\n        return result",
  "        var result = List[Long](numbers.size())\n        for (i <- 0 until numbers.size())\
    \ {\n            result = result.updated(i, numbers.apply(i).max(result.apply(i)))\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.max(numbers.take(i).toList)\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result = result.update(i,\
    \ numbers.apply(i).max(result.apply(i)))\n        }\n        return result", " \
    \       var result = List[Long](numbers.size())\n        for (i <- 0 until numbers.size())\
    \ {\n            var max = numbers[i]\n            for (j <- i + 1 until numbers.size())\
    \ {\n                if (numbers[j] > max) max = numbers[j]\n            }\n \
    \           result[i] = max\n        }\n        return result\n    }\n\n    //\
    \ From a given list of integers, generate a list of rolling minimum element found\
    \ until given moment\n    // in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong))\n    def rollingMin(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = List[Long](numbers.size())\n        for (i <- 0 until numbers.size())\
    \ {\n            var min = numbers[i]\n            for (j <- i + 1 until numbers.size())\
    \ {\n                if (numbers[j] < min) min = numbers[j]\n            }\n \
    \           result[i] = min\n        }\n        return result\n    }\n\n    //\
    \ From a given list of integers, generate a list of rolling sum found until given\
    \ moment\n    // in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 3l.toLong, 6l.toLong, 6l.toLong, 9l.toLong, 12l.toLong,\
    \ 12l.toLong))\n    def rollingSum(numbers : List[Long]) : List[Long] = {\n  \
    \      var result = List[Long](numbers.size())\n        for (i <- 0 until numbers.size())\
    \ {\n            var sum =", "        val result = mutable.List[Long]()\n    \
    \    for (i <- 0 until numbers.size) {\n            val max = numbers.apply(i).toLong\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers.apply(j).toLong\
    \ > max) {\n                    max = numbers.apply(j).toLong\n              \
    \  }\n            }\n            result = result.append(max)\n        }\n    \
    \    return result", "        var result = List[Long](numbers.size)\n        for\
    \ (i <- 0 until numbers.size) {\n            result = result.updated(i, numbers.apply(i).max(result.apply(i)))\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result = result.update(i,\
    \ numbers.apply(i).max(result.apply(i)))\n        }\n        return result", " \
    \       var result = List[Long](numbers.size())\n        for (i <- 0 until numbers.size())\
    \ {\n            result = result.update(i, numbers.apply(i).max(result.apply(i)))\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.max(numbers.take(i).toSeq)\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result = result.update(i,\
    \ numbers.apply(i).max(result.apply(i)))\n        }\n        return result", " \
    \       var max = numbers.head\n        var maxIndex = 0\n        for (i <- numbers.size\
    \ - 1) {\n            if (numbers[i] > max) {\n                max = numbers[i]\n\
    \                maxIndex = i\n            }\n        }\n        var result =\
    \ numbers.take(maxIndex + 1)\n        result.update(max)\n        return result",
  "        var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            var max = numbers[i]\n            for (j <- i + 1 until numbers.size)\
    \ {\n                if (numbers[j] > max) max = numbers[j]\n            }\n \
    \           result[i] = max\n        }\n        return result\n    }\n\n    //\
    \ From a given list of integers, generate a list of rolling minimum element found\
    \ until given moment\n    // in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong))\n    def rollingMin(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            var min = numbers[i]\n            for (j <- i + 1 until numbers.size)\
    \ {\n                if (numbers[j] < min) min = numbers[j]\n            }\n \
    \           result[i] = min\n        }\n        return result\n    }\n\n    //\
    \ From a given list of integers, generate a list of rolling sum of elements found\
    \ until given moment\n    // in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](3l.toLong, 6l.toLong, 9l.toLong, 6l.toLong, 9l.toLong, 12l.toLong,\
    \ 6l.toLong))\n    def rollingSum(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            var", "        var result = List[Long](numbers.size)\n      \
    \  for (i <- 0 until numbers.size) {\n            result[i] = _.max(numbers.take(i).toSeq)\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    //\
    \ in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def\
    \ rollingMin(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.min(numbers.take(i).toSeq)\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling sum of elements found until given moment\n    //\
    \ in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 6l.toLong, 6l.toLong, 9l.toLong, 12l.toLong, 6l.toLong))\n    def\
    \ rollingSum(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.sum(numbers.take(i).toSeq)\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling product of elements found until given moment\n  \
    \  // in the sequence.\n    // >>>", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var max = numbers[i]\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers[j]\
    \ > max) max = numbers[j]\n            }\n            result[i] = max\n      \
    \  }\n        return result\n    }\n\n    // From a given list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    // in the sequence.\n\
    \    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def rollingMin(numbers\
    \ : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var min = numbers[i]\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers[j]\
    \ < min) min = numbers[j]\n            }\n            result[i] = min\n      \
    \  }\n        return result\n    }\n\n    // From a given list of integers, generate\
    \ a list of rolling sum found until given moment\n    // in the sequence.\n  \
    \  // >>> rollingSum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 3l.toLong, 6l.toLong,\
    \ 6l.toLong, 9l.toLong, 12l.toLong, 12l.toLong))\n    def rollingSum(numbers :\
    \ List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var sum =", "        var\
    \ result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size) {\n\
    \            result = result.updated(i, numbers.apply(i).max(result.apply(i)))\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result = result.updated(i,\
    \ numbers.apply(i).max(result.apply(i)))\n        }\n        return result\n \
    \   }\n\n    // From a given list of integers, generate a list of rolling minimum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong))\n    def rollingMin(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            result = result.updated(i, numbers.apply(i).min(result.apply(i)))\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling sum found until given moment\n    // in the sequence.\n\
    \    // >>> rollingSum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 3l.toLong,\
    \ 6l.toLong, 6l.toLong, 9l.toLong, 12l.toLong, 6l.toLong))\n    def rollingSum(numbers\
    \ : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result = result.updated(i,\
    \ result.apply(i) + numbers.apply(i))\n        }\n        return result\n    }\n\
    \n    // From a given list of integers, generate a list of rolling product found\
    \ until given moment\n    // in the sequence.\n    //", "        var result =\
    \ List[Long](numbers.size)\n        for (i <- 0 until numbers.size) {\n      \
    \      result = result.updated(i, numbers.apply(i).max(result.apply(i)))\n   \
    \     }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    //\
    \ in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def\
    \ rollingMin(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result = result.updated(i,\
    \ numbers.apply(i).min(result.apply(i)))\n        }\n        return result\n \
    \   }\n\n    // From a given list of integers, generate a list of rolling sum\
    \ of elements found until given moment\n    // in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 3l.toLong, 6l.toLong, 6l.toLong, 9l.toLong, 12l.toLong,\
    \ 6l.toLong))\n    def rollingSum(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            result = result.updated(i, result.apply(i) + numbers.apply(i))\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling product of elements found until given moment\n  \
    \  // in the sequence", "        var result = List[Long](numbers.size)\n     \
    \   for (i <- 0 until numbers.size) {\n            result[i] = _.max(numbers.take(i).toList)\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result = result.updated(i,\
    \ numbers.apply(i).max(result.apply(i)))\n        }\n        return result", " \
    \       var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            result[i] = _.max(numbers.take(i).toSeq)\n        }\n       \
    \ return result", "        val result = mutable.List[Long]()\n        for (i <-\
    \ 0 until numbers.length) {\n            val max = numbers[i]\n            for\
    \ (j <- i + 1 until numbers.length) {\n                if (numbers[j] > max) max\
    \ = numbers[j]\n            }\n            result = result.append(max)\n     \
    \   }\n        return result", "        val result = mutable.List[Long]()\n  \
    \      for (i <- 0 until numbers.size) {\n            val max = numbers.apply(i).toLong\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers.apply(j).toLong\
    \ > max) {\n                    max = numbers.apply(j).toLong\n              \
    \  }\n            }\n            result.append(max)\n        }\n        return\
    \ result", "        var result = List[Long](numbers.size)\n        for (i <- 0\
    \ until numbers.size) {\n            result = result.update(i, numbers.apply(i).max(result.apply(i)))\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.max(numbers.take(i).toSeq)\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result = result.updated(i,\
    \ numbers.apply(i).max(result.apply(i)))\n        }\n        return result", " \
    \       var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            var max = numbers[i]\n            for (j <- i + 1 until numbers.size)\
    \ {\n                if (numbers[j] > max) {\n                    max = numbers[j]\n\
    \                }\n            }\n            result[i] = max\n        }\n  \
    \      return result", "        var result = List[Long](numbers.size)\n      \
    \  for (i <- 0 until numbers.size) {\n            var max = numbers[i]\n     \
    \       for (j <- i + 1 until numbers.size) {\n                if (numbers[j]\
    \ > max) max = numbers[j]\n            }\n            result[i] = max\n      \
    \  }\n        return result\n    }\n\n    // From a given list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    // in the sequence.\n\
    \    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def rollingMin(numbers\
    \ : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var min = numbers[i]\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers[j]\
    \ < min) min = numbers[j]\n            }\n            result[i] = min\n      \
    \  }\n        return result\n    }\n\n    // From a given list of integers, generate\
    \ a list of rolling sum of elements found until given moment\n    // in the sequence.\n\
    \    // >>> rollingSum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 3l.toLong,\
    \ 6l.toLong, 6l.toLong, 9l.toLong, 12l.toLong, 12l.toLong))\n    def rollingSum(numbers\
    \ : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var", "        var max\
    \ = numbers.head\n        var result = List[Long](max)\n        for (i <- numbers.tail.takeWhile(i\
    \ => i <= max)) {\n            max = max(i)\n            result = result.updated(max)\n\
    \        }\n        return result", "        val result = mutable.List[Long]()\n\
    \        for (i <- 0 until numbers.size) {\n            val max = numbers.apply(i)\n\
    \            for (j <- i + 1 until numbers.size) {\n                val candidate\
    \ = numbers.apply(j)\n                if (candidate > max) {\n               \
    \     max = candidate\n                }\n            }\n            result.append(max)\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var max = numbers[i]\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers[j]\
    \ > max) {\n                    max = numbers[j]\n                }\n        \
    \    }\n            result[i] = max\n        }\n        return result", "    \
    \    var max = numbers.head\n        var result = List[Long](max)\n        for\
    \ (i <- numbers.tail) {\n            max = max(max, i)\n            result = result.updated(max)\n\
    \        }\n        return result", "        var result = List[Long](numbers.size())\n\
    \        for (i <- 0 until numbers.size()) {\n            var max = numbers.apply(i)\n\
    \            for (j <- i + 1 until numbers.size()) {\n                if (numbers.apply(j)\
    \ > max) {\n                    max = numbers.apply(j)\n                }\n  \
    \          }\n            result = result.update(i, max)\n        }\n        return\
    \ result", "        val result = mutable.List[Long]()\n        for (i <- 0 until\
    \ numbers.size) {\n            val max = numbers.apply(i).toLong\n           \
    \ for (j <- i + 1 until numbers.size) {\n                val curr = numbers.apply(j).toLong\n\
    \                if (curr > max) {\n                    max = curr\n         \
    \       }\n            }\n            result.append(max)\n        }\n        return\
    \ result", "        val result = mutable.List[Long]()\n        for (i <- 0 until\
    \ numbers.size - 1) {\n            val max = numbers.apply(i).toLong\n       \
    \     for (j <- i + 1 until numbers.size) {\n                if (numbers.apply(j).toLong\
    \ > max) {\n                    max = numbers.apply(j).toLong\n              \
    \  }\n            }\n            result.append(max)\n        }\n        return\
    \ result", "        val result = mutable.List[Long]()\n        for (i <- 0 until\
    \ numbers.size) {\n            val max = numbers.apply(i)\n            for (j\
    \ <- i + 1 until numbers.size) {\n                val candidate = numbers.apply(j)\n\
    \                if (candidate > max) {\n                    max = candidate\n\
    \                }\n            }\n            result.append(max)\n        }\n\
    \        return result", "        var result = List[Long](numbers.size())\n  \
    \      for (i <- 0 until numbers.size()) {\n            result = result.update(i,\
    \ numbers.apply(i).max(result.apply(i)))\n        }\n        return result", " \
    \       val result = mutable.List[Long]()\n        for (i <- 0 until numbers.size)\
    \ {\n            val max = numbers.apply(i).toLong\n            for (j <- i +\
    \ 1 until numbers.size) {\n                if (numbers.apply(j).toLong > max)\
    \ {\n                    max = numbers.apply(j).toLong\n                }\n  \
    \          }\n            result = result.append(max)\n        }\n        return\
    \ result", '        numbers.reduce((a, b) -> a > b ? a : b)', "        val result\
    \ = mutable.List[Long]()\n        for (i <- 0 until numbers.size) {\n        \
    \    val max = numbers.apply(i).toLong\n            for (j <- i + 1 until numbers.size)\
    \ {\n                val candidate = numbers.apply(j).toLong\n               \
    \ if (candidate > max) {\n                    max = candidate\n              \
    \  }\n            }\n            result = result.append(max)\n        }\n    \
    \    return result", "        var result = List[Long](numbers.size)\n        for\
    \ (i <- 0 until numbers.size) {\n            var max = numbers[i]\n          \
    \  for (j <- i + 1 until numbers.size) {\n                if (numbers[j] > max)\
    \ max = numbers[j]\n            }\n            result[i] = max\n        }\n  \
    \      return result\n    }\n\n    // From a given list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    // in the sequence.\n\
    \    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def rollingMin(numbers\
    \ : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var min = numbers[i]\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers[j]\
    \ < min) min = numbers[j]\n            }\n            result[i] = min\n      \
    \  }\n        return result\n    }\n\n    // From a given list of integers, generate\
    \ a list of rolling sum of elements found until given moment\n    // in the sequence.\n\
    \    // >>> rollingSum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 3l.toLong,\
    \ 6l.toLong, 6l.toLong, 9l.toLong, 12l.toLong, 12l.toLong))\n    def rollingSum(numbers\
    \ : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var", "        var result\
    \ = List[Long](numbers.size())\n        for (i <- 0 until numbers.size()) {\n\
    \            result = result.update(i, numbers.apply(i).max(result.apply(i)))\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size - 1) {\n            result[i] = _.max(numbers.take(i\
    \ + 1).toList)\n        }\n        return result", "        var max = numbers.head\n\
    \        var maxIndex = 0\n        for (i <- numbers.size - 1) {\n           \
    \ if (numbers[i] > max) {\n                max = numbers[i]\n                maxIndex\
    \ = i\n            }\n        }\n        var result = numbers.take(maxIndex +\
    \ 1)\n        result = result.append(max)\n        return result", "        val\
    \ result = mutable.List[Long]()\n        for (i <- 0 until numbers.size) {\n \
    \           val max = numbers.apply(i)\n            for (j <- i + 1 until numbers.size)\
    \ {\n                if (numbers.apply(j) > max) {\n                    max =\
    \ numbers.apply(j)\n                }\n            }\n            result = result.append(max)\n\
    \        }\n        return result", "        val result = mutable.List[Long]()\n\
    \        for (i <- 0 until numbers.size) {\n            val max = numbers.apply(i)\n\
    \            for (j <- i + 1 until numbers.size) {\n                val candidate\
    \ = numbers.apply(j)\n                if (candidate > max) {\n               \
    \     max = candidate\n                }\n            }\n            result.append(max)\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.max(numbers.take(i).toSeq)\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var max = numbers[i]\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers[j]\
    \ > max) {\n                    max = numbers[j]\n                }\n        \
    \    }\n            result[i] = max\n        }\n        return result", "    \
    \    val result = mutable.List[Long]()\n        for (i <- 0 until numbers.size)\
    \ {\n            val max = numbers.apply(i)\n            for (j <- i + 1 until\
    \ numbers.size) {\n                val candidate = numbers.apply(j)\n        \
    \        if (candidate > max) {\n                    max = candidate\n       \
    \         }\n            }\n            result.append(max)\n        }\n      \
    \  return result", "        var result = List[Long](numbers.size)\n        for\
    \ (i <- 0 until numbers.size) {\n            result[i] = _.max(numbers.take(i).toList)\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.max(numbers.take(i).toList)\n\
    \        }\n        return result", "        val result = mutable.List[Long]()\n\
    \        for (i <- 0 until numbers.size) {\n            val max = numbers.apply(i).toLong\n\
    \            for (j <- i + 1 until numbers.size) {\n                val candidate\
    \ = numbers.apply(j).toLong\n                if (candidate > max) {\n        \
    \            max = candidate\n                }\n            }\n            result.append(max)\n\
    \        }\n        return result", "        val result = mutable.List[Long]()\n\
    \        for (i <- 0 until numbers.size) {\n            val max = numbers.apply(i).toLong\n\
    \            for (j <- i + 1 until numbers.size) {\n                val candidate\
    \ = numbers.apply(j).toLong\n                if (candidate > max) {\n        \
    \            max = candidate\n                }\n            }\n            result\
    \ = result.append(max)\n        }\n        return result", "        val result\
    \ = mutable.List[Long]()\n        for (i <- 0 until numbers.size - 1) {\n    \
    \        val max = numbers.apply(i).toLong\n            for (j <- i + 1 until\
    \ numbers.size) {\n                if (numbers.apply(j).toLong > max) {\n    \
    \                max = numbers.apply(j).toLong\n                }\n          \
    \  }\n            result.append(max)\n        }\n        return result", "   \
    \     var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            var max = numbers[i]\n            for (j <- i + 1 until numbers.size)\
    \ {\n                if (numbers[j] > max) {\n                    max = numbers[j]\n\
    \                }\n            }\n            result[i] = max\n        }\n  \
    \      return result", "        var max = numbers.head\n        var maxIndex =\
    \ 0\n        for (i <- 1 until numbers.size) {\n            if (numbers[i] > max)\
    \ {\n                max = numbers[i]\n                maxIndex = i\n        \
    \    }\n        }\n        return maxIndex == 0 ? numbers : maxIndex + 1 == numbers.size\
    \ ? numbers : maxIndex + 1", "        val result = mutable.List[Long]()\n    \
    \    for (i <- 0 until numbers.size) {\n            val max = numbers.apply(i).toLong\n\
    \            for (j <- i + 1 until numbers.size) {\n                val current\
    \ = numbers.apply(j).toLong\n                if (current > max) {\n          \
    \          max = current\n                }\n            }\n            result\
    \ = result.append(max)\n        }\n        return result", "        var max =\
    \ numbers.head\n        var maxIndex = 0\n        for (i <- numbers.size - 1)\
    \ {\n            if (numbers[i] > max) {\n                max = numbers[i]\n \
    \               maxIndex = i\n            }\n        }\n        var result = numbers.take(maxIndex\
    \ + 1)\n        result.update(max)\n        return result", "        var result\
    \ = mutable.List[Long]()\n        for (i <- 0 until numbers.length) {\n      \
    \      var max = numbers[i]\n            for (j <- i + 1 until numbers.length)\
    \ {\n                if (numbers[j] > max) max = numbers[j]\n            }\n \
    \           result = result.append(max)\n        }\n        return result", " \
    \       var result = List[Long](numbers.size())\n        for (i <- 0 until numbers.size())\
    \ {\n            result = result.update(i, numbers.apply(i).max(result.apply(i)))\n\
    \        }\n        return result", "        val result = mutable.List[Long]()\n\
    \        for (i <- 0 until numbers.size) {\n            val max = numbers.apply(i)\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers.apply(j)\
    \ > max) {\n                    max = numbers.apply(j)\n                }\n  \
    \          }\n            result = result.append(max)\n        }\n        return\
    \ result", "        var result = List[Long](numbers.size())\n        for (i <-\
    \ 0 until numbers.size()) {\n            result = result.updated(i, numbers.apply(i).max(result.apply(i)))\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    //\
    \ in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def\
    \ rollingMin(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size())\n\
    \        for (i <- 0 until numbers.size()) {\n            result = result.updated(i,\
    \ numbers.apply(i).min(result.apply(i)))\n        }\n        return result\n \
    \   }\n\n    // From a given list of integers, generate a list of rolling sum\
    \ found until given moment\n    // in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 3l.toLong, 6l.toLong, 9l.toLong, 12l.toLong, 15l.toLong,\
    \ 18l.toLong))\n    def rollingSum(numbers : List[Long]) : List[Long] = {\n  \
    \      var result = List[Long](numbers.size())\n        for (i <- 0 until numbers.size())\
    \ {\n            result = result.updated(i, numbers.apply(i).sum(result.apply(i)))\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling product found until given moment\n    // in the sequence.\n\
    \    ", "        var result = List[Long](numbers.size)\n        for (i <- 0 until\
    \ numbers.size - 1) {\n            result[i + 1] = max(numbers[i], result[i])\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    //\
    \ in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def\
    \ rollingMin(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size - 1) {\n            result[i + 1] = min(numbers[i],\
    \ result[i])\n        }\n        return result\n    }\n\n    // From a given list\
    \ of integers, generate a list of rolling sum of elements found until given moment\n\
    \    // in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 6l.toLong, 8l.toLong, 11l.toLong, 14l.toLong, 16l.toLong))\n    def\
    \ rollingSum(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size - 1) {\n            result[i + 1] = result[i]\
    \ + numbers[i]\n        }\n        return result\n    }\n\n    // From a given\
    \ list of integers, generate a list of rolling product of elements found until\
    \ given moment\n    // in the sequence.\n    // >>> rollingProduct", "       \
    \ var result = List[Long](numbers.size())\n        for (i <- 0 until numbers.size())\
    \ {\n            result = result.update(i, numbers.apply(i).max(result.apply(i)))\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    //\
    \ in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def\
    \ rollingMin(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size())\n\
    \        for (i <- 0 until numbers.size()) {\n            result = result.update(i,\
    \ numbers.apply(i).min(result.apply(i)))\n        }\n        return result\n \
    \   }\n\n    // From a given list of integers, generate a list of rolling sum\
    \ of elements found until given moment\n    // in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 3l.toLong, 6l.toLong, 6l.toLong, 9l.toLong, 12l.toLong,\
    \ 12l.toLong))\n    def rollingSum(numbers : List[Long]) : List[Long] = {\n  \
    \      var result = List[Long](numbers.size())\n        for (i <- 0 until numbers.size())\
    \ {\n            result = result.update(i, numbers.apply(i).sum(result.apply(i)))\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling product of elements found until given moment\n  \
    \  // in the", "        var result = List[Long](numbers.size)\n        for (i\
    \ <- 0 until numbers.size) {\n            result[i] = _.max(numbers.take(i).toList)\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var max = numbers[i]\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers[j]\
    \ > max) max = numbers[j]\n            }\n            result[i] = max\n      \
    \  }\n        return result", "        var max = numbers.head\n        var result\
    \ = List[Long](max)\n        for (i <- 1 until numbers.length) {\n           \
    \ max = max(numbers.apply(i))\n            result = result.updated(max)\n    \
    \    }\n        return result", "        var result = List[Long](numbers.size())\n\
    \        for (i <- 0 until numbers.size()) {\n            result = result.update(i,\
    \ numbers.apply(i).max(result.apply(i)))\n        }\n        return result", " \
    \       var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            result[i] = _.max(numbers.take(i).toList)\n        }\n      \
    \  return result\n    }\n\n    // From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    // in the sequence.\n\
    \    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def rollingMin(numbers\
    \ : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.min(numbers.take(i).toList)\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling sum found until given moment\n    // in the sequence.\n\
    \    // >>> rollingSum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 3l.toLong,\
    \ 6l.toLong, 8l.toLong, 11l.toLong, 14l.toLong, 16l.toLong))\n    def rollingSum(numbers\
    \ : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.sum(numbers.take(i).toList)\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling product found until given moment\n    // in the sequence.\n\
    \    // >>> rollingProduct((List[Long](", "        var result = List[Long](numbers.size())\n\
    \        for (i <- 0 until numbers.size()) {\n            var max = numbers.apply(i)\n\
    \            for (j <- i + 1 until numbers.size()) {\n                if (numbers.apply(j)\
    \ > max) {\n                    max = numbers.apply(j)\n                }\n  \
    \          }\n            result = result.updated(i, max)\n        }\n       \
    \ return result\n    }\n\n    // From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    // in the sequence.\n\
    \    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def rollingMin(numbers\
    \ : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size())\n\
    \        for (i <- 0 until numbers.size()) {\n            var min = numbers.apply(i)\n\
    \            for (j <- i + 1 until numbers.size()) {\n                if (numbers.apply(j)\
    \ < min) {\n                    min = numbers.apply(j)\n                }\n  \
    \          }\n            result = result.updated(i, min)\n        }\n       \
    \ return result\n    }\n\n    // From a given list of integers, generate a list\
    \ of rolling sum found until given moment\n    // in the sequence.\n    // >>>\
    \ rollingSum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 3l.toLong, 6l.toLong,\
    \ 8l.toLong, 11l.toLong, 15l.toLong, 17l.toLong))\n    def rollingSum(numbers\
    \ : List[Long]) : List[Long] = {", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var max = numbers[i]\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers[j]\
    \ > max) {\n                    max = numbers[j]\n                }\n        \
    \    }\n            result[i] = max\n        }\n        return result", "    \
    \    val result = mutable.List[Long]()\n        for (i <- 0 until numbers.size)\
    \ {\n            val max = numbers.apply(i)\n            for (j <- i + 1 until\
    \ numbers.size) {\n                if (numbers.apply(j) > max) {\n           \
    \         max = numbers.apply(j)\n                }\n            }\n         \
    \   result = result.append(max)\n        }\n        return result", "        val\
    \ result = mutable.List[Long]()\n        for (i <- 0 until numbers.size) {\n \
    \           val max = numbers.apply(i).toLong\n            for (j <- i + 1 until\
    \ numbers.size) {\n                val candidate = numbers.apply(j).toLong\n \
    \               if (candidate > max) {\n                    max = candidate\n\
    \                }\n            }\n            result.append(max)\n        }\n\
    \        return result", "        var result = List[Long](numbers.size)\n    \
    \    for (i <- 0 until numbers.size) {\n            result = result.update(i,\
    \ numbers.apply(i).max(_))\n        }\n        return result", "        var result\
    \ = List[Long](numbers.size())\n        for (i <- 0 until numbers.size()) {\n\
    \            result = result.updated(i, numbers.apply(i).max(result.apply(i)))\n\
    \        }\n        return result", "        var max = numbers.head\n        var\
    \ maxIndex = 0\n        for (i <- 1 until numbers.size) {\n            if (numbers[i]\
    \ > max) {\n                max = numbers[i]\n                maxIndex = i\n \
    \           }\n        }\n        var result = numbers.take(maxIndex + 1)\n  \
    \      result.append(max)\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.max(numbers.take(i).toSeq)\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result = result.update(i,\
    \ numbers.apply(i).max(result.apply(i)))\n        }\n        return result", " \
    \       var result = List[Long](numbers.size())\n        for (i <- 0 until numbers.size())\
    \ {\n            result = result.updated(i, numbers.apply(i).max(result.apply(i)))\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    //\
    \ in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def\
    \ rollingMin(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size())\n\
    \        for (i <- 0 until numbers.size()) {\n            result = result.updated(i,\
    \ numbers.apply(i).min(result.apply(i)))\n        }\n        return result\n \
    \   }\n\n    // From a given list of integers, generate a list of rolling sum\
    \ found until given moment\n    // in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 3l.toLong, 6l.toLong, 6l.toLong, 9l.toLong, 12l.toLong,\
    \ 6l.toLong))\n    def rollingSum(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = List[Long](numbers.size())\n        for (i <- 0 until numbers.size())\
    \ {\n            result = result.updated(i, result.apply(i) + numbers.apply(i))\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling product found until given moment\n    // in the sequence.\n\
    \    //", "        val result = mutable.List[Long]()\n        for (i <- 0 until\
    \ numbers.size) {\n            val max = numbers.apply(i).toLong\n           \
    \ for (j <- i + 1 until numbers.size) {\n                if (numbers.apply(j).toLong\
    \ > max) {\n                    max = numbers.apply(j).toLong\n              \
    \  }\n            }\n            result.append(max)\n        }\n        return\
    \ result", "        val result = mutable.List[Long]()\n        for (i <- 0 until\
    \ numbers.size) {\n            val max = numbers.apply(i)\n            for (j\
    \ <- i + 1 until numbers.size) {\n                val candidate = numbers.apply(j)\n\
    \                if (candidate > max) {\n                    max = candidate\n\
    \                }\n            }\n            result.append(max)\n        }\n\
    \        return result\n    }\n\n    // From a given list of integers, generate\
    \ a list of rolling minimum element found until given moment\n    // in the sequence.\n\
    \    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def rollingMin(numbers\
    \ : List[Long]) : List[Long] = {\n        val result = mutable.List[Long]()\n\
    \        for (i <- 0 until numbers.size) {\n            val min = numbers.apply(i)\n\
    \            for (j <- i + 1 until numbers.size) {\n                val candidate\
    \ = numbers.apply(j)\n                if (candidate < min) {\n               \
    \     min = candidate\n                }\n            }\n            result.append(min)\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling sum of elements found until given moment\n    //\
    \ in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](3l.toLong,\
    \ 6l.toLong, 9l.toLong, 6l.toLong, 9l.toLong, 12l.toLong, 6l.toLong))\n    def\
    \ rollingSum(numbers : List[Long]) : List[Long] = {\n        val result = mut",
  "        var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            var max = numbers[i]\n            for (j <- i + 1 until numbers.size)\
    \ {\n                if (numbers[j] > max) max = numbers[j]\n            }\n \
    \           result[i] = max\n        }\n        return result", "        var result\
    \ = List[Long](numbers.size())\n        for (i <- 0 until numbers.size()) {\n\
    \            result[i] = _.max(numbers.take(i).toSeq)\n        }\n        return\
    \ result", "        val result = mutable.List[Long]()\n        for (i <- 0 until\
    \ numbers.length) {\n            val max = numbers.apply(i)\n            for (j\
    \ <- i + 1 until numbers.length) {\n                val candidate = numbers.apply(j)\n\
    \                if (candidate > max) {\n                    max = candidate\n\
    \                }\n            }\n            result.append(max)\n        }\n\
    \        return result", "        var result = List[Long](numbers.size)\n    \
    \    for (i <- 0 until numbers.size) {\n            result = result.updated(i,\
    \ max(numbers.slice(i, i + 1)))\n        }\n        return result", "        val\
    \ result = mutable.List[Long]()\n        for (i <- 0 until numbers.size - 1) {\n\
    \            val max = numbers.apply(i).toLong\n            for (j <- i + 1 until\
    \ numbers.size) {\n                if (numbers.apply(j).toLong > max) {\n    \
    \                max = numbers.apply(j).toLong\n                }\n          \
    \  }\n            result.append(max)\n        }\n        return result\n    }\n\
    \n    // From a given list of integers, generate a list of rolling minimum element\
    \ found until given moment\n    // in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong))\n    def rollingMin(numbers : List[Long]) : List[Long] = {\n   \
    \     val result = mutable.List[Long]()\n        for (i <- 0 until numbers.size\
    \ - 1) {\n            val min = numbers.apply(i).toLong\n            for (j <-\
    \ i + 1 until numbers.size) {\n                if (numbers.apply(j).toLong < min)\
    \ {\n                    min = numbers.apply(j).toLong\n                }\n  \
    \          }\n            result.append(min)\n        }\n        return result\n\
    \    }\n\n    // From a given list of integers, generate a list of rolling sum\
    \ of elements found until given moment\n    // in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](3l.toLong, 6l.toLong, 9l.toLong, 6l.toLong, 9l.toLong, 12l.toLong,\
    \ 6l.toLong))\n    def rollingSum(numbers : List[Long", "        var result =\
    \ List[Long](numbers.size)\n        for (i <- 0 until numbers.size) {\n      \
    \      result = result.update(i, numbers.apply(i).max(_))\n        }\n       \
    \ return result\n    }\n\n    // From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    // in the sequence.\n\
    \    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def rollingMin(numbers\
    \ : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result = result.update(i,\
    \ numbers.apply(i).min(_))\n        }\n        return result\n    }\n\n    //\
    \ From a given list of integers, generate a list of rolling sum of elements found\
    \ until given moment\n    // in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 3l.toLong, 6l.toLong, 6l.toLong, 9l.toLong, 12l.toLong,\
    \ 12l.toLong))\n    def rollingSum(numbers : List[Long]) : List[Long] = {\n  \
    \      var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            result = result.update(i, numbers.apply(i).sum(_))\n        }\n\
    \        return result\n    }\n\n    // From a given list of integers, generate\
    \ a list of rolling product of elements found until given moment\n    // in the\
    \ sequence.\n    // >>> rollingProduct((List[Long](1l", "        var result =\
    \ List[Long](numbers.size)\n        for (i <- 0 until numbers.size - 1) {\n  \
    \          result[i] = _.max(numbers.take(i + 1).toList)\n        }\n        return\
    \ result", "        var result = List[Long](numbers.size)\n        for (i <- 0\
    \ until numbers.size) {\n            var max = numbers[i]\n            for (j\
    \ <- i + 1 until numbers.size) {\n                if (numbers[j] > max) max =\
    \ numbers[j]\n            }\n            result[i] = max\n        }\n        return\
    \ result\n    }\n\n    // From a given list of integers, generate a list of rolling\
    \ minimum element found until given moment\n    // in the sequence.\n    // >>>\
    \ rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def rollingMin(numbers : List[Long])\
    \ : List[Long] = {\n        var result = List[Long](numbers.size)\n        for\
    \ (i <- 0 until numbers.size) {\n            var min = numbers[i]\n          \
    \  for (j <- i + 1 until numbers.size) {\n                if (numbers[j] < min)\
    \ min = numbers[j]\n            }\n            result[i] = min\n        }\n  \
    \      return result\n    }\n\n    // From a given list of integers, generate\
    \ a list of rolling sum found until given moment\n    // in the sequence.\n  \
    \  // >>> rollingSum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 3l.toLong, 6l.toLong,\
    \ 8l.toLong, 9l.toLong, 12l.toLong, 10l.toLong))\n    def rollingSum(numbers :\
    \ List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var sum =", "        var\
    \ result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size) {\n\
    \            result = result.update(i, numbers.apply(i).max)\n        }\n    \
    \    return result", "        val result = mutable.List[Long]()\n        for (i\
    \ <- 0 until numbers.size) {\n            val max = numbers.apply(i).toLong\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers.apply(j).toLong\
    \ > max) {\n                    max = numbers.apply(j).toLong\n              \
    \  }\n            }\n            result = result.append(max)\n        }\n    \
    \    return result", "        var result = List[Long](numbers.size)\n        for\
    \ (i <- 0 until numbers.size) {\n            var max = numbers[i]\n          \
    \  for (j <- i + 1 until numbers.size) {\n                if (numbers[j] > max)\
    \ max = numbers[j]\n            }\n            result[i] = max\n        }\n  \
    \      return result", "        var result = List[Long](numbers.size)\n      \
    \  for (i <- 0 until numbers.size) {\n            var max = numbers[i]\n     \
    \       for (j <- i + 1 until numbers.size) {\n                if (numbers[j]\
    \ > max) max = numbers[j]\n            }\n            result[i] = max\n      \
    \  }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.max(numbers.take(i).toSeq)\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.max(numbers.take(i).toList)\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    //\
    \ in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def\
    \ rollingMin(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.min(numbers.take(i).toList)\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling sum found until given moment\n    // in the sequence.\n\
    \    // >>> rollingSum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 3l.toLong,\
    \ 6l.toLong, 6l.toLong, 9l.toLong, 12l.toLong, 12l.toLong))\n    def rollingSum(numbers\
    \ : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.sum(numbers.take(i).toList)\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling product found until given moment\n    // in the sequence.\n\
    \    // >>> rollingProduct((List[Long](", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.max(numbers.take(i).toSeq)\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    //\
    \ in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def\
    \ rollingMin(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.min(numbers.take(i).toSeq)\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling sum of elements found until given moment\n    //\
    \ in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 6l.toLong, 6l.toLong, 9l.toLong, 12l.toLong, 6l.toLong))\n    def\
    \ rollingSum(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.sum(numbers.take(i).toSeq)\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling product of elements found until given moment\n  \
    \  // in the sequence.\n    // >>>", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result = result.updated(i,\
    \ numbers.apply(i).max(result.apply(i)))\n        }\n        return result", " \
    \       val result = mutable.List[Long]()\n        for (i <- 0 until numbers.size())\
    \ {\n            val max = numbers.apply(i)\n            for (j <- i + 1 until\
    \ numbers.size()) {\n                val candidate = numbers.apply(j)\n      \
    \          if (candidate > max) {\n                    max = candidate\n     \
    \           }\n            }\n            result.append(max)\n        }\n    \
    \    return result", "        var result = List[Long](numbers.size)\n        for\
    \ (i <- 0 until numbers.size) {\n            result[i] = _.max(numbers.take(i).toList)\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    //\
    \ in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def\
    \ rollingMin(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.min(numbers.take(i).toList)\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling sum of elements found until given moment\n    //\
    \ in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 6l.toLong, 6l.toLong, 9l.toLong, 12l.toLong, 6l.toLong))\n    def\
    \ rollingSum(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.sum(numbers.take(i).toList)\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling product of elements found until given moment\n  \
    \  // in the sequence.\n    // >>> rollingProduct((", '        numbers.reduce((a,
    b) -> a > b ? a : b)', "        var result = List[Long](numbers.size)\n      \
    \  for (i <- 0 until numbers.size) {\n            result = result.update(i, numbers.apply(i).max)\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var max = numbers[i]\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers[j]\
    \ > max) {\n                    max = numbers[j]\n                }\n        \
    \    }\n            result[i] = max\n        }\n        return result", "    \
    \    var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            result[i] = _.max(numbers.take(i).toList)\n        }\n      \
    \  return result", "        var result = List[Long](numbers.size)\n        for\
    \ (i <- 0 until numbers.size) {\n            var max = numbers[i]\n          \
    \  for (j <- i + 1 until numbers.size) {\n                if (numbers[j] > max)\
    \ max = numbers[j]\n            }\n            result[i] = max\n        }\n  \
    \      return result", "        var result = List[Long](numbers.size)\n      \
    \  for (i <- 0 until numbers.size) {\n            var max = numbers[i]\n     \
    \       for (j <- i + 1 until numbers.size) {\n                if (numbers[j]\
    \ > max) max = numbers[j]\n            }\n            result[i] = max\n      \
    \  }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result = result.update(i,\
    \ numbers.apply(i).max(_))\n        }\n        return result\n    }\n\n    //\
    \ From a given list of integers, generate a list of rolling minimum element found\
    \ until given moment\n    // in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong))\n    def rollingMin(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            result = result.update(i, numbers.apply(i).min(_))\n        }\n\
    \        return result\n    }\n\n    // From a given list of integers, generate\
    \ a list of rolling sum found until given moment\n    // in the sequence.\n  \
    \  // >>> rollingSum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 3l.toLong, 6l.toLong,\
    \ 9l.toLong, 12l.toLong, 15l.toLong, 18l.toLong))\n    def rollingSum(numbers\
    \ : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result = result.update(i,\
    \ numbers.apply(i).sum(_))\n        }\n        return result\n    }\n\n    //\
    \ From a given list of integers, generate a list of rolling product found until\
    \ given moment\n    // in the sequence.\n    // >>> rollingProduct((List[Long](1l.toLong,",
  "        val result = mutable.List[Long]()\n        for (i <- 0 until numbers.size\
    \ - 1) {\n            val max = numbers.apply(i).toLong\n            for (j <-\
    \ i + 1 until numbers.size) {\n                if (numbers.apply(j).toLong > max)\
    \ {\n                    max = numbers.apply(j).toLong\n                }\n  \
    \          }\n            result = result.append(max)\n        }\n        return\
    \ result", "        val result = mutable.List[Long]()\n        for (i <- 0 until\
    \ numbers.size) {\n            val max = numbers.apply(i).toLong\n           \
    \ for (j <- i + 1 until numbers.size) {\n                if (numbers.apply(j).toLong\
    \ > max) {\n                    max = numbers.apply(j).toLong\n              \
    \  }\n            }\n            result.append(max)\n        }\n        return\
    \ result", "        var result = List[Long](numbers.size())\n        for (i <-\
    \ 0 until numbers.size()) {\n            result = result.update(i, numbers.apply(i).max(result.apply(i)))\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    //\
    \ in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def\
    \ rollingMin(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size())\n\
    \        for (i <- 0 until numbers.size()) {\n            result = result.update(i,\
    \ numbers.apply(i).min(result.apply(i)))\n        }\n        return result\n \
    \   }\n\n    // From a given list of integers, generate a list of rolling sum\
    \ of elements found until given moment\n    // in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 3l.toLong, 6l.toLong, 6l.toLong, 9l.toLong, 12l.toLong,\
    \ 6l.toLong))\n    def rollingSum(numbers : List[Long]) : List[Long] = {\n   \
    \     var result = List[Long](numbers.size())\n        for (i <- 0 until numbers.size())\
    \ {\n            result = result.update(i, numbers.apply(i).sum(result.apply(i)))\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling product of elements found until given moment\n  \
    \  // in the", "        var result = List[Long](numbers.size)\n        for (i\
    \ <- 0 until numbers.size) {\n            var max = numbers[i]\n            for\
    \ (j <- i + 1 until numbers.size) {\n                if (numbers[j] > max) {\n\
    \                    max = numbers[j]\n                }\n            }\n    \
    \        result[i] = max\n        }\n        return result", "        var result\
    \ = mutable.List[Long]()\n        for (i <- 0 until numbers.size) {\n        \
    \    var max = numbers.apply(i)\n            for (j <- i + 1 until numbers.size)\
    \ {\n                if (numbers.apply(j) > max) {\n                    max =\
    \ numbers.apply(j)\n                }\n            }\n            result = result.append(max)\n\
    \        }\n        return result", "        val result = mutable.List[Long]()\n\
    \        for (i <- 0 until numbers.size) {\n            val max = numbers.apply(i)\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers.apply(j)\
    \ > max) {\n                    max = numbers.apply(j)\n                }\n  \
    \          }\n            result.append(max)\n        }\n        return result",
  "        var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            result[i] = _.max(numbers.take(i).toList)\n        }\n      \
    \  return result\n    }\n\n    // From a given list of integers, generate a list\
    \ of rolling minimum element found until given moment\n    // in the sequence.\n\
    \    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def rollingMin(numbers\
    \ : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.min(numbers.take(i).toList)\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling sum of elements found until given moment\n    //\
    \ in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 6l.toLong, 6l.toLong, 9l.toLong, 12l.toLong, 12l.toLong))\n    def\
    \ rollingSum(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.sum(numbers.take(i).toList)\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling product of elements found until given moment\n  \
    \  // in the sequence.\n    // >>> rollingProduct((", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.max(numbers.take(i).toList)\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.max(numbers.take(i).toList)\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result = result.update(i,\
    \ numbers.apply(i).max(result.apply(i)))\n        }\n        return result", " \
    \       var result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size)\
    \ {\n            result[i] = _.max(numbers.take(i).toSeq)\n        }\n       \
    \ return result", "        var result = List[Long](numbers.size)\n        for\
    \ (i <- 0 until numbers.size) {\n            result[i] = _.max(numbers.take(i).toList)\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    //\
    \ in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def\
    \ rollingMin(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.min(numbers.take(i).toList)\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling sum of elements found until given moment\n    //\
    \ in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 6l.toLong, 6l.toLong, 9l.toLong, 12l.toLong, 12l.toLong))\n    def\
    \ rollingSum(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.sum(numbers.take(i).toList)\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling product of elements found until given moment\n  \
    \  // in the sequence.\n    // >>> rollingProduct((", "        val result = mutable.List[Long]()\n\
    \        for (i <- 0 until numbers.size) {\n            val max = numbers.apply(i)\n\
    \            for (j <- i + 1 until numbers.size) {\n                val candidate\
    \ = numbers.apply(j)\n                if (candidate > max) {\n               \
    \     max = candidate\n                }\n            }\n            result.append(max)\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling minimum element found until given moment\n    //\
    \ in the sequence.\n    // >>> rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def\
    \ rollingMin(numbers : List[Long]) : List[Long] = {\n        val result = mutable.List[Long]()\n\
    \        for (i <- 0 until numbers.size) {\n            val min = numbers.apply(i)\n\
    \            for (j <- i + 1 until numbers.size) {\n                val candidate\
    \ = numbers.apply(j)\n                if (candidate < min) {\n               \
    \     min = candidate\n                }\n            }\n            result.append(min)\n\
    \        }\n        return result\n    }\n\n    // From a given list of integers,\
    \ generate a list of rolling sum of elements found until given moment\n    //\
    \ in the sequence.\n    // >>> rollingSum((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 6l.toLong, 8l.toLong, 11l.toLong, 14l.toLong, 16l.toLong))\n    def\
    \ rollingSum(numbers : List[Long]) : List[Long] = {\n        val result = mut",
  "        val result = mutable.List[Long]()\n        for (i <- 0 until numbers.size)\
    \ {\n            val max = numbers.apply(i)\n            for (j <- i + 1 until\
    \ numbers.size) {\n                if (numbers.apply(j) > max) {\n           \
    \         max = numbers.apply(j)\n                }\n            }\n         \
    \   result = result.append(max)\n        }\n        return result", "        var\
    \ result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size) {\n\
    \            result[i] = _.max(numbers.take(i).toList)\n        }\n        return\
    \ result", "        var result = List[Long](numbers.size)\n        for (i <- 0\
    \ until numbers.size) {\n            var max = numbers[i]\n            for (j\
    \ <- i + 1 until numbers.size) {\n                if (numbers[j] > max) max =\
    \ numbers[j]\n            }\n            result[i] = max\n        }\n        return\
    \ result\n    }\n\n    // From a given list of integers, generate a list of rolling\
    \ minimum element found until given moment\n    // in the sequence.\n    // >>>\
    \ rollingMin((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ 2l.toLong, 2l.toLong, 2l.toLong, 2l.toLong))\n    def rollingMin(numbers : List[Long])\
    \ : List[Long] = {\n        var result = List[Long](numbers.size)\n        for\
    \ (i <- 0 until numbers.size) {\n            var min = numbers[i]\n          \
    \  for (j <- i + 1 until numbers.size) {\n                if (numbers[j] < min)\
    \ min = numbers[j]\n            }\n            result[i] = min\n        }\n  \
    \      return result\n    }\n\n    // From a given list of integers, generate\
    \ a list of rolling sum found until given moment\n    // in the sequence.\n  \
    \  // >>> rollingSum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 3l.toLong, 6l.toLong,\
    \ 6l.toLong, 9l.toLong, 12l.toLong, 12l.toLong))\n    def rollingSum(numbers :\
    \ List[Long]) : List[Long] = {\n        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var sum =", "        var\
    \ result = List[Long](numbers.size)\n        for (i <- 0 until numbers.size) {\n\
    \            result[i] = _.max(numbers.take(i).toList)\n        }\n        return\
    \ result", "        val result = mutable.List[Long]()\n        for (i <- 0 until\
    \ numbers.size) {\n            val max = numbers.apply(i).toLong\n           \
    \ for (j <- i + 1 until numbers.size) {\n                val candidate = numbers.apply(j).toLong\n\
    \                if (candidate > max) {\n                    max = candidate\n\
    \                }\n            }\n            result.append(max)\n        }\n\
    \        return result", "        var result = List[Long](numbers.size)\n    \
    \    for (i <- 0 until numbers.size) {\n            result = result.update(i,\
    \ numbers.apply(i).max(result.apply(i)))\n        }\n        return result", " \
    \       var result = List[Long](numbers.size())\n        for (i <- 0 until numbers.size())\
    \ {\n            result = result.updated(i, numbers.apply(i).max(result.apply(i)))\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var max = numbers[i]\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers[j]\
    \ > max) max = numbers[j]\n            }\n            result[i] = max\n      \
    \  }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var max = numbers[i]\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers[j]\
    \ > max) max = numbers[j]\n            }\n            result[i] = max\n      \
    \  }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.max(numbers.take(i).toSeq)\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            result[i] = _.max(numbers.take(i).toSeq)\n\
    \        }\n        return result", "        var result = List[Long](numbers.size)\n\
    \        for (i <- 0 until numbers.size) {\n            var max = numbers[i]\n\
    \            for (j <- i + 1 until numbers.size) {\n                if (numbers[j]\
    \ > max) max = numbers[j]\n            }\n            result[i] = max\n      \
    \  }\n        return result"]
stop_tokens:
- "\n    }\n"
