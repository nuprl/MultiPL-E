{
  "name": "HumanEval_49_modp",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "results": [
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppqmnk7x9.scala:20)\n\tat Problem.main(tmppqmnk7x9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(3l, 6l)\n    // (3l)\n    // >>> gcd(3l, 0l)\n    // (1l)\n    // >>> gcd(0l, 0l)\n    // (0l)\n    // >>> gcd(0l, 3l)\n    // (1l)\n    // >>> gcd(3l, 3l)\n    // (3l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0l) {\n            return b\n        } else if (b == 0l) {\n            return a\n        } else {\n            return gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(3l, 6l)\n    // (18l)\n    // >>> lcm(3l, 0l)\n    // (0l)\n    // >>> lcm(0l, 0l)\n    // (0l)\n    // >>> lcm(0l, 3l)\n    // (0l)\n    // >>> lcm(3l, 3l)\n    // (3l)\n    def lcm(a : Long, b : Long) : Long = {\n        return (a * b) / gcd(a, b)\n    }\n\n    // Return the sum of the squares of the first n natural numbers.\n    // >>> sum_of_squares(5l)\n    // (30l)\n    def sum_of_squares(n : Long) : Long = {\n        n * (n + 1) * (2 * n + 1) / 6\n    }\n\n    // Return the sum of the first n natural numbers.\n    // >>> sum(5l)\n    // (15l)\n    def sum(n : Long) : Long = {\n        n * (n + 1) /\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp6z00f2lx.scala:70:21 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m70 |\u001b[0m        n * (n + \u001b[31m1\u001b[0m) /\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val nn = n.mod(p)\n        if (nn == 0) {\n            nn = p\n        }\n        nn\n    }\n\n    // Return the number of bits in n.\n    // >>> bitcount(3l)\n    // 2\n    // >>> bitcount(0l)\n    // 0\n    // >>> bitcount(-3l)\n    // 2\n    // >>> bitcount(-0l)\n    // 0\n    // >>> bitcount(3l)\n    // 2\n    // >>> bitcount(3l)\n    // 2\n    def bitcount(n : Long) : Long = {\n        val nn = n.bitCount()\n        if (nn == 0) {\n            nn = 1\n        }\n        nn\n    }\n\n    // Return the number of 1's in n.\n    // >>> bitcount(3l)\n    // 2\n    // >>> bitcount(0l)\n    // 0\n    // >>> bitcount(-3l)\n    // 2\n    // >>> bitcount(-0l)\n    // 0\n    // >>> bitcount(3l)\n    // 2\n    // >>> bitcount(3l)\n    // 2\n    def bitcount1(n : Long) : Long = {\n        val nn = n.bitCount()\n        if (nn == 0) {\n            nn = 1\n        }\n        nn\n    }\n\n    // Return the number of 0's in n.\n    // >>> bitcount(3l)\n    // 2\n    // >>> bitcount(0l)\n    // 0\n    // >>> bitcount(-3l)\n    // 2\n    // >>> bitcount(-0l)\n    // 0\n    // >>> bitcount(3l)\n    // 2\n    // >>> bitcount(3l)\n    // 2\n    def bitcount0(n : Long) : Long = {\n        val nn = n.bitCount()\n        if (nn == 0) {\n            nn = 1\n        }\n        nn\n    }\n\n    // Return the number of 1's in n.\n    // >>> bitcount(3l)\n    // 2\n    // >>> bitcount(0l)\n    // 0\n    // >>> bit\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293308,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmppjg3s1kv.scala:103:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m103 |\u001b[0m}\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppjg3s1kv.scala:16:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnn\u001b[0m = n.mod(p)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue mod is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.long2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmppjg3s1kv.scala:18:15 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            nn = p\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val nn\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppjg3s1kv.scala:37:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnn\u001b[0m = n.bitCount()\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue bitCount is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.long2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmppjg3s1kv.scala:39:15 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            nn = \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val nn\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppjg3s1kv.scala:58:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnn\u001b[0m = n.bitCount()\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue bitCount is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0) {\n            0\n        } else if (n < 0) {\n            modp(n + p, p)\n        } else {\n            n % p\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3, 5)\n    // 1\n    // >>> gcd(3, 6)\n    // 3\n    // >>> gcd(6, 9)\n    // 3\n    // >>> gcd(9, 12)\n    // 3\n    // >>> gcd(12, 15)\n    // 3\n    // >>> gcd(15, 18)\n    // 3\n    // >>> gcd(18, 21)\n    // 3\n    // >>> gcd(21, 24)\n    // 3\n    // >>> gcd(24, 27)\n    // 3\n    // >>> gcd(27, 30)\n    // 3\n    // >>> gcd(30, 33)\n    // 3\n    // >>> gcd(33, 36)\n    // 3\n    // >>> gcd(36, 39)\n    // 3\n    // >>> gcd(39, 42)\n    // 3\n    // >>> gcd(42, 45)\n    // 3\n    // >>> gcd(45, 48)\n    // 3\n    // >>> gcd(48, 51)\n    // 3\n    // >>> gcd(51, 54)\n    // 3\n    // >>> gcd(54, 57)\n    // 3\n    // >>> gcd(57, 60)\n    // 3\n    // >>> gcd(60, 63)\n    // 3\n    // >>> gcd(63, 66)\n    // 3\n    // >>> gcd(66, 69)\n    // 3\n    // >>> gcd(69, 72)\n    // 3\n    // >>> gcd(72, 75)\n    // 3\n    // >>> gcd(75, 78)\n    // 3\n    // >>> gcd(78, 81)\n    // 3\n    // >>> gcd(81, 84)\n    // 3\n    // >>> gcd(84, 87)\n    // 3\n    // >>> gcd(87, 90)\n    \n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpk1oyu4qe.scala:97:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m97 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpk1oyu4qe.scala:88:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpk1oyu4qe.scala:89:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m89 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpk1oyu4qe.scala:90:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m90 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpk1oyu4qe.scala:91:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m91 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpk1oyu4qe.scala:92:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpk1oyu4qe.scala:93:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m93 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(3l, 6l)\n    // (3l)\n    // >>> gcd(3l, 0l)\n    // (1l)\n    // >>> gcd(0l, 0l)\n    // (0l)\n    // >>> gcd(0l, 3l)\n    // (3l)\n    // >>> gcd(3l, 3l)\n    // (3l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0l) {\n            return b\n        } else {\n            return gcd(b % a, a)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(3l, 6l)\n    // (18l)\n    // >>> lcm(3l, 0l)\n    // (0l)\n    // >>> lcm(0l, 0l)\n    // (0l)\n    // >>> lcm(0l, 3l)\n    // (0l)\n    // >>> lcm(3l, 3l)\n    // (3l)\n    def lcm(a : Long, b : Long) : Long = {\n        return a * b / gcd(a, b)\n    }\n\n    // Return the sum of the squares of the first n natural numbers.\n    // >>> sum_of_squares(0l)\n    // (0l)\n    // >>> sum_of_squares(1l)\n    // (1l)\n    // >>> sum_of_squares(2l)\n    // (5l)\n    // >>> sum_of_squares(3l)\n    // (14l)\n    def sum_of_squares(n : Long) : Long = {\n        n * (n + 1) / 2\n    }\n\n    // Return the sum of the first n natural numbers.\n    \n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmppr_hpk4r.scala:83:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppr_hpk4r.scala:74:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppr_hpk4r.scala:75:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppr_hpk4r.scala:76:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppr_hpk4r.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppr_hpk4r.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppr_hpk4r.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        return (n % p) + p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(11l, 101l)\n    // (1l)\n    // >>> gcd(0l, 101l)\n    // (101l)\n    // >>> gcd(3l, 11l)\n    // (1l)\n    // >>> gcd(100l, 101l)\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            return b\n        } else {\n            return gcd(b % a, a)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(11l, 101l)\n    // (101l)\n    // >>> lcm(0l, 101l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (3l)\n    // >>> lcm(100l, 101l)\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        return a * b / gcd(a, b)\n    }\n\n    // Return the sum of a and b.\n    // >>> add(3l, 5l)\n    // (8l)\n    // >>> add(11l, 101l)\n    // (112l)\n    // >>> add(0l, 101l)\n    // (101l)\n    // >>> add(3l, 11l)\n    // (14l)\n    // >>> add(100l, 101l)\n    // (101l)\n    def add(a : Long, b : Long) : Long = {\n        return a + b\n    }\n\n    // Return the product of a and b.\n    // >>> mult(3l, 5l)\n    // (15l)\n    // >>> mult(11l, 101l)\n    // (112l)\n    \n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpn1nolpp0.scala:85:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn1nolpp0.scala:76:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn1nolpp0.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn1nolpp0.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn1nolpp0.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn1nolpp0.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn1nolpp0.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0l) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0l) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0l) {\n            return 0l\n        }\n        return (n * (n - 1l) / 2l) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmps54khr7a.scala:32)\n\tat Problem.main(tmps54khr7a.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppqmnk7x9.scala:20)\n\tat Problem.main(tmppqmnk7x9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n < 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p < 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p == 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n * (n - 1) / 2) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp3q70edsv.scala:32)\n\tat Problem.main(tmp3q70edsv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (101l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (101l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            return b\n        } else {\n            return gcd(b % a, a)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (33l)\n    // >>> lcm((100l), (101l))\n    // (101l)\n    def lcm(a : Long, b : Long) : Long = {\n        return a * b / gcd(a, b)\n    }\n\n    // Return the sum of the squares of the digits of n.\n    // >>> sum_of_squares(123456789l)\n    // (1l)\n    // >>> sum_of_squares(0l)\n    // (0l)\n    // >>> sum_of_squares(123456789l)\n    // (1l)\n    def sum_of_squares(n : Long) : Long = {\n        return n * (n + 1) / 2\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sum_of_digits(123456789l)\n    // (9l)\n    // >>> sum_of_digits(0l)\n    // (0l)\n    \n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpmf1vokgb.scala:81:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmf1vokgb.scala:72:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmf1vokgb.scala:73:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmf1vokgb.scala:74:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmf1vokgb.scala:75:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmf1vokgb.scala:76:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmf1vokgb.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val m = n % p\n        if (m < 0) {\n            m += p\n        }\n        return m\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // 1l\n    // >>> gcd(3l, 6l)\n    // 3l\n    // >>> gcd(3l, 0l)\n    // 3l\n    // >>> gcd(0l, 0l)\n    // 0l\n    // >>> gcd(0l, 3l)\n    // 3l\n    // >>> gcd(3l, -3l)\n    // 3l\n    // >>> gcd(-3l, 3l)\n    // 3l\n    // >>> gcd(-3l, -3l)\n    // 1l\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            return a\n        } else {\n            return gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // 15l\n    // >>> lcm(3l, 6l)\n    // 18l\n    // >>> lcm(3l, 0l)\n    // 0l\n    // >>> lcm(0l, 0l)\n    // 0l\n    // >>> lcm(0l, 3l)\n    // 0l\n    // >>> lcm(3l, -3l)\n    // -3l\n    // >>> lcm(-3l, 3l)\n    // -3l\n    // >>> lcm(-3l, -3l)\n    // 0l\n    def lcm(a : Long, b : Long) : Long = {\n        return (a * b) / gcd(a, b)\n    }\n\n    // Return the sum of a and b.\n    // >>> add(3l, 5l)\n    // 8l\n    // >>> add(3l, 6l)\n    // 9l\n    // >>> add(3l, 0l)\n    // 3l\n    // >>> add\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293307,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp1g_eng09.scala:88:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1g_eng09.scala:18:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            m += p\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean m.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1g_eng09.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1g_eng09.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1g_eng09.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1g_eng09.scala:82:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1g_eng09.scala:83:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0l) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0l) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0l) {\n            return 0l\n        }\n        return (n * (n % p)) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293307,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpxxlpd1em.scala:31)\n\tat Problem.main(tmpxxlpd1em.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0) {\n            0l\n        } else {\n            n % p\n        }\n    }\n\n    // Return the number of 1's in the binary representation of n.\n    // >>> countBits(0l)\n    // 0\n    // >>> countBits(1l)\n    // 1\n    // >>> countBits(2l)\n    // 2\n    // >>> countBits(3l)\n    // 2\n    // >>> countBits(4l)\n    // 3\n    // >>> countBits(5l)\n    // 3\n    // >>> countBits(6l)\n    // 4\n    // >>> countBits(7l)\n    // 4\n    // >>> countBits(8l)\n    // 5\n    // >>> countBits(9l)\n    // 5\n    // >>> countBits(10l)\n    // 6\n    // >>> countBits(11l)\n    // 6\n    // >>> countBits(12l)\n    // 7\n    // >>> countBits(13l)\n    // 7\n    // >>> countBits(14l)\n    // 8\n    // >>> countBits(15l)\n    // 8\n    // >>> countBits(16l)\n    // 9\n    // >>> countBits(17l)\n    // 9\n    // >>> countBits(18l)\n    // 10\n    // >>> countBits(19l)\n    // 10\n    // >>> countBits(20l)\n    // 11\n    // >>> countBits(21l)\n    // 11\n    // >>> countBits(22l)\n    // 12\n    // >>> countBits(23l)\n    // 12\n    // >>> countBits(24l)\n    // 13\n    // >>> countBits(25l)\n    // 13\n    // >>> countBits(26l)\n    // 14\n    // >>> countBits(27l)\n    // 14\n    // >>> countBits(28l)\n    // 15\n    // >>> countBits(29l)\n    // 15\n    // >>> countBits(30l)\n    // 16\n    //\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp8hh__9g.scala:98:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m98 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp8hh__9g.scala:89:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m89 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp8hh__9g.scala:90:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m90 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp8hh__9g.scala:91:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m91 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp8hh__9g.scala:92:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp8hh__9g.scala:93:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m93 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp8hh__9g.scala:94:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m94 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppqmnk7x9.scala:20)\n\tat Problem.main(tmppqmnk7x9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val nn = n.mod(p)\n        if (nn.isZero()) nn = p\n        nn\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (101l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        val aa = a.abs()\n        val bb = b.abs()\n        if (aa.equals(bb)) {\n            if (aa.equals(0l)) return bb\n            else return aa\n        }\n        val q = aa.div(bb)\n        val r = aa.mod(bb)\n        if (r.equals(0l)) return bb\n        else return gcd(bb, r)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (11l)\n    // >>> lcm((100l), (101l))\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        val aa = a.abs()\n        val bb = b.abs()\n        if (aa.equals(bb)) {\n            if (aa.equals(0l)) return aa\n            else return aa\n        }\n        val q = aa.div(bb)\n        val r = aa.mod(bb)\n        if (r.equals(0l)) return bb\n        \n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293307,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpto3rnayu.scala:16:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnn\u001b[0m = n.mod(p)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue mod is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.long2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpto3rnayu.scala:17:28 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mif\u001b[0m (nn.isZero()) nn = p\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Reassignment to val nn\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpto3rnayu.scala:33:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36maa\u001b[0m = a.abs()\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 \u001b[33mmethod\u001b[0m \u001b[35mabs\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mRichLong\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpto3rnayu.scala:34:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbb\u001b[0m = b.abs()\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 \u001b[33mmethod\u001b[0m \u001b[35mabs\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mRichLong\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpto3rnayu.scala:57:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36maa\u001b[0m = a.abs()\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 \u001b[33mmethod\u001b[0m \u001b[35mabs\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mRichLong\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Ty",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new RuntimeException(\"Negative number\")\n        }\n        if (p < 0) {\n            throw new RuntimeException(\"Negative number\")\n        }\n        if (p == 0) {\n            throw new RuntimeException(\"Zero modulus\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n * (n % p)) % p\n    }\n\n    // Return the sum of the squares of the first n natural numbers.\n    // >>> sum_of_squares(5)\n    // 55\n    // >>> sum_of_squares(10)\n    // 385\n    // >>> sum_of_squares(100)\n    // 1025\n    def sum_of_squares(n : Int) : Int = {\n        if (n < 0) {\n            throw new RuntimeException(\"Negative number\")\n        }\n        if (n == 0) {\n            return 0\n        }\n        return (n * (n + 1) * (2 * n + 1)) / 6\n    }\n\n    // Return the sum of the squares of the first n natural numbers.\n    // >>> sum_of_cubes(5)\n    // 125\n    // >>> sum_of_cubes(10)\n    // 15125\n    // >>> sum_of_cubes(100)\n    // 15625\n    def sum_of_cubes(n : Int) : Int = {\n        if (n < 0) {\n            throw new RuntimeException(\"Negative number\")\n        }\n        if (n == 0) {\n            return 0\n        }\n        return (n * (n + 1) * (2 * n + 1)) / 6\n    }\n\n    // Return the sum of the first n natural numbers.\n    // >>> sum(5)\n    // 55\n    // >>> sum(10)\n    // 55\n    // >>> sum(100)\n    // 55\n    def sum(n : Int) : Int = {\n        if (n < 0) {\n            throw new RuntimeException(\"Negative number\")\n        }\n        if (n == 0) {\n            return 0\n        }\n        return (n * (n + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpo0hp07j0.scala:80:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val m = n % p\n        if (m < 0) {\n            m += p\n        }\n        return m\n    }\n\n    // Return the number of 1s in the binary representation of n.\n    // >>> count1s(0l)\n    // 0\n    // >>> count1s(1l)\n    // 1\n    // >>> count1s(2l)\n    // 2\n    // >>> count1s(3l)\n    // 3\n    // >>> count1s(4l)\n    // 4\n    // >>> count1s(5l)\n    // 5\n    // >>> count1s(6l)\n    // 6\n    // >>> count1s(7l)\n    // 7\n    // >>> count1s(8l)\n    // 8\n    // >>> count1s(9l)\n    // 9\n    // >>> count1s(10l)\n    // 10\n    // >>> count1s(11l)\n    // 11\n    // >>> count1s(12l)\n    // 12\n    // >>> count1s(13l)\n    // 13\n    // >>> count1s(14l)\n    // 14\n    // >>> count1s(15l)\n    // 15\n    def count1s(n : Long) : Long = {\n        val m = n % 2\n        if (m < 0) {\n            m += 2\n        }\n        return m\n    }\n\n    // Return the number of 0s in the binary representation of n.\n    // >>> count0s(0l)\n    // 0\n    // >>> count0s(1l)\n    // 1\n    // >>> count0s(2l)\n    // 2\n    // >>> count0s(3l)\n    // 3\n    // >>> count0s(4l)\n    // 4\n    // >>> count0s(5l)\n    // 5\n    // >>> count0s(6l)\n    // 6\n    // >>> count0s(7l)\n    // 7\n    // >>> count0s(8l)\n    // 8\n    // >>> count0s(9l)\n    // 9\n    // >>> count0s(10l)\n\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293307,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbp6f321n.scala:98:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m98 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbp6f321n.scala:18:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            m += p\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean m.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbp6f321n.scala:59:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m            m += \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean m.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbp6f321n.scala:89:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m89 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbp6f321n.scala:90:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m90 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbp6f321n.scala:91:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m91 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbp6f321n.scala:92:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compilin",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val nn = n.mod(p)\n        if (nn == 0) {\n            nn = p\n        }\n        return nn\n    }\n\n    // Return the number of 1s in the binary representation of n.\n    // >>> countBits(0l)\n    // 0\n    // >>> countBits(1l)\n    // 1\n    // >>> countBits(2l)\n    // 2\n    // >>> countBits(3l)\n    // 3\n    // >>> countBits(4l)\n    // 3\n    // >>> countBits(5l)\n    // 4\n    // >>> countBits(6l)\n    // 4\n    // >>> countBits(7l)\n    // 5\n    // >>> countBits(8l)\n    // 5\n    // >>> countBits(9l)\n    // 6\n    // >>> countBits(10l)\n    // 6\n    // >>> countBits(11l)\n    // 7\n    // >>> countBits(12l)\n    // 7\n    // >>> countBits(13l)\n    // 8\n    // >>> countBits(14l)\n    // 8\n    // >>> countBits(15l)\n    // 9\n    // >>> countBits(16l)\n    // 9\n    // >>> countBits(17l)\n    // 10\n    // >>> countBits(18l)\n    // 10\n    // >>> countBits(19l)\n    // 11\n    // >>> countBits(20l)\n    // 11\n    // >>> countBits(21l)\n    // 12\n    // >>> countBits(22l)\n    // 12\n    // >>> countBits(23l)\n    // 13\n    // >>> countBits(24l)\n    // 13\n    // >>> countBits(25l)\n    // 14\n    // >>> countBits(26l)\n    // 14\n    // >>> countBits(27l)\n    // 15\n    // >>> countBits(28l)\n    // 15\n    // >>> countBits(29l)\n    // 16\n    // >>> countBits(30l\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293307,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpu66m93xk.scala:96:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m96 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu66m93xk.scala:16:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnn\u001b[0m = n.mod(p)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue mod is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.long2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpu66m93xk.scala:18:15 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            nn = p\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val nn\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpu66m93xk.scala:87:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpu66m93xk.scala:88:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpu66m93xk.scala:89:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m89 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpu66m93xk.scala:90:11 -------------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0l) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0l) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        return (n % p)\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (101l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0l) {\n            throw new IllegalArgumentException(\"a must be >= 0\")\n        }\n        if (b < 0l) {\n            throw new IllegalArgumentException(\"b must be >= 0\")\n        }\n        if (b == 0l) {\n            throw new IllegalArgumentException(\"b must be > 0\")\n        }\n        return (a % b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (3l)\n    // >>> lcm((100l), (101l))\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a < 0l) {\n            throw new IllegalArgumentException(\"a must be >= 0\")\n        }\n        if (b < 0l) {\n            throw new IllegalArgumentException(\"\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293301,
      "stdout": "error while checking \u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[31mnull\u001b[0m)\nerror while checking \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[31mnull\u001b[0m)\nerror while checking {\n  \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[31mnull\u001b[0m)\n}\nerror while checking \u001b[33mif \u001b[0m(b < \u001b[31m0L\u001b[0m) \n  {\n    \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[31mnull\u001b[0m)\n  }\nerror while checking {\n  \u001b[33mif \u001b[0m(a < \u001b[31m0L\u001b[0m) \n    {\n      \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[32m\"a must be >= 0\"\u001b[0m)\n    }\n  \u001b[33mif \u001b[0m(b < \u001b[31m0L\u001b[0m) \n    {\n      \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[31mnull\u001b[0m)\n    }\n  \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = \n    {\n      assert(modp((\u001b[31m3L\u001b[0m), (\u001b[31m5L\u001b[0m)) == (\u001b[31m3L\u001b[0m))\n      assert(modp((\u001b[31m1101L\u001b[0m), (\u001b[31m101L\u001b[0m)) == (\u001b[31m2L\u001b[0m))\n      assert(modp((\u001b[31m0L\u001b[0m), (\u001b[31m101L\u001b[0m)) == (\u001b[31m1L\u001b[0m))\n      assert(modp((\u001b[31m3L\u001b[0m), (\u001b[31m11L\u001b[0m)) == (\u001b[31m8L\u001b[0m))\n      assert(modp((\u001b[31m100L\u001b[0m), (\u001b[31m101L\u001b[0m)) == (\u001b[31m1L\u001b[0m))\n      assert(modp((\u001b[31m30L\u001b[0m), (\u001b[31m5L\u001b[0m)) == (\u001b[31m4L\u001b[0m))\n      assert(modp((\u001b[31m31L\u001b[0m), (\u001b[31m5L\u001b[0m)) == (\u001b[31m3L\u001b[0m))\n    }\n  <empty>\n}\nerror while checking \u001b[33mdef\u001b[0m \u001b[36mlcm\u001b[0m(\u001b[36ma\u001b[0m: \u001b[35mLong\u001b[0m, \u001b[36mb\u001b[0m: \u001b[35mLong\u001b[0m): \u001b[35mLong\u001b[0m = \n  {\n    \u001b[33mif \u001b[0m(a < \u001b[31m0L\u001b[0m) \n      {\n        \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[32m\"a must be >= 0\"\u001b[0m)\n      }\n    \u001b[33mif \u001b[0m(b < \u001b[31m0L\u001b[0m) \n      {\n        \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[31mnull\u001b[0m)\n      }\n    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = \n      {\n        assert(modp((\u001b[31m3L\u001b[0m), (\u001b[31m5L\u001b[0m)) == (\u001b[31m3L\u001b[0m))\n        assert(modp((\u001b[31m1101L\u001b[0m), (\u001b[31m101L\u001b[0m)) == (\u001b[31m2L\u001b[0m))\n        assert(modp((\u001b[31m0L\u001b[0m), (\u001b[31m101L\u001b[0m)) == (\u001b[31m1L\u001b[0m))\n        assert(modp((\u001b[31m3L\u001b[0m), (\u001b[31m11",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpgwap64vo.scala:68:47 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m            \u001b[33mthrow\u001b[0m \u001b[33mnew\u001b[0m \u001b[35mIllegalArgumentException\u001b[0m(\"\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               unclosed string literal\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgwap64vo.scala:81:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\nexception occurred while parser /tmp/tmpgwap64vo.scala\nexception occurred while compiling /tmp/tmpgwap64vo.scala\nException in thread \"main\" java.lang.AssertionError: assertion failed: position error, parent span does not contain child span\nparent      = \u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[31mnull\u001b[0m) # -1,\nparent span = <1770..1800>,\nchild       = \u001b[31mnull\u001b[0m # -1,\nchild span  = [1799..1805..1805]\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:8)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:172)\n\tat dotty.tools.dotc.ast.Positioned.check$1$$anonfun$3(Positioned.scala:202)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)\n\tat scala.collection.immutable.List.foreach(List.scala:333)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:202)\n\tat dotty.tools.dotc.ast.Positioned.checkPos(Positioned.scala:223)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:197)\n\tat dotty.tools.dotc.ast.Positioned.checkPos(Positioned.scala:223)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:197)\n\tat dotty.tools.dotc.ast.Positioned.checkPos(Positioned.scala:223)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:197)\n\tat dotty.tools.dotc.ast.Positioned.checkPos(Positioned.scala:223)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:197)\n\tat dotty.tools.dotc.ast.Positioned.check$1$$anonfun$3(Positioned.scala:202)\n\tat scala.runtime.function.JPro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (p < 0l) {\n            throw new IllegalArgumentException(\"p must be non-negative\")\n        }\n        if (p == 0l) {\n            throw new IllegalArgumentException(\"p must be non-zero\")\n        }\n        return (n % p)\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (101l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0l) {\n            throw new IllegalArgumentException(\"a must be non-negative\")\n        }\n        if (b < 0l) {\n            throw new IllegalArgumentException(\"b must be non-negative\")\n        }\n        if (a == 0l) {\n            return b\n        }\n        if (b == 0l) {\n            return a\n        }\n        return gcd(b, a % b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (11l)\n    // >>> lcm((100l), (101l))\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a < 0l) {\n            throw new IllegalArgumentException(\"a must be non-negative\")\n        }\n        if\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmplyemy5np.scala:70:10 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m70 |\u001b[0m        \u001b[33mif\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0l) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0l) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0l) {\n            return 0l\n        }\n        return (n % p) + (n / p) * (p - 1l)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpfdo7108q.scala:32)\n\tat Problem.main(tmpfdo7108q.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // 5l\n    // >>> gcd(3l, 6l)\n    // 3l\n    // >>> gcd(3l, 0l)\n    // 3l\n    // >>> gcd(0l, 0l)\n    // 0l\n    // >>> gcd(3l, -3l)\n    // 3l\n    // >>> gcd(-3l, 0l)\n    // 3l\n    // >>> gcd(-3l, -3l)\n    // -3l\n    // >>> gcd(-3l, 3l)\n    // 3l\n    // >>> gcd(3l, 3l)\n    // 3l\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            return a\n        } else {\n            return gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // 15l\n    // >>> lcm(3l, 6l)\n    // 18l\n    // >>> lcm(3l, 0l)\n    // 0l\n    // >>> lcm(0l, 0l)\n    // 0l\n    // >>> lcm(3l, -3l)\n    // -3l\n    // >>> lcm(-3l, 0l)\n    // 0l\n    // >>> lcm(-3l, -3l)\n    // -3l\n    // >>> lcm(-3l, 3l)\n    // -3l\n    // >>> lcm(3l, 3l)\n    // 3l\n    def lcm(a : Long, b : Long) : Long = {\n        return a * b / gcd(a, b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // 15l\n    // >>> lcm(3l, 6l)\n    // 18l\n    // >>> lcm\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpmuh_mbr0.scala:86:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmuh_mbr0.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmuh_mbr0.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmuh_mbr0.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmuh_mbr0.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmuh_mbr0.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmuh_mbr0.scala:82:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val nn = n.toInt\n        val pp = p.toInt\n        if (nn < 0) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (pp < 0) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (nn >= pp) {\n            throw new IllegalArgumentException(\"n must be < p\")\n        }\n        val r = nn % pp\n        if (r == 0) {\n            return nn\n        } else {\n            return r\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (1l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        val aa = a.toInt\n        val bb = b.toInt\n        if (aa < 0) {\n            throw new IllegalArgumentException(\"a must be >= 0\")\n        }\n        if (bb < 0) {\n            throw new IllegalArgumentException(\"b must be >= 0\")\n        }\n        if (aa >= bb) {\n            throw new IllegalArgumentException(\"a must be < b\")\n        }\n        val r = aa % bb\n        if (r == 0) {\n            return bb\n        } else {\n            return r\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpujzu9a58.scala:86:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpujzu9a58.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpujzu9a58.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpujzu9a58.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpujzu9a58.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpujzu9a58.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpujzu9a58.scala:82:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppqmnk7x9.scala:20)\n\tat Problem.main(tmppqmnk7x9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val nn = n.mod(p)\n        if (nn == 0) {\n            nn = p\n        }\n        return nn\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(5l, 3l)\n    // (1l)\n    // >>> gcd(5l, 15l)\n    // (5l)\n    // >>> gcd(15l, 5l)\n    // (5l)\n    // >>> gcd(15l, 15l)\n    // (15l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            return b\n        } else {\n            return gcd(b % a, a)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(5l, 3l)\n    // (15l)\n    // >>> lcm(5l, 15l)\n    // (15l)\n    // >>> lcm(15l, 5l)\n    // (15l)\n    // >>> lcm(15l, 15l)\n    // (15l)\n    def lcm(a : Long, b : Long) : Long = {\n        return a * b / gcd(a, b)\n    }\n\n    // Return the sum of the squares of the first n natural numbers.\n    // >>> sum_of_squares(5l)\n    // (30l)\n    // >>> sum_of_squares(10l)\n    // (385l)\n    def sum_of_squares(n : Long) : Long = {\n        return n * (n + 1) * (2 * n + 1) / 6\n    }\n\n    // Return the sum of the first n natural numbers.\n    // >>> sum(5l)\n    // (15l)\n    // >>> sum(10l)\n    // (55l)\n    def sum(n : Long) : Long = {\n        return n * (n + 1) / 2\n    }\n\n    // Return the sum of the first n natural numbers modulo p.\n    // >>> sum_modp(5l\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmptzfrnyse.scala:84:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptzfrnyse.scala:16:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnn\u001b[0m = n.mod(p)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue mod is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.long2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmptzfrnyse.scala:18:15 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            nn = p\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val nn\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptzfrnyse.scala:75:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptzfrnyse.scala:76:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptzfrnyse.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptzfrnyse.scala:78:11 -------------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be non-negative\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be non-zero\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n * (n - 1) / 2) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293307,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpw8qnq1xe.scala:32)\n\tat Problem.main(tmpw8qnq1xe.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n % p == 0) {\n            n\n        } else {\n            n + p - (n % p)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293311,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpfw3i3y0z.scala:23)\n\tat Problem.main(tmpfw3i3y0z.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the sum of the squares of the digits of n.\n    // >>> sumDigitsSquares(12345l)\n    // 15\n    // >>> sumDigitsSquares(123456l)\n    // 16\n    // >>> sumDigitsSquares(1234567l)\n    // 17\n    // >>> sumDigitsSquares(12345678l)\n    // 18\n    // >>> sumDigitsSquares(123456789l)\n    // 19\n    def sumDigitsSquares(n : Long) : Long = {\n        n % 1l\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(12345l)\n    // 5\n    // >>> sumDigits(123456l)\n    // 6\n    // >>> sumDigits(1234567l)\n    // 7\n    // >>> sumDigits(12345678l)\n    // 8\n    // >>> sumDigits(123456789l)\n    // 9\n    def sumDigits(n : Long) : Long = {\n        n % 1l\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(12345l)\n    // 5\n    // >>> sumDigits(123456l)\n    // 6\n    // >>> sumDigits(1234567l)\n    // 7\n    // >>> sumDigits(12345678l)\n    // 8\n    // >>> sumDigits(123456789l)\n    // 9\n    def sumDigits(n : Long) : Long = {\n        n % 1l\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(12345l)\n    // 5\n    // >>> sumDigits(123456l)\n    // 6\n    // >>> sumDigits(1234567l)\n    // 7\n    // >>> sumDigits(12345678l)\n    // 8\n    // >>> sumDigits(123456789l)\n    // 9\n    def sumDigits(n : Long) : Long = {\n        n % 1l\n    }\n\n    // Return the sum of the digits of\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293310,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmplitgnsr9.scala:91:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m91 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E120] Naming Error: /tmp/tmplitgnsr9.scala:60:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36msumDigits\u001b[0m(\u001b[36mn\u001b[0m : \u001b[35mLong\u001b[0m) : \u001b[35mLong\u001b[0m = {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mDouble definition:\n\u001b[31m   |\u001b[0mdef sumDigits(n: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 45 and\n\u001b[31m   |\u001b[0mdef sumDigits(n: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 60\n\u001b[31m   |\u001b[0mhave the same type after erasure.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mConsider adding a @targetName annotation to one of the conflicting definitions\n\u001b[31m   |\u001b[0mfor disambiguation.\n\u001b[31m\u001b[31m-- [E120] Naming Error: /tmp/tmplitgnsr9.scala:75:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36msumDigits\u001b[0m(\u001b[36mn\u001b[0m : \u001b[35mLong\u001b[0m) : \u001b[35mLong\u001b[0m = {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mDouble definition:\n\u001b[31m   |\u001b[0mdef sumDigits(n: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 60 and\n\u001b[31m   |\u001b[0mdef sumDigits(n: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 75\n\u001b[31m   |\u001b[0mhave the same type after erasure.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mConsider adding a @targetName annotation to one of the conflicting definitions\n\u001b[31m   |\u001b[0mfor disambiguation.\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplitgnsr9.scala:82:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplitgnsr9.scala:83:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n % p) + (n / p) * (p - 1l)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293312,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp92x0p05v.scala:32)\n\tat Problem.main(tmp92x0p05v.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new RuntimeException(\"Negative number\")\n        }\n        if (p < 0l) {\n            throw new RuntimeException(\"Negative number\")\n        }\n        if (p == 0l) {\n            throw new RuntimeException(\"Zero modulus\")\n        }\n        return (n % p)\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (101l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (101l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0l) {\n            throw new RuntimeException(\"Negative number\")\n        }\n        if (b < 0l) {\n            throw new RuntimeException(\"Negative number\")\n        }\n        if (a == 0l) {\n            return b\n        }\n        if (b == 0l) {\n            return a\n        }\n        return gcd(b, a % b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (11l)\n    // >>> lcm((100l), (101l))\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a < 0l) {\n            throw new RuntimeException(\"Negative number\")\n        }\n        if (b < 0l) {\n            throw new RuntimeException(\"Negative number\")\n        }\n        if (a == 0l)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293310,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmphmzx_oi4.scala:74:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    'then' expected, but '}' found\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n < 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p < 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p == 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n * n) % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // 5l\n    // >>> gcd(3l, 0l)\n    // 3l\n    // >>> gcd(0l, 0l)\n    // 0l\n    // >>> gcd(3l, -5l)\n    // 5l\n    // >>> gcd(-3l, 5l)\n    // 1l\n    // >>> gcd(-3l, -5l)\n    // 5l\n    // >>> gcd(3l, -5l)\n    // 1l\n    // >>> gcd(-3l, -5l)\n    // 5l\n    // >>> gcd(0l, -5l)\n    // 5l\n    // >>> gcd(-3l, 0l)\n    // 3l\n    // >>> gcd(0l, 0l)\n    // 0l\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a < 0\")\n        }\n        if (b < 0) {\n            throw new IllegalArgumentException(\"b < 0\")\n        }\n        if (a == 0) {\n            return b\n        }\n        if (b == 0) {\n            return a\n        }\n        return gcd(b, a % b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // 15l\n    // >>> lcm(3l, 0l)\n    // 0l\n    // >>> lcm(0l, 0l)\n    // 0l\n    // >>> lcm(3\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293309,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpapz9xhx9.scala:89:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m89 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpapz9xhx9.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpapz9xhx9.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpapz9xhx9.scala:82:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpapz9xhx9.scala:83:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpapz9xhx9.scala:84:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpapz9xhx9.scala:85:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppqmnk7x9.scala:20)\n\tat Problem.main(tmppqmnk7x9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppqmnk7x9.scala:20)\n\tat Problem.main(tmppqmnk7x9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new RuntimeException(\"Negative modulo\")\n        }\n        if (p < 0) {\n            throw new RuntimeException(\"Negative modulo\")\n        }\n        if (p == 0) {\n            throw new RuntimeException(\"Zero modulo\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n % p) + (n / p) * (p - 1l)\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (101l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (101l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new RuntimeException(\"Negative modulo\")\n        }\n        if (b < 0) {\n            throw new RuntimeException(\"Negative modulo\")\n        }\n        if (a == 0) {\n            return b\n        }\n        if (b == 0) {\n            return a\n        }\n        return gcd(b, a % b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (11l)\n    // >>> lcm((100l), (101l))\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new RuntimeException(\"Negative modulo\")\n        }\n        if (b <\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293310,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmph73j3ki6.scala:73:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m        \u001b[33mif\u001b[0m (b <\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n < 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p < 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p == 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n * n) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293312,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpgzbfqbr2.scala:31)\n\tat Problem.main(tmpgzbfqbr2.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0l) {\n            0l\n        } else {\n            (n * 2l) % p\n        }\n    }\n\n    // Return the sum of the squares of the first n natural numbers.\n    // >>> sum_of_squares(5)\n    // 55\n    // >>> sum_of_squares(10)\n    // 385\n    // >>> sum_of_squares(100)\n    // 1025\n    // >>> sum_of_squares(1000)\n    // 1025\n    def sum_of_squares(n : Int) : Int = {\n        if (n == 0) {\n            0\n        } else {\n            (n * n) + sum_of_squares(n - 1)\n        }\n    }\n\n    // Return the sum of the squares of the first n natural numbers.\n    // >>> sum_of_cubes(5)\n    // 125\n    // >>> sum_of_cubes(10)\n    // 15125\n    // >>> sum_of_cubes(100)\n    // 1025\n    // >>> sum_of_cubes(1000)\n    // 1025\n    def sum_of_cubes(n : Int) : Int = {\n        if (n == 0) {\n            0\n        } else {\n            (n * n * n) + sum_of_cubes(n - 1)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293312,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptro30fh1.scala:57)\n\tat Problem.main(tmptro30fh1.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0) {\n            0\n        } else if (n < 0) {\n            modp(-n, p)\n        } else if (n > p) {\n            n % p\n        } else {\n            n\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(5l, 10l)\n    // (5l)\n    // >>> gcd(5l, 15l)\n    // (5l)\n    // >>> gcd(15l, 5l)\n    // (5l)\n    // >>> gcd(0l, 5l)\n    // (5l)\n    // >>> gcd(15l, 0l)\n    // (15l)\n    // >>> gcd(15l, 15l)\n    // (15l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            b\n        } else if (b == 0) {\n            a\n        } else {\n            gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(5l, 10l)\n    // (10l)\n    // >>> lcm(5l, 15l)\n    // (15l)\n    // >>> lcm(15l, 5l)\n    // (15l)\n    // >>> lcm(0l, 5l)\n    // (0l)\n    // >>> lcm(15l, 0l)\n    // (15l)\n    // >>> lcm(15l, 15l)\n    // (15l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            0\n        } else if (b == 0) {\n            0\n        } else {\n            a * b / gcd(a, b)\n        }\n    }\n\n    // Return the sum of the squares of the first n natural numbers.\n    // >>> sum_of_squares(5)\n    // (30l)\n    // >>> sum_of_squares(10)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293310,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp6mk7barv.scala:88:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6mk7barv.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6mk7barv.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6mk7barv.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6mk7barv.scala:82:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6mk7barv.scala:83:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6mk7barv.scala:84:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the sum of the squares of the first n natural numbers.\n    // >>> sum_of_squares(10)\n    // 385\n    // >>> sum_of_squares(100)\n    // 1025\n    // >>> sum_of_squares(1000)\n    // 1365\n    def sum_of_squares(n : Int) : Int = {\n        n * (n + 1) / 2\n    }\n\n    // Return the sum of the squares of the first n natural numbers.\n    // >>> sum_of_cubes(10)\n    // 385\n    // >>> sum_of_cubes(100)\n    // 1025\n    // >>> sum_of_cubes(1000)\n    // 1365\n    def sum_of_cubes(n : Int) : Int = {\n        n * (n + 1) * (n + 2) / 6\n    }\n\n    // Return the sum of the first n natural numbers.\n    // >>> sum(10)\n    // 55\n    // >>> sum(100)\n    // 265\n    def sum(n : Int) : Int = {\n        n * (n + 1) / 2\n    }\n\n    // Return the sum of the first n natural numbers.\n    // >>> sum_of_squares(10)\n    // 385\n    // >>> sum_of_squares(100)\n    // 1025\n    // >>> sum_of_squares(1000)\n    // 1365\n    def sum_of_squares(n : Int) : Int = {\n        n * (n + 1) / 2\n    }\n\n    // Return the sum of the first n natural numbers.\n    // >>> sum_of_cubes(10)\n    // 385\n    // >>> sum_of_cubes(100)\n    // 1025\n    // >>> sum_of_cubes(1000)\n    // 1365\n    def sum_of_cubes(n : Int) : Int = {\n        n * (n + 1) * (n + 2) / 6\n    }\n\n    // Return the sum of the first n natural numbers.\n    // >>> sum_of_squares(10)\n    // 385\n\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293311,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpn_by0b8c.scala:87:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E120] Naming Error: /tmp/tmpn_by0b8c.scala:57:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36msum_of_squares\u001b[0m(\u001b[36mn\u001b[0m : \u001b[35mInt\u001b[0m) : \u001b[35mInt\u001b[0m = {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mDouble definition:\n\u001b[31m   |\u001b[0mdef sum_of_squares(n: Int): Int in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 26 and\n\u001b[31m   |\u001b[0mdef sum_of_squares(n: Int): Int in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 57\n\u001b[31m   |\u001b[0mhave the same type after erasure.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mConsider adding a @targetName annotation to one of the conflicting definitions\n\u001b[31m   |\u001b[0mfor disambiguation.\n\u001b[31m\u001b[31m-- [E120] Naming Error: /tmp/tmpn_by0b8c.scala:68:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36msum_of_cubes\u001b[0m(\u001b[36mn\u001b[0m : \u001b[35mInt\u001b[0m) : \u001b[35mInt\u001b[0m = {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mDouble definition:\n\u001b[31m   |\u001b[0mdef sum_of_cubes(n: Int): Int in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 37 and\n\u001b[31m   |\u001b[0mdef sum_of_cubes(n: Int): Int in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 68\n\u001b[31m   |\u001b[0mhave the same type after erasure.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mConsider adding a @targetName annotation to one of the conflicting definitions\n\u001b[31m   |\u001b[0mfor disambiguation.\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn_by0b8c.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn_by0b8c.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: mod",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0) {\n            0\n        } else if (n < 0) {\n            modp(-n, p)\n        } else {\n            n % p\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(11l, 101l)\n    // (1l)\n    // >>> gcd(0l, 101l)\n    // (101l)\n    // >>> gcd(3l, 11l)\n    // (1l)\n    // >>> gcd(100l, 101l)\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            b\n        } else if (b == 0) {\n            a\n        } else {\n            gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(11l, 101l)\n    // (101l)\n    // >>> lcm(0l, 101l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (33l)\n    // >>> lcm(100l, 101l)\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            0\n        } else if (b == 0) {\n            0\n        } else {\n            a * b / gcd(a, b)\n        }\n    }\n\n    // Return the sum of the squares of the first n natural numbers.\n    // >>> sum_of_squares(0)\n    // (0l)\n    // >>> sum_of_squares(1)\n    // (1l)\n    // >>> sum_of_squares(2)\n    // (5l)\n    // >>> sum_of_squares(3)\n    // (14l)\n    def sum_of_\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293310,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E019] Syntax Error: /tmp/tmpf6ab4wkz.scala:76:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36msum_of_\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               Missing return type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpf6ab4wkz.scala:88:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf6ab4wkz.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf6ab4wkz.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf6ab4wkz.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf6ab4wkz.scala:82:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf6ab4wkz.scala:83:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new java.lang.IllegalArgumentException(\"n < 0\")\n        }\n        if (p < 0) {\n            throw new java.lang.IllegalArgumentException(\"p < 0\")\n        }\n        if (p == 0) {\n            throw new java.lang.IllegalArgumentException(\"p == 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n * (n - 1)) % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(11l, 101l)\n    // (1l)\n    // >>> gcd(0l, 101l)\n    // (101l)\n    // >>> gcd(3l, 11l)\n    // (1l)\n    // >>> gcd(100l, 101l)\n    // (101l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new java.lang.IllegalArgumentException(\"a < 0\")\n        }\n        if (b < 0) {\n            throw new java.lang.IllegalArgumentException(\"b < 0\")\n        }\n        if (a == 0) {\n            return b\n        }\n        if (b == 0) {\n            return a\n        }\n        return gcd(b, a % b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(11l, 101l)\n    // (101l)\n    // >>> lcm(0l, 101l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (3l)\n    // >>> lcm(100l, 101l)\n    // (101l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new java.lang.Illegal\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293316,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpty3a9l99.scala:84:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpty3a9l99.scala:71:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m            \u001b[33mthrow\u001b[0m \u001b[33mnew\u001b[0m java.lang.Illegal\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      type Illegal is not a member of java.lang\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpty3a9l99.scala:83:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpty3a9l99.scala:73:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m73 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the number of bits set in a long.\n    // >>> countBits(0l)\n    // 0\n    // >>> countBits(1l)\n    // 1\n    // >>> countBits(2l)\n    // 2\n    // >>> countBits(3l)\n    // 2\n    // >>> countBits(4l)\n    // 3\n    // >>> countBits(5l)\n    // 3\n    // >>> countBits(6l)\n    // 4\n    // >>> countBits(7l)\n    // 4\n    // >>> countBits(8l)\n    // 5\n    // >>> countBits(9l)\n    // 5\n    // >>> countBits(10l)\n    // 6\n    // >>> countBits(11l)\n    // 6\n    // >>> countBits(12l)\n    // 7\n    // >>> countBits(13l)\n    // 7\n    // >>> countBits(14l)\n    // 8\n    // >>> countBits(15l)\n    // 8\n    // >>> countBits(16l)\n    // 9\n    // >>> countBits(17l)\n    // 9\n    // >>> countBits(18l)\n    // 10\n    // >>> countBits(19l)\n    // 10\n    // >>> countBits(20l)\n    // 11\n    // >>> countBits(21l)\n    // 11\n    // >>> countBits(22l)\n    // 12\n    // >>> countBits(23l)\n    // 12\n    // >>> countBits(24l)\n    // 13\n    // >>> countBits(25l)\n    // 13\n    // >>> countBits(26l)\n    // 14\n    // >>> countBits(27l)\n    // 14\n    // >>> countBits(28l)\n    // 15\n    // >>> countBits(29l)\n    // 15\n    // >>> countBits(30l)\n    // 16\n    // >>> countBits(31l)\n    // 16\n    // >>> countBits(32l)\n\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293312,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbxi3ed11.scala:97:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m97 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbxi3ed11.scala:88:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbxi3ed11.scala:89:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m89 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbxi3ed11.scala:90:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m90 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbxi3ed11.scala:91:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m91 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbxi3ed11.scala:92:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbxi3ed11.scala:93:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m93 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val m = n % p\n        if (m < 0) {\n            m += p\n        }\n        return m\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (101l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        val aa = a\n        val bb = b\n        if (aa < 0) {\n            aa = -aa\n        }\n        if (bb < 0) {\n            bb = -bb\n        }\n        if (aa == 0) {\n            return bb\n        }\n        if (bb == 0) {\n            return aa\n        }\n        val r = gcd(bb, aa % bb)\n        return r\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (3l)\n    // >>> lcm((100l), (101l))\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        val aa = a\n        val bb = b\n        if (aa < 0) {\n            aa = -aa\n        }\n        if (bb < 0) {\n            bb = -bb\n        }\n        if (aa == 0) {\n            return bb\n        }\n        if (bb == 0) {\n            return aa\n        }\n        val r = lcm(bb, aa % b\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293317,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpk0a6g4_v.scala:80:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpk0a6g4_v.scala:18:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            m += p\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean m.!=?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpk0a6g4_v.scala:38:15 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            aa = -aa\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val aa\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpk0a6g4_v.scala:41:15 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m            bb = -bb\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val bb\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpk0a6g4_v.scala:68:15 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m            aa = -aa\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val aa\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpk0a6g4_v.scala:71:15 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m            bb = -bb\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val bb\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk0a6g4_v.scala:80:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n7 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the number of bits set in n.\n    // >>> countBits(0l)\n    // 0\n    // >>> countBits(1l)\n    // 1\n    // >>> countBits(2l)\n    // 2\n    // >>> countBits(3l)\n    // 2\n    // >>> countBits(4l)\n    // 3\n    // >>> countBits(5l)\n    // 3\n    // >>> countBits(6l)\n    // 4\n    // >>> countBits(7l)\n    // 4\n    // >>> countBits(8l)\n    // 5\n    // >>> countBits(9l)\n    // 5\n    // >>> countBits(10l)\n    // 6\n    // >>> countBits(11l)\n    // 6\n    // >>> countBits(12l)\n    // 7\n    // >>> countBits(13l)\n    // 7\n    // >>> countBits(14l)\n    // 8\n    // >>> countBits(15l)\n    // 8\n    // >>> countBits(16l)\n    // 9\n    // >>> countBits(17l)\n    // 9\n    // >>> countBits(18l)\n    // 10\n    // >>> countBits(19l)\n    // 10\n    // >>> countBits(20l)\n    // 11\n    // >>> countBits(21l)\n    // 11\n    // >>> countBits(22l)\n    // 12\n    // >>> countBits(23l)\n    // 12\n    // >>> countBits(24l)\n    // 13\n    // >>> countBits(25l)\n    // 13\n    // >>> countBits(26l)\n    // 14\n    // >>> countBits(27l)\n    // 14\n    // >>> countBits(28l)\n    // 15\n    // >>> countBits(29l)\n    // 15\n    // >>> countBits(30l)\n    // 16\n    // >>> countBits(31l)\n    // 16\n    // >>> countBits(32l)\n    \n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293312,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp1siwote1.scala:97:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m97 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1siwote1.scala:88:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1siwote1.scala:89:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m89 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1siwote1.scala:90:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m90 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1siwote1.scala:91:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m91 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1siwote1.scala:92:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1siwote1.scala:93:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m93 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val m = n % p\n        if (m < 0) {\n            m += p\n        }\n        return m\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // 1l\n    // >>> gcd(11l, 101l)\n    // 101l\n    // >>> gcd(0l, 101l)\n    // 1l\n    // >>> gcd(3l, 11l)\n    // 1l\n    // >>> gcd(100l, 101l)\n    // 101l\n    def gcd(a : Long, b : Long) : Long = {\n        val t = a % b\n        if (t == 0) {\n            return b\n        } else {\n            return gcd(b, t)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // 15l\n    // >>> lcm(11l, 101l)\n    // 101l\n    // >>> lcm(0l, 101l)\n    // 0l\n    // >>> lcm(3l, 11l)\n    // 3l\n    // >>> lcm(100l, 101l)\n    // 100l\n    def lcm(a : Long, b : Long) : Long = {\n        val t = a * b / gcd(a, b)\n        return t\n    }\n\n    // Return the sum of the squares of the numbers in the list.\n    // >>> sumOfSquares([1, 2, 3])\n    // 14l\n    // >>> sumOfSquares([1, 2, 3, 4])\n    // 30l\n    def sumOfSquares(xs : List[Long]) : Long = {\n        val t = 0l\n        for (x <- xs) {\n            t += x * x\n        }\n        return t\n    }\n\n    // Return the sum of the squares of the numbers in the list.\n    // >>> sumOfSquares([1, 2, 3, 4])\n    // 30l\n    // >>> sumOfSquares([1, 2, 3, 4, 5])\n    // 55l\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293317,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp67f88tfy.scala:88:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp67f88tfy.scala:18:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            m += p\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean m.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp67f88tfy.scala:67:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m            t += x * x\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean t.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp67f88tfy.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp67f88tfy.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp67f88tfy.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp67f88tfy.scala:82:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling wit",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0) {\n            0l\n        } else {\n            n % p\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(11l, 101l)\n    // (1l)\n    // >>> gcd(0l, 101l)\n    // (101l)\n    // >>> gcd(3l, 11l)\n    // (1l)\n    // >>> gcd(100l, 101l)\n    // (101l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            b\n        } else {\n            gcd(b % a, a)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(11l, 101l)\n    // (101l)\n    // >>> lcm(0l, 101l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (33l)\n    // >>> lcm(100l, 101l)\n    // (101l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            0l\n        } else {\n            a * b / gcd(a, b)\n        }\n    }\n\n    // Return the sum of the squares of the first n natural numbers.\n    // >>> sum_of_squares(0)\n    // (0l)\n    // >>> sum_of_squares(1)\n    // (1l)\n    // >>> sum_of_squares(2)\n    // (5l)\n    // >>> sum_of_squares(3)\n    // (14l)\n    def sum_of_squares(n : Long) : Long = {\n        if (n == 0) {\n            0l\n        } else {\n            n * n\n        }\n    }\n\n    // Return the sum\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293313,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp83y6wr2_.scala:90:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m90 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp83y6wr2_.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp83y6wr2_.scala:82:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp83y6wr2_.scala:83:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp83y6wr2_.scala:84:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp83y6wr2_.scala:85:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp83y6wr2_.scala:86:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new RuntimeException(\"Negative number\")\n        }\n        if (p < 0l) {\n            throw new RuntimeException(\"Negative number\")\n        }\n        if (p == 0l) {\n            throw new RuntimeException(\"Zero modulus\")\n        }\n        return (n % p)\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((2l), (3l))\n    // (1l)\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((0l), (1l))\n    // (1l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0l) {\n            throw new RuntimeException(\"Negative number\")\n        }\n        if (b < 0l) {\n            throw new RuntimeException(\"Negative number\")\n        }\n        if (a == 0l) {\n            return b\n        }\n        if (b == 0l) {\n            return a\n        }\n        return gcd(b, a % b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((2l), (3l))\n    // (6l)\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((0l), (1l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (33l)\n    // >>> lcm((100l), (101l))\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a < 0l) {\n            throw new RuntimeException(\"Negative number\")\n        }\n        if (b < 0l) {\n            throw new RuntimeException(\"Negative number\")\n        }\n        if (a == 0l) {\n\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293317,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbjn6vu_r.scala:87:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbjn6vu_r.scala:86:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpbjn6vu_r.scala:76:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m76 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0) {\n            0l\n        } else {\n            n % p\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (101l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (101l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            b\n        } else {\n            gcd(b % a, a)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (33l)\n    // >>> lcm((100l), (101l))\n    // (101l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            0l\n        } else {\n            a * (b / gcd(a, b))\n        }\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(123l)\n    // 6\n    // >>> sumDigits(1234l)\n    // 10\n    // >>> sumDigits(12345l)\n    // 15\n    def sumDigits(n : Long) : Long = {\n        if (n == 0) {\n            0l\n        } else {\n            n % 10 + sumDigits(n / 10)\n        }\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(123l)\n\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293313,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpell6ys5z.scala:90:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m90 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpell6ys5z.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpell6ys5z.scala:82:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpell6ys5z.scala:83:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpell6ys5z.scala:84:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpell6ys5z.scala:85:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpell6ys5z.scala:86:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(3l, 0l)\n    // (3l)\n    // >>> gcd(0l, 0l)\n    // (0l)\n    // >>> gcd(0l, 3l)\n    // (3l)\n    // >>> gcd(3l, 3l)\n    // (3l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            a\n        } else {\n            gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(3l, 0l)\n    // (0l)\n    // >>> lcm(0l, 0l)\n    // (0l)\n    // >>> lcm(0l, 3l)\n    // (0l)\n    // >>> lcm(3l, 3l)\n    // (3l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            a\n        } else {\n            lcm(b, a / b) * b\n        }\n    }\n\n    // Return the sum of a and b.\n    // >>> add(3l, 5l)\n    // (8l)\n    // >>> add(3l, 0l)\n    // (3l)\n    // >>> add(0l, 0l)\n    // (0l)\n    // >>> add(0l, 3l)\n    // (3l)\n    // >>> add(3l, 3l)\n    // (6l)\n    def add(a : Long, b : Long) : Long = {\n        a + b\n    }\n\n    // Return the product of a and b.\n    // >>> mul(3l, 5l)\n    // (15l)\n    // >>> mul(3l\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293313,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmprw4ee1ar.scala:87:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprw4ee1ar.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprw4ee1ar.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprw4ee1ar.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprw4ee1ar.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprw4ee1ar.scala:82:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprw4ee1ar.scala:83:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val nn = n.toInt\n        val pp = p.toInt\n        if (nn < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (pp < 0) {\n            throw new IllegalArgumentException(\"p must be non-negative\")\n        }\n        if (nn == 0) {\n            return 0l\n        }\n        if (pp == 0) {\n            return 1l\n        }\n        if (nn == 1) {\n            return n\n        }\n        if (nn == 2) {\n            return (n * n) % pp\n        }\n        if (nn % 2 == 0) {\n            return (n * n * n) % pp\n        } else {\n            return (n * n * n * n) % pp\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293316,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpl00zb_u1.scala:43)\n\tat Problem.main(tmpl00zb_u1.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val nn = n.toInt\n        val pp = p.toInt\n        if (nn < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (pp < 0) {\n            throw new IllegalArgumentException(\"p must be non-negative\")\n        }\n        if (nn >= pp) {\n            throw new IllegalArgumentException(\"n must be less than p\")\n        }\n        val r = nn % pp\n        if (r < 0) {\n            r += pp\n        }\n        return r\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(5l, 10l)\n    // (5l)\n    // >>> gcd(5l, 0l)\n    // (5l)\n    // >>> gcd(0l, 0l)\n    // (0l)\n    // >>> gcd(5l, -5l)\n    // (5l)\n    // >>> gcd(-5l, 5l)\n    // (5l)\n    // >>> gcd(-5l, -5l)\n    // (5l)\n    // >>> gcd(5l, -5l)\n    // (5l)\n    // >>> gcd(-5l, 5l)\n    // (5l)\n    // >>> gcd(-5l, -5l)\n    // (5l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            return b\n        }\n        if (b == 0) {\n            return a\n        }\n        if (a < 0) {\n            a = -a\n        }\n        if (b < 0) {\n            b = -b\n        }\n        if (a < b) {\n            a, b = b, a\n        }\n        while (b != 0) {\n            val r = a % b\n            a = b\n            b = r\n        }\n        return a\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(5l, 10l)\n    // (50l)\n\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293317,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpf4b7_ihq.scala:67:13 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m            a, b = b, a\n\u001b[31m\u001b[31m   |\u001b[0m             ^\u001b[0m\n\u001b[31m   |\u001b[0m             end of statement expected but ',' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpf4b7_ihq.scala:92:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpf4b7_ihq.scala:29:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            r += pp\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean r.!=?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpf4b7_ihq.scala:61:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m            a = -a\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val a\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpf4b7_ihq.scala:64:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m            b = -b\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val b\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpf4b7_ihq.scala:71:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m            a = b\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val a\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpf4b7_ihq.scala:72:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m            b = r\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val b\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf4b7_ihq.scala:83:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m))",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the number of 1s in the binary representation of n.\n    // >>> countBits(3l)\n    // 2\n    // >>> countBits(0l)\n    // 0\n    // >>> countBits(1l)\n    // 1\n    // >>> countBits(2l)\n    // 2\n    // >>> countBits(3l)\n    // 2\n    // >>> countBits(4l)\n    // 3\n    // >>> countBits(5l)\n    // 4\n    // >>> countBits(6l)\n    // 5\n    // >>> countBits(7l)\n    // 6\n    // >>> countBits(8l)\n    // 7\n    // >>> countBits(9l)\n    // 8\n    // >>> countBits(10l)\n    // 9\n    // >>> countBits(11l)\n    // 10\n    // >>> countBits(12l)\n    // 11\n    // >>> countBits(13l)\n    // 12\n    // >>> countBits(14l)\n    // 13\n    // >>> countBits(15l)\n    // 14\n    // >>> countBits(16l)\n    // 15\n    // >>> countBits(17l)\n    // 16\n    // >>> countBits(18l)\n    // 17\n    // >>> countBits(19l)\n    // 18\n    // >>> countBits(20l)\n    // 19\n    // >>> countBits(21l)\n    // 20\n    // >>> countBits(22l)\n    // 21\n    // >>> countBits(23l)\n    // 22\n    // >>> countBits(24l)\n    // 23\n    // >>> countBits(25l)\n    // 24\n    // >>> countBits(26l)\n    // 25\n    // >>> countBits(27l)\n    // 26\n    // >>> countBits(28l)\n    // 27\n    // >>> countBits(29l)\n    // 28\n    // >>> countBits(30l)\n    // 29\n    // >>> countBits(31\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293313,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpitddpxwd.scala:96:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m96 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpitddpxwd.scala:87:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpitddpxwd.scala:88:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpitddpxwd.scala:89:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m89 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpitddpxwd.scala:90:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m90 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpitddpxwd.scala:91:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m91 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpitddpxwd.scala:92:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be non-negative\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be non-zero\")\n        }\n        return (n * 2l) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293319,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpwv4_nzeu.scala:28)\n\tat Problem.main(tmpwv4_nzeu.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new java.lang.IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0l) {\n            throw new java.lang.IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0l) {\n            throw new java.lang.IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0l) {\n            return 0l\n        }\n        return (n * (n - 1l) / 2l) % p\n    }\n\n    // Return the number of bits set in n.\n    // >>> countBits(0l)\n    // 0\n    // >>> countBits(1l)\n    // 1\n    // >>> countBits(2l)\n    // 2\n    // >>> countBits(3l)\n    // 2\n    // >>> countBits(4l)\n    // 3\n    // >>> countBits(5l)\n    // 3\n    // >>> countBits(6l)\n    // 4\n    // >>> countBits(7l)\n    // 4\n    // >>> countBits(8l)\n    // 5\n    // >>> countBits(9l)\n    // 5\n    // >>> countBits(10l)\n    // 6\n    // >>> countBits(11l)\n    // 6\n    // >>> countBits(12l)\n    // 7\n    // >>> countBits(13l)\n    // 7\n    // >>> countBits(14l)\n    // 8\n    // >>> countBits(15l)\n    // 8\n    // >>> countBits(16l)\n    // 9\n    // >>> countBits(17l)\n    // 9\n    // >>> countBits(18l)\n    // 10\n    // >>> countBits(19l)\n    // 10\n    // >>> countBits(20l)\n    // 11\n    // >>> countBits(21l)\n    // 11\n    // >>> countBits(22l)\n    // 12\n    // >>> countBits(23l)\n    // 12\n    //\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293316,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpyyxvot7e.scala:92:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyyxvot7e.scala:83:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyyxvot7e.scala:84:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyyxvot7e.scala:85:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyyxvot7e.scala:86:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyyxvot7e.scala:87:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyyxvot7e.scala:88:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0) {\n            return 0l\n        } else {\n            return (n % p) + (n / p) * p\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293319,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpohr_wxge.scala:24)\n\tat Problem.main(tmpohr_wxge.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be non-negative\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be non-zero\")\n        }\n        return (n % p) + (n / p) * p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293319,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpx7e42d6q.scala:29)\n\tat Problem.main(tmpx7e42d6q.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(3l, 6l)\n    // (3l)\n    // >>> gcd(3l, 0l)\n    // (3l)\n    // >>> gcd(0l, 0l)\n    // (0l)\n    // >>> gcd(3l, -3l)\n    // (1l)\n    // >>> gcd(-3l, 3l)\n    // (3l)\n    // >>> gcd(-3l, -3l)\n    // (3l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            a\n        } else {\n            gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(3l, 6l)\n    // (18l)\n    // >>> lcm(3l, 0l)\n    // (0l)\n    // >>> lcm(0l, 0l)\n    // (0l)\n    // >>> lcm(3l, -3l)\n    // (-3l)\n    // >>> lcm(-3l, 3l)\n    // (-3l)\n    // >>> lcm(-3l, -3l)\n    // (0l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            a\n        } else {\n            lcm(b, a / b) * b\n        }\n    }\n\n    // Return the sum of the squares of the first n natural numbers.\n    // >>> sum_of_squares(5)\n    // (30l)\n    // >>> sum_of_squares(0)\n    // (0l)\n    def sum_of_squares(n : Long) : Long = {\n        n * (n + 1) / 2\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293319,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptnqccfjg.scala:75)\n\tat Problem.main(tmptnqccfjg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0l) {\n            0l\n        } else {\n            n % p\n        }\n    }\n\n    // Return the greatest common divisor of two numbers.\n    // >>> gcd(3l, 5l)\n    // 1l\n    // >>> gcd(11l, 101l)\n    // 101l\n    // >>> gcd(0l, 101l)\n    // 101l\n    // >>> gcd(3l, 11l)\n    // 1l\n    // >>> gcd(100l, 101l)\n    // 101l\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0l) {\n            b\n        } else {\n            gcd(b % a, a)\n        }\n    }\n\n    // Return the least common multiple of two numbers.\n    // >>> lcm(3l, 5l)\n    // 15l\n    // >>> lcm(11l, 101l)\n    // 101l\n    // >>> lcm(0l, 101l)\n    // 1l\n    // >>> lcm(3l, 11l)\n    // 11l\n    // >>> lcm(100l, 101l)\n    // 101l\n    def lcm(a : Long, b : Long) : Long = {\n        if (a == 0l) {\n            b\n        } else {\n            lcm(b / a, a)\n        }\n    }\n\n    // Return the greatest common divisor of a list of numbers.\n    // >>> gcd([3l, 5l, 11l])\n    // 1l\n    // >>> gcd([11l, 101l, 0l])\n    // 101l\n    // >>> gcd([0l, 101l, 0l])\n    // 1l\n    // >>> gcd([3l, 11l, 0l])\n    // 1l\n    // >>> gcd([100l, 101l, 0l])\n    // 101l\n    def gcd_list(numbers : List[Long]) : Long = {\n        if (numbers.length == 0) {\n            0l\n        } else {\n            gcd_list(numbers.\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293320,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0b1e_1ge.scala:77:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0b1e_1ge.scala:89:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m89 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0b1e_1ge.scala:88:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmp0b1e_1ge.scala:78:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m78 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new IllegalArgumentException(\"n must be a non-negative number\")\n        }\n        if (p < 0l) {\n            throw new IllegalArgumentException(\"p must be a non-negative number\")\n        }\n        if (p == 0l) {\n            throw new IllegalArgumentException(\"p must be a non-zero number\")\n        }\n        if (n == 0l) {\n            return 0l\n        }\n        return (n * (n - 1l)) % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (1l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0l) {\n            throw new IllegalArgumentException(\"a must be a non-negative number\")\n        }\n        if (b < 0l) {\n            throw new IllegalArgumentException(\"b must be a non-negative number\")\n        }\n        if (a == 0l) {\n            return b\n        }\n        if (b == 0l) {\n            return a\n        }\n        return gcd(b, a % b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (11l)\n    // >>> lcm((100l), (101l))\n    // (100l)\n    def lcm(a : Long, b : Long) : Long\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293318,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp1vivkn81.scala:81:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E067] Syntax Error: /tmp/tmp1vivkn81.scala:69:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mlcm\u001b[0m(\u001b[36ma\u001b[0m : \u001b[35mLong\u001b[0m, \u001b[36mb\u001b[0m : \u001b[35mLong\u001b[0m) : \u001b[35mLong\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mDeclaration of \u001b[33mmethod\u001b[0m \u001b[35mlcm\u001b[0m not allowed here: only classes can have declared but undefined members\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1vivkn81.scala:72:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1vivkn81.scala:73:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1vivkn81.scala:74:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1vivkn81.scala:75:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1vivkn81.scala:76:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(12345l)\n    // 15\n    // >>> sumDigits(123456789l)\n    // 18\n    // >>> sumDigits(1234567890123456789l)\n    // 18\n    def sumDigits(n : Long) : Long = {\n        n % 10\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(12345l)\n    // 15\n    // >>> sumDigits(123456789l)\n    // 18\n    // >>> sumDigits(1234567890123456789l)\n    // 18\n    def sumDigits(n : Long) : Long = {\n        n % 10\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(12345l)\n    // 15\n    // >>> sumDigits(123456789l)\n    // 18\n    // >>> sumDigits(1234567890123456789l)\n    // 18\n    def sumDigits(n : Long) : Long = {\n        n % 10\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(12345l)\n    // 15\n    // >>> sumDigits(123456789l)\n    // 18\n    // >>> sumDigits(1234567890123456789l)\n    // 18\n    def sumDigits(n : Long) : Long = {\n        n % 10\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(12345l)\n    // 15\n    // >>> sumDigits(123456789l)\n    // 18\n    // >>> sumDigits(1234567890123456789l)\n    // 18\n    def sumDigits(n : Long) : Long = {\n        n % 10\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(12345l)\n    // 15\n    // >>> sumDigits(123456789l)\n    //\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293318,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbvxc2vx_.scala:90:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m90 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E120] Naming Error: /tmp/tmpbvxc2vx_.scala:37:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36msumDigits\u001b[0m(\u001b[36mn\u001b[0m : \u001b[35mLong\u001b[0m) : \u001b[35mLong\u001b[0m = {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mDouble definition:\n\u001b[31m   |\u001b[0mdef sumDigits(n: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 26 and\n\u001b[31m   |\u001b[0mdef sumDigits(n: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 37\n\u001b[31m   |\u001b[0mhave the same type after erasure.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mConsider adding a @targetName annotation to one of the conflicting definitions\n\u001b[31m   |\u001b[0mfor disambiguation.\n\u001b[31m\u001b[31m-- [E120] Naming Error: /tmp/tmpbvxc2vx_.scala:48:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36msumDigits\u001b[0m(\u001b[36mn\u001b[0m : \u001b[35mLong\u001b[0m) : \u001b[35mLong\u001b[0m = {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mDouble definition:\n\u001b[31m   |\u001b[0mdef sumDigits(n: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 37 and\n\u001b[31m   |\u001b[0mdef sumDigits(n: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 48\n\u001b[31m   |\u001b[0mhave the same type after erasure.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mConsider adding a @targetName annotation to one of the conflicting definitions\n\u001b[31m   |\u001b[0mfor disambiguation.\n\u001b[31m\u001b[31m-- [E120] Naming Error: /tmp/tmpbvxc2vx_.scala:59:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36msumDigits\u001b[0m(\u001b[36mn\u001b[0m : \u001b[35mLong\u001b[0m) : \u001b[35mLong\u001b[0m = {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mDouble definition:\n\u001b[31m   |\u001b[0mdef sumDigits(n: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 48 and\n\u001b[31m   |\u001b[0mdef sumDigits(n: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 59\n\u001b[31m   |\u001b[0mhave the same type after erasure.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mConsider adding a @targetName annotation to one of the conflicting definitions\n\u001b[31m   |\u001b[0mfor d",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new java.lang.IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0l) {\n            throw new java.lang.IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0l) {\n            throw new java.lang.IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0l) {\n            return 0l\n        }\n        return (n * (n - 1l) / 2l) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293321,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpn9wqj9u3.scala:32)\n\tat Problem.main(tmpn9wqj9u3.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        return (n % p) + p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (101l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0l)\n            return a\n        else\n            return gcd(b, a % b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (33l)\n    // >>> lcm((100l), (101l))\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        return (a * b) / gcd(a, b)\n    }\n\n    // Return the sum of the squares of the first n natural numbers.\n    // >>> sum_of_squares(0)\n    // (0l)\n    // >>> sum_of_squares(1)\n    // (1l)\n    // >>> sum_of_squares(2)\n    // (5l)\n    // >>> sum_of_squares(3)\n    // (14l)\n    def sum_of_squares(n : Long) : Long = {\n        return (n * (n + 1) * (2 * n + 1)) / 6\n    }\n\n    // Return the sum of the cubes of the first n natural numbers.\n    // >>> sum_of_cubes(0)\n    // (0l)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293319,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpi22h59mz.scala:79:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpi22h59mz.scala:70:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m70 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpi22h59mz.scala:71:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpi22h59mz.scala:72:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpi22h59mz.scala:73:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpi22h59mz.scala:74:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpi22h59mz.scala:75:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0) {\n            0l\n        } else if (n < 0) {\n            modp(-n, p)\n        } else if (n > p) {\n            n % p\n        } else {\n            n\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(5l, 3l)\n    // (1l)\n    // >>> gcd(5l, 0l)\n    // (5l)\n    // >>> gcd(0l, 0l)\n    // (0l)\n    // >>> gcd(5l, 5l)\n    // (5l)\n    // >>> gcd(5l, -5l)\n    // (5l)\n    // >>> gcd(-5l, 5l)\n    // (5l)\n    // >>> gcd(-5l, -5l)\n    // (5l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            a\n        } else {\n            gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(5l, 3l)\n    // (15l)\n    // >>> lcm(5l, 0l)\n    // (5l)\n    // >>> lcm(0l, 0l)\n    // (0l)\n    // >>> lcm(5l, 5l)\n    // (5l)\n    // >>> lcm(5l, -5l)\n    // (-5l)\n    // >>> lcm(-5l, 5l)\n    // (-5l)\n    // >>> lcm(-5l, -5l)\n    // (5l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            a\n        } else {\n            lcm(b, a / b) * b\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(5l, 3l)\n    \n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293319,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmplt2jbyk6.scala:87:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplt2jbyk6.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplt2jbyk6.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplt2jbyk6.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplt2jbyk6.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplt2jbyk6.scala:82:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplt2jbyk6.scala:83:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(11l, 101l)\n    // (1l)\n    // >>> gcd(0l, 101l)\n    // (101l)\n    // >>> gcd(3l, 11l)\n    // (1l)\n    // >>> gcd(100l, 101l)\n    // (101l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            return a\n        } else {\n            return gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(11l, 101l)\n    // (101l)\n    // >>> lcm(0l, 101l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (33l)\n    // >>> lcm(100l, 101l)\n    // (101l)\n    def lcm(a : Long, b : Long) : Long = {\n        return a * b / gcd(a, b)\n    }\n\n    // Return the sum of the squares of the first n natural numbers.\n    // >>> sumOfSquares(0)\n    // (0l)\n    // >>> sumOfSquares(1)\n    // (1l)\n    // >>> sumOfSquares(2)\n    // (5l)\n    // >>> sumOfSquares(3)\n    // (14l)\n    def sumOfSquares(n : Long) : Long = {\n        return (n * (n + 1) * (2 * n + 1)) / 6\n    }\n\n    // Return the sum of the cubes of the first n natural numbers.\n    // >>> sumOfCubes(0)\n    // (0l)\n    // >>> sumOfCubes(1)\n    // (1l)\n    // >>> sumOfC\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293319,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpkam3uvq6.scala:83:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkam3uvq6.scala:74:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkam3uvq6.scala:75:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkam3uvq6.scala:76:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkam3uvq6.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkam3uvq6.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkam3uvq6.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // 5l\n    // >>> gcd(3l, 0l)\n    // 3l\n    // >>> gcd(0l, 0l)\n    // 0l\n    // >>> gcd(3l, -5l)\n    // 5l\n    // >>> gcd(-3l, 5l)\n    // 1l\n    // >>> gcd(-3l, -5l)\n    // 5l\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            return a\n        } else {\n            return gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // 15l\n    // >>> lcm(3l, 0l)\n    // 0l\n    // >>> lcm(0l, 0l)\n    // 0l\n    // >>> lcm(3l, -5l)\n    // -15l\n    // >>> lcm(-3l, 5l)\n    // -15l\n    // >>> lcm(-3l, -5l)\n    // 15l\n    def lcm(a : Long, b : Long) : Long = {\n        return (a * b) / gcd(a, b)\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // 5l\n    // >>> gcd(3l, 0l)\n    // 3l\n    // >>> gcd(0l, 0l)\n    // 0l\n    // >>> gcd(3l, -5l)\n    // 5l\n    // >>> gcd(-3l, 5l)\n    // 1l\n    // >>> gcd(-3l, -5l)\n    // 5l\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            return a\n        } else {\n\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293323,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpis1yx3yn.scala:87:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpis1yx3yn.scala:86:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E120] Naming Error: /tmp/tmpis1yx3yn.scala:70:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m70 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mgcd\u001b[0m(\u001b[36ma\u001b[0m : \u001b[35mLong\u001b[0m, \u001b[36mb\u001b[0m : \u001b[35mLong\u001b[0m) : \u001b[35mLong\u001b[0m = {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mDouble definition:\n\u001b[31m   |\u001b[0mdef gcd(a: Long, b: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 32 and\n\u001b[31m   |\u001b[0mdef gcd(a: Long, b: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 70\n\u001b[31m   |\u001b[0mhave the same type after erasure.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mConsider adding a @targetName annotation to one of the conflicting definitions\n\u001b[31m   |\u001b[0mfor disambiguation.\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpis1yx3yn.scala:76:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m76 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val nn = n.mod(p)\n        if (nn == 0) {\n            nn = p\n        }\n        nn\n    }\n\n    // Return the number of bits set in the binary representation of n.\n    // >>> bitCount(3l)\n    // 2\n    // >>> bitCount(11l)\n    // 4\n    // >>> bitCount(0l)\n    // 0\n    // >>> bitCount(-3l)\n    // 0\n    // >>> bitCount(-11l)\n    // 0\n    // >>> bitCount(-100l)\n    // 0\n    def bitCount(n : Long) : Long = {\n        val nn = n.toInt\n        if (nn == 0) {\n            0\n        } else {\n            nn.bitCount()\n        }\n    }\n\n    // Return the number of 1-bits in the binary representation of n.\n    // >>> bitCountOne(3l)\n    // 2\n    // >>> bitCountOne(11l)\n    // 2\n    // >>> bitCountOne(0l)\n    // 0\n    // >>> bitCountOne(-3l)\n    // 0\n    // >>> bitCountOne(-11l)\n    // 0\n    // >>> bitCountOne(-100l)\n    // 0\n    def bitCountOne(n : Long) : Long = {\n        val nn = n.toInt\n        if (nn == 0) {\n            0\n        } else {\n            nn.bitCount()\n        }\n    }\n\n    // Return the number of 0-bits in the binary representation of n.\n    // >>> bitCountZero(3l)\n    // 2\n    // >>> bitCountZero(11l)\n    // 4\n    // >>> bitCountZero(0l)\n    // 4\n    // >>> bitCountZero(-3l)\n    // 2\n    // >>> bitCountZero(-11l)\n    // 0\n    // >>> bitCountZero(-100l)\n    // 0\n    def bitCountZero(n : Long) : Long = {\n        val nn = n.toInt\n        if (nn == 0) {\n            nn = 4\n        } else {\n            nn.bitCount()\n        }\n\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293324,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_mhg6wl3.scala:16:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnn\u001b[0m = n.mod(p)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue mod is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.long2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp_mhg6wl3.scala:18:15 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            nn = p\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val nn\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_mhg6wl3.scala:41:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m            nn.bitCount()\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue bitCount is not a member of Int, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.int2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_mhg6wl3.scala:63:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m            nn.bitCount()\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue bitCount is not a member of Int, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.int2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp_mhg6wl3.scala:83:15 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m            nn = \u001b[31m4\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val nn\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_mhg6wl3.scala:85:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n * (n - 1) / 2) % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // 5l\n    // >>> gcd(11l, 101l)\n    // 101l\n    // >>> gcd(0l, 101l)\n    // 101l\n    // >>> gcd(3l, 11l)\n    // 1l\n    // >>> gcd(100l, 101l)\n    // 101l\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a must be >= 0\")\n        }\n        if (b < 0) {\n            throw new IllegalArgumentException(\"b must be >= 0\")\n        }\n        if (a == 0) {\n            return b\n        }\n        if (b == 0) {\n            return a\n        }\n        while (a != b) {\n            if (a > b) {\n                a = a - b\n            } else {\n                b = b - a\n            }\n        }\n        return a\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // 15l\n    // >>> lcm(11l, 101l)\n    // 101l\n    // >>> lcm(0l, 101l)\n    // 0l\n    // >>> lcm(3l, 11l)\n    // 3l\n    // >>> lcm(100l, 101l)\n    // 100l\n    def lcm(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgument\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293323,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmptu7ytavv.scala:91:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m91 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmptu7ytavv.scala:57:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m                a = a - b\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val a\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmptu7ytavv.scala:59:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m                b = b - a\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val b\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptu7ytavv.scala:78:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m            \u001b[33mthrow\u001b[0m \u001b[33mnew\u001b[0m \u001b[35mIllegalArgument\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: type IllegalArgument\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptu7ytavv.scala:90:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m90 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmptu7ytavv.scala:80:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m80 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n < 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p < 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p == 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n * (n - 1l) / 2l) % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((2l), (3l))\n    // (1l)\n    // >>> gcd((2l), (5l))\n    // (2l)\n    // >>> gcd((2l), (0l))\n    // (0l)\n    // >>> gcd((0l), (0l))\n    // (0l)\n    // >>> gcd((0l), (1l))\n    // (1l)\n    // >>> gcd((1l), (2l))\n    // (1l)\n    // >>> gcd((3l), (5l))\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a < 0\")\n        }\n        if (b < 0) {\n            throw new IllegalArgumentException(\"b < 0\")\n        }\n        if (a == 0) {\n            return b\n        }\n        if (b == 0) {\n            return a\n        }\n        return gcd(b, a % b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((2l), (3l))\n    // (6l)\n    // >>> lcm((2l), (5l))\n    // (10l)\n    // >>> lcm((2l), (0l))\n    // (0l)\n    // >>> lcm((0l), (0l))\n    // (0l)\n    // >>> lcm((0l), (1l))\n    // (0l)\n    // >>> l\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293320,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9qlbrubf.scala:85:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9qlbrubf.scala:76:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9qlbrubf.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9qlbrubf.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9qlbrubf.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9qlbrubf.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9qlbrubf.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppqmnk7x9.scala:20)\n\tat Problem.main(tmppqmnk7x9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0l) {\n            (0l)\n        } else {\n            (n % p)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293323,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpfi3lmcfl.scala:24)\n\tat Problem.main(tmpfi3lmcfl.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0) {\n            0l\n        } else {\n            n % p\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293325,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp1e8jnnde.scala:24)\n\tat Problem.main(tmp1e8jnnde.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(11l, 101l)\n    // (1l)\n    // >>> gcd(0l, 101l)\n    // (101l)\n    // >>> gcd(3l, 11l)\n    // (1l)\n    // >>> gcd(100l, 101l)\n    // (101l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            a\n        } else {\n            gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(11l, 101l)\n    // (101l)\n    // >>> lcm(0l, 101l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (33l)\n    // >>> lcm(100l, 101l)\n    // (101l)\n    def lcm(a : Long, b : Long) : Long = {\n        a * b / gcd(a, b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(11l, 101l)\n    // (101l)\n    // >>> lcm(0l, 101l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (33l)\n    // >>> lcm(100l, 101l)\n    // (101l)\n    def lcm(a : Long, b : Long) : Long = {\n        a * b / gcd(a, b)\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(11\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293323,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_gksatz8.scala:83:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E120] Naming Error: /tmp/tmp_gksatz8.scala:64:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mlcm\u001b[0m(\u001b[36ma\u001b[0m : \u001b[35mLong\u001b[0m, \u001b[36mb\u001b[0m : \u001b[35mLong\u001b[0m) : \u001b[35mLong\u001b[0m = {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mDouble definition:\n\u001b[31m   |\u001b[0mdef lcm(a: Long, b: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 49 and\n\u001b[31m   |\u001b[0mdef lcm(a: Long, b: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 64\n\u001b[31m   |\u001b[0mhave the same type after erasure.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mConsider adding a @targetName annotation to one of the conflicting definitions\n\u001b[31m   |\u001b[0mfor disambiguation.\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_gksatz8.scala:74:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_gksatz8.scala:75:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_gksatz8.scala:76:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_gksatz8.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(11l, 101l)\n    // (1l)\n    // >>> gcd(0l, 101l)\n    // (101l)\n    // >>> gcd(3l, 11l)\n    // (1l)\n    // >>> gcd(100l, 101l)\n    // (101l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0l) {\n            return b\n        } else {\n            return gcd(b % a, a)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(11l, 101l)\n    // (101l)\n    // >>> lcm(0l, 101l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (33l)\n    // >>> lcm(100l, 101l)\n    // (101l)\n    def lcm(a : Long, b : Long) : Long = {\n        return (a * b) / gcd(a, b)\n    }\n\n    // Return the sum of the digits of a.\n    // >>> sumDigits(123l)\n    // (3l)\n    // >>> sumDigits(1101l)\n    // (2l)\n    // >>> sumDigits(0l)\n    // (0l)\n    // >>> sumDigits(3l)\n    // (6l)\n    // >>> sumDigits(100l)\n    // (1l)\n    def sumDigits(a : Long) : Long = {\n        return (a % 10l) + (a / 10l)\n    }\n\n    // Return the sum of the digits of a.\n    // >>> sumDigits(123l)\n    // (3l)\n    // >>> sumDigits(1101l)\n    // (2l\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293322,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp65xxtj5k.scala:84:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp65xxtj5k.scala:75:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp65xxtj5k.scala:76:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp65xxtj5k.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp65xxtj5k.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp65xxtj5k.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp65xxtj5k.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(3l, 6l)\n    // (3l)\n    // >>> gcd(3l, 0l)\n    // (1l)\n    // >>> gcd(0l, 0l)\n    // (0l)\n    // >>> gcd(0l, 3l)\n    // (1l)\n    // >>> gcd(3l, 3l)\n    // (3l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0l) {\n            return b\n        } else {\n            return gcd(b % a, a)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(3l, 6l)\n    // (18l)\n    // >>> lcm(3l, 0l)\n    // (0l)\n    // >>> lcm(0l, 0l)\n    // (0l)\n    // >>> lcm(0l, 3l)\n    // (0l)\n    // >>> lcm(3l, 3l)\n    // (3l)\n    def lcm(a : Long, b : Long) : Long = {\n        return a * b / gcd(a, b)\n    }\n\n    // Return the sum of the squares of the numbers in the list.\n    // >>> sumOfSquares([1, 2, 3])\n    // (14l)\n    // >>> sumOfSquares([1, 2, 3, 4])\n    // (30l)\n    def sumOfSquares(numbers : List[Long]) : Long = {\n        return sum(map(n -> n * n, numbers))\n    }\n\n    // Return the sum of the products of the numbers in the list.\n    // >>> sumOfProducts([1, 2, 3])\n    // (6l)\n    // >>> sumOfProducts([1, 2\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293323,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpjmbj0j7j.scala:81:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjmbj0j7j.scala:63:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m        \u001b[33mreturn\u001b[0m sum(map(n -> n * n, numbers))\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Not found: sum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjmbj0j7j.scala:63:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m        \u001b[33mreturn\u001b[0m sum(map(n -> n * n, numbers))\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: map\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjmbj0j7j.scala:63:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m        \u001b[33mreturn\u001b[0m sum(map(n -> n * n, numbers))\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: n\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjmbj0j7j.scala:72:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjmbj0j7j.scala:73:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjmbj0j7j.scala:74:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new RuntimeException(\"Negative numbers not supported\")\n        }\n        if (p < 0l) {\n            throw new RuntimeException(\"Negative numbers not supported\")\n        }\n        if (p == 0l) {\n            throw new RuntimeException(\"Zero modulus not supported\")\n        }\n        return (n % p)\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(3l, 0l)\n    // (3l)\n    // >>> gcd(0l, 0l)\n    // (0l)\n    // >>> gcd(3l, 11l)\n    // (1l)\n    // >>> gcd(100l, 101l)\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0l) {\n            throw new RuntimeException(\"Negative numbers not supported\")\n        }\n        if (b < 0l) {\n            throw new RuntimeException(\"Negative numbers not supported\")\n        }\n        if (a == 0l) {\n            return b\n        }\n        if (b == 0l) {\n            return a\n        }\n        return modp(gcd(b, a % b), a)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(3l, 0l)\n    // (0l)\n    // >>> lcm(0l, 0l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (33l)\n    // >>> lcm(100l, 101l)\n    // (101l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a < 0l) {\n            throw new RuntimeException(\"Negative numbers not supported\")\n        }\n        if (b < 0l) {\n            throw new RuntimeException(\"Negative numbers not supported\")\n        }\n        \n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293324,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1xza0hbp.scala:70:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m70 |\u001b[0m        \u001b[33mif\u001b[0m (b < \u001b[31m0l\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Unit\n\u001b[31m   |\u001b[0m        Required: Long\n\u001b[31m   |\u001b[0m        Maybe you are missing an else part for the conditional?\n\u001b[31m71 |\u001b[0m            \u001b[33mthrow\u001b[0m \u001b[33mnew\u001b[0m \u001b[35mRuntimeException\u001b[0m(\u001b[31m\"Negative numbers not supported\"\u001b[0m)\n\u001b[31m72 |\u001b[0m        }\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppqmnk7x9.scala:20)\n\tat Problem.main(tmppqmnk7x9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n * (n % p)) % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(2l, 3l)\n    // (1l)\n    // >>> gcd(2l, 4l)\n    // (2l)\n    // >>> gcd(2l, 6l)\n    // (2l)\n    // >>> gcd(2l, 8l)\n    // (2l)\n    // >>> gcd(2l, 12l)\n    // (2l)\n    // >>> gcd(2l, 16l)\n    // (2l)\n    // >>> gcd(2l, 24l)\n    // (6l)\n    // >>> gcd(2l, 36l)\n    // (6l)\n    // >>> gcd(2l, 48l)\n    // (6l)\n    // >>> gcd(2l, 60l)\n    // (6l)\n    // >>> gcd(2l, 64l)\n    // (8l)\n    // >>> gcd(2l, 128l)\n    // (8l)\n    // >>> gcd(2l, 256l)\n    // (8l)\n    // >>> gcd(2l, 512l)\n    // (8l)\n    // >>> gcd(2l, 1024l)\n    // (8l)\n    // >>> gcd(2l, 2048l)\n    // (16l)\n    // >>> gcd(2l, 4096l)\n    // (16l)\n    // >>> gcd(2l, 8192l)\n    // (16l)\n    // >>> gcd(2l, 16384l)\n    // (16l)\n    \n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293323,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpz0rsyl3k.scala:82:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz0rsyl3k.scala:73:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz0rsyl3k.scala:74:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz0rsyl3k.scala:75:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz0rsyl3k.scala:76:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz0rsyl3k.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz0rsyl3k.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        return (n % p) + p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(3l, 0l)\n    // (1l)\n    // >>> gcd(0l, 0l)\n    // (0l)\n    // >>> gcd(3l, 6l)\n    // (3l)\n    // >>> gcd(6l, 0l)\n    // (0l)\n    // >>> gcd(6l, 6l)\n    // (6l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            return a\n        } else {\n            return gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(3l, 0l)\n    // (0l)\n    // >>> lcm(0l, 0l)\n    // (0l)\n    // >>> lcm(3l, 6l)\n    // (18l)\n    // >>> lcm(6l, 0l)\n    // (0l)\n    // >>> lcm(6l, 6l)\n    // (6l)\n    def lcm(a : Long, b : Long) : Long = {\n        return a * b / gcd(a, b)\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(123l)\n    // (3l)\n    // >>> sumDigits(0l)\n    // (0l)\n    // >>> sumDigits(-123l)\n    // (0l)\n    def sumDigits(n : Long) : Long = {\n        return n % 10\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(123l)\n    // (3l)\n    // >>> sumDigits(0l)\n    // (0l)\n    // >>>\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293323,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp5w61_8_.scala:85:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp5w61_8_.scala:76:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp5w61_8_.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp5w61_8_.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp5w61_8_.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp5w61_8_.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp5w61_8_.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        if (p == 1) {\n            return 1l\n        }\n        if (p == 2) {\n            return n\n        }\n        if (p == 3) {\n            return (n * 2l) % 3l\n        }\n        if (p == 4) {\n            return (n * 3l) % 4l\n        }\n        if (p == 5) {\n            return (n * 2l) % 5l\n        }\n        if (p == 6) {\n            return (n * 3l) % 6l\n        }\n        if (p == 7) {\n            return (n * 2l) % 7l\n        }\n        if (p == 8) {\n            return (n * 3l) % 8l\n        }\n        if (p == 9) {\n            return (n * 2l) % 9l\n        }\n        if (p == 10) {\n            return (n * 3l) % 10l\n        }\n        if (p == 11) {\n            return (n * 2l) % 11l\n        }\n        if (p == 12) {\n            return (n * 3l) % 12l\n        }\n        if (p == 13) {\n            return (n * 2l) % 13l\n        }\n        if (p == 14) {\n            return (n * 3l) % 14l\n        }\n        if (p == 15) {\n            return (n * 2l) % 15l\n        }\n        if (p == 16) {\n            return (n * 3l) % 16l\n        }\n        if (p == 17) {\n            return (n * 2l) % 17l\n        }\n        if (p == 18) {\n            return (n * 3l) % 18l\n\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293328,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpos1d2stv.scala:94:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m94 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpos1d2stv.scala:93:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m93 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpos1d2stv.scala:83:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m83 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0l) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0l) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0l) {\n            return 0l\n        }\n        return (n * (n - 1l) / 2l) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmps54khr7a.scala:32)\n\tat Problem.main(tmps54khr7a.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val m = n % p\n        if (m < 0) {\n            m += p\n        }\n        return m\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293327,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbx0qwhew.scala:18:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            m += p\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean m.!=?\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n * (n - 1) / 2) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293328,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp9kalviu5.scala:32)\n\tat Problem.main(tmp9kalviu5.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be non-negative\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be non-zero\")\n        }\n        return (n % p)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293328,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpjpn8hbeq.scala:29)\n\tat Problem.main(tmpjpn8hbeq.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0) {\n            0l\n        } else {\n            n % p\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(2l, 4l)\n    // (2l)\n    // >>> gcd(5l, 10l)\n    // (5l)\n    // >>> gcd(5l, 0l)\n    // (5l)\n    // >>> gcd(0l, 0l)\n    // (0l)\n    // >>> gcd(0l, 5l)\n    // (5l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            a\n        } else {\n            gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(2l, 4l)\n    // (8l)\n    // >>> lcm(5l, 10l)\n    // (50l)\n    // >>> lcm(5l, 0l)\n    // (0l)\n    // >>> lcm(0l, 0l)\n    // (0l)\n    // >>> lcm(0l, 5l)\n    // (0l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            a\n        } else {\n            a * b / gcd(a, b)\n        }\n    }\n\n    // Return the sum of the squares of the numbers in the list.\n    // >>> sum_of_squares([1, 2, 3, 4])\n    // (30l)\n    // >>> sum_of_squares([1, 2, 3, 4, 5])\n    // (55l)\n    // >>> sum_of_squares([])\n    // (0l)\n    def sum_of_squares(numbers : List[Long]) : Long = {\n        if (numbers.isEmpty()) {\n            0l\n        } else {\n            numbers.foreach(x => x * x)\n        }\n\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293328,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpsliot5hi.scala:69:20 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m        \u001b[33mif\u001b[0m (numbers.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsliot5hi.scala:72:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m            numbers.foreach(\u001b[36mx\u001b[0m => x * x)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    Unit\n\u001b[31m   |\u001b[0m            Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the number of 1's in the binary representation of n.\n    // >>> countOnes(0l)\n    // 0\n    // >>> countOnes(1l)\n    // 1\n    // >>> countOnes(2l)\n    // 2\n    // >>> countOnes(3l)\n    // 2\n    // >>> countOnes(4l)\n    // 3\n    // >>> countOnes(5l)\n    // 3\n    // >>> countOnes(6l)\n    // 4\n    // >>> countOnes(7l)\n    // 4\n    // >>> countOnes(8l)\n    // 5\n    // >>> countOnes(9l)\n    // 5\n    // >>> countOnes(10l)\n    // 6\n    // >>> countOnes(11l)\n    // 6\n    // >>> countOnes(12l)\n    // 7\n    // >>> countOnes(13l)\n    // 7\n    // >>> countOnes(14l)\n    // 8\n    // >>> countOnes(15l)\n    // 8\n    def countOnes(n : Long) : Int = {\n        var count = 0\n        while (n > 0) {\n            count += (n & 1)\n            n >>= 1\n        }\n        return count\n    }\n\n    // Return the number of 1's in the binary representation of n.\n    // >>> countOnes2(0l)\n    // 0\n    // >>> countOnes2(1l)\n    // 1\n    // >>> countOnes2(2l)\n    // 2\n    // >>> countOnes2(3l)\n    // 2\n    // >>> countOnes2(4l)\n    // 3\n    // >>> countOnes2(5l)\n    // 3\n    // >>> countOnes2(6l)\n    // 4\n    // >>> countOnes2(7l)\n    // 4\n    // >>> countOnes2(8l)\n    // 5\n    // >>> countOnes2(9l)\n    // 5\n    // >>> countOnes2(10l)\n    // 6\n    \n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293329,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp6h7l5pa8.scala:96:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m96 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6h7l5pa8.scala:55:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m            count += (n & \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6h7l5pa8.scala:56:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m            n >>= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value >>= is not a member of Long - did you mean n.>=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6h7l5pa8.scala:87:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6h7l5pa8.scala:88:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6h7l5pa8.scala:89:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m89 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6h7l5pa8.scala:90:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m90 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanat",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n % p == 0) {\n            n / p\n        } else {\n            n % p\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (101l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (101l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            b\n        } else if (b == 0) {\n            a\n        } else {\n            gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (33l)\n    // >>> lcm((100l), (101l))\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            b\n        } else if (b == 0) {\n            a\n        } else {\n            a * b / gcd(a, b)\n        }\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(123l)\n    // 3\n    // >>> sumDigits(1234l)\n    // 4\n    // >>> sumDigits(12345l)\n    // 5\n    def sumDigits(n : Long) : Long = {\n        n % 10\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(123l)\n    \n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293326,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9jczsj6y.scala:90:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m90 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9jczsj6y.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9jczsj6y.scala:82:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9jczsj6y.scala:83:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9jczsj6y.scala:84:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9jczsj6y.scala:85:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9jczsj6y.scala:86:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be a non-negative number\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be a non-negative number\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be a non-zero number\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n * (n % p)) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293329,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpk6bwia3b.scala:31)\n\tat Problem.main(tmpk6bwia3b.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0l) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0l) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0l) {\n            return 0l\n        }\n        return (n * (n % p)) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293307,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpxxlpd1em.scala:31)\n\tat Problem.main(tmpxxlpd1em.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (p < 0l) {\n            throw new IllegalArgumentException(\"p must be non-negative\")\n        }\n        if (p == 0l) {\n            throw new IllegalArgumentException(\"p must be non-zero\")\n        }\n        if (n == 0l) {\n            return 0l\n        }\n        return (n * (n - 1l) / 2l) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293329,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp4b6t20x6.scala:32)\n\tat Problem.main(tmp4b6t20x6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n % p) + (n / p) * (p - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293330,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp7v1dpr_x.scala:32)\n\tat Problem.main(tmp7v1dpr_x.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val m = n % p\n        if (m == 0) {\n            m\n        } else {\n            m + p\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // 1l\n    // >>> gcd(11l, 101l)\n    // 1l\n    // >>> gcd(0l, 101l)\n    // 101l\n    // >>> gcd(3l, 11l)\n    // 1l\n    // >>> gcd(100l, 101l)\n    // 101l\n    def gcd(a : Long, b : Long) : Long = {\n        val aa = a\n        val bb = b\n        if (aa == 0) {\n            bb\n        } else if (bb == 0) {\n            aa\n        } else {\n            gcd(bb, aa % bb)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // 15l\n    // >>> lcm(11l, 101l)\n    // 101l\n    // >>> lcm(0l, 101l)\n    // 0l\n    // >>> lcm(3l, 11l)\n    // 3l\n    // >>> lcm(100l, 101l)\n    // 100l\n    def lcm(a : Long, b : Long) : Long = {\n        val aa = a\n        val bb = b\n        if (aa == 0) {\n            bb\n        } else if (bb == 0) {\n            aa\n        } else {\n            lcm(bb, aa / bb) * bb\n        }\n    }\n\n    // Return the sum of a and b.\n    // >>> add(3l, 5l)\n    // 8l\n    // >>> add(11l, 101l)\n    // 112l\n    // >>> add(0l, 101l)\n    // 101l\n    // >>> add(3l, 11l)\n    // 14l\n    // >>> add(100l, 101l)\n    // 101l\n    def add(a\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293327,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpmlyyggaj.scala:82:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ':' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpmlyyggaj.scala:93:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m93 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmlyyggaj.scala:84:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmlyyggaj.scala:85:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmlyyggaj.scala:86:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmlyyggaj.scala:87:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmlyyggaj.scala:88:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer expl",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the number of 1's in the binary representation of n.\n    // >>> countBits(3l)\n    // 2\n    // >>> countBits(11l)\n    // 3\n    // >>> countBits(0l)\n    // 0\n    // >>> countBits(-3l)\n    // 0\n    // >>> countBits(-11l)\n    // 0\n    def countBits(n : Long) : Long = {\n        n.bitCount()\n    }\n\n    // Return the number of 1's in the binary representation of n.\n    // >>> countOnes(3l)\n    // 2\n    // >>> countOnes(11l)\n    // 3\n    // >>> countOnes(0l)\n    // 0\n    // >>> countOnes(-3l)\n    // 0\n    // >>> countOnes(-11l)\n    // 0\n    def countOnes(n : Long) : Long = {\n        n.bitCount()\n    }\n\n    // Return the number of 0's in the binary representation of n.\n    // >>> countZeros(3l)\n    // 2\n    // >>> countZeros(11l)\n    // 3\n    // >>> countZeros(0l)\n    // 0\n    // >>> countZeros(-3l)\n    // 0\n    // >>> countZeros(-11l)\n    // 0\n    def countZeros(n : Long) : Long = {\n        n.bitCount()\n    }\n\n    // Return the number of 1's in the binary representation of n.\n    // >>> countBits(3l)\n    // 2\n    // >>> countBits(11l)\n    // 3\n    // >>> countBits(0l)\n    // 0\n    // >>> countBits(-3l)\n    // 0\n    // >>> countBits(-11l)\n    // 0\n    def countBits2(n : Long) : Long = {\n        n.bitCount()\n    }\n\n    // Return the number of 1's in the binary representation of n.\n    // >>> countOnes(3l)\n    // 2\n    // >>> countOnes(11\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293332,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpa_biq8qs.scala:94:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m94 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa_biq8qs.scala:31:10 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        n.bitCount()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue bitCount is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.long2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa_biq8qs.scala:46:10 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        n.bitCount()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue bitCount is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.long2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa_biq8qs.scala:61:10 ------------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m        n.bitCount()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue bitCount is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.long2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa_biq8qs.scala:76:10 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m        n.bitCount()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue bitCount is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.long2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpa_biq8qs.scala:85:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (p < 0l) {\n            throw new IllegalArgumentException(\"p must be non-negative\")\n        }\n        if (p == 0l) {\n            throw new IllegalArgumentException(\"p must be non-zero\")\n        }\n        if (n == 0l) {\n            return 0l\n        }\n        return (n * (n - 1l)) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293331,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpus7f34ga.scala:31)\n\tat Problem.main(tmpus7f34ga.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new RuntimeException(\"Negative numbers not supported\")\n        }\n        if (p < 0l) {\n            throw new RuntimeException(\"Negative numbers not supported\")\n        }\n        if (p == 0l) {\n            throw new RuntimeException(\"Division by zero not supported\")\n        }\n        return (n % p)\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (1l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0l) {\n            throw new RuntimeException(\"Negative numbers not supported\")\n        }\n        if (b < 0l) {\n            throw new RuntimeException(\"Negative numbers not supported\")\n        }\n        if (a == 0l) {\n            return b\n        }\n        if (b == 0l) {\n            return a\n        }\n        return modp(gcd(b, a % b), a)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (11l)\n    // >>> lcm((100l), (101l))\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a < 0l) {\n            throw new RuntimeException(\"Negative numbers not supported\")\n        }\n        if (b < 0l) {\n            throw new Runtime\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293333,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9texlw_y.scala:84:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- Error: /tmp/tmp9texlw_y.scala:71:22 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m            \u001b[33mthrow\u001b[0m \u001b[33mnew\u001b[0m \u001b[35mRuntime\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m\u001b[33mconstructor\u001b[0m \u001b[35mRuntime\u001b[0m cannot be accessed as a member of Runtime from module class Problem$.\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9texlw_y.scala:83:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmp9texlw_y.scala:73:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m73 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppqmnk7x9.scala:20)\n\tat Problem.main(tmppqmnk7x9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n % p == 0) {\n            n\n        } else {\n            n + p - (n % p)\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // 1l\n    // >>> gcd(3l, 6l)\n    // 3l\n    // >>> gcd(3l, 0l)\n    // 3l\n    // >>> gcd(0l, 0l)\n    // 0l\n    // >>> gcd(3l, -3l)\n    // 3l\n    // >>> gcd(-3l, 0l)\n    // 3l\n    // >>> gcd(0l, -3l)\n    // 3l\n    // >>> gcd(-3l, -3l)\n    // 1l\n    // >>> gcd(-3l, -6l)\n    // 3l\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            a\n        } else {\n            gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // 15l\n    // >>> lcm(3l, 6l)\n    // 18l\n    // >>> lcm(3l, 0l)\n    // 0l\n    // >>> lcm(0l, 0l)\n    // 0l\n    // >>> lcm(3l, -3l)\n    // -3l\n    // >>> lcm(-3l, 0l)\n    // 0l\n    // >>> lcm(0l, -3l)\n    // -3l\n    // >>> lcm(-3l, -3l)\n    // 0l\n    // >>> lcm(-3l, -6l)\n    // -18l\n    def lcm(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            a\n        } else {\n            a * (b / gcd(a, b))\n        }\n    }\n\n    // Return the\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293329,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgvoabhr4.scala:89:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m89 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgvoabhr4.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgvoabhr4.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgvoabhr4.scala:82:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgvoabhr4.scala:83:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgvoabhr4.scala:84:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgvoabhr4.scala:85:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n * (n - 1) / 2) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293328,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp9kalviu5.scala:32)\n\tat Problem.main(tmp9kalviu5.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppqmnk7x9.scala:20)\n\tat Problem.main(tmppqmnk7x9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val nn = n.toInt\n        val pp = p.toInt\n        val r = nn % pp\n        if (r == 0) {\n            r = pp\n        }\n        return r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293330,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpowgt9gxp.scala:20:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            r = pp\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val r\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new RuntimeException(\"Negative number\")\n        }\n        if (p < 0) {\n            throw new RuntimeException(\"Negative number\")\n        }\n        if (p == 0) {\n            throw new RuntimeException(\"Zero modulus\")\n        }\n        return (n * (p - 1l)) % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((2l), (3l))\n    // (1l)\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((0l), (0l))\n    // (0l)\n    // >>> gcd((0l), (1l))\n    // (1l)\n    // >>> gcd((1l), (2l))\n    // (1l)\n    // >>> gcd((2l), (3l))\n    // (1l)\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((11l), (101l))\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new RuntimeException(\"Negative number\")\n        }\n        if (b < 0) {\n            throw new RuntimeException(\"Negative number\")\n        }\n        if (a == 0) {\n            return b\n        }\n        if (b == 0) {\n            return a\n        }\n        return gcd(b, a % b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((2l), (3l))\n    // (6l)\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((0l), (0l))\n    // (0l)\n    // >>> lcm((0l), (1l))\n    // (0l)\n    // >>> lcm((1l), (2l))\n    // (2l)\n    // >>> lcm((2l), (3l))\n\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293330,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4z4qf167.scala:85:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4z4qf167.scala:76:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4z4qf167.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4z4qf167.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4z4qf167.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4z4qf167.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4z4qf167.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be non-negative\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be non-zero\")\n        }\n        return (n * (n - 1) / 2) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293333,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpaa3fsgv_.scala:29)\n\tat Problem.main(tmpaa3fsgv_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0l) {\n            0l\n        } else {\n            (n * 2l) % p\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293332,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpgfxrr25v.scala:23)\n\tat Problem.main(tmpgfxrr25v.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        return _.modp(n, p)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293329,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpcrdhmq1s.scala:16:15 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mreturn\u001b[0m _.modp(n, p)\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$1 of expanded function:\n\u001b[31m   |\u001b[0m   _$1 => _$1.modp(n, p).\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0) {\n            0l\n        } else {\n            (n * 2l) % p\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293334,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpvn_dm_j9.scala:23)\n\tat Problem.main(tmpvn_dm_j9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val nn = n.toInt\n        val pp = p.toInt\n        if (nn < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (pp < 0) {\n            throw new IllegalArgumentException(\"p must be non-negative\")\n        }\n        if (nn >= pp) {\n            throw new IllegalArgumentException(\"n must be less than p\")\n        }\n        val m = 1l\n        for (i <- 0 until (nn - pp)) {\n            m *= 2l\n        }\n        m %= p\n        return m\n    }\n\n    // Return the number of bits set in n.\n    // >>> countBits(0l)\n    // 0\n    // >>> countBits(1l)\n    // 1\n    // >>> countBits(2l)\n    // 2\n    // >>> countBits(3l)\n    // 2\n    // >>> countBits(4l)\n    // 3\n    // >>> countBits(5l)\n    // 3\n    // >>> countBits(6l)\n    // 4\n    // >>> countBits(7l)\n    // 4\n    // >>> countBits(8l)\n    // 5\n    // >>> countBits(9l)\n    // 5\n    // >>> countBits(10l)\n    // 6\n    // >>> countBits(11l)\n    // 6\n    // >>> countBits(12l)\n    // 7\n    // >>> countBits(13l)\n    // 7\n    // >>> countBits(14l)\n    // 8\n    // >>> countBits(15l)\n    // 8\n    // >>> countBits(16l)\n    // 9\n    // >>> countBits(17l)\n    // 9\n    // >>> countBits(18l)\n    // 10\n    // >>> countBits(19l)\n    // 10\n    // >>> countBits(20l)\n    // 11\n    // >>> countBits(21l)\n    // 11\n    // >>> countBits(22l)\n    // 12\n    // >>> countBits(23\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293334,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpd7n445z8.scala:94:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m94 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpd7n445z8.scala:29:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            m *= \u001b[31m2l\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value *= is not a member of Long - did you mean m.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpd7n445z8.scala:31:10 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        m %= p\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value %= is not a member of Long - did you mean m.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd7n445z8.scala:85:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd7n445z8.scala:86:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd7n445z8.scala:87:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd7n445z8.scala:88:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-ex",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (p < 0l) {\n            throw new IllegalArgumentException(\"p must be non-negative\")\n        }\n        if (p == 0l) {\n            throw new IllegalArgumentException(\"p must be non-zero\")\n        }\n        if (p == 1l) {\n            return n\n        }\n        return (n * modp(n - 1l, p)) % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((2l), (3l))\n    // (1l)\n    // >>> gcd((-2l), (3l))\n    // (2l)\n    // >>> gcd((2l), (-3l))\n    // (1l)\n    // >>> gcd((-2l), (-3l))\n    // (1l)\n    // >>> gcd((2l), (0l))\n    // (0l)\n    // >>> gcd((-2l), (0l))\n    // (0l)\n    // >>> gcd((0l), (0l))\n    // (0l)\n    // >>> gcd((1l), (0l))\n    // (0l)\n    // >>> gcd((0l), (1l))\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0l) {\n            a = -a\n        }\n        if (b < 0l) {\n            b = -b\n        }\n        if (a == 0l) {\n            return b\n        }\n        if (b == 0l) {\n            return a\n        }\n        while (true) {\n            if (a > b) {\n                a = a - b\n            } else {\n                b = b - a\n            }\n            if (a == 0l) {\n                return b\n            }\n            if (b == 0l) {\n                return a\n            }\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293332,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfz28ej3a.scala:90:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m90 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpfz28ej3a.scala:52:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m            a = -a\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val a\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpfz28ej3a.scala:55:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m            b = -b\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val b\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpfz28ej3a.scala:65:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m65 |\u001b[0m                a = a - b\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val a\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpfz28ej3a.scala:67:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m                b = b - a\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val b\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfz28ej3a.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfz28ej3a.scala:82:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n % p) + (n / p) * (p - 1l)\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(11l, 101l)\n    // (1l)\n    // >>> gcd(0l, 101l)\n    // (101l)\n    // >>> gcd(3l, 11l)\n    // (1l)\n    // >>> gcd(100l, 101l)\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a must be >= 0\")\n        }\n        if (b < 0) {\n            throw new IllegalArgumentException(\"b must be >= 0\")\n        }\n        if (a == 0) {\n            return b\n        }\n        if (b == 0) {\n            return a\n        }\n        return gcd(b, a % b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(11l, 101l)\n    // (101l)\n    // >>> lcm(0l, 101l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (3l)\n    // >>> lcm(100l, 101l)\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a must be >= 0\")\n        \n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293335,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmphxlp58qd.scala:85:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphxlp58qd.scala:84:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmphxlp58qd.scala:74:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m74 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(3l, 6l)\n    // (3l)\n    // >>> gcd(3l, 0l)\n    // (1l)\n    // >>> gcd(0l, 0l)\n    // (0l)\n    // >>> gcd(3l, -3l)\n    // (1l)\n    // >>> gcd(3l, -6l)\n    // (3l)\n    // >>> gcd(3l, -0l)\n    // (1l)\n    // >>> gcd(0l, -0l)\n    // (0l)\n    // >>> gcd(-3l, -6l)\n    // (3l)\n    // >>> gcd(-3l, -0l)\n    // (1l)\n    // >>> gcd(-3l, 0l)\n    // (1l)\n    // >>> gcd(-6l, 0l)\n    // (0l)\n    // >>> gcd(-6l, -0l)\n    // (6l)\n    // >>> gcd(-0l, -0l)\n    // (0l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            return a\n        } else {\n            return gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(3l, 6l)\n    // (18l)\n    // >>> lcm(3l, 0l)\n    // (0l)\n    // >>> lcm(0l, 0l)\n    // (0l)\n    // >>> lcm(3l, -3l)\n    // (-3l)\n    // >>> lcm(3l, -6l)\n    // (0l)\n    // >>> lcm(3l, -0\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293333,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm6tud1q7.scala:81:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm6tud1q7.scala:72:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm6tud1q7.scala:73:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm6tud1q7.scala:74:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm6tud1q7.scala:75:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm6tud1q7.scala:76:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm6tud1q7.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be non-negative\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be non-zero\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n * (n - 1l) / 2l) % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // 5l\n    // >>> gcd(11l, 101l)\n    // 101l\n    // >>> gcd(0l, 101l)\n    // 101l\n    // >>> gcd(3l, 11l)\n    // 1l\n    // >>> gcd(100l, 101l)\n    // 101l\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a must be non-negative\")\n        }\n        if (b < 0) {\n            throw new IllegalArgumentException(\"b must be non-negative\")\n        }\n        if (a == 0) {\n            return b\n        }\n        if (b == 0) {\n            return a\n        }\n        return gcd(b, a % b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // 15l\n    // >>> lcm(11l, 101l)\n    // 101l\n    // >>> lcm(0l, 101l)\n    // 101l\n    // >>> lcm(3l, 11l)\n    // 3l\n    // >>> lcm(100l, 101l)\n    // 101l\n    def lcm(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a must be non-negative\")\n        }\n        if (b < 0) {\n            throw new IllegalArgument\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293337,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmppxijrlud.scala:87:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppxijrlud.scala:74:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m            \u001b[33mthrow\u001b[0m \u001b[33mnew\u001b[0m \u001b[35mIllegalArgument\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: type IllegalArgument\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppxijrlud.scala:86:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmppxijrlud.scala:76:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m76 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n % p == 0) {\n            n\n        } else {\n            n + p - n % p\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // 5l\n    // >>> gcd(11l, 101l)\n    // 101l\n    // >>> gcd(0l, 101l)\n    // 1l\n    // >>> gcd(3l, 11l)\n    // 1l\n    // >>> gcd(100l, 101l)\n    // 101l\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0) {\n            a\n        } else {\n            gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // 15l\n    // >>> lcm(11l, 101l)\n    // 1011l\n    // >>> lcm(0l, 101l)\n    // 0l\n    // >>> lcm(3l, 11l)\n    // 3l\n    // >>> lcm(100l, 101l)\n    // 100l\n    def lcm(a : Long, b : Long) : Long = {\n        if (b == 0) {\n            a\n        } else {\n            a * b / gcd(a, b)\n        }\n    }\n\n    // Return the sum of the squares of the first n natural numbers.\n    // >>> sumOfSquares(0)\n    // 0l\n    // >>> sumOfSquares(1)\n    // 1l\n    // >>> sumOfSquares(2)\n    // 5l\n    // >>> sumOfSquares(3)\n    // 14l\n    def sumOfSquares(n : Long) : Long = {\n        n * (n + 1) / 2\n    }\n\n    // Return the sum of the first n natural numbers.\n    // >>> sum(0)\n    // 0l\n    // >>> sum(1)\n    // 1l\n    // >>> sum(2)\n    // 3l\n    \n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293334,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7dozb138.scala:93:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m93 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7dozb138.scala:84:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7dozb138.scala:85:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7dozb138.scala:86:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7dozb138.scala:87:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7dozb138.scala:88:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7dozb138.scala:89:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m89 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppqmnk7x9.scala:20)\n\tat Problem.main(tmppqmnk7x9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        return (n % p) + p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(3l, 0l)\n    // (3l)\n    // >>> gcd(0l, 0l)\n    // (0l)\n    // >>> gcd(0l, 3l)\n    // (3l)\n    // >>> gcd(3l, 3l)\n    // (3l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            return a\n        } else {\n            return gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(3l, 0l)\n    // (0l)\n    // >>> lcm(0l, 0l)\n    // (0l)\n    // >>> lcm(0l, 3l)\n    // (0l)\n    // >>> lcm(3l, 3l)\n    // (3l)\n    def lcm(a : Long, b : Long) : Long = {\n        return (a * b) / gcd(a, b)\n    }\n\n    // Return the sum of a and b.\n    // >>> add(3l, 5l)\n    // (8l)\n    // >>> add(3l, 0l)\n    // (3l)\n    // >>> add(0l, 0l)\n    // (0l)\n    // >>> add(0l, 3l)\n    // (3l)\n    // >>> add(3l, 3l)\n    // (6l)\n    def add(a : Long, b : Long) : Long = {\n        return a + b\n    }\n\n    // Return the product of a and b.\n    // >>> mult(3l, 5l)\n    // (15l)\n    // >>> mult(3l, 0l)\n    // (0l\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293334,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpcqa1k4ym.scala:84:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcqa1k4ym.scala:75:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcqa1k4ym.scala:76:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcqa1k4ym.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcqa1k4ym.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcqa1k4ym.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcqa1k4ym.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be a non-negative number\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be a non-negative number\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be a non-zero number\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n * (n % p)) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293329,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpk6bwia3b.scala:31)\n\tat Problem.main(tmpk6bwia3b.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0l) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0l) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0l) {\n            return 0l\n        }\n        return (n * (n - 1l) / 2l) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmps54khr7a.scala:32)\n\tat Problem.main(tmps54khr7a.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppqmnk7x9.scala:20)\n\tat Problem.main(tmppqmnk7x9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n < 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p < 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p == 0\")\n        }\n        return (n % p) + (n / p) * (p - 1)\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(11l, 101l)\n    // (1l)\n    // >>> gcd(0l, 101l)\n    // (101l)\n    // >>> gcd(3l, 11l)\n    // (1l)\n    // >>> gcd(100l, 101l)\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a < 0\")\n        }\n        if (b < 0) {\n            throw new IllegalArgumentException(\"b < 0\")\n        }\n        if (a == 0) {\n            return b\n        }\n        if (b == 0) {\n            return a\n        }\n        return gcd(b, a % b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(11l, 101l)\n    // (101l)\n    // >>> lcm(0l, 101l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (3l)\n    // >>> lcm(100l, 101l)\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a < 0\")\n        }\n        if (b < 0) {\n            throw new IllegalArgumentException(\"b < 0\")\n        }\n        if (\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293335,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp1puafp6d.scala:73:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m        \u001b[33mif\u001b[0m (\n\u001b[31m\u001b[31m   |\u001b[0m            ^\u001b[0m\n\u001b[31m   |\u001b[0m            expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new java.lang.IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0l) {\n            throw new java.lang.IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0l) {\n            throw new java.lang.IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0l) {\n            return 0l\n        }\n        return (n * (n - 1l)) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293339,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp749wuhzx.scala:31)\n\tat Problem.main(tmp749wuhzx.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(3l, 0l)\n    // (3l)\n    // >>> gcd(0l, 0l)\n    // (0l)\n    // >>> gcd(3l, -5l)\n    // (1l)\n    // >>> gcd(-3l, 5l)\n    // (1l)\n    // >>> gcd(-3l, 0l)\n    // (3l)\n    // >>> gcd(3l, -5l)\n    // (1l)\n    // >>> gcd(-3l, -5l)\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            return a\n        } else {\n            return gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(3l, 0l)\n    // (0l)\n    // >>> lcm(0l, 0l)\n    // (0l)\n    // >>> lcm(3l, -5l)\n    // (-15l)\n    // >>> lcm(-3l, 5l)\n    // (-15l)\n    // >>> lcm(-3l, 0l)\n    // (0l)\n    // >>> lcm(3l, -5l)\n    // (-15l)\n    // >>> lcm(-3l, -5l)\n    // (15l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            return a\n        } else {\n            return a * b / gcd(a, b)\n        }\n    }\n\n    // Return the sum of a and b.\n    // >>> add(3l, 5l)\n    // (8l)\n    // >>> add(3l,\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293335,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpq2m_k7wq.scala:84:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq2m_k7wq.scala:75:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq2m_k7wq.scala:76:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq2m_k7wq.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq2m_k7wq.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq2m_k7wq.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq2m_k7wq.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        if (p == 1) {\n            return n\n        }\n        return (n * modp(n - 1, p)) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293338,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmphyifa3g7.scala:34)\n\tat Problem.main(tmphyifa3g7.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        return (n % p)\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (1l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a must be >= 0\")\n        }\n        if (b < 0) {\n            throw new IllegalArgumentException(\"b must be >= 0\")\n        }\n        if (a == 0) {\n            return b\n        }\n        if (b == 0) {\n            return a\n        }\n        return gcd(b, a % b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (11l)\n    // >>> lcm((100l), (101l))\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a must be >= 0\")\n        }\n        if (b < 0) {\n            throw new IllegalArgumentException\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293338,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpcy7zdm9w.scala:84:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcy7zdm9w.scala:83:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpcy7zdm9w.scala:73:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m73 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n * (n % p)) % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(11l, 101l)\n    // (1l)\n    // >>> gcd(0l, 101l)\n    // (101l)\n    // >>> gcd(3l, 11l)\n    // (1l)\n    // >>> gcd(100l, 101l)\n    // (101l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a must be >= 0\")\n        }\n        if (b < 0) {\n            throw new IllegalArgumentException(\"b must be >= 0\")\n        }\n        if (b == 0) {\n            return a\n        }\n        return gcd(b, a % b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(11l, 101l)\n    // (101l)\n    // >>> lcm(0l, 101l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (3l)\n    // >>> lcm(100l, 101l)\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a must be >= 0\")\n        }\n        if (b < 0) {\n            throw new IllegalArgumentException(\"b must be >= 0\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293334,
      "stdout": "error while checking \u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[31mnull\u001b[0m)\nerror while checking \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[31mnull\u001b[0m)\nerror while checking {\n  \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[31mnull\u001b[0m)\n}\nerror while checking \u001b[33mif \u001b[0m(b < 0) \n  {\n    \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[31mnull\u001b[0m)\n  }\nerror while checking {\n  \u001b[33mif \u001b[0m(a < 0) \n    {\n      \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[32m\"a must be >= 0\"\u001b[0m)\n    }\n  \u001b[33mif \u001b[0m(b < 0) \n    {\n      \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[31mnull\u001b[0m)\n    }\n  b must be >= 0def main (args:\u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m])\n}\nerror while checking \u001b[33mdef\u001b[0m \u001b[36mlcm\u001b[0m(\u001b[36ma\u001b[0m: \u001b[35mLong\u001b[0m, \u001b[36mb\u001b[0m: \u001b[35mLong\u001b[0m): \u001b[35mLong\u001b[0m = \n  {\n    \u001b[33mif \u001b[0m(a < 0) \n      {\n        \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[32m\"a must be >= 0\"\u001b[0m)\n      }\n    \u001b[33mif \u001b[0m(b < 0) \n      {\n        \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[31mnull\u001b[0m)\n      }\n    b must be >= 0def main (args:\u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m])\n  }\nerror while checking  {\n  \u001b[33mdef\u001b[0m \u001b[36mmodp\u001b[0m(\u001b[36mn\u001b[0m: \u001b[35mLong\u001b[0m, \u001b[36mp\u001b[0m: \u001b[35mLong\u001b[0m): \u001b[35mLong\u001b[0m = \n    {\n      \u001b[33mif \u001b[0m(n < 0) \n        {\n          \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[32m\"n must be >= 0\"\u001b[0m)\n        }\n      \u001b[33mif \u001b[0m(p < 0) \n        {\n          \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[32m\"p must be >= 0\"\u001b[0m)\n        }\n      \u001b[33mif \u001b[0m(p == 0) \n        {\n          \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[32m\"p must be > 0\"\u001b[0m)\n        }\n      \u001b[33mif \u001b[0m(n == 0) \n        {\n          \u001b[33mreturn\u001b[0m \u001b[31m0L\u001b[0m\n        }\n      \u001b[33mreturn\u001b[0m (n * (n % p)) % p\n    }\n  \u001b[33mdef\u001b[0m \u001b[36mgcd\u001b[0m(\u001b[36ma\u001b[0m: \u001b[35mLong\u001b[0m, \u001b[36mb\u001b[0m: \u001b[35mLong\u001b[0m): \u001b[35mLong\u001b[0m = \n    {\n      \u001b[33mif \u001b[0m(a < 0) \n    ",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpk2337w4h.scala:71:47 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m            \u001b[33mthrow\u001b[0m \u001b[33mnew\u001b[0m \u001b[35mIllegalArgumentException\u001b[0m(\"b must be >= 0\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               unclosed string literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmpk2337w4h.scala:73:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 end of statement expected but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpk2337w4h.scala:84:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\nexception occurred while parser /tmp/tmpk2337w4h.scala\nexception occurred while compiling /tmp/tmpk2337w4h.scala\nException in thread \"main\" java.lang.AssertionError: assertion failed: position error, parent span does not contain child span\nparent      = \u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[31mnull\u001b[0m) # -1,\nparent span = <1747..1791>,\nchild       = \u001b[31mnull\u001b[0m # -1,\nchild span  = [1776..1796..1796]\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:8)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:172)\n\tat dotty.tools.dotc.ast.Positioned.check$1$$anonfun$3(Positioned.scala:202)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)\n\tat scala.collection.immutable.List.foreach(List.scala:333)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:202)\n\tat dotty.tools.dotc.ast.Positioned.checkPos(Positioned.scala:223)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:197)\n\tat dotty.tools.dotc.ast.Positioned.checkPos(Positioned.scala:223)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:197)\n\tat dotty.tools.dotc.",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0) {\n            0l\n        } else if (n < 0) {\n            modp(-n, p)\n        } else {\n            n % p\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(3l, 0l)\n    // (3l)\n    // >>> gcd(0l, 0l)\n    // (0l)\n    // >>> gcd(3l, 11l)\n    // (1l)\n    // >>> gcd(100l, 101l)\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0) {\n            a\n        } else {\n            gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(3l, 0l)\n    // (0l)\n    // >>> lcm(0l, 0l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (33l)\n    // >>> lcm(100l, 101l)\n    // (101l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (b == 0) {\n            0l\n        } else {\n            a * (b / gcd(a, b))\n        }\n    }\n\n    // Return the sum of a and b.\n    // >>> add(3l, 5l)\n    // (8l)\n    // >>> add(3l, 0l)\n    // (3l)\n    // >>> add(0l, 0l)\n    // (0l)\n    // >>> add(3l, 11l)\n    // (14l)\n    // >>> add(100l, 101l)\n    // (201l)\n    def add(a : Long, b : Long) : Long = {\n        a + b\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293339,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpd1gclk7q.scala:79)\n\tat Problem.main(tmpd1gclk7q.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val nn = n.toInt\n        val pp = p.toInt\n        if (nn >= 0 && pp >= 0) {\n            val r = nn % pp\n            if (r == 0) {\n                return nn\n            } else {\n                return r\n            }\n        } else {\n            throw new IllegalArgumentException(\"n and p must be >= 0\")\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (101l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        val aa = a.toInt\n        val bb = b.toInt\n        if (aa >= 0 && bb >= 0) {\n            val r = gcd(aa, bb)\n            if (r == 0) {\n                return r\n            } else {\n                return r\n            }\n        } else {\n            throw new IllegalArgumentException(\"a and b must be >= 0\")\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (3l)\n    // >>> lcm((100l), (101l))\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        val aa = a.toInt\n        val bb = b.toInt\n        if (aa >= 0 && bb >= 0) {\n            val r = lcm(\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293340,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp8jdogmq6.scala:71:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mr\u001b[0m = lcm(\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8jdogmq6.scala:84:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8jdogmq6.scala:83:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmp8jdogmq6.scala:73:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m73 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val nn = n.mod(p)\n        if (nn == 0) {\n            nn = p\n        }\n        return nn\n    }\n\n    // Return the number of bits set in the integer n.\n    // >>> bitcount(3l)\n    // 2\n    // >>> bitcount(1101l)\n    // 3\n    // >>> bitcount(0l)\n    // 0\n    // >>> bitcount(3l)\n    // 2\n    // >>> bitcount(100l)\n    // 1\n    def bitcount(n : Long) : Long = {\n        val nn = n.toInt\n        if (nn == 0) {\n            return 0\n        }\n        return 1 + bitcount(nn.shiftRight(1).and(1l << nn.intValue()))\n    }\n\n    // Return the number of bits set in the integer n.\n    // >>> bitcount(3l)\n    // 2\n    // >>> bitcount(1101l)\n    // 3\n    // >>> bitcount(0l)\n    // 0\n    // >>> bitcount(3l)\n    // 2\n    // >>> bitcount(100l)\n    // 1\n    def bitcount2(n : Long) : Long = {\n        val nn = n.toInt\n        if (nn == 0) {\n            return 0\n        }\n        return 1 + bitcount2(nn.shiftRight(1).and(1l << nn.intValue()))\n    }\n\n    // Return the number of bits set in the integer n.\n    // >>> bitcount(3l)\n    // 2\n    // >>> bitcount(1101l)\n    // 3\n    // >>> bitcount(0l)\n    // 0\n    // >>> bitcount(3l)\n    // 2\n    // >>> bitcount(100l)\n    // 1\n    def bitcount3(n : Long) : Long = {\n        val nn = n.toInt\n        if (nn == 0) {\n            return 0\n        }\n        return 1 + bitcount3(nn.shiftRight(1).and(1l << nn.intValue()))\n    }\n\n    // Return the number of\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293341,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmppwbh3aoz.scala:92:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppwbh3aoz.scala:16:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnn\u001b[0m = n.mod(p)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue mod is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.long2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmppwbh3aoz.scala:18:15 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            nn = p\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val nn\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppwbh3aoz.scala:39:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mreturn\u001b[0m \u001b[31m1\u001b[0m + bitcount(nn.shiftRight(\u001b[31m1\u001b[0m).and(\u001b[31m1l\u001b[0m << nn.intValue()))\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            value shiftRight is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppwbh3aoz.scala:58:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m        \u001b[33mreturn\u001b[0m \u001b[31m1\u001b[0m + bitcount2(nn.shiftRight(\u001b[31m1\u001b[0m).and(\u001b[31m1l\u001b[0m << nn.intValue()))\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             value shiftRight is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppwbh3aoz.scala:77:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m        \u001b[33mreturn\u001b[0m \u001b[31m1\u001b[0m + bitcount3(nn.shiftRight(\u001b[31m1\u001b[0m).and(\u001b[31m1l\u001b[0m << nn.intValue()))\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             value shiftRight is not a member of Int\n\u001b[31m\u001b[31m-- [E00",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(5l, 7l)\n    // (1l)\n    // >>> gcd(5l, 0l)\n    // (5l)\n    // >>> gcd(0l, 0l)\n    // (0l)\n    // >>> gcd(0l, 5l)\n    // (5l)\n    // >>> gcd(5l, 5l)\n    // (5l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            return a\n        } else {\n            return gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(5l, 7l)\n    // (35l)\n    // >>> lcm(5l, 0l)\n    // (5l)\n    // >>> lcm(0l, 0l)\n    // (0l)\n    // >>> lcm(0l, 5l)\n    // (0l)\n    // >>> lcm(5l, 5l)\n    // (5l)\n    def lcm(a : Long, b : Long) : Long = {\n        return (a * b) / gcd(a, b)\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(123l)\n    // (3l)\n    // >>> sumDigits(0l)\n    // (0l)\n    // >>> sumDigits(-123l)\n    // (0l)\n    def sumDigits(n : Long) : Long = {\n        return n % 10l\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(123l)\n    // (3l)\n    // >>> sumDigits(0l)\n    // (0l)\n    // >>> sumDigits(-123l)\n    // (0l)\n    def sumDigits(n : Long) : Long = {\n        return n % 10l\n    }\n\n    //\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293337,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpyxjzrx1z.scala:87:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E120] Naming Error: /tmp/tmpyxjzrx1z.scala:71:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36msumDigits\u001b[0m(\u001b[36mn\u001b[0m : \u001b[35mLong\u001b[0m) : \u001b[35mLong\u001b[0m = {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mDouble definition:\n\u001b[31m   |\u001b[0mdef sumDigits(n: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 60 and\n\u001b[31m   |\u001b[0mdef sumDigits(n: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 71\n\u001b[31m   |\u001b[0mhave the same type after erasure.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mConsider adding a @targetName annotation to one of the conflicting definitions\n\u001b[31m   |\u001b[0mfor disambiguation.\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyxjzrx1z.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyxjzrx1z.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyxjzrx1z.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyxjzrx1z.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m         ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the number of bits set in the given long.\n    // >>> countBits(0l)\n    // 0\n    // >>> countBits(1l)\n    // 1\n    // >>> countBits(2l)\n    // 2\n    // >>> countBits(3l)\n    // 2\n    // >>> countBits(4l)\n    // 3\n    // >>> countBits(5l)\n    // 3\n    // >>> countBits(6l)\n    // 4\n    // >>> countBits(7l)\n    // 4\n    // >>> countBits(8l)\n    // 5\n    // >>> countBits(9l)\n    // 5\n    // >>> countBits(10l)\n    // 6\n    // >>> countBits(11l)\n    // 6\n    // >>> countBits(12l)\n    // 7\n    // >>> countBits(13l)\n    // 7\n    // >>> countBits(14l)\n    // 8\n    // >>> countBits(15l)\n    // 8\n    // >>> countBits(16l)\n    // 9\n    // >>> countBits(17l)\n    // 9\n    // >>> countBits(18l)\n    // 10\n    // >>> countBits(19l)\n    // 10\n    // >>> countBits(20l)\n    // 11\n    // >>> countBits(21l)\n    // 11\n    // >>> countBits(22l)\n    // 12\n    // >>> countBits(23l)\n    // 12\n    // >>> countBits(24l)\n    // 13\n    // >>> countBits(25l)\n    // 13\n    // >>> countBits(26l)\n    // 14\n    // >>> countBits(27l)\n    // 14\n    // >>> countBits(28l)\n    // 15\n    // >>> countBits(29l)\n    // 15\n    // >>> countBits(30l)\n    // 16\n    // >>> countBits(31l)\n    // 16\n    // >>> countBits(32l)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293338,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3h30mkoq.scala:96:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m96 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3h30mkoq.scala:87:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3h30mkoq.scala:88:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3h30mkoq.scala:89:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m89 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3h30mkoq.scala:90:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m90 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3h30mkoq.scala:91:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m91 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3h30mkoq.scala:92:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppqmnk7x9.scala:20)\n\tat Problem.main(tmppqmnk7x9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val m = n % p\n        if (m < 0) {\n            m += p\n        }\n        return m\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((5l), (7l))\n    // (1l)\n    // >>> gcd((-5l), (7l))\n    // (1l)\n    // >>> gcd((5l), (-7l))\n    // (1l)\n    // >>> gcd((-5l), (-7l))\n    // (1l)\n    // >>> gcd((0l), (0l))\n    // (0l)\n    // >>> gcd((-5l), (0l))\n    // (5l)\n    // >>> gcd((0l), (-5l))\n    // (5l)\n    // >>> gcd((-5l), (-7l))\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            return b\n        }\n        if (b == 0) {\n            return a\n        }\n        val g = gcd(b, a % b)\n        return g\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((5l), (7l))\n    // (35l)\n    // >>> lcm((-5l), (7l))\n    // (-35l)\n    // >>> lcm((5l), (-7l))\n    // (-35l)\n    // >>> lcm((-5l), (-7l))\n    // (35l)\n    // >>> lcm((0l), (0l))\n    // (0l)\n    // >>> lcm((-5l), (0l))\n    // (-5l)\n    // >>> lcm((0l), (-5l))\n    // (0l)\n    // >>> lcm((-5l), (-7l))\n    // (-7l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            return 0\n        }\n        if (\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293341,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp7e46x0g6.scala:72:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m        \u001b[33mif\u001b[0m (\n\u001b[31m\u001b[31m   |\u001b[0m            ^\u001b[0m\n\u001b[31m   |\u001b[0m            expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7e46x0g6.scala:18:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            m += p\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean m.!=?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n * (n - 1)) % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((5l), (7l))\n    // (1l)\n    // >>> gcd((-5l), (7l))\n    // (1l)\n    // >>> gcd((5l), (-7l))\n    // (1l)\n    // >>> gcd((-5l), (-7l))\n    // (1l)\n    // >>> gcd((0l), (7l))\n    // (7l)\n    // >>> gcd((0l), (-7l))\n    // (7l)\n    // >>> gcd((-5l), (0l))\n    // (5l)\n    // >>> gcd((-5l), (-0l))\n    // (5l)\n    // >>> gcd((0l), (0l))\n    // (0l)\n    // >>> gcd((-5l), (0l))\n    // (5l)\n    // >>> gcd((0l), (-0l))\n    // (0l)\n    // >>> gcd((-5l), (-0l))\n    // (5l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a must be >= 0\")\n        }\n        if (b < 0) {\n            throw new IllegalArgumentException(\"b must be >= 0\")\n        }\n        if (a == 0) {\n            return b\n        }\n        if (b == 0) {\n            return a\n        }\n        return gcd(b, a % b)\n    }\n\n    // Return the least common\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293339,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_vw2t06w.scala:84:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_vw2t06w.scala:75:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_vw2t06w.scala:76:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_vw2t06w.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_vw2t06w.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_vw2t06w.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_vw2t06w.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new RuntimeException(\"n must be a non-negative number\")\n        }\n        if (p < 0l) {\n            throw new RuntimeException(\"p must be a non-negative number\")\n        }\n        if (p == 0l) {\n            throw new RuntimeException(\"p must be a non-zero number\")\n        }\n        if (n == 0l) {\n            return 0l\n        }\n        return (n * (n - 1l) / 2l) % p\n    }\n\n    // Return the sum of the squares of the first n natural numbers.\n    // >>> sum_of_squares(0)\n    // 0\n    // >>> sum_of_squares(1)\n    // 1\n    // >>> sum_of_squares(2)\n    // 5\n    // >>> sum_of_squares(3)\n    // 14\n    // >>> sum_of_squares(4)\n    // 30\n    // >>> sum_of_squares(5)\n    // 55\n    // >>> sum_of_squares(6)\n    // 132\n    // >>> sum_of_squares(7)\n    // 221\n    // >>> sum_of_squares(8)\n    // 352\n    // >>> sum_of_squares(9)\n    // 683\n    // >>> sum_of_squares(10)\n    // 1396\n    def sum_of_squares(n : Int) : Int = {\n        if (n < 0) {\n            throw new RuntimeException(\"n must be a non-negative number\")\n        }\n        if (n == 0) {\n            return 0\n        }\n        return (n * (n + 1) * (2 * n + 1)) / 6\n    }\n\n    // Return the sum of the squares of the first n natural numbers.\n    // >>> sum_of_squares_mod_p(0, (5l))\n    // 0\n    // >>> sum_of_squares_mod_p(1, (5l))\n    // 1\n    // >>> sum_of_squares_mod_p(2, (5l))\n    // 5\n    // >>> sum\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293339,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp59f6br1z.scala:83:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp59f6br1z.scala:74:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp59f6br1z.scala:75:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp59f6br1z.scala:76:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp59f6br1z.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp59f6br1z.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp59f6br1z.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(123l)\n    // 3\n    // >>> sumDigits(1234l)\n    // 4\n    // >>> sumDigits(12345l)\n    // 5\n    // >>> sumDigits(123456l)\n    // 6\n    // >>> sumDigits(1234567l)\n    // 7\n    // >>> sumDigits(12345678l)\n    // 8\n    def sumDigits(n : Long) : Long = {\n        n % 10\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(123l)\n    // 3\n    // >>> sumDigits(1234l)\n    // 4\n    // >>> sumDigits(12345l)\n    // 5\n    // >>> sumDigits(123456l)\n    // 6\n    // >>> sumDigits(1234567l)\n    // 7\n    // >>> sumDigits(12345678l)\n    // 8\n    def sumDigits(n : Long) : Long = {\n        n % 10\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(123l)\n    // 3\n    // >>> sumDigits(1234l)\n    // 4\n    // >>> sumDigits(12345l)\n    // 5\n    // >>> sumDigits(123456l)\n    // 6\n    // >>> sumDigits(1234567l)\n    // 7\n    // >>> sumDigits(12345678l)\n    // 8\n    def sumDigits(n : Long) : Long = {\n        n % 10\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(123l)\n    // 3\n    // >>> sumDigits(1234l)\n    // 4\n    // >>> sumDigits(12345l)\n    // 5\n    // >>> sumDigits(123456l)\n    // 6\n    // >>> sumDigits(1234567l)\n    // 7\n    // >>> sumDigits(12345678l)\n    // 8\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293340,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpx959swoh.scala:94:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m94 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E120] Naming Error: /tmp/tmpx959swoh.scala:49:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36msumDigits\u001b[0m(\u001b[36mn\u001b[0m : \u001b[35mLong\u001b[0m) : \u001b[35mLong\u001b[0m = {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mDouble definition:\n\u001b[31m   |\u001b[0mdef sumDigits(n: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 32 and\n\u001b[31m   |\u001b[0mdef sumDigits(n: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 49\n\u001b[31m   |\u001b[0mhave the same type after erasure.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mConsider adding a @targetName annotation to one of the conflicting definitions\n\u001b[31m   |\u001b[0mfor disambiguation.\n\u001b[31m\u001b[31m-- [E120] Naming Error: /tmp/tmpx959swoh.scala:66:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m66 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36msumDigits\u001b[0m(\u001b[36mn\u001b[0m : \u001b[35mLong\u001b[0m) : \u001b[35mLong\u001b[0m = {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mDouble definition:\n\u001b[31m   |\u001b[0mdef sumDigits(n: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 49 and\n\u001b[31m   |\u001b[0mdef sumDigits(n: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 66\n\u001b[31m   |\u001b[0mhave the same type after erasure.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mConsider adding a @targetName annotation to one of the conflicting definitions\n\u001b[31m   |\u001b[0mfor disambiguation.\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpx959swoh.scala:85:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpx959swoh.scala:86:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        if (p == 1) {\n            return n\n        }\n        return (n * modp(n - 1, p)) % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // 1l\n    // >>> gcd(11l, 101l)\n    // 101l\n    // >>> gcd(0l, 101l)\n    // 101l\n    // >>> gcd(3l, 11l)\n    // 1l\n    // >>> gcd(100l, 101l)\n    // 101l\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a must be >= 0\")\n        }\n        if (b < 0) {\n            throw new IllegalArgumentException(\"b must be >= 0\")\n        }\n        if (a == 0) {\n            return b\n        }\n        if (b == 0) {\n            return a\n        }\n        return gcd(b, a % b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // 15l\n    // >>> lcm(11l, 101l)\n    // 101l\n    // >>> lcm(0l, 101l)\n    // 0l\n    // >>> lcm(3l, 11l)\n    // 3l\n    // >>> lcm(100l, 101l)\n    // 100l\n    def lcm(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a must be >= 0\")\n        }\n        if (b < 0\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293341,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpa4n46fh5.scala:77:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0) {\n            0l\n        } else if (n < 0) {\n            modp(-n, p)\n        } else if (p == 0) {\n            n\n        } else if (p < 0) {\n            modp(n, -p)\n        } else {\n            n % p\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // 1l\n    // >>> gcd(3l, 0l)\n    // 3l\n    // >>> gcd(0l, 0l)\n    // 0l\n    // >>> gcd(3l, -5l)\n    // 5l\n    // >>> gcd(-3l, 5l)\n    // 1l\n    // >>> gcd(-3l, 0l)\n    // 3l\n    // >>> gcd(0l, 0l)\n    // 0l\n    // >>> gcd(-3l, -5l)\n    // 5l\n    // >>> gcd(-3l, -0l)\n    // 3l\n    // >>> gcd(-0l, -0l)\n    // 0l\n    // >>> gcd(-3l, 5l)\n    // 1l\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0) {\n            a\n        } else {\n            gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // 15l\n    // >>> lcm(3l, 0l)\n    // 0l\n    // >>> lcm(0l, 0l)\n    // 0l\n    // >>> lcm(3l, -5l)\n    // -15l\n    // >>> lcm(-3l, 5l)\n    // -15l\n    // >>> lcm(-3l, 0l)\n    // 0l\n    // >>> lcm(0l, 0l)\n    // 0l\n    // >>> lcm(-3l, -5l)\n    // -\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293340,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpai8vzjir.scala:88:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpai8vzjir.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpai8vzjir.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpai8vzjir.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpai8vzjir.scala:82:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpai8vzjir.scala:83:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpai8vzjir.scala:84:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(3l, 6l)\n    // (3l)\n    // >>> gcd(3l, 0l)\n    // (1l)\n    // >>> gcd(0l, 0l)\n    // (0l)\n    // >>> gcd(3l, -3l)\n    // (1l)\n    // >>> gcd(3l, -6l)\n    // (3l)\n    // >>> gcd(-3l, -6l)\n    // (3l)\n    // >>> gcd(-3l, -6l)\n    // (3l)\n    // >>> gcd(-3l, 6l)\n    // (3l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            a\n        } else {\n            gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(3l, 6l)\n    // (18l)\n    // >>> lcm(3l, 0l)\n    // (0l)\n    // >>> lcm(0l, 0l)\n    // (0l)\n    // >>> lcm(3l, -3l)\n    // (-3l)\n    // >>> lcm(3l, -6l)\n    // (0l)\n    // >>> lcm(-3l, -6l)\n    // (-6l)\n    // >>> lcm(-3l, -6l)\n    // (-6l)\n    // >>> lcm(-3l, 6l)\n    // (0l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            a\n        } else {\n            lcm(b, a / b) * b\n        }\n    }\n\n\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293340,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_lkrlzvt.scala:85:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_lkrlzvt.scala:76:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_lkrlzvt.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_lkrlzvt.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_lkrlzvt.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_lkrlzvt.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_lkrlzvt.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0) {\n            0l\n        } else {\n            n % p\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(11l, 101l)\n    // (1l)\n    // >>> gcd(0l, 101l)\n    // (101l)\n    // >>> gcd(3l, 11l)\n    // (1l)\n    // >>> gcd(100l, 101l)\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            b\n        } else {\n            gcd(b % a, a)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(11l, 101l)\n    // (101l)\n    // >>> lcm(0l, 101l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (33l)\n    // >>> lcm(100l, 101l)\n    // (101l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            0l\n        } else {\n            a * (b / gcd(a, b))\n        }\n    }\n\n    // Return the sum of the squares of the first n natural numbers.\n    // >>> sum_of_squares(0)\n    // (0l)\n    // >>> sum_of_squares(1)\n    // (1l)\n    // >>> sum_of_squares(2)\n    // (5l)\n    // >>> sum_of_squares(3)\n    // (14l)\n    def sum_of_squares(n : Long) : Long = {\n        if (n == 0) {\n            0l\n        } else {\n            n * (n + 1) / 2\n        }\n    \n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293344,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpwxqu17hd.scala:80)\n\tat Problem.main(tmpwxqu17hd.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppqmnk7x9.scala:20)\n\tat Problem.main(tmppqmnk7x9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val nn = n.toInt\n        val pp = p.toInt\n        val r = nn % pp\n        if (r == 0) {\n            return nn\n        } else {\n            return r\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (101l)\n    // >>> gcd((0l), (101l))\n    // (1l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (101l)\n    def gcd(a : Long, b : Long) : Long = {\n        val aa = a.toInt\n        val bb = b.toInt\n        if (aa == 0) {\n            return bb\n        } else if (bb == 0) {\n            return aa\n        } else {\n            return gcd(bb, aa % bb)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (11l)\n    // >>> lcm((100l), (101l))\n    // (101l)\n    def lcm(a : Long, b : Long) : Long = {\n        val aa = a.toInt\n        val bb = b.toInt\n        if (aa == 0) {\n            return 0l\n        } else if (bb == 0) {\n            return 0l\n        } else {\n            return aa * bb / gcd(aa, bb)\n        }\n    }\n\n    // Return the sum of a and b.\n    // >>> add((3l), (5l))\n    //\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293342,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpn4dooun4.scala:86:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn4dooun4.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn4dooun4.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn4dooun4.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn4dooun4.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn4dooun4.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn4dooun4.scala:82:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val nn = n.toInt\n        val pp = p.toInt\n        if (nn < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (pp < 0) {\n            throw new IllegalArgumentException(\"p must be non-negative\")\n        }\n        if (nn >= pp) {\n            throw new IllegalArgumentException(\"n must be less than p\")\n        }\n        return (nn % pp).toInt\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(11l, 101l)\n    // (1l)\n    // >>> gcd(0l, 101l)\n    // (101l)\n    // >>> gcd(3l, 11l)\n    // (1l)\n    // >>> gcd(100l, 101l)\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        val aa = a.toInt\n        val bb = b.toInt\n        if (aa < 0) {\n            throw new IllegalArgumentException(\"a must be non-negative\")\n        }\n        if (bb < 0) {\n            throw new IllegalArgumentException(\"b must be non-negative\")\n        }\n        if (aa >= bb) {\n            throw new IllegalArgumentException(\"a must be less than b\")\n        }\n        return (aa % bb).toInt\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(11l, 101l)\n    // (101l)\n    // >>> lcm(0l, 101l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (3l)\n    // >>> lcm(100l, 101l)\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        val aa = a.toInt\n        val b\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293344,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp13mzt554.scala:70:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m70 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp13mzt554.scala:70:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m70 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val nn = n.mod(p)\n        if (nn.isZero()) {\n            nn = p\n        }\n        nn\n    }\n\n    // Return the greatest common divisor of two numbers.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(11l, 101l)\n    // (1l)\n    // >>> gcd(0l, 101l)\n    // (101l)\n    // >>> gcd(3l, 11l)\n    // (1l)\n    // >>> gcd(100l, 101l)\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        val aa = a.abs()\n        val bb = b.abs()\n        if (aa.equals(bb)) {\n            if (aa.isZero()) {\n                aa = bb\n            }\n        } else {\n            if (aa.isZero()) {\n                aa = bb\n            } else if (bb.isZero()) {\n                bb = aa\n            } else {\n                val aa_bb = aa.div(bb)\n                val bb_aa = bb.div(aa)\n                aa = aa_bb\n                bb = bb_aa\n            }\n        }\n        aa\n    }\n\n    // Return the least common multiple of two numbers.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(11l, 101l)\n    // (101l)\n    // >>> lcm(0l, 101l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (3l)\n    // >>> lcm(100l, 101l)\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        val aa = a.abs()\n        val bb = b.abs()\n        if (aa.equals(bb)) {\n            if (aa.isZero()) {\n                aa = bb\n            }\n        } else {\n            if (aa.\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293346,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpja9blhxm.scala:76:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpja9blhxm.scala:88:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpja9blhxm.scala:16:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnn\u001b[0m = n.mod(p)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue mod is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.long2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpja9blhxm.scala:18:15 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            nn = p\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val nn\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpja9blhxm.scala:35:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36maa\u001b[0m = a.abs()\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 \u001b[33mmethod\u001b[0m \u001b[35mabs\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mRichLong\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpja9blhxm.scala:36:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbb\u001b[0m = b.abs()\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 \u001b[33mmethod\u001b[0m \u001b[35mabs\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mRichLong\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpja9blhxm.scala:39:19 -----------------------------\u001b[0m\u001b[0m\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val nn = n.toInt\n        val pp = p.toInt\n        if (nn < 0) {\n            throw new IllegalArgumentException(\"n must be a non-negative integer\")\n        }\n        if (pp < 0) {\n            throw new IllegalArgumentException(\"p must be a non-negative integer\")\n        }\n        if (nn == 0) {\n            return 0l\n        }\n        if (nn == 1) {\n            return 1l\n        }\n        if (nn == 2) {\n            return 2l\n        }\n        if (nn == 3) {\n            return 3l\n        }\n        if (nn == 4) {\n            return 4l\n        }\n        if (nn == 5) {\n            return 5l\n        }\n        if (nn == 6) {\n            return 6l\n        }\n        if (nn == 7) {\n            return 7l\n        }\n        if (nn == 8) {\n            return 8l\n        }\n        if (nn == 9) {\n            return 9l\n        }\n        if (nn == 10) {\n            return 10l\n        }\n        if (nn == 11) {\n            return 11l\n        }\n        if (nn == 12) {\n            return 12l\n        }\n        if (nn == 13) {\n            return 13l\n        }\n        if (nn == 14) {\n            return 14l\n        }\n        if (nn == 15) {\n            return 15l\n        }\n        if (nn == 16) {\n            return 16l\n        }\n        if (nn == 17) {\n            return 17l\n        }\n        if (nn == 18) {\n            return 18l\n        }\n        if (nn == 19) {\n            return 19l\n        }\n        if (nn == 20) {\n            return 20l\n        }\n        if (nn == 21) {\n            return 21l\n        }\n        if (nn == 22) {\n            return 22l\n        }\n        if (nn == 23) {\n            return 23l\n        }\n        if (nn == 24) {\n            return 24l\n        }\n        if (nn == 25) {\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293346,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpu0u5graq.scala:112:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m112 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu0u5graq.scala:111:1 --------------------\u001b[0m\u001b[0m\n\u001b[31m111 |\u001b[0m}\n\u001b[31m\u001b[31m    |\u001b[0m ^\u001b[0m\n\u001b[31m    |\u001b[0m Found:    Unit\n\u001b[31m    |\u001b[0m Required: Long\n\u001b[31m    |\u001b[0m\n\u001b[31m    |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpu0u5graq.scala:101:4 ---------------------------------------\u001b[0m\u001b[0m\n\u001b[33m101 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m    |\u001b[0m    ^\u001b[0m\n\u001b[33m    |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppqmnk7x9.scala:20)\n\tat Problem.main(tmppqmnk7x9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new RuntimeException(\"Negative numbers not supported\")\n        }\n        if (p < 0) {\n            throw new RuntimeException(\"Negative numbers not supported\")\n        }\n        if (p == 0) {\n            throw new RuntimeException(\"Zero modulus not supported\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n % p) + (n / p) * (p - 1l)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293346,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_zle6hzi.scala:32)\n\tat Problem.main(tmp_zle6hzi.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(11l, 101l)\n    // (1l)\n    // >>> gcd(0l, 101l)\n    // (101l)\n    // >>> gcd(3l, 11l)\n    // (1l)\n    // >>> gcd(100l, 101l)\n    // (101l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            a\n        } else {\n            gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(11l, 101l)\n    // (101l)\n    // >>> lcm(0l, 101l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (33l)\n    // >>> lcm(100l, 101l)\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        a * b / gcd(a, b)\n    }\n\n    // Return the sum of the squares of the first n natural numbers.\n    // >>> sum_of_squares(0)\n    // (0l)\n    // >>> sum_of_squares(1)\n    // (1l)\n    // >>> sum_of_squares(2)\n    // (5l)\n    // >>> sum_of_squares(3)\n    // (14l)\n    def sum_of_squares(n : Long) : Long = {\n        n * (n + 1) / 2\n    }\n\n    // Return the sum of the first n natural numbers.\n    // >>> sum(0)\n    // (0l)\n    // >>> sum(1)\n    // (1l)\n    // >>> sum(2)\n    // (3l)\n    // >>>\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293342,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmphv86tljt.scala:85:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphv86tljt.scala:76:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphv86tljt.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphv86tljt.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphv86tljt.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphv86tljt.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphv86tljt.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppqmnk7x9.scala:20)\n\tat Problem.main(tmppqmnk7x9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new RuntimeException(\"n must be a non-negative number\")\n        }\n        if (p < 0) {\n            throw new RuntimeException(\"p must be a non-negative number\")\n        }\n        if (p == 0) {\n            throw new RuntimeException(\"p must be a non-zero number\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n * (n % p)) % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(11l, 101l)\n    // (1l)\n    // >>> gcd(0l, 101l)\n    // (101l)\n    // >>> gcd(3l, 11l)\n    // (1l)\n    // >>> gcd(100l, 101l)\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new RuntimeException(\"a must be a non-negative number\")\n        }\n        if (b < 0) {\n            throw new RuntimeException(\"b must be a non-negative number\")\n        }\n        if (a == 0) {\n            return b\n        }\n        if (b == 0) {\n            return a\n        }\n        return gcd(b, a % b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(11l, 101l)\n    // (101l)\n    // >>> lcm(0l, 101l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (3l)\n    // >>> lcm(100l, 101l)\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new RuntimeException(\"a must be a non-negative number\")\n        }\n\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293345,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7sv5ujcd.scala:70:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m70 |\u001b[0m        \u001b[33mif\u001b[0m (a < \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Unit\n\u001b[31m   |\u001b[0m        Required: Long\n\u001b[31m   |\u001b[0m        Maybe you are missing an else part for the conditional?\n\u001b[31m71 |\u001b[0m            \u001b[33mthrow\u001b[0m \u001b[33mnew\u001b[0m \u001b[35mRuntimeException\u001b[0m(\u001b[31m\"a must be a non-negative number\"\u001b[0m)\n\u001b[31m72 |\u001b[0m        }\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // 5l\n    // >>> gcd(3l, 6l)\n    // 3l\n    // >>> gcd(3l, 0l)\n    // 3l\n    // >>> gcd(0l, 0l)\n    // 0l\n    // >>> gcd(3l, -3l)\n    // 3l\n    // >>> gcd(-3l, 0l)\n    // 3l\n    // >>> gcd(0l, -3l)\n    // 3l\n    // >>> gcd(-3l, -3l)\n    // 3l\n    // >>> gcd(-3l, -6l)\n    // 3l\n    // >>> gcd(-6l, -3l)\n    // 3l\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            return a\n        } else {\n            return gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // 15l\n    // >>> lcm(3l, 6l)\n    // 18l\n    // >>> lcm(3l, 0l)\n    // 0l\n    // >>> lcm(0l, 0l)\n    // 0l\n    // >>> lcm(3l, -3l)\n    // -3l\n    // >>> lcm(-3l, 0l)\n    // 0l\n    // >>> lcm(0l, -3l)\n    // -3l\n    // >>> lcm(-3l, -3l)\n    // -3l\n    // >>> lcm(-3l, -6l)\n    // -6l\n    // >>> lcm(-6l, -3l)\n    // -6l\n    def lcm(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            return a\n        } else {\n            return a * b / gcd(\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293348,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp26b24hv1.scala:73:31 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m            \u001b[33mreturn\u001b[0m a * b / gcd(\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp26b24hv1.scala:86:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp26b24hv1.scala:85:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmp26b24hv1.scala:75:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m75 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0) {\n            0l\n        } else if (n < 0) {\n            modp(-n, p)\n        } else if (n > p) {\n            n % p\n        } else {\n            n\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // 1l\n    // >>> gcd(11l, 101l)\n    // 101l\n    // >>> gcd(0l, 101l)\n    // 1l\n    // >>> gcd(3l, 11l)\n    // 1l\n    // >>> gcd(100l, 101l)\n    // 101l\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            b\n        } else if (b == 0) {\n            a\n        } else {\n            gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // 15l\n    // >>> lcm(11l, 101l)\n    // 101l\n    // >>> lcm(0l, 101l)\n    // 0l\n    // >>> lcm(3l, 11l)\n    // 3l\n    // >>> lcm(100l, 101l)\n    // 100l\n    def lcm(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            0l\n        } else if (b == 0) {\n            0l\n        } else {\n            a * b / gcd(a, b)\n        }\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(123l)\n    // 3\n    // >>> sumDigits(1234l)\n    // 4\n    // >>> sumDigits(12345l)\n    // 5\n    // >>> sumDigits(123456l)\n    // 6\n    def sumDigits(n : Long) : Long = {\n        if (n == 0) {\n            0l\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293346,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpr91ejmpq.scala:79:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m        \u001b[33mif\u001b[0m (n == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Unit\n\u001b[31m   |\u001b[0m        Required: Long\n\u001b[31m   |\u001b[0m        Maybe you are missing an else part for the conditional?\n\u001b[31m80 |\u001b[0m            \u001b[31m0l\u001b[0m\n\u001b[31m81 |\u001b[0m        }\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n * (n - 1) / 2) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293328,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp9kalviu5.scala:32)\n\tat Problem.main(tmp9kalviu5.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (101l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (101l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            return b\n        } else {\n            return gcd(b % a, a)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (11l)\n    // >>> lcm((100l), (101l))\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        return a * b / gcd(a, b)\n    }\n\n    // Return the sum of the squares of the numbers in the list.\n    // >>> sumOfSquares([1, 2, 3])\n    // 14\n    // >>> sumOfSquares([1, 2, 3, 4])\n    // 26\n    def sumOfSquares(xs : List[Long]) : Long = {\n        var sum = 0l\n        for (x : Long) {\n            sum += x * x\n        }\n        return sum\n    }\n\n    // Return the sum of the products of the numbers in the list.\n    // >>> sumOfProducts([1, 2, 3])\n    // 14\n    // >>> sumOfProducts([1, 2, 3, 4])\n    // 24\n    def sumOfProducts(xs : List[Long]) : Long\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293349,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5frulpuz.scala:60:23 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m        \u001b[33mfor\u001b[0m (x : \u001b[35mLong\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       '<-' expected, but '{' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5frulpuz.scala:83:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5frulpuz.scala:62:9 -------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m         ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator asScala\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.set asScala\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E067] Syntax Error: /tmp/tmp5frulpuz.scala:71:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36msumOfProducts\u001b[0m(\u001b[36mxs\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m]) : \u001b[35mLong\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mDeclaration of \u001b[33mmethod\u001b[0m \u001b[35msumOfProducts\u001b[0m not allowed here: only classes can have declared but undefined members\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5frulpuz.scala:74:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m    assert(modp((\u001b[31m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0) {\n            0l\n        } else {\n            n % p\n        }\n    }\n\n    // Return the number of bits set in the given number.\n    // >>> bits(0l)\n    // 0\n    // >>> bits(1l)\n    // 1\n    // >>> bits(2l)\n    // 2\n    // >>> bits(3l)\n    // 2\n    // >>> bits(4l)\n    // 3\n    // >>> bits(5l)\n    // 3\n    // >>> bits(6l)\n    // 4\n    // >>> bits(7l)\n    // 4\n    // >>> bits(8l)\n    // 5\n    // >>> bits(9l)\n    // 5\n    // >>> bits(10l)\n    // 6\n    // >>> bits(11l)\n    // 6\n    // >>> bits(12l)\n    // 7\n    // >>> bits(13l)\n    // 7\n    // >>> bits(14l)\n    // 8\n    // >>> bits(15l)\n    // 8\n    // >>> bits(16l)\n    // 9\n    // >>> bits(17l)\n    // 9\n    // >>> bits(18l)\n    // 10\n    // >>> bits(19l)\n    // 10\n    // >>> bits(20l)\n    // 11\n    // >>> bits(21l)\n    // 11\n    // >>> bits(22l)\n    // 12\n    // >>> bits(23l)\n    // 12\n    // >>> bits(24l)\n    // 13\n    // >>> bits(25l)\n    // 13\n    // >>> bits(26l)\n    // 14\n    // >>> bits(27l)\n    // 14\n    // >>> bits(28l)\n    // 15\n    // >>> bits(29l)\n    // 15\n    // >>> bits(30l)\n    // 16\n    // >>> bits(31l)\n    // 16\n    // >>> bits(32l)\n    // 17\n    // >>> bits(33l)\n    // 17\n    // >>> bits(34l)\n    // 18\n    // >>> bits(35l)\n    // 18\n    \n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293345,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpuy93qugt.scala:108:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m108 |\u001b[0m}\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuy93qugt.scala:99:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m99 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuy93qugt.scala:100:11 -----------------------\u001b[0m\u001b[0m\n\u001b[31m100 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m    |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m    |\u001b[0m           Not found: modp\n\u001b[31m    |\u001b[0m\n\u001b[31m    |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuy93qugt.scala:101:11 -----------------------\u001b[0m\u001b[0m\n\u001b[31m101 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m    |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m    |\u001b[0m           Not found: modp\n\u001b[31m    |\u001b[0m\n\u001b[31m    |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuy93qugt.scala:102:11 -----------------------\u001b[0m\u001b[0m\n\u001b[31m102 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m    |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m    |\u001b[0m           Not found: modp\n\u001b[31m    |\u001b[0m\n\u001b[31m    |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuy93qugt.scala:103:11 -----------------------\u001b[0m\u001b[0m\n\u001b[31m103 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m    |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m    |\u001b[0m           Not found: modp\n\u001b[31m    |\u001b[0m\n\u001b[31m    |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuy93qugt.scala:104:11 -----------------------\u001b[0m\u001b[0m\n\u001b[31m104 |\u001b[0m    as",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0l) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0l) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0l) {\n            return 0l\n        }\n        return (n * (n - 1l) / 2l) % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(2l, 3l)\n    // (1l)\n    // >>> gcd(2l, 4l)\n    // (2l)\n    // >>> gcd(2l, 6l)\n    // (2l)\n    // >>> gcd(2l, 8l)\n    // (2l)\n    // >>> gcd(2l, 12l)\n    // (2l)\n    // >>> gcd(2l, 16l)\n    // (2l)\n    // >>> gcd(2l, 24l)\n    // (6l)\n    // >>> gcd(2l, 32l)\n    // (8l)\n    // >>> gcd(2l, 48l)\n    // (12l)\n    // >>> gcd(2l, 64l)\n    // (16l)\n    // >>> gcd(2l, 96l)\n    // (24l)\n    // >>> gcd(2l, 128l)\n    // (32l)\n    // >>> gcd(2l, 256l)\n    // (64l)\n    // >>> gcd(2l, 512l)\n    // (128l)\n    // >>> gcd(2l, 1024l)\n    // (256l)\n    // >>> gcd(2l, 2048l)\n    // (512l)\n    // >>> gcd(2l, 4096l)\n    // (1024l)\n    // >>> gcd(2l, 8192l)\n    // (2048l)\n    // >>> gcd(2l, 16384l\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293346,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3y6d5bcb.scala:80:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3y6d5bcb.scala:71:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3y6d5bcb.scala:72:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3y6d5bcb.scala:73:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3y6d5bcb.scala:74:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3y6d5bcb.scala:75:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3y6d5bcb.scala:76:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0) {\n            0l\n        } else {\n            n % p\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (101l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (101l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            b\n        } else {\n            gcd(b % a, a)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (33l)\n    // >>> lcm((100l), (101l))\n    // (101l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            0l\n        } else {\n            a * b / gcd(a, b)\n        }\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(123l)\n    // 3\n    // >>> sumDigits(1234l)\n    // 4\n    // >>> sumDigits(12345l)\n    // 5\n    // >>> sumDigits(123456l)\n    // 6\n    def sumDigits(n : Long) : Long = {\n        if (n == 0) {\n            0l\n        } else {\n            n % 10\n        }\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDig\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293346,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpy3bqgtc0.scala:91:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m91 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy3bqgtc0.scala:82:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy3bqgtc0.scala:83:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy3bqgtc0.scala:84:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy3bqgtc0.scala:85:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy3bqgtc0.scala:86:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy3bqgtc0.scala:87:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0l) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0l) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0l) {\n            return 0l\n        }\n        return (n % p) + (n / p) * p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (1l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0l) {\n            throw new IllegalArgumentException(\"a must be >= 0\")\n        }\n        if (b < 0l) {\n            throw new IllegalArgumentException(\"b must be >= 0\")\n        }\n        if (a == 0l) {\n            return b\n        }\n        if (b == 0l) {\n            return a\n        }\n        while (b != 0l) {\n            a = a % b\n            b = b % a\n        }\n        return a\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (11l)\n    // >>> lcm((100l), (101l))\n    // (100l)\n    def lcm(a : Long,\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293346,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpmguz6ogm.scala:74:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpmguz6ogm.scala:85:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpmguz6ogm.scala:56:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m            a = a % b\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val a\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpmguz6ogm.scala:57:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m            b = b % a\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val b\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmguz6ogm.scala:76:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmguz6ogm.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmguz6ogm.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E0",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (101l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (101l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0l) {\n            return b\n        } else {\n            return gcd(b % a, a)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (33l)\n    // >>> lcm((100l), (101l))\n    // (101l)\n    def lcm(a : Long, b : Long) : Long = {\n        return a * b / gcd(a, b)\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(123l)\n    // 3\n    // >>> sumDigits(1234l)\n    // 4\n    // >>> sumDigits(12345l)\n    // 5\n    def sumDigits(n : Long) : Long = {\n        return n % 10\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(123l)\n    // 3\n    // >>> sumDigits(1234l)\n    // 4\n    // >>> sumDigits(12345l)\n    // 5\n    def sumDigits(n : Long) : Long = {\n        return n % 10\n    }\n\n    // Return the sum of the digits\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293346,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpoh6wdxsv.scala:87:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E120] Naming Error: /tmp/tmpoh6wdxsv.scala:71:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36msumDigits\u001b[0m(\u001b[36mn\u001b[0m : \u001b[35mLong\u001b[0m) : \u001b[35mLong\u001b[0m = {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mDouble definition:\n\u001b[31m   |\u001b[0mdef sumDigits(n: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 60 and\n\u001b[31m   |\u001b[0mdef sumDigits(n: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 71\n\u001b[31m   |\u001b[0mhave the same type after erasure.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mConsider adding a @targetName annotation to one of the conflicting definitions\n\u001b[31m   |\u001b[0mfor disambiguation.\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpoh6wdxsv.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpoh6wdxsv.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpoh6wdxsv.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpoh6wdxsv.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m         ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0l) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0l) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        return (n % p)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293350,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpe41v89kg.scala:29)\n\tat Problem.main(tmpe41v89kg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val nn = n.toLong\n        val pp = p.toLong\n        val r = nn % pp\n        if (r == 0) {\n            r = pp\n        }\n        return r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293347,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpc14wq9vl.scala:20:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            r = pp\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val r\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val nn = n.toInt\n        val pp = p.toInt\n        val r = nn % pp\n        if (r == 0) {\n            r = pp\n        }\n        return r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293330,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpowgt9gxp.scala:20:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            r = pp\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val r\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (p < 0l) {\n            throw new IllegalArgumentException(\"p must be non-negative\")\n        }\n        if (p == 0l) {\n            throw new IllegalArgumentException(\"p must be non-zero\")\n        }\n        if (n == 0l) {\n            return 0l\n        }\n        return (n * (n - 1l) / 2l) % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293329,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp4b6t20x6.scala:32)\n\tat Problem.main(tmp4b6t20x6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n < 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p < 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p == 0\")\n        }\n        return (n * (n % p)) % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(11l, 101l)\n    // (1l)\n    // >>> gcd(0l, 101l)\n    // (101l)\n    // >>> gcd(3l, 11l)\n    // (1l)\n    // >>> gcd(100l, 101l)\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a < 0\")\n        }\n        if (b < 0) {\n            throw new IllegalArgumentException(\"b < 0\")\n        }\n        if (a == 0) {\n            return b\n        }\n        if (b == 0) {\n            return a\n        }\n        return gcd(b, a % b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(11l, 101l)\n    // (101l)\n    // >>> lcm(0l, 101l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (3l)\n    // >>> lcm(100l, 101l)\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a < 0\")\n        }\n        if (b < 0) {\n            throw new IllegalArgumentException(\"b < 0\")\n        }\n        if (a == 0) {\n            \n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293350,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7i6def4h.scala:87:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7i6def4h.scala:86:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmp7i6def4h.scala:76:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m76 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0) {\n            0\n        } else if (n < 0) {\n            modp(-n, p)\n        } else {\n            n % p\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(11l, 101l)\n    // (1l)\n    // >>> gcd(0l, 101l)\n    // (101l)\n    // >>> gcd(3l, 11l)\n    // (1l)\n    // >>> gcd(100l, 101l)\n    // (101l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            b\n        } else if (b == 0) {\n            a\n        } else {\n            gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(11l, 101l)\n    // (101l)\n    // >>> lcm(0l, 101l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (33l)\n    // >>> lcm(100l, 101l)\n    // (101l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            0\n        } else if (b == 0) {\n            0\n        } else {\n            a * b / gcd(a, b)\n        }\n    }\n\n    // Return the sum of a and b.\n    // >>> add(3l, 5l)\n    // (8l)\n    // >>> add(11l, 101l)\n    // (112l)\n    // >>> add(0l, 101l)\n    // (101l)\n    // >>> add(3l, 11l)\n    // (14l)\n    // >>> add(100l, 101l)\n    // (\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293346,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp6zntjryr.scala:89:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m89 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6zntjryr.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6zntjryr.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6zntjryr.scala:82:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6zntjryr.scala:83:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6zntjryr.scala:84:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6zntjryr.scala:85:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0l) {\n            0l\n        } else {\n            (n * 2l) % p\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (101l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0l) {\n            b\n        } else {\n            gcd(b % a, a)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (11l)\n    // >>> lcm((100l), (101l))\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a == 0l) {\n            0l\n        } else {\n            (a * b) / gcd(a, b)\n        }\n    }\n\n    // Return the sum of the squares of the numbers in the list.\n    // >>> sumOfSquares([1, 2, 3, 4])\n    // 30\n    // >>> sumOfSquares([1, 2, 3, 4, 5])\n    // 55\n    def sumOfSquares(numbers : List[Long]) : Long = {\n        numbers.reduce((a, b) -> a + (b * b))\n    }\n\n    // Return the sum of the squares of the numbers in the list.\n    // >>> sumOfSquares([\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293348,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpu469dzlx.scala:83:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpu469dzlx.scala:67:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m        numbers.reduce((a, b) -> a + (b * b))\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: a\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpu469dzlx.scala:67:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m        numbers.reduce((a, b) -> a + (b * b))\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: b\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpu469dzlx.scala:67:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m        numbers.reduce((a, b) -> a + (b * b))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Not found: a\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpu469dzlx.scala:67:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m        numbers.reduce((a, b) -> a + (b * b))\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: b\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpu469dzlx.scala:74:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpu469dzlx.scala:75:11 ------------------------\u001b[0m\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n * (n - 1) / 2) % p\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(123l)\n    // 3\n    // >>> sumDigits(1234l)\n    // 10\n    // >>> sumDigits(12345l)\n    // 23\n    // >>> sumDigits(123456l)\n    // 34\n    // >>> sumDigits(1234567l)\n    // 45\n    // >>> sumDigits(12345678l)\n    // 56\n    // >>> sumDigits(123456789l)\n    // 67\n    def sumDigits(n : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n * (n - 1) / 2) % 10\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(123l)\n    // 3\n    // >>> sumDigits(1234l)\n    // 10\n    // >>> sumDigits(12345l)\n    // 23\n    // >>> sumDigits(123456l)\n    // 34\n    // >>> sumDigits(1234567l)\n    // 45\n    // >>> sumDigits(12345678l)\n    // 56\n    // >>> sumDigits(123456789l)\n    // 67\n    def sumDigits2(n : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293347,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp1jki7_k0.scala:78:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m        \u001b[33mreturn\u001b[0m (\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n < 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p < 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p == 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n * (n - 1)) % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((2l), (3l))\n    // (1l)\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((0l), (5l))\n    // (5l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a < 0\")\n        }\n        if (b < 0) {\n            throw new IllegalArgumentException(\"b < 0\")\n        }\n        if (a == 0) {\n            return b\n        }\n        if (b == 0) {\n            return a\n        }\n        return gcd(b, a % b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((2l), (3l))\n    // (6l)\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((0l), (5l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (33l)\n    // >>> lcm((100l), (101l))\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a < 0\")\n        }\n        if (b < 0) {\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293350,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpffneke9j.scala:86:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpffneke9j.scala:85:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpffneke9j.scala:75:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m75 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n < 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p < 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p == 0\")\n        }\n        return (n % p) + (n / p) * p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293352,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_8lzjoop.scala:29)\n\tat Problem.main(tmp_8lzjoop.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((11l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (101l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (101l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            return b\n        } else {\n            return gcd(b % a, a)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((11l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (11l)\n    // >>> lcm((100l), (101l))\n    // (101l)\n    def lcm(a : Long, b : Long) : Long = {\n        return a * b / gcd(a, b)\n    }\n\n    // Return the sum of the squares of the numbers in the list.\n    // >>> sum_of_squares([1, 2, 3])\n    // 14\n    // >>> sum_of_squares([1, 2, 3, 4])\n    // 26\n    def sum_of_squares(numbers : List[Long]) : Long = {\n        return sum(map(n -> n * n, numbers))\n    }\n\n    // Return the sum of the squares of the numbers in the list.\n    // >>> sum_of_cubes([1, 2, 3])\n    // 14\n    // >>> sum_of_cubes([1, 2, 3, 4])\n    // 26\n    def sum_of_cubes(numbers : List[Long]) : Long\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293348,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpajq93ssc.scala:79:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpajq93ssc.scala:59:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m        \u001b[33mreturn\u001b[0m sum(map(n -> n * n, numbers))\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Not found: sum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpajq93ssc.scala:59:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m        \u001b[33mreturn\u001b[0m sum(map(n -> n * n, numbers))\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: map\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpajq93ssc.scala:59:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m        \u001b[33mreturn\u001b[0m sum(map(n -> n * n, numbers))\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: n\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E067] Syntax Error: /tmp/tmpajq93ssc.scala:67:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36msum_of_cubes\u001b[0m(\u001b[36mnumbers\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m]) : \u001b[35mLong\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mDeclaration of \u001b[33mmethod\u001b[0m \u001b[35msum_of_cubes\u001b[0m not allowed here: only classes can have declared but undefined members\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpajq93ssc.scala:70:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m70 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpajq93ssc.scala:71:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m71 ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be non-negative\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be non-zero\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n % p) + (n / p) * (p - 1l)\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(11l, 101l)\n    // (1l)\n    // >>> gcd(0l, 101l)\n    // (101l)\n    // >>> gcd(3l, 11l)\n    // (1l)\n    // >>> gcd(100l, 101l)\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a must be non-negative\")\n        }\n        if (b < 0) {\n            throw new IllegalArgumentException(\"b must be non-negative\")\n        }\n        if (a == 0) {\n            return b\n        }\n        if (b == 0) {\n            return a\n        }\n        return gcd(b, a % b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(11l, 101l)\n    // (101l)\n    // >>> lcm(0l, 101l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (3l)\n    // >>> lcm(100l, 101l)\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a must be\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293349,
      "stdout": "error while checking \u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[31mnull\u001b[0m)\nerror while checking \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[31mnull\u001b[0m)\nerror while checking {\n  \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[31mnull\u001b[0m)\n}\nerror while checking \u001b[33mif \u001b[0m(a < 0) \n  {\n    \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[31mnull\u001b[0m)\n  }\nerror while checking {\n  \u001b[33mif \u001b[0m(a < 0) \n    {\n      \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[31mnull\u001b[0m)\n    }\n  a must bedef main (args:\u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m])\n}\nerror while checking \u001b[33mdef\u001b[0m \u001b[36mlcm\u001b[0m(\u001b[36ma\u001b[0m: \u001b[35mLong\u001b[0m, \u001b[36mb\u001b[0m: \u001b[35mLong\u001b[0m): \u001b[35mLong\u001b[0m = \n  {\n    \u001b[33mif \u001b[0m(a < 0) \n      {\n        \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[31mnull\u001b[0m)\n      }\n    a must bedef main (args:\u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m])\n  }\nerror while checking  {\n  \u001b[33mdef\u001b[0m \u001b[36mmodp\u001b[0m(\u001b[36mn\u001b[0m: \u001b[35mLong\u001b[0m, \u001b[36mp\u001b[0m: \u001b[35mLong\u001b[0m): \u001b[35mLong\u001b[0m = \n    {\n      \u001b[33mif \u001b[0m(n < 0) \n        {\n          \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[32m\"n must be non-negative\"\u001b[0m)\n        }\n      \u001b[33mif \u001b[0m(p < 0) \n        {\n          \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[32m\"p must be non-negative\"\u001b[0m)\n        }\n      \u001b[33mif \u001b[0m(p == 0) \n        {\n          \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[32m\"p must be non-zero\"\u001b[0m)\n        }\n      \u001b[33mif \u001b[0m(n == 0) \n        {\n          \u001b[33mreturn\u001b[0m \u001b[31m0L\u001b[0m\n        }\n      \u001b[33mreturn\u001b[0m (n % p) + (n / p) * (p - \u001b[31m1L\u001b[0m)\n    }\n  \u001b[33mdef\u001b[0m \u001b[36mgcd\u001b[0m(\u001b[36ma\u001b[0m: \u001b[35mLong\u001b[0m, \u001b[36mb\u001b[0m: \u001b[35mLong\u001b[0m): \u001b[35mLong\u001b[0m = \n    {\n      \u001b[33mif \u001b[0m(a < 0) \n        {\n          \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[32m\"a must be non-negative\"\u001b[0m)\n        }\n      \u001b[33mif \u001b[0m(b < 0) \n        {\n          \u001b[33mthrow \u001b[0m\u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[32m",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpu45a_ksa.scala:71:47 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m            \u001b[33mthrow\u001b[0m \u001b[33mnew\u001b[0m \u001b[35mIllegalArgumentException\u001b[0m(\"a must be\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               unclosed string literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmpu45a_ksa.scala:73:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 end of statement expected but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpu45a_ksa.scala:84:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\nexception occurred while parser /tmp/tmpu45a_ksa.scala\nexception occurred while compiling /tmp/tmpu45a_ksa.scala\nException in thread \"main\" java.lang.AssertionError: assertion failed: position error, parent span does not contain child span\nparent      = \u001b[33mnew \u001b[0m\u001b[35mIllegalArgumentException\u001b[0m(\u001b[31mnull\u001b[0m) # -1,\nparent span = <1750..1789>,\nchild       = \u001b[31mnull\u001b[0m # -1,\nchild span  = [1779..1794..1794]\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:8)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:172)\n\tat dotty.tools.dotc.ast.Positioned.check$1$$anonfun$3(Positioned.scala:202)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)\n\tat scala.collection.immutable.List.foreach(List.scala:333)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:202)\n\tat dotty.tools.dotc.ast.Positioned.checkPos(Positioned.scala:223)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:197)\n\tat dotty.tools.dotc.ast.Positioned.checkPos(Positioned.scala:223)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:197)\n\tat dotty.tools.dotc.ast.P",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val nn = n.mod(p)\n        if (nn == 0) {\n            nn = p\n        }\n        return nn\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (101l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        val aa = a.abs()\n        val bb = b.abs()\n        if (aa == 0) {\n            return bb\n        } else if (bb == 0) {\n            return aa\n        } else {\n            return gcd(bb, aa % bb)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (11l)\n    // >>> lcm((100l), (101l))\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        val aa = a.abs()\n        val bb = b.abs()\n        if (aa == 0) {\n            return 0\n        } else if (bb == 0) {\n            return 0\n        } else {\n            return aa * bb / gcd(aa, bb)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293355,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpsgd39arq.scala:84:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsgd39arq.scala:16:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnn\u001b[0m = n.mod(p)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue mod is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.long2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpsgd39arq.scala:18:15 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            nn = p\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val nn\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpsgd39arq.scala:35:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36maa\u001b[0m = a.abs()\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 \u001b[33mmethod\u001b[0m \u001b[35mabs\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mRichLong\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpsgd39arq.scala:36:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbb\u001b[0m = b.abs()\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 \u001b[33mmethod\u001b[0m \u001b[35mabs\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mRichLong\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpsgd39arq.scala:58:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36maa\u001b[0m = a.abs()\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 \u001b[33mmethod\u001b[0m \u001b[35mabs\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mRichLong\u001b[0m does",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        return (n * (n - 1) / 2) % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(11l, 101l)\n    // (1l)\n    // >>> gcd(0l, 101l)\n    // (101l)\n    // >>> gcd(3l, 11l)\n    // (1l)\n    // >>> gcd(100l, 101l)\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a must be >= 0\")\n        }\n        if (b < 0) {\n            throw new IllegalArgumentException(\"b must be >= 0\")\n        }\n        if (a == 0) {\n            return b\n        }\n        if (b == 0) {\n            return a\n        }\n        if (a < b) {\n            a, b = b, a\n        }\n        while (b != 0) {\n            a, b = b, a % b\n        }\n        return a\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(11l, 101l)\n    // (101l)\n    // >>> lcm(0l, 101l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (33l)\n    // >>> lcm(100l, 101l)\n    // (100l)\n    def lcm(a : Long, b : Long\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293351,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpgiokd0p2.scala:56:13 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m            a, b = b, a\n\u001b[31m\u001b[31m   |\u001b[0m             ^\u001b[0m\n\u001b[31m   |\u001b[0m             end of statement expected but ',' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpgiokd0p2.scala:59:13 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m            a, b = b, a % b\n\u001b[31m\u001b[31m   |\u001b[0m             ^\u001b[0m\n\u001b[31m   |\u001b[0m             end of statement expected but ',' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgiokd0p2.scala:76:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgiokd0p2.scala:87:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgiokd0p2.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgiokd0p2.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgiokd0p2.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgiokd0p2.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) =",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n % p) + (n / p) * (p - 1l)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293312,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp92x0p05v.scala:32)\n\tat Problem.main(tmp92x0p05v.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n % p == 0) {\n            n / p\n        } else {\n            n % p\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293354,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptif7o79t.scala:24)\n\tat Problem.main(tmptif7o79t.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0l) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0l) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        return (n % p)\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (101l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0l) {\n            throw new IllegalArgumentException(\"a must be >= 0\")\n        }\n        if (b < 0l) {\n            throw new IllegalArgumentException(\"b must be >= 0\")\n        }\n        if (a == 0l) {\n            return b\n        }\n        if (b == 0l) {\n            return a\n        }\n        return gcd(b, a % b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (3l)\n    // >>> lcm((100l), (101l))\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a < 0l) {\n            throw new IllegalArgumentException(\"a must be >= 0\")\n        }\n        if (b < 0l)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293353,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4rqq7axh.scala:71:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    'then' expected, but '}' found\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0) {\n            0\n        } else if (n < 0) {\n            modp(-n, p)\n        } else if (n > p) {\n            n % p\n        } else {\n            n\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (1l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            b\n        } else if (b == 0) {\n            a\n        } else if (a < 0) {\n            gcd(-a, b)\n        } else if (b < 0) {\n            gcd(a, -b)\n        } else if (a > b) {\n            gcd(b, a % b)\n        } else {\n            gcd(a, b % a)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (33l)\n    // >>> lcm((100l), (101l))\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            0\n        } else if (b == 0) {\n            0\n        } else if (a < 0) {\n            lcm(-a, b)\n        } else if (b < 0) {\n            lcm(a,\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293356,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmprnfc8al6.scala:74:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmprnfc8al6.scala:86:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- Error: /tmp/tmprnfc8al6.scala:73:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m            lcm(a,\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter b of \u001b[33mmethod\u001b[0m \u001b[35mlcm\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m: (a: Long, b: Long): Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprnfc8al6.scala:85:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmprnfc8al6.scala:75:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m75 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0) {\n            0l\n        } else if (p == 0) {\n            n\n        } else {\n            (n * modp(n - 1, p)) % p\n        }\n    }\n\n    // Return the number of 1's in the binary representation of n.\n    // >>> countBits(3l)\n    // 2\n    // >>> countBits(0l)\n    // 0\n    // >>> countBits(7l)\n    // 3\n    // >>> countBits(11l)\n    // 5\n    def countBits(n : Long) : Long = {\n        if (n == 0) {\n            0l\n        } else {\n            (n * countBits(n - 1)) + 1\n        }\n    }\n\n    // Return the number of 1's in the binary representation of n.\n    // >>> countOnes(3l)\n    // 2\n    // >>> countOnes(0l)\n    // 0\n    // >>> countOnes(7l)\n    // 3\n    // >>> countOnes(11l)\n    // 5\n    def countOnes(n : Long) : Long = {\n        if (n == 0) {\n            0l\n        } else {\n            (n * countOnes(n - 1)) + 1\n        }\n    }\n\n    // Return the number of 1's in the binary representation of n.\n    // >>> countZeros(3l)\n    // 2\n    // >>> countZeros(0l)\n    // 0\n    // >>> countZeros(7l)\n    // 3\n    // >>> countZeros(11l)\n    // 5\n    def countZeros(n : Long) : Long = {\n        if (n == 0) {\n            0l\n        } else {\n            (n * countZeros(n - 1)) + 1\n        }\n    }\n\n    // Return the number of 1's in the binary representation of n.\n    // >>> countBits(3l)\n    // 2\n    // >>> countBits(0l)\n    // 0\n    // >>> countBits(7l)\n    // 3\n    // >>> countBits(\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293353,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9ss2mob4.scala:95:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m95 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9ss2mob4.scala:86:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9ss2mob4.scala:87:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9ss2mob4.scala:88:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9ss2mob4.scala:89:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m89 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9ss2mob4.scala:90:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m90 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9ss2mob4.scala:91:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m91 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0) {\n            0\n        } else {\n            n % p\n        }\n    }\n\n    // Return the number of bits set in n.\n    // >>> countbits(0l)\n    // 0\n    // >>> countbits(1l)\n    // 1\n    // >>> countbits(2l)\n    // 2\n    // >>> countbits(3l)\n    // 2\n    // >>> countbits(4l)\n    // 3\n    // >>> countbits(5l)\n    // 3\n    // >>> countbits(6l)\n    // 4\n    // >>> countbits(7l)\n    // 4\n    // >>> countbits(8l)\n    // 5\n    // >>> countbits(9l)\n    // 5\n    // >>> countbits(10l)\n    // 6\n    // >>> countbits(11l)\n    // 6\n    // >>> countbits(12l)\n    // 7\n    // >>> countbits(13l)\n    // 7\n    // >>> countbits(14l)\n    // 8\n    // >>> countbits(15l)\n    // 8\n    // >>> countbits(16l)\n    // 9\n    // >>> countbits(17l)\n    // 9\n    // >>> countbits(18l)\n    // 10\n    // >>> countbits(19l)\n    // 10\n    // >>> countbits(20l)\n    // 11\n    // >>> countbits(21l)\n    // 11\n    // >>> countbits(22l)\n    // 12\n    // >>> countbits(23l)\n    // 12\n    // >>> countbits(24l)\n    // 13\n    // >>> countbits(25l)\n    // 13\n    // >>> countbits(26l)\n    // 14\n    // >>> countbits(27l)\n    // 14\n    // >>> countbits(28l)\n    // 15\n    // >>> countbits(29l)\n    // 15\n    // >>> countbits(30l)\n    // 16\n    // >>> countbits(31l)\n    // 16\n    // >>> countbits(32l)\n    // 17\n    // >>> countbits(33l)\n\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293352,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpmvsm0o31.scala:103:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m103 |\u001b[0m}\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmvsm0o31.scala:94:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m94 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmvsm0o31.scala:95:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m95 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmvsm0o31.scala:96:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m96 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmvsm0o31.scala:97:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m97 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmvsm0o31.scala:98:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m98 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmvsm0o31.scala:99:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m99 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the number of bits set in the binary representation of n.\n    // >>> bitCount(3l)\n    // 2\n    // >>> bitCount(11l)\n    // 3\n    // >>> bitCount(0l)\n    // 0\n    // >>> bitCount(101l)\n    // 5\n    // >>> bitCount(11l)\n    // 3\n    // >>> bitCount(100l)\n    // 1\n    def bitCount(n : Long) : Long = {\n        n.bitCount()\n    }\n\n    // Return the number of 1s in the binary representation of n.\n    // >>> bitCount(3l)\n    // 2\n    // >>> bitCount(11l)\n    // 3\n    // >>> bitCount(0l)\n    // 0\n    // >>> bitCount(101l)\n    // 5\n    // >>> bitCount(11l)\n    // 3\n    // >>> bitCount(100l)\n    // 1\n    def bitCount1(n : Long) : Long = {\n        n.bitCount1()\n    }\n\n    // Return the number of 0s in the binary representation of n.\n    // >>> bitCount(3l)\n    // 2\n    // >>> bitCount(11l)\n    // 3\n    // >>> bitCount(0l)\n    // 0\n    // >>> bitCount(101l)\n    // 5\n    // >>> bitCount(11l)\n    // 3\n    // >>> bitCount(100l)\n    // 1\n    def bitCount0(n : Long) : Long = {\n        n.bitCount0()\n    }\n\n    // Return the number of 1s in the binary representation of n.\n    // >>> bitCount(3l)\n    // 2\n    // >>> bitCount(11l)\n    // 3\n    // >>> bitCount(0l)\n    // 0\n    // >>> bitCount(101l)\n    // 5\n    // >>> bitCount(11l)\n    // 3\n    // >>> bitCount(100l)\n    // 1\n    def bitCount1(n : Long) : Long = {\n        n.bitCount1()\n    }\n\n    //\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293356,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpjhw5mwlx.scala:99:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m99 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjhw5mwlx.scala:33:10 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        n.bitCount()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue bitCount is not a member of Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.long2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjhw5mwlx.scala:50:10 ------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m        n.bitCount1()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value bitCount1 is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjhw5mwlx.scala:67:10 ------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m        n.bitCount0()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value bitCount0 is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjhw5mwlx.scala:84:10 ------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m        n.bitCount1()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value bitCount1 is not a member of Long\n\u001b[31m\u001b[31m-- [E120] Naming Error: /tmp/tmpjhw5mwlx.scala:83:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mbitCount1\u001b[0m(\u001b[36mn\u001b[0m : \u001b[35mLong\u001b[0m) : \u001b[35mLong\u001b[0m = {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mDouble definition:\n\u001b[31m   |\u001b[0mdef bitCount1(n: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 49 and\n\u001b[31m   |\u001b[0mdef bitCount1(n: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 83\n\u001b[31m   |\u001b[0mhave the same type after erasure.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mConsider adding a @targetName annotation to one of the conflicting definitions\n\u001b[31m   |\u001b[0mfor disambiguation.\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjhw5mwlx.scala:90:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m90",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0) {\n            0l\n        } else {\n            n % p\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (101l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (101l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            b\n        } else {\n            gcd(b % a, a)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (11l)\n    // >>> lcm((100l), (101l))\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            0l\n        } else {\n            a * b / gcd(a, b)\n        }\n    }\n\n    // Return the sum of a and b.\n    // >>> add((3l), (5l))\n    // (8l)\n    // >>> add((1101l), (101l))\n    // (1202l)\n    // >>> add((0l), (101l))\n    // (101l)\n    // >>> add((3l), (11l))\n    // (14l)\n    // >>> add((100l), (101l))\n    // (101l)\n    def add(a : Long, b : Long) : Long = {\n        a + b\n    \n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293356,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptu81p3_i.scala:78)\n\tat Problem.main(tmptu81p3_i.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val m = n % p\n        if (m < 0) {\n            m += p\n        }\n        return m\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293327,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbx0qwhew.scala:18:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            m += p\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean m.!=?\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(11l, 101l)\n    // (1l)\n    // >>> gcd(0l, 101l)\n    // (101l)\n    // >>> gcd(3l, 11l)\n    // (1l)\n    // >>> gcd(100l, 101l)\n    // (101l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            a\n        } else {\n            gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(11l, 101l)\n    // (101l)\n    // >>> lcm(0l, 101l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (33l)\n    // >>> lcm(100l, 101l)\n    // (101l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a == 0l) {\n            b\n        } else {\n            lcm(b, a / b) * b\n        }\n    }\n\n    // Return the sum of a and b.\n    // >>> add(3l, 5l)\n    // (8l)\n    // >>> add(11l, 101l)\n    // (112l)\n    // >>> add(0l, 101l)\n    // (101l)\n    // >>> add(3l, 11l)\n    // (14l)\n    // >>> add(100l, 101l)\n    // (101l)\n    def add(a : Long, b : Long) : Long = {\n        a + b\n    }\n\n    // Return the product of a and b.\n    // >>> mult(3l, 5l)\n    // (15l)\n    // >>> mult(11l\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293352,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbwfkw5pt.scala:87:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbwfkw5pt.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbwfkw5pt.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbwfkw5pt.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbwfkw5pt.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbwfkw5pt.scala:82:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbwfkw5pt.scala:83:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0l) {\n            0l\n        } else {\n            n % p\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // 1l\n    // >>> gcd(3l, 0l)\n    // 3l\n    // >>> gcd(0l, 0l)\n    // 0l\n    // >>> gcd(3l, 11l)\n    // 1l\n    // >>> gcd(100l, 101l)\n    // 1l\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            a\n        } else {\n            gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // 15l\n    // >>> lcm(3l, 0l)\n    // 0l\n    // >>> lcm(0l, 0l)\n    // 0l\n    // >>> lcm(3l, 11l)\n    // 11l\n    // >>> lcm(100l, 101l)\n    // 101l\n    def lcm(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            0l\n        } else {\n            a * (b / gcd(a, b))\n        }\n    }\n\n    // Return the sum of a and b.\n    // >>> add(3l, 5l)\n    // 8l\n    // >>> add(3l, 0l)\n    // 3l\n    // >>> add(0l, 0l)\n    // 0l\n    // >>> add(3l, 11l)\n    // 14l\n    // >>> add(100l, 101l)\n    // 102l\n    def add(a : Long, b : Long) : Long = {\n        a + b\n    }\n\n    // Return the product of a and b.\n    // >>> mult(3l, 5l)\n    // 15l\n    // >>> mult(3l, 0l)\n    // 0\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293353,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4wb5th0m.scala:92:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4wb5th0m.scala:83:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4wb5th0m.scala:84:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4wb5th0m.scala:85:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4wb5th0m.scala:86:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4wb5th0m.scala:87:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4wb5th0m.scala:88:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the number of bits set in n.\n    // >>> countBits(0l)\n    // 0\n    // >>> countBits(1l)\n    // 1\n    // >>> countBits(2l)\n    // 2\n    // >>> countBits(3l)\n    // 2\n    // >>> countBits(4l)\n    // 3\n    // >>> countBits(5l)\n    // 3\n    // >>> countBits(6l)\n    // 4\n    // >>> countBits(7l)\n    // 4\n    // >>> countBits(8l)\n    // 5\n    // >>> countBits(9l)\n    // 5\n    // >>> countBits(10l)\n    // 6\n    // >>> countBits(11l)\n    // 6\n    // >>> countBits(12l)\n    // 7\n    // >>> countBits(13l)\n    // 7\n    // >>> countBits(14l)\n    // 8\n    // >>> countBits(15l)\n    // 8\n    // >>> countBits(16l)\n    // 9\n    // >>> countBits(17l)\n    // 9\n    // >>> countBits(18l)\n    // 10\n    // >>> countBits(19l)\n    // 10\n    // >>> countBits(20l)\n    // 11\n    // >>> countBits(21l)\n    // 11\n    // >>> countBits(22l)\n    // 12\n    // >>> countBits(23l)\n    // 12\n    // >>> countBits(24l)\n    // 13\n    // >>> countBits(25l)\n    // 13\n    // >>> countBits(26l)\n    // 14\n    // >>> countBits(27l)\n    // 14\n    // >>> countBits(28l)\n    // 15\n    // >>> countBits(29l)\n    // 15\n    // >>> countBits(30l)\n    // 16\n    // >>> countBits(31l)\n    // 16\n    // >>> countBits(32l)\n    \n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293312,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp1siwote1.scala:97:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m97 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1siwote1.scala:88:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1siwote1.scala:89:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m89 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1siwote1.scala:90:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m90 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1siwote1.scala:91:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m91 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1siwote1.scala:92:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1siwote1.scala:93:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m93 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppqmnk7x9.scala:20)\n\tat Problem.main(tmppqmnk7x9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n * n) % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(3l, 0l)\n    // (3l)\n    // >>> gcd(0l, 0l)\n    // (0l)\n    // >>> gcd(0l, 3l)\n    // (3l)\n    // >>> gcd(3l, 3l)\n    // (3l)\n    // >>> gcd(3l, -3l)\n    // (3l)\n    // >>> gcd(-3l, 3l)\n    // (3l)\n    // >>> gcd(-3l, -3l)\n    // (3l)\n    // >>> gcd(-3l, 0l)\n    // (3l)\n    // >>> gcd(0l, -3l)\n    // (3l)\n    // >>> gcd(-3l, -3l)\n    // (3l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a must be >= 0\")\n        }\n        if (b < 0) {\n            throw new IllegalArgumentException(\"b must be >= 0\")\n        }\n        if (b == 0) {\n            return a\n        }\n        return gcd(b, a % b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(3l, 0l)\n    // (0l)\n    // >>> lcm(\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293353,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp816i2u2h.scala:84:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp816i2u2h.scala:75:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp816i2u2h.scala:76:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp816i2u2h.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp816i2u2h.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp816i2u2h.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp816i2u2h.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppqmnk7x9.scala:20)\n\tat Problem.main(tmppqmnk7x9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0l) {\n            throw new IllegalArgumentException(\"n < 0\")\n        }\n        if (p < 0l) {\n            throw new IllegalArgumentException(\"p < 0\")\n        }\n        if (p == 0l) {\n            throw new IllegalArgumentException(\"p == 0\")\n        }\n        return (n % p)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293356,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp48j47vcd.scala:29)\n\tat Problem.main(tmp48j47vcd.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val nn = n.toInt\n        val pp = p.toInt\n        if (nn < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (pp < 0) {\n            throw new IllegalArgumentException(\"p must be non-negative\")\n        }\n        if (nn == 0) {\n            return 0l\n        }\n        if (nn == 1) {\n            return 1l\n        }\n        if (nn == 2) {\n            return 2l\n        }\n        if (nn == 3) {\n            return 3l\n        }\n        if (nn == 4) {\n            return 4l\n        }\n        if (nn == 5) {\n            return 5l\n        }\n        if (nn == 6) {\n            return 6l\n        }\n        if (nn == 7) {\n            return 7l\n        }\n        if (nn == 8) {\n            return 8l\n        }\n        if (nn == 9) {\n            return 9l\n        }\n        if (nn == 10) {\n            return 10l\n        }\n        if (nn == 11) {\n            return 11l\n        }\n        if (nn == 12) {\n            return 12l\n        }\n        if (nn == 13) {\n            return 13l\n        }\n        if (nn == 14) {\n            return 14l\n        }\n        if (nn == 15) {\n            return 15l\n        }\n        if (nn == 16) {\n            return 16l\n        }\n        if (nn == 17) {\n            return 17l\n        }\n        if (nn == 18) {\n            return 18l\n        }\n        if (nn == 19) {\n            return 19l\n        }\n        if (nn == 20) {\n            return 20l\n        }\n        if (nn == 21) {\n            return 21l\n        }\n        if (nn == 22) {\n            return 22l\n        }\n        if (nn == 23) {\n            return 23l\n        }\n        if (nn == 24) {\n            return 24l\n        }\n        if (nn == 25) {\n            return 25\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293357,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwd02_fli.scala:113:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m113 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwd02_fli.scala:112:1 --------------------\u001b[0m\u001b[0m\n\u001b[31m112 |\u001b[0m}\n\u001b[31m\u001b[31m    |\u001b[0m ^\u001b[0m\n\u001b[31m    |\u001b[0m Found:    Unit\n\u001b[31m    |\u001b[0m Required: Long\n\u001b[31m    |\u001b[0m\n\u001b[31m    |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpwd02_fli.scala:102:4 ---------------------------------------\u001b[0m\u001b[0m\n\u001b[33m102 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m    |\u001b[0m    ^\u001b[0m\n\u001b[33m    |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val nn = n\n        val pp = p\n        val m = nn % pp\n        if (m == 0) {\n            return nn\n        } else {\n            return modp(nn - m, pp)\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (101l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (101l)\n    def gcd(a : Long, b : Long) : Long = {\n        val aa = a\n        val bb = b\n        val g = gcd(aa, bb)\n        if (g == 0) {\n            return bb\n        } else {\n            return g\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (33l)\n    // >>> lcm((100l), (101l))\n    // (101l)\n    def lcm(a : Long, b : Long) : Long = {\n        val aa = a\n        val bb = b\n        val l = lcm(aa, bb)\n        if (l == 0) {\n            return bb\n        } else {\n            return l\n        }\n    }\n\n    // Return the sum of the squares of the first n natural numbers.\n    // >>> sum_of_squares(0)\n    // (0l)\n    // >>> sum_of_squares(1)\n    // (1l)\n    // >>> sum_of_squares\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293355,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqyda_2k8.scala:87:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqyda_2k8.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqyda_2k8.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqyda_2k8.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqyda_2k8.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqyda_2k8.scala:82:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqyda_2k8.scala:83:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val m = n % p\n        if (m == 0) {\n            m\n        } else {\n            m + p\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293356,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpapjexxx7.scala:24)\n\tat Problem.main(tmpapjexxx7.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(11l, 101l)\n    // (1l)\n    // >>> gcd(0l, 101l)\n    // (101l)\n    // >>> gcd(3l, 11l)\n    // (1l)\n    // >>> gcd(100l, 101l)\n    // (101l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            return b\n        } else {\n            return gcd(b % a, a)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(11l, 101l)\n    // (101l)\n    // >>> lcm(0l, 101l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (33l)\n    // >>> lcm(100l, 101l)\n    // (101l)\n    def lcm(a : Long, b : Long) : Long = {\n        return a * b / gcd(a, b)\n    }\n\n    // Return the sum of the squares of the numbers in the list.\n    // >>> sumOfSquares([1, 2, 3])\n    // (14l)\n    // >>> sumOfSquares([1, 2, 3, 4])\n    // (30l)\n    def sumOfSquares(numbers : List[Long]) : Long = {\n        return sum(map(n -> n * n, numbers))\n    }\n\n    // Return the sum of the products of the numbers in the list.\n    // >>> sumOfProducts([1, 2, 3])\n    // (6l)\n    // >>> sumOfProducts([1, 2, 3, 4])\n    // (24l)\n    def sumOfProducts(numbers : List[Long]) : Long = {\n        return sum(map(n -> n *\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293355,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpp7mbk8cu.scala:68:31 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m        \u001b[33mreturn\u001b[0m sum(map(n -> n *\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp7mbk8cu.scala:59:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m        \u001b[33mreturn\u001b[0m sum(map(n -> n * n, numbers))\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Not found: sum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp7mbk8cu.scala:59:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m        \u001b[33mreturn\u001b[0m sum(map(n -> n * n, numbers))\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: map\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp7mbk8cu.scala:59:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m        \u001b[33mreturn\u001b[0m sum(map(n -> n * n, numbers))\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: n\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp7mbk8cu.scala:68:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m        \u001b[33mreturn\u001b[0m sum(map(n -> n *\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Not found: sum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp7mbk8cu.scala:68:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m        \u001b[33mreturn\u001b[0m sum(map(n -> n *\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: map\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // 5l\n    // >>> gcd(11l, 101l)\n    // 101l\n    // >>> gcd(0l, 101l)\n    // 1l\n    // >>> gcd(3l, 11l)\n    // 1l\n    // >>> gcd(100l, 101l)\n    // 101l\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            a\n        } else {\n            gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // 15l\n    // >>> lcm(11l, 101l)\n    // 1011l\n    // >>> lcm(0l, 101l)\n    // 0l\n    // >>> lcm(3l, 11l)\n    // 11l\n    // >>> lcm(100l, 101l)\n    // 101l\n    def lcm(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            a\n        } else {\n            lcm(b, a / b) * b\n        }\n    }\n\n    // Return the sum of the squares of the first n natural numbers.\n    // >>> sum_of_squares(0)\n    // 0l\n    // >>> sum_of_squares(1)\n    // 1l\n    // >>> sum_of_squares(2)\n    // 5l\n    // >>> sum_of_squares(3)\n    // 14l\n    // >>> sum_of_squares(4)\n    // 30l\n    def sum_of_squares(n : Long) : Long = {\n        n * (n + 1) / 2\n    }\n\n    // Return the sum of the first n natural numbers.\n    // >>> sum(0)\n    // 0l\n    // >>> sum(1)\n    // 1l\n    // >>> sum(2)\n    //\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293355,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp2cprlupo.scala:90:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m90 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2cprlupo.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2cprlupo.scala:82:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2cprlupo.scala:83:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2cprlupo.scala:84:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2cprlupo.scala:85:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2cprlupo.scala:86:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val nn = n.toInt\n        val pp = p.toInt\n        val r = nn % pp\n        if (r < 0) {\n            r += pp\n        }\n        return r\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(123)\n    // 3\n    // >>> sumDigits(1234)\n    // 4\n    // >>> sumDigits(12345)\n    // 5\n    // >>> sumDigits(1234567)\n    // 6\n    // >>> sumDigits(123456789)\n    // 9\n    def sumDigits(n : Long) : Long = {\n        val nn = n.toInt\n        return nn % 10\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(123)\n    // 3\n    // >>> sumDigits(1234)\n    // 4\n    // >>> sumDigits(12345)\n    // 5\n    // >>> sumDigits(1234567)\n    // 6\n    // >>> sumDigits(123456789)\n    // 9\n    def sumDigits(n : Long) : Long = {\n        val nn = n.toInt\n        return nn % 10\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(123)\n    // 3\n    // >>> sumDigits(1234)\n    // 4\n    // >>> sumDigits(12345)\n    // 5\n    // >>> sumDigits(1234567)\n    // 6\n    // >>> sumDigits(123456789)\n    // 9\n    def sumDigits(n : Long) : Long = {\n        val nn = n.toInt\n        return nn % 10\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(123)\n    // 3\n    // >>> sumDigits(1234)\n    // 4\n    // >>> sumDigits(12345)\n    // 5\n    // >>> sumDigits(1234567)\n    // 6\n    // >>> sumDigits(123456789)\n    // 9\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293357,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpc1yc9x5d.scala:95:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m95 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpc1yc9x5d.scala:20:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            r += pp\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean r.!=?\n\u001b[31m\u001b[31m-- [E120] Naming Error: /tmp/tmpc1yc9x5d.scala:52:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36msumDigits\u001b[0m(\u001b[36mn\u001b[0m : \u001b[35mLong\u001b[0m) : \u001b[35mLong\u001b[0m = {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mDouble definition:\n\u001b[31m   |\u001b[0mdef sumDigits(n: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 36 and\n\u001b[31m   |\u001b[0mdef sumDigits(n: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 52\n\u001b[31m   |\u001b[0mhave the same type after erasure.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mConsider adding a @targetName annotation to one of the conflicting definitions\n\u001b[31m   |\u001b[0mfor disambiguation.\n\u001b[31m\u001b[31m-- [E120] Naming Error: /tmp/tmpc1yc9x5d.scala:68:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36msumDigits\u001b[0m(\u001b[36mn\u001b[0m : \u001b[35mLong\u001b[0m) : \u001b[35mLong\u001b[0m = {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mDouble definition:\n\u001b[31m   |\u001b[0mdef sumDigits(n: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 52 and\n\u001b[31m   |\u001b[0mdef sumDigits(n: Long): Long in \u001b[33mobject\u001b[0m \u001b[35mProblem\u001b[0m at line 68\n\u001b[31m   |\u001b[0mhave the same type after erasure.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mConsider adding a @targetName annotation to one of the conflicting definitions\n\u001b[31m   |\u001b[0mfor disambiguation.\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpc1yc9x5d.scala:86:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] N",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0) {\n            0l\n        } else if (n < 0) {\n            modp(-n, p)\n        } else {\n            n % p\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (101l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            b\n        } else if (b == 0) {\n            a\n        } else {\n            gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (33l)\n    // >>> lcm((100l), (101l))\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            0l\n        } else if (b == 0) {\n            0l\n        } else {\n            a * b / gcd(a, b)\n        }\n    }\n\n    // Return the sum of the squares of the numbers from 1 to n.\n    // >>> sum_of_squares(10)\n    // 385\n    def sum_of_squares(n : Int) : Int = {\n        n * (n + 1) / 2\n    }\n\n    // Return the sum of the digits of the number n.\n    // >>> sum_of_\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293356,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0wkei26d.scala:87:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0wkei26d.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0wkei26d.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0wkei26d.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0wkei26d.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0wkei26d.scala:82:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0wkei26d.scala:83:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0) {\n            0l\n        } else if (n < 0) {\n            modp(-n, p)\n        } else if (n > p) {\n            n % p\n        } else {\n            n\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (101l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            b\n        } else if (b == 0) {\n            a\n        } else if (a < 0) {\n            gcd(-a, b)\n        } else if (b < 0) {\n            gcd(a, -b)\n        } else if (a > b) {\n            gcd(b, a % b)\n        } else {\n            gcd(a, b % a)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (33l)\n    // >>> lcm((100l), (101l))\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a == 0) {\n            0l\n        } else if (b == 0) {\n            0l\n        } else if (a < 0) {\n            lcm(-a, b)\n        } else if (b < 0) {\n            lcm\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293357,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpev2dm5kn.scala:86:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpev2dm5kn.scala:73:12 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m            lcm\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^\u001b[0m\n\u001b[31m   |\u001b[0m            missing arguments for value of type (Long, Long) => Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpev2dm5kn.scala:85:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpev2dm5kn.scala:75:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m75 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new java.lang.IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0) {\n            throw new java.lang.IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0) {\n            throw new java.lang.IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n * (n - 1) / 2) % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (1l)\n    // >>> gcd((0l), (101l))\n    // (101l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (101l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new java.lang.IllegalArgumentException(\"a must be >= 0\")\n        }\n        if (b < 0) {\n            throw new java.lang.IllegalArgumentException(\"b must be >= 0\")\n        }\n        if (a == 0) {\n            return b\n        }\n        if (b == 0) {\n            return a\n        }\n        while (a != b) {\n            if (a > b) {\n                a = a - b\n            } else {\n                b = b - a\n            }\n        }\n        return a\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (11\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293357,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5yhj49zt.scala:85:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp5yhj49zt.scala:57:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m                a = a - b\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val a\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp5yhj49zt.scala:59:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m                b = b - a\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val b\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5yhj49zt.scala:76:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5yhj49zt.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5yhj49zt.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5yhj49zt.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        return (n % p) + p\n    }\n\n    // Return the number of bits set in the integer n.\n    // >>> bitcount(3l)\n    // 2\n    // >>> bitcount(11l)\n    // 3\n    // >>> bitcount(0l)\n    // 0\n    // >>> bitcount(-3l)\n    // 0\n    // >>> bitcount(-11l)\n    // 0\n    // >>> bitcount(-100l)\n    // 0\n    def bitcount(n : Long) : Long = {\n        return (n & -n) + n\n    }\n\n    // Return the number of 1-bits in the integer n.\n    // >>> bitcount1(3l)\n    // 2\n    // >>> bitcount1(11l)\n    // 3\n    // >>> bitcount1(0l)\n    // 0\n    // >>> bitcount1(-3l)\n    // 0\n    // >>> bitcount1(-11l)\n    // 0\n    // >>> bitcount1(-100l)\n    // 0\n    def bitcount1(n : Long) : Long = {\n        return (n & -n) + n\n    }\n\n    // Return the number of 0-bits in the integer n.\n    // >>> bitcount0(3l)\n    // 2\n    // >>> bitcount0(11l)\n    // 3\n    // >>> bitcount0(0l)\n    // 0\n    // >>> bitcount0(-3l)\n    // 0\n    // >>> bitcount0(-11l)\n    // 0\n    // >>> bitcount0(-100l)\n    // 0\n    def bitcount0(n : Long) : Long = {\n        return (n & -n) + n\n    }\n\n    // Return the number of 1-bits in the integer n.\n    // >>> bitcount1(3l)\n    // 2\n    // >>> bitcount1(11l)\n    // 3\n    // >>> bitcount1(0l)\n    // 0\n    // >>> bitcount1(-3l)\n    // 0\n    // >>> bitcount1(-11l)\n    // 0\n    // >>> bitcount1(-100l)\n    // 0\n\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293357,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmphv0zhsuh.scala:95:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m95 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphv0zhsuh.scala:86:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphv0zhsuh.scala:87:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m87 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphv0zhsuh.scala:88:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m88 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphv0zhsuh.scala:89:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m89 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphv0zhsuh.scala:90:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m90 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphv0zhsuh.scala:91:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m91 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0l) {\n            0l\n        } else {\n            n % p\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (101l)\n    // >>> gcd((0l), (101l))\n    // (1l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0l) {\n            b\n        } else {\n            b % a\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (3l)\n    // >>> lcm((100l), (101l))\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a == 0l) {\n            0l\n        } else {\n            a * b / gcd(a, b)\n        }\n    }\n\n    // Return the sum of the squares of the numbers in the list.\n    // >>> sumOfSquares([1, 2, 3, 4])\n    // 30\n    // >>> sumOfSquares([1, 2, 3, 4, 5])\n    // 55\n    def sumOfSquares(numbers : List[Long]) : Long = {\n        numbers.reduce((a, b) -> a + b * b)\n    }\n\n    // Return the sum of the squares of the numbers in the list.\n    // >>> sumOfSquares([1, 2, 3, 4])\n    // 30\n    \n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293357,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3k5zdim3.scala:85:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3k5zdim3.scala:67:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m        numbers.reduce((a, b) -> a + b * b)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: a\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3k5zdim3.scala:67:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m        numbers.reduce((a, b) -> a + b * b)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: b\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3k5zdim3.scala:67:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m        numbers.reduce((a, b) -> a + b * b)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Not found: a\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3k5zdim3.scala:67:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m67 |\u001b[0m        numbers.reduce((a, b) -> a + b * b)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: b\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3k5zdim3.scala:76:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3k5zdim3.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(11l, 101l)\n    // (1l)\n    // >>> gcd(0l, 101l)\n    // (101l)\n    // >>> gcd(3l, 11l)\n    // (1l)\n    // >>> gcd(100l, 101l)\n    // (101l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            return a\n        } else {\n            return gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(11l, 101l)\n    // (101l)\n    // >>> lcm(0l, 101l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (33l)\n    // >>> lcm(100l, 101l)\n    // (101l)\n    def lcm(a : Long, b : Long) : Long = {\n        return (a * b) / gcd(a, b)\n    }\n\n    // Return the sum of the squares of the first n natural numbers.\n    // >>> sumOfSquares(0)\n    // (0l)\n    // >>> sumOfSquares(1)\n    // (1l)\n    // >>> sumOfSquares(2)\n    // (5l)\n    // >>> sumOfSquares(3)\n    // (14l)\n    def sumOfSquares(n : Long) : Long = {\n        return (n * (n + 1) * (2 * n + 1)) / 6\n    }\n\n    // Return the sum of the cubes of the first n natural numbers.\n    // >>> sumOfCubes(0)\n    // (0l)\n    // >>> sumOfCubes(1)\n    // (1l)\n    // >>> sum\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293357,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpnabjh_av.scala:83:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnabjh_av.scala:74:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnabjh_av.scala:75:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnabjh_av.scala:76:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnabjh_av.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnabjh_av.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnabjh_av.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m30l\u001b[0m)",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n == 0l) {\n            0l\n        } else {\n            n % p\n        }\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd((3l), (5l))\n    // (1l)\n    // >>> gcd((1101l), (101l))\n    // (101l)\n    // >>> gcd((0l), (101l))\n    // (1l)\n    // >>> gcd((3l), (11l))\n    // (1l)\n    // >>> gcd((100l), (101l))\n    // (101l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a == 0l) {\n            b\n        } else {\n            gcd(b % a, a)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm((3l), (5l))\n    // (15l)\n    // >>> lcm((1101l), (101l))\n    // (101l)\n    // >>> lcm((0l), (101l))\n    // (0l)\n    // >>> lcm((3l), (11l))\n    // (11l)\n    // >>> lcm((100l), (101l))\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a == 0l) {\n            0l\n        } else {\n            a * b / gcd(a, b)\n        }\n    }\n\n    // Return the sum of a and b.\n    // >>> add((3l), (5l))\n    // (8l)\n    // >>> add((1101l), (101l))\n    // (1202l)\n    // >>> add((0l), (101l))\n    // (101l)\n    // >>> add((3l), (11l))\n    // (14l)\n    // >>> add((100l), (101l))\n    // (101l)\n    def add(a : Long, b : Long) : Long = {\n        a +\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293357,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmps_k4gvam.scala:73:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m        a +\n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be >= 0\")\n        }\n        if (p < 0) {\n            throw new IllegalArgumentException(\"p must be >= 0\")\n        }\n        if (p == 0) {\n            throw new IllegalArgumentException(\"p must be > 0\")\n        }\n        if (n == 0) {\n            return 0l\n        }\n        return (n % p) + (n / p) * (p - 1l)\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(11l, 101l)\n    // (1l)\n    // >>> gcd(0l, 101l)\n    // (101l)\n    // >>> gcd(3l, 11l)\n    // (1l)\n    // >>> gcd(100l, 101l)\n    // (1l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a must be >= 0\")\n        }\n        if (b < 0) {\n            throw new IllegalArgumentException(\"b must be >= 0\")\n        }\n        if (a == 0) {\n            return b\n        }\n        if (b == 0) {\n            return a\n        }\n        return gcd(b, a % b)\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(11l, 101l)\n    // (101l)\n    // >>> lcm(0l, 101l)\n    // (0l)\n    // >>> lcm(3l, 11l)\n    // (3l)\n    // >>> lcm(100l, 101l)\n    // (100l)\n    def lcm(a : Long, b : Long) : Long = {\n        if (a < 0) {\n            throw new IllegalArgumentException(\"a must be >= 0\")\n        \n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293335,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmphxlp58qd.scala:85:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m85 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphxlp58qd.scala:84:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmphxlp58qd.scala:74:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m74 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppqmnk7x9.scala:20)\n\tat Problem.main(tmppqmnk7x9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        val m = n % p\n        if (m < 0) {\n            m += p\n        }\n        return m\n    }\n\n    // Return the greatest common divisor of a and b.\n    // >>> gcd(3l, 5l)\n    // (1l)\n    // >>> gcd(3l, 6l)\n    // (3l)\n    // >>> gcd(3l, 0l)\n    // (3l)\n    // >>> gcd(0l, 0l)\n    // (0l)\n    // >>> gcd(0l, 3l)\n    // (3l)\n    // >>> gcd(3l, 3l)\n    // (3l)\n    def gcd(a : Long, b : Long) : Long = {\n        if (b == 0l) {\n            return a\n        } else {\n            return gcd(b, a % b)\n        }\n    }\n\n    // Return the least common multiple of a and b.\n    // >>> lcm(3l, 5l)\n    // (15l)\n    // >>> lcm(3l, 6l)\n    // (18l)\n    // >>> lcm(3l, 0l)\n    // (0l)\n    // >>> lcm(0l, 0l)\n    // (0l)\n    // >>> lcm(0l, 3l)\n    // (0l)\n    // >>> lcm(3l, 3l)\n    // (3l)\n    def lcm(a : Long, b : Long) : Long = {\n        return a * b / gcd(a, b)\n    }\n\n    // Return the sum of the digits of n.\n    // >>> sumDigits(123l)\n    // (3l)\n    // >>> sumDigits(1234l)\n    // (4l)\n    // >>> sumDigits(12345l)\n    // (5l)\n    // >>> sumDigits(123456l)\n    // (6l)\n    def sumDigits(n : Long) : Long = {\n        return n % 10\n    }\n\n    // Return the sum of the digits of n.\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293358,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpcxflew9d.scala:86:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcxflew9d.scala:18:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            m += p\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean m.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcxflew9d.scala:77:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m5l\u001b[0m)) == (\u001b[31m3l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcxflew9d.scala:78:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m    assert(modp((\u001b[31m1101l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m2l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcxflew9d.scala:79:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m    assert(modp((\u001b[31m0l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcxflew9d.scala:80:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m    assert(modp((\u001b[31m3l\u001b[0m), (\u001b[31m11l\u001b[0m)) == (\u001b[31m8l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: modp\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcxflew9d.scala:81:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m    assert(modp((\u001b[31m100l\u001b[0m), (\u001b[31m101l\u001b[0m)) == (\u001b[31m1l\u001b[0m));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp((3l), (5l))\n    // (3l)\n    // >>> modp((1101l), (101l))\n    // (2l)\n    // >>> modp((0l), (101l))\n    // (1l)\n    // >>> modp((3l), (11l))\n    // (8l)\n    // >>> modp((100l), (101l))\n    // (1l)\n    def modp(n : Long, p : Long) : Long = {\n        n % p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n",
      "timestamp": 1664293306,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppqmnk7x9.scala:20)\n\tat Problem.main(tmppqmnk7x9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    }
  ]
}