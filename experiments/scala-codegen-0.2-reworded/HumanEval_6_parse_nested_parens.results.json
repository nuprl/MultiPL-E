{
  "name": "HumanEval_6_parse_nested_parens",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "results": [
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var result = List[Long]()\n        for (i <- 0 until paren_list.length) {\n            var paren_group = paren_list[i]\n            var paren_count = 0\n            for (j <- 0 until paren_group.length) {\n                if (paren_group[j] == '(') {\n                    paren_count += 1\n                } else if (paren_group[j] == ')') {\n                    paren_count -= 1\n                }\n            }\n            result = result.append(paren_count)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292640,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo0yz5gjh.scala:13:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen_group\u001b[0m = paren_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo0yz5gjh.scala:16:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_group[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo0yz5gjh.scala:18:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_group[j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo0yz5gjh.scala:22:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            result = result.append(paren_count)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var result = List[Long]()\n        var paren_stack = List[String]()\n        var paren_count = 0\n        var paren_index = 0\n        var paren_char = \"\"\n        var paren_level = 0\n        var paren_count_max = 0\n        var paren_count_min = 0\n        var paren_count_diff = 0\n        var paren_count_diff_max = 0\n        var paren_count_diff_min = 0\n        var paren_count_diff_diff = 0\n        var paren_count_diff_diff_max = 0\n        var paren_count_diff_diff_min = 0\n        var paren_count_diff_diff_diff = 0\n        var paren_count_diff_diff_diff_max = 0\n        var paren_count_diff_diff_diff_min = 0\n        var paren_count_diff_diff_diff_diff = 0\n        var paren_count_diff_diff_diff_diff_max = 0\n        var paren_count_diff_diff_diff_diff_min = 0\n        var paren_count_diff_diff_diff_diff_diff = 0\n        var paren_count_diff_diff_diff_diff_diff_max = 0\n        var paren_count_diff_diff_diff_diff_diff_min = 0\n        var paren_count_diff_diff_diff_diff_diff_diff = 0\n        var paren_count_diff_diff_diff_diff_diff_diff_max = 0\n        var paren_count_diff_diff_diff_diff_diff_diff_min = 0\n        var paren_count_diff_diff_diff_diff_diff_diff_diff = 0\n        var paren_count_diff_diff_diff_diff_diff_diff_diff_max = 0\n        var paren_count_diff_diff_diff_diff_diff_diff_diff_min = 0\n        var paren_count_diff_diff_diff_diff_diff_diff_diff_diff = 0\n        var paren_count_diff_diff_diff_diff_diff_diff_diff_\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292640,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmplb1s3r44.scala:41:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmplb1s3r44.scala:41:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var max_nesting = 0\n        var result = List[Long]()\n        for (i <- 0 until paren_list.length) {\n            var paren_group = paren_list[i]\n            var paren_count = 0\n            for (j <- 0 until paren_group.length) {\n                if (paren_group[j] == '(') {\n                    paren_count += 1\n                } else if (paren_group[j] == ')') {\n                    paren_count -= 1\n                }\n            }\n            if (paren_count > max_nesting) {\n                max_nesting = paren_count\n            }\n            if (paren_count == 0) {\n                result = result.append(max_nesting)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292640,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpi9pw0z8q.scala:14:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen_group\u001b[0m = paren_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpi9pw0z8q.scala:17:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (paren_group[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpi9pw0z8q.scala:19:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_group[j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi9pw0z8q.scala:27:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result = result.append(max_nesting)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        val result_list = result.map(Long.parseLong).toList\n        result_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuygvrdlp.scala:12:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult_list\u001b[0m = result.map(Long.parseLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value parseLong is not a member of object Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmpuygvrdlp.scala:12:52 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult_list\u001b[0m = result.map(Long.parseLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val paren_list = parens.map(p -> p.replaceAll(\"[()]\", \"\"))\n        val paren_counts = paren_list.map(p -> p.length()).toSeq\n        val max_paren_count = paren_counts.max()\n        val max_paren_count_index = paren_counts.indexOf(max_paren_count)\n        val max_paren_count_parens = paren_list.take(max_paren_count_index)\n        val max_paren_count_parens_count = max_paren_count_parens.length()\n        val max_paren_count_parens_list = max_paren_count_parens.map(p -> p.length()).toSeq\n        val max_paren_count_parens_count_list = max_paren_count_parens_list.map(p -> p.toLong).toSeq\n        val max_paren_count_parens_count_list_to_list = max_paren_count_parens_count_list.toList\n        val max_paren_count_parens_count_list_to_list_to_list = max_paren_count_parens_count_list_to_list.toList\n        val max_paren_count_parens_count_list_to_list_to_list_to_list = max_paren_count_parens_count_list_to_list_to_list.toList\n        val max_paren_count_parens_count_list_to_list_to_list_to_list_to_list = max_paren_count_parens_count_list_to_list_to_list_to_list.toList\n        val max_paren_count_parens_count_list_to_list_to_list_to_list_to_list_to_list = max_paren_count_parens_count_list_to_list_to_list_to_list_to_list.toList\n        val max_paren_count_parens_count_list_to_list_\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp1vx2pju_.scala:25:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1vx2pju_.scala:11:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_list\u001b[0m = parens.map(p -> p.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: p\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp1vx2pju_.scala:11:66 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_list\u001b[0m = parens.map(p -> p.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1vx2pju_.scala:25:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var parens = paren_string.split(\" \")\n        var max_nesting = 0\n        var max_nesting_index = 0\n        for (i <- 0 until parens.length) {\n            var paren_count = 0\n            for (j <- i until parens.length) {\n                if (parens[j] == \"(\" || parens[j] == \")\") {\n                    paren_count += 1\n                } else {\n                    paren_count -= 1\n                }\n                if (paren_count > max_nesting) {\n                    max_nesting = paren_count\n                    max_nesting_index = j\n                }\n            }\n        }\n        var result = List[Long]()\n        for (i <- 0 until max_nesting_index) {\n            result = result.append(i)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292640,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy94yxls_.scala:16:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (parens[\u001b[35mj\u001b[0m] == \u001b[31m\"(\"\u001b[0m || parens[\u001b[35mj\u001b[0m] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy94yxls_.scala:29:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(s => {\n            val parens = s.split(\"(\")\n            val depth = parens.length - 1\n            val max_depth = depth.max()\n            return depth.toLong\n        })\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp6sgtd2qw.scala:14:37 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mmax_depth\u001b[0m = depth.max()\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter that of \u001b[33mmethod\u001b[0m \u001b[35mmax\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mRichInt\u001b[0m: (that: Int): Int\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6sgtd2qw.scala:15:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mreturn\u001b[0m depth.toLong\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    Long\n\u001b[31m   |\u001b[0m                   Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mLong\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp6sgtd2qw.scala:16:10 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        })\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          where:    B is a type variable\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.toLong).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"(()())\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:697)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$1(tmp1_0xw5jf.scala:11)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseNestedParens(tmp1_0xw5jf.scala:11)\n\tat Problem$.main(tmp1_0xw5jf.scala:15)\n\tat Problem.main(tmp1_0xw5jf.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(Problem::parseNestedParens).reduce(_.maxBy(Comparator.naturalOrder()))\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl2ty3ecj.scala:11:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(_.trim).map(Problem::parseNestedParens).reduce(_.maxBy(Comparator.naturalOrder()))\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpl2ty3ecj.scala:11:71 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(_.trim).map(Problem::parseNestedParens).reduce(_.maxBy(Comparator.naturalOrder()))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var result = List[Long]()\n        for (i <- 0 until paren_list.length) {\n            var level = 0\n            var paren_str = paren_list[i]\n            for (j <- 0 until paren_str.length) {\n                if (paren_str[j] == '(') {\n                    level += 1\n                } else if (paren_str[j] == ')') {\n                    level -= 1\n                }\n                if (level == 0) {\n                    result = result.append(j)\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292639,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_qk3e974.scala:14:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen_str\u001b[0m = paren_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_qk3e974.scala:16:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_str[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_qk3e974.scala:18:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_str[j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_qk3e974.scala:22:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                    result = result.append(j)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = List[Long]()\n        for (i <- 0 until parens.length) {\n            val paren = parens(i)\n            val depth = depth(paren)\n            result = result.append(depth)\n        }\n        return result\n    }\n\n    // Returns the depth of the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> depth(\"(()()) ((())) () ((())()())\"))\n    // 2\n    def depth(paren : String) : Long = {\n        val parens = paren.split(\" \")\n        val result = 0L\n        for (i <- 0 until parens.length) {\n            val paren = parens(i)\n            val depth = depth(paren)\n            if (depth > result) {\n                result = depth\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpk3ja6glu.scala:14:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdepth\u001b[0m = depth(paren)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mdepth\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpk3ja6glu.scala:15:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result = result.append(depth)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpk3ja6glu.scala:31:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                result = depth\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var paren_list_len = paren_list.length\n        var result = List[Long]()\n        for (i <- 0 until paren_list_len) {\n            var paren_group = paren_list[i]\n            var paren_group_len = paren_group.length\n            var paren_group_count = 0\n            for (j <- 0 until paren_group_len) {\n                if (paren_group[j] == '(') {\n                    paren_group_count += 1\n                } else if (paren_group[j] == ')') {\n                    paren_group_count -= 1\n                }\n            }\n            result = result.append(paren_group_count)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292640,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7vtzeyl5.scala:14:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen_group\u001b[0m = paren_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7vtzeyl5.scala:18:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                \u001b[33mif\u001b[0m (paren_group[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7vtzeyl5.scala:20:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_group[j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7vtzeyl5.scala:24:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            result = result.append(paren_group_count)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseParen).toList\n        result.sort(Comparator.comparingLong(l -> l))\n        return result\n    }\n\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens(\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseParen(paren : String) : Long = {\n        val parens = paren.split(\"(\")\n        val result = parens.map(Problem.parseParen).toList\n        result.sort(Comparator.comparingLong(l -> l))\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphupd4b_z.scala:12:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        result.sort(Comparator.comparingLong(l -> l))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m  value sort is not a member of List[Long] - did you mean result.sortBy?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphupd4b_z.scala:12:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        result.sort(Comparator.comparingLong(l -> l))\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: Comparator\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphupd4b_z.scala:24:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        result.sort(Comparator.comparingLong(l -> l))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue sort is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphupd4b_z.scala:24:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        result.sort(Comparator.comparingLong(l -> l))\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: Comparator\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphupd4b_z.scala:25:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mreturn\u001b[0m result\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Found:    (result : List[Long])\n\u001b[31m   |\u001b[0m               Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var parens = paren_string.split(\" \")\n        var max_nesting = 0\n        var max_nesting_index = 0\n        for (i <- 0 until parens.length) {\n            var nesting = 0\n            for (j <- 0 until parens[i].length) {\n                if (parens[i][j] == '(') {\n                    nesting += 1\n                } else if (parens[i][j] == ')') {\n                    nesting -= 1\n                }\n                if (nesting > max_nesting) {\n                    max_nesting = nesting\n                    max_nesting_index = i\n                }\n            }\n        }\n        var result = List[Long]()\n        for (i <- 0 until max_nesting_index) {\n            result = result.append(i)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiuhjjogu.scala:15:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until parens[\u001b[35mi\u001b[0m].length) {\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiuhjjogu.scala:16:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (parens[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiuhjjogu.scala:16:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (parens[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiuhjjogu.scala:18:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (parens[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiuhjjogu.scala:18:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (parens[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpiuhjjogu.",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpf61ngfhb.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpf61ngfhb.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(p -> {\n            val parens = p.split(\"(\")\n            val depth = parens.length - 1\n            return depth\n        }).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292640,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy48evwi0.scala:11:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(p -> {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: p\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpy48evwi0.scala:15:10 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        }).toList\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var parens = paren_string.split(\" \")\n        var result = List[Long]()\n        for (i <- 0 until parens.length) {\n            var level = 0\n            for (j <- 0 until parens[i].length) {\n                if (parens[i][j] == '(') {\n                    level += 1\n                } else if (parens[i][j] == ')') {\n                    level -= 1\n                }\n                if (level < 0) {\n                    throw new RuntimeException(\"Invalid parentheses\")\n                }\n            }\n            result = result.append(level.toLong)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292640,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfs2psq9o.scala:14:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until parens[\u001b[35mi\u001b[0m].length) {\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfs2psq9o.scala:15:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                \u001b[33mif\u001b[0m (parens[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfs2psq9o.scala:15:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                \u001b[33mif\u001b[0m (parens[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfs2psq9o.scala:17:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (parens[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfs2psq9o.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (parens[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfs2psq9o.",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens).reduce(List[Long]())\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4lc2txvn.scala:11:76 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]())\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    List[Long]\n\u001b[31m   |\u001b[0m                        Required: (List[Long], List[Long]) => List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        val result_list = result.map(Long.parseLong).toList\n        result_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuygvrdlp.scala:12:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult_list\u001b[0m = result.map(Long.parseLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value parseLong is not a member of object Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmpuygvrdlp.scala:12:52 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult_list\u001b[0m = result.map(Long.parseLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpiyfzvtbd.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpiyfzvtbd.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var parens = paren_string.split(\" \")\n        var max_depth = 0\n        var max_depth_index = 0\n        for (i <- 0 until parens.length) {\n            var depth = 0\n            for (j <- 0 until parens.length) {\n                if (parens[j].equals(\"(\")) depth += 1\n                if (parens[j].equals(\")\")) depth -= 1\n                if (depth > max_depth) {\n                    max_depth = depth\n                    max_depth_index = j\n                }\n            }\n        }\n        var result = List[Long]()\n        for (i <- 0 until max_depth_index) {\n            result = result.append(Long(parens[i].length()))\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292640,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwyf7pkjv.scala:16:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (parens[\u001b[35mj\u001b[0m].equals(\u001b[31m\"(\"\u001b[0m)) depth += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwyf7pkjv.scala:17:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (parens[\u001b[35mj\u001b[0m].equals(\u001b[31m\")\"\u001b[0m)) depth -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwyf7pkjv.scala:26:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            result = result.append(Long(parens[\u001b[35mi\u001b[0m].length()))\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpwyf7pkjv.scala:26:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            result = result.append(Long(parens[\u001b[35mi\u001b[0m].length()))\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   \u001b[33mobject\u001b[0m \u001b[35mLong\u001b[0m in \u001b[33mpackage\u001b[0m \u001b[35mscala\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwyf7pkjv.scala:26:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            result = result.append(Long(parens[\u001b[35mi\u001b[0m].length()))\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(s => {\n            val parens = s.split(\"(\")\n            val max_nesting = parens.map(s1 => {\n                val parens1 = s1.split(\")\")\n                return parens1.length - 1\n            }).max()\n            return max_nesting\n        }).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbt0441yo.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                \u001b[33mreturn\u001b[0m parens1.length - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    Int\n\u001b[31m   |\u001b[0m                       Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpbt0441yo.scala:16:14 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            }).max()\n\u001b[31m\u001b[31m   |\u001b[0m              ^\u001b[0m\n\u001b[31m   |\u001b[0m              No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m              where:    B is a type variable\n\u001b[31m\u001b[31m-- Error: /tmp/tmpbt0441yo.scala:18:10 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        }).toList\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          where:    B is a type variable\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var max_nesting = 0\n        var result = List[Long]()\n        for (i <- 0 until paren_list.length) {\n            var paren_group = paren_list[i]\n            var paren_count = 0\n            for (j <- 0 until paren_group.length) {\n                if (paren_group[j] == '(') {\n                    paren_count += 1\n                } else if (paren_group[j] == ')') {\n                    paren_count -= 1\n                }\n                if (paren_count > max_nesting) {\n                    max_nesting = paren_count\n                }\n            }\n            result = result.append(max_nesting)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292640,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcq02xemj.scala:14:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen_group\u001b[0m = paren_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcq02xemj.scala:17:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (paren_group[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcq02xemj.scala:19:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_group[j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcq02xemj.scala:26:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            result = result.append(max_nesting)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var max_nesting = 0\n        var max_nesting_index = 0\n        for (i <- 0 until paren_list.length) {\n            var nesting = 0\n            for (j <- i until paren_list.length) {\n                if (paren_list[j] == \"(\" && paren_list[j - 1] == \")\") {\n                    nesting += 1\n                } else if (paren_list[j] == \")\" && paren_list[j - 1] == \")\") {\n                    nesting -= 1\n                }\n                if (nesting > max_nesting) {\n                    max_nesting = nesting\n                    max_nesting_index = j\n                }\n            }\n        }\n        var result = List[Long]()\n        for (i <- 0 until max_nesting_index) {\n            result = result.append(Long(paren_list[i].toLong))\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292640,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5p1a99_s.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mj\u001b[0m] == \u001b[31m\"(\"\u001b[0m && paren_list[\u001b[35mj\u001b[0m \u001b[35m-\u001b[0m \u001b[31m1\u001b[0m] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5p1a99_s.scala:18:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[j] == \u001b[31m\")\"\u001b[0m && paren_list[j - \u001b[31m1\u001b[0m] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5p1a99_s.scala:29:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            result = result.append(Long(paren_list[\u001b[35mi\u001b[0m].toLong))\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp5p1a99_s.scala:29:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            result = result.append(Long(paren_list[\u001b[35mi\u001b[0m].toLong))\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   \u001b[33mobject\u001b[0m \u001b[35mLong\u001b[0m in \u001b[33mpackage\u001b[0m \u001b[35mscala\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5p1a99_s.scala:29:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            result = result.append(Long(paren_list[\u001b[35mi\u001b[0m].toLong))\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   Not found: type i\n\u001b[31m   |\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(s => {\n            val parens = s.split(\"(\")\n            val paren_count = parens.length - 1\n            val max_paren_count = paren_count\n            for (i <- 0 until paren_count) {\n                val paren_count_i = parens[i].length - 1\n                if (paren_count_i > max_paren_count) max_paren_count = paren_count_i\n            }\n            return max_paren_count\n        })\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292653,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpa6pbadpa.scala:16:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mparen_count_i\u001b[0m = parens[\u001b[35mi\u001b[0m].length - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpa6pbadpa.scala:17:69 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (paren_count_i > max_paren_count) max_paren_count = paren_count_i\n\u001b[31m\u001b[31m   |\u001b[0m                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Reassignment to val max_paren_count\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpa6pbadpa.scala:19:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mreturn\u001b[0m max_paren_count\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (max_paren_count : Int)\n\u001b[31m   |\u001b[0m                   Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpa6pbadpa.scala:20:10 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        })\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          where:    B is a type variable\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.toLong).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"(()())\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:697)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$1(tmp1_0xw5jf.scala:11)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseNestedParens(tmp1_0xw5jf.scala:11)\n\tat Problem$.main(tmp1_0xw5jf.scala:15)\n\tat Problem.main(tmp1_0xw5jf.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val paren_list = paren_string.split(\" \")\n        val result = paren_list.map(s => {\n            val paren_list = s.split(\"(\")\n            val paren_list_2 = paren_list.map(s2 => {\n                val paren_list_3 = s2.split(\")\")\n                val paren_list_4 = paren_list_3.map(s3 => {\n                    val paren_list_5 = s3.split(\"(\")\n                    val paren_list_6 = paren_list_5.map(s4 => {\n                        val paren_list_7 = s4.split(\")\")\n                        val paren_list_8 = paren_list_7.map(s5 => {\n                            val paren_list_9 = s5.split(\"(\")\n                            val paren_list_10 = paren_list_9.map(s6 => {\n                                val paren_list_11 = s6.split(\")\")\n                                val paren_list_12 = paren_list_11.map(s7 => {\n                                    val paren_list_13 = s7.split(\"(\")\n                                    val paren_list_14 = paren_list_13.map(s8 => {\n                                        val paren_list_15 = s8.split(\")\")\n                                        val paren_list_16 = paren_list_15.map(s9 => {\n                                            val paren_list_17 = s9.split(\"(\")\n                                            val paren_list_18 = paren_list_17.map(s10 => {\n                                                val paren_list_19 = s10.split(\")\")\n                                                val paren_list_20 = paren_list_19.map(s11 => {\n                                                    val paren_list_21 = s11.split(\"(\")\n                                                    val paren_list_22 = paren_list_21.map(s12 => {\n                                                        val paren_list_23 = s12.\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292651,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7ox91slt.scala:35:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7ox91slt.scala:36:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m    ^^^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but 'def' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7ox91slt.scala:43:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m')' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7ox91slt.scala:42:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        val result_list = result.map(_.split(\"(\")).map(_.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        result_list.forEach(x -> {\n            val result_list_2 = x.map(_.split(\"(\")).map(_.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n            result_list_2.forEach(y -> {\n                val result_list_3 = y.map(_.split(\"(\")).map(_.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n                result_list_3.forEach(z -> {\n                    val result_list_4 = z.map(_.split(\"(\")).map(_.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n                    result_list_4.forEach(w -> {\n                        val result_list_5 = w.map(_.split(\"(\")).map(_.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n                        result_list_5.forEach(v -> {\n                            val result_list_6 = v.map(_.split(\"(\")).map(_.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n                            result_list_6.forEach(u -> {\n                                val result_list_7 = u.map(_.split(\"(\")).map(_.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n                                result_list_7.forEach(t -> {\n                                    val result_list_8 = t.map(_.split(\"(\")).map(_.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n                                    result_list_8.forEach(s -> {\n                                        val result_list_9 = s.map(_.split(\"(\")).map(_.map(_.trim).map(_.replaceAll(\"[()\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292651,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpgfekrnyi.scala:13:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        result_list.forEach(x -> {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'.'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpgfekrnyi.scala:28:115 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                                        \u001b[33mval\u001b[0m \u001b[36mresult_list_9\u001b[0m = s.map(_.split(\u001b[31m\"(\"\u001b[0m)).map(_.map(_.trim).map(_.replaceAll(\"[()\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                 unclosed string literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmpgfekrnyi.scala:37:0 ------------------------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0mNo ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mwhere:    B is a type variable\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens1).reduce(_.maxBy(Comparator.naturalOrder()))\n        return result\n    }\n\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens1((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens1(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens2).reduce(_.maxBy(Comparator.naturalOrder()))\n        return result\n    }\n\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens2((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens2(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens3).reduce(_.maxBy(Comparator.naturalOrder()))\n        return result\n    }\n\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292653,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp2qj9c87i.scala:47:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp2qj9c87i.scala:11:67 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens1).reduce(_.maxBy(Comparator.naturalOrder()))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 2\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp2qj9c87i.scala:22:67 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens2).reduce(_.maxBy(Comparator.naturalOrder()))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 2\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2qj9c87i.scala:33:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens3).reduce(_.maxBy(Comparator.naturalOrder()))\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue parseNestedParens3 is not a member of object Problem - did you mean Problem.parseNestedParens?\n\u001b[31m\u001b[31m-- Error: /tmp/tmp2qj9c87i.scala:33:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens3).reduce(_.maxBy(Comparator.naturalOrder()))\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2qj9c87i.sc",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(s => {\n            val parens = s.split(\"(\")\n            val depth = parens.length - 1\n            val max_depth = depth.max()\n            return max_depth\n        }).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292651,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp72eb6ei6.scala:14:37 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mmax_depth\u001b[0m = depth.max()\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter that of \u001b[33mmethod\u001b[0m \u001b[35mmax\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mRichInt\u001b[0m: (that: Int): Int\n\u001b[31m\u001b[31m-- Error: /tmp/tmp72eb6ei6.scala:16:10 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        }).toList\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.toLong).toList\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292653,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"(()())\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:697)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$1(tmpircx9is_.scala:11)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseNestedParens(tmpircx9is_.scala:11)\n\tat Problem$.main(tmpircx9is_.scala:15)\n\tat Problem.main(tmpircx9is_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpiyfzvtbd.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpiyfzvtbd.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens_helper).reduce(List[Long]::concat)\n        return result\n    }\n\n    // Helper function for parseNestedParens.\n    // Returns the depth of the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens_helper(\"(()()) ((())) () ((())()())\")(0)\n    // 2\n    def parseNestedParens_helper(parens : String, depth : Long) : Long = {\n        if (parens.isEmpty()) {\n            return depth\n        } else {\n            val curr_depth = depth + 1\n            val curr_parens = parens.substring(0, 1)\n            val next_depth = parseNestedParens_helper(parens.substring(1), curr_depth)\n            if (next_depth > curr_depth) {\n                return next_depth\n            } else {\n                return curr_depth\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292653,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpoo67ky20.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens_helper).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value :: is not a member of (String, Long) => Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmpoo67ky20.scala:11:66 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens_helper).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val paren_list = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        val paren_counts = paren_list.map(parens => parens.length()).toSeq\n        val max_paren_count = paren_counts.max()\n        val max_paren_count_index = paren_counts.indexOf(max_paren_count)\n        val max_paren_count_list = paren_list.take(max_paren_count_index)\n        val max_paren_count_list_length = max_paren_count_list.length\n        val max_paren_count_list_as_longs = max_paren_count_list.map(Long).toSeq\n        val max_paren_count_as_long = max_paren_count_list_as_longs.head\n        val max_paren_count_as_long_as_long = max_paren_count_as_long.toLong\n        val max_paren_count_as_long_as_long_as_long = max_paren_count_as_long_as_long.toLong\n        val max_paren_count_as_long_as_long_as_long_as_long = max_paren_count_as_long_as_long_as_long.toLong\n        val max_paren_count_as_long_as_long_as_long_as_long_as_long = max_paren_count_as_long_as_long_as_long_as_long.toLong\n        val max_paren_count_as_long_as_long_as_long_as_long_as_long_as_long = max_paren_count_as_long_as_long_as_long_as_long_as_long.toLong\n        val max_paren_count_as_long_as_long_as_long_as_long_as_long_as_long_as_long = max_paren_count_as_long_as_long_as_long_as_long_as_long_as\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292653,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp885d3hdx.scala:13:46 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax_paren_count\u001b[0m = paren_counts.max()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter ord of \u001b[33mmethod\u001b[0m \u001b[35mmax\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOnceOps\u001b[0m: (\u001b[33mimplicit \u001b[0mord: Ordering[B]): Int\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp885d3hdx.scala:17:69 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax_paren_count_list_as_longs\u001b[0m = max_paren_count_list.map(Long).toSeq\n\u001b[31m\u001b[31m   |\u001b[0m                                                                     ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                 Found:    Long.type\n\u001b[31m   |\u001b[0m                                                 Required: String => Any\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp885d3hdx.scala:17:74 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax_paren_count_list_as_longs\u001b[0m = max_paren_count_list.map(Long).toSeq\n\u001b[31m\u001b[31m   |\u001b[0m                                                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp885d3hdx.scala:24:86 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax_paren_count_as_long_as_long_as_long_as_long_as_long_as_long_as_long\u001b[0m = max_paren_count_as_long_as_long_as_long_as_long_as_long_as\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m   Not found: max_paren_count_as_long_as_long_as_long_as_long_as_long_as\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation av",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var parens = paren_string.split(\" \")\n        var result = List[Long]()\n        for (i <- 0 until parens.length) {\n            var level = 0\n            for (j <- 0 until parens[i].length) {\n                if (parens[i][j] == '(') {\n                    level += 1\n                } else if (parens[i][j] == ')') {\n                    level -= 1\n                }\n                if (level < 0) {\n                    throw new RuntimeException(\"Invalid parentheses string\")\n                }\n            }\n            result = result.append(level.toLong)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292651,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzjyi2ep4.scala:14:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until parens[\u001b[35mi\u001b[0m].length) {\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzjyi2ep4.scala:15:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                \u001b[33mif\u001b[0m (parens[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzjyi2ep4.scala:15:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                \u001b[33mif\u001b[0m (parens[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzjyi2ep4.scala:17:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (parens[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzjyi2ep4.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (parens[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzjyi2ep4.",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens).reduce(List[Long]::concat)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292649,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzt_qoqms.scala:11:78 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: concat\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var result = List[Long]()\n        for (i <- 0 until paren_list.length) {\n            var paren_group = paren_list[i]\n            var paren_count = 0\n            for (j <- 0 until paren_group.length) {\n                if (paren_group[j] == '(') {\n                    paren_count += 1\n                } else if (paren_group[j] == ')') {\n                    paren_count -= 1\n                }\n            }\n            result = result.append(paren_count)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292640,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo0yz5gjh.scala:13:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen_group\u001b[0m = paren_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo0yz5gjh.scala:16:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_group[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo0yz5gjh.scala:18:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_group[j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo0yz5gjh.scala:22:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            result = result.append(paren_count)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        val result_list = result.map(Long.parseLong).toList\n        return result_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292652,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpulyo352r.scala:12:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult_list\u001b[0m = result.map(Long.parseLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value parseLong is not a member of object Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmpulyo352r.scala:12:52 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult_list\u001b[0m = result.map(Long.parseLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var parens = paren_string.split(\" \")\n        var result = List[Long]()\n        for (i <- 0 until parens.length) {\n            var paren = parens[i]\n            var depth = 0\n            for (j <- 0 until paren.length) {\n                if (paren[j] == '(') depth += 1\n                if (paren[j] == ')') depth -= 1\n                if (depth < 0) throw new RuntimeException(\"Invalid parentheses\")\n            }\n            result = result.append(depth)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292653,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpk9s9m44b.scala:13:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen\u001b[0m = parens[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpk9s9m44b.scala:16:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) depth += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpk9s9m44b.scala:17:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (paren[\u001b[35mj\u001b[0m] == \u001b[31m')'\u001b[0m) depth -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpk9s9m44b.scala:20:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            result = result.append(depth)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(_.maxBy(Comparator.naturalOrder()))\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292653,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0gt_2iye.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(_.maxBy(Comparator.naturalOrder()))\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmp0gt_2iye.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(_.maxBy(Comparator.naturalOrder()))\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        val result_list = result.map(Long::parseLong).toList\n        return result_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292652,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo8xijqtb.scala:12:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult_list\u001b[0m = result.map(Long::parseLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Not found: parseLong\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpo8xijqtb.scala:12:53 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult_list\u001b[0m = result.map(Long::parseLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpiyfzvtbd.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpiyfzvtbd.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var result = List[Long]()\n        for (i <- 0 until paren_list.length) {\n            var paren_group = paren_list[i]\n            var paren_count = 0\n            for (j <- 0 until paren_group.length) {\n                if (paren_group[j] == \"(\" || paren_group[j] == \"{\") {\n                    paren_count += 1\n                } else if (paren_group[j] == \")\" || paren_group[j] == \"}\") {\n                    paren_count -= 1\n                }\n            }\n            result = result.append(paren_count.toLong)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292653,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_keego6h.scala:13:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen_group\u001b[0m = paren_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_keego6h.scala:16:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_group[\u001b[35mj\u001b[0m] == \u001b[31m\"(\"\u001b[0m || paren_group[\u001b[35mj\u001b[0m] == \u001b[31m\"{\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_keego6h.scala:18:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_group[j] == \u001b[31m\")\"\u001b[0m || paren_group[j] == \u001b[31m\"}\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_keego6h.scala:22:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            result = result.append(paren_count.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(s => {\n            val parens = s.split(\"(\")\n            val depth = parens.length - 1\n            val max_depth = depth.max()\n            return depth.map(d => d.toLong)\n        }).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292652,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmplirig6gf.scala:14:37 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mmax_depth\u001b[0m = depth.max()\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter that of \u001b[33mmethod\u001b[0m \u001b[35mmax\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mRichInt\u001b[0m: (that: Int): Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplirig6gf.scala:15:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mreturn\u001b[0m depth.map(\u001b[36md\u001b[0m => d.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value map is not a member of Int\n\u001b[31m\u001b[31m-- Error: /tmp/tmplirig6gf.scala:16:10 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        }).toList\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          where:    B is a type variable\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var parens = paren_string.split(\" \")\n        var result = List[Long]()\n        for (i <- 0 until parens.length) {\n            var paren = parens[i]\n            var depth = 0\n            for (j <- 0 until paren.length) {\n                if (paren[j] == '(') {\n                    depth += 1\n                } else if (paren[j] == ')') {\n                    depth -= 1\n                }\n                if (depth == 0) {\n                    result = result.append(j)\n                    break\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292653,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp14clzsn6.scala:13:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen\u001b[0m = parens[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp14clzsn6.scala:16:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp14clzsn6.scala:18:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren[j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp14clzsn6.scala:22:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                    result = result.append(j)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp14clzsn6.scala:23:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens_).reduce(List[Long]::concat)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292653,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpllby_f2h.scala:11:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens_).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue parseNestedParens_ is not a member of object Problem - did you mean Problem.parseNestedParens?\n\u001b[31m\u001b[31m-- Error: /tmp/tmpllby_f2h.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens_).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var parens = paren_string.split(\" \")\n        var result = List[Long]()\n        for (i <- 0 until parens.length) {\n            var paren = parens[i]\n            if (paren.equals(\"\")) {\n                continue\n            }\n            var depth = 0\n            for (j <- 0 until paren.length) {\n                if (paren[j] == '(') {\n                    depth += 1\n                } else if (paren[j] == ')') {\n                    depth -= 1\n                }\n                if (depth < 0) {\n                    throw new RuntimeException(\"Invalid parentheses\")\n                }\n            }\n            result = result.append(depth.toLong)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292653,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpayno41z2.scala:13:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen\u001b[0m = parens[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpayno41z2.scala:15:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                continue\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: continue\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpayno41z2.scala:19:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                \u001b[33mif\u001b[0m (paren[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpayno41z2.scala:21:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren[j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpayno41z2.scala:28:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            result = result.append(depth.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        result.map(_.toLong).toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292654,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.parseNestedParens$$anonfun$1(tmpth3a8rwm.scala:12)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseNestedParens(tmpth3a8rwm.scala:12)\n\tat Problem$.main(tmpth3a8rwm.scala:15)\n\tat Problem.main(tmpth3a8rwm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var result = mutable.List[Long]()\n        var parens = paren_string.split(\" \")\n        for (i <- 0 until parens.length) {\n            var paren = parens[i]\n            var depth = 0\n            for (j <- 0 until paren.length) {\n                if (paren[j] == '(') {\n                    depth += 1\n                } else if (paren[j] == ')') {\n                    depth -= 1\n                }\n                if (depth < 0) {\n                    throw new RuntimeException(\"Invalid parentheses\")\n                }\n            }\n            result = result.append(depth.toLong)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292651,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8jba4qf6.scala:10:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8jba4qf6.scala:13:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen\u001b[0m = parens[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8jba4qf6.scala:16:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8jba4qf6.scala:18:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren[j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseParens).reduce(List[Long]::concat)\n        result\n    }\n\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens2((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens2(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseParens).reduce(List[Long]::concat)\n        result\n    }\n\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens3((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens3(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseParens).reduce(List[Long]::concat)\n        result\n    }\n\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens4((\"\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292654,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp6ewqcjl.scala:48:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpp6ewqcjl.scala:11:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value parseParens is not a member of object Problem\n\u001b[31m\u001b[31m-- Error: /tmp/tmpp6ewqcjl.scala:11:52 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpp6ewqcjl.scala:22:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value parseParens is not a member of object Problem\n\u001b[31m\u001b[31m-- Error: /tmp/tmpp6ewqcjl.scala:22:52 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpp6ewqcjl.scala:33:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = pare",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        val result_list = result.map(Long.parseLong).toList\n        return result_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292652,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpulyo352r.scala:12:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult_list\u001b[0m = result.map(Long.parseLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value parseLong is not a member of object Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmpulyo352r.scala:12:52 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult_list\u001b[0m = result.map(Long.parseLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var result = List[Long]()\n        for (i <- 0 until paren_list.length) {\n            var paren_group = paren_list[i]\n            var paren_count = 0\n            for (j <- 0 until paren_group.length) {\n                if (paren_group[j] == \"(\" || paren_group[j] == \")\") {\n                    paren_count += 1\n                }\n            }\n            result = result.append(paren_count)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292653,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj9xs9bzb.scala:13:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen_group\u001b[0m = paren_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj9xs9bzb.scala:16:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_group[\u001b[35mj\u001b[0m] == \u001b[31m\"(\"\u001b[0m || paren_group[\u001b[35mj\u001b[0m] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj9xs9bzb.scala:20:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            result = result.append(paren_count)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val paren_list = parens.map(s => s.replaceAll(\"[()]\", \"\"))\n        val paren_list_length = paren_list.length\n        val result = paren_list.map(s => {\n            val paren_count = 0\n            for (i <- 0 until paren_list_length) {\n                if (s[i] == '(') {\n                    paren_count += 1\n                } else if (s[i] == ')') {\n                    paren_count -= 1\n                }\n                if (paren_count == 0) {\n                    return i\n                }\n            }\n            return -1\n        })\n        result.sort((a, b) => a - b)\n        return result.map(i => paren_list_length - i - 1).toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292664,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcy93t34r.scala:16:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcy93t34r.scala:17:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                    paren_count += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value += is not a member of Int - did you mean paren_count.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcy93t34r.scala:18:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (s[i] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcy93t34r.scala:19:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                    paren_count -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value -= is not a member of Int - did you mean paren_count.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcy93t34r.scala:22:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                    \u001b[33mreturn\u001b[0m i\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (i : Int)\n\u001b[31m   |\u001b[0m                           Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcy93t34r.scala:25:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mreturn\u001b[0m -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (\u001b[31m-1\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                   Req",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"(\", \"\").replaceAll(\")\", \"\"))\n        val result_list = result.map(Long::parseLong).toList\n        return result_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292663,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp2u9ztjv.scala:12:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult_list\u001b[0m = result.map(Long::parseLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Not found: parseLong\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpp2u9ztjv.scala:12:53 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult_list\u001b[0m = result.map(Long::parseLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens_).reduce(List[Long]())\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292663,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwsr5t9x2.scala:11:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens_).reduce(List[\u001b[35mLong\u001b[0m]())\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue parseNestedParens_ is not a member of object Problem - did you mean Problem.parseNestedParens?\n\u001b[31m\u001b[31m-- Error: /tmp/tmpwsr5t9x2.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens_).reduce(List[\u001b[35mLong\u001b[0m]())\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var parens = paren_string.split(\" \")\n        var max_nesting = 0\n        var max_nesting_index = 0\n        for (i <- 0 until parens.length) {\n            var nesting = 0\n            for (j <- 0 until parens[i].length) {\n                if (parens[i][j] == '(') {\n                    nesting += 1\n                } else if (parens[i][j] == ')') {\n                    nesting -= 1\n                }\n                if (nesting > max_nesting) {\n                    max_nesting = nesting\n                    max_nesting_index = i\n                }\n            }\n        }\n        var result = List[Long]()\n        for (i <- 0 until max_nesting_index) {\n            result = result.append(i)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiuhjjogu.scala:15:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until parens[\u001b[35mi\u001b[0m].length) {\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiuhjjogu.scala:16:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (parens[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiuhjjogu.scala:16:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (parens[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiuhjjogu.scala:18:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (parens[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiuhjjogu.scala:18:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (parens[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpiuhjjogu.",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var paren_list_len = paren_list.length\n        var paren_list_len_minus_1 = paren_list_len - 1\n        var max_nesting = 0\n        var max_nesting_index = 0\n        for (i <- 0 to paren_list_len_minus_1) {\n            var nesting = 0\n            var nesting_index = i\n            for (j <- i to paren_list_len_minus_1) {\n                if (paren_list[j].equals(\"(\")) {\n                    nesting += 1\n                } else if (paren_list[j].equals(\")\")) {\n                    nesting -= 1\n                }\n                if (nesting > max_nesting) {\n                    max_nesting = nesting\n                    max_nesting_index = nesting_index\n                }\n            }\n        }\n        var max_nesting_list = paren_list.substring(max_nesting_index, paren_list_len_minus_1).split(\"\")\n        var max_nesting_list_len = max_nesting_list.length\n        var max_nesting_list_len_minus_1 = max_nesting_list_len - 1\n        var max_nesting_list_len_minus_2 = max_nesting_list_len - 2\n        var max_nesting_list_len_minus_3 = max_nesting_list_len - 3\n        var max_nesting_list_len_minus_4 = max_nesting_list_len - 4\n        var max_nesting_list_len_minus_5 = max_nesting_list_len - 5\n        var max_nesting_list_len_minus_6 = max_nesting_list_len - 6\n        var max_nesting_list_len_minus_7 = max_nesting_list_len - 7\n        var max_nesting_list_len_minus_8 = max_nesting_list_len - 8\n        var max_nesting_list_len_minus_9 = max_nesting_list_len - 9\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292665,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5hsxnliv.scala:19:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mj\u001b[0m].equals(\u001b[31m\"(\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5hsxnliv.scala:21:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[j].equals(\u001b[31m\")\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5hsxnliv.scala:30:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmax_nesting_list\u001b[0m = paren_list.substring(max_nesting_index, paren_list_len_minus_1).split(\u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value substring is not a member of Array[String]\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5hsxnliv.scala:41:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val paren_list = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        val paren_list_length = paren_list.length\n        val paren_list_length_minus_1 = paren_list_length - 1\n        val paren_list_length_minus_2 = paren_list_length - 2\n        val paren_list_length_minus_3 = paren_list_length - 3\n        val paren_list_length_minus_4 = paren_list_length - 4\n        val paren_list_length_minus_5 = paren_list_length - 5\n        val paren_list_length_minus_6 = paren_list_length - 6\n        val paren_list_length_minus_7 = paren_list_length - 7\n        val paren_list_length_minus_8 = paren_list_length - 8\n        val paren_list_length_minus_9 = paren_list_length - 9\n        val paren_list_length_minus_10 = paren_list_length - 10\n        val paren_list_length_minus_11 = paren_list_length - 11\n        val paren_list_length_minus_12 = paren_list_length - 12\n        val paren_list_length_minus_13 = paren_list_length - 13\n        val paren_list_length_minus_14 = paren_list_length - 14\n        val paren_list_length_minus_15 = paren_list_length - 15\n        val paren_list_length_minus_16 = paren_list_length - 16\n        val paren_list_length_minus_17 = paren_list_length - 17\n        val paren_list_length_minus_18 = paren_list_length - 18\n        val paren_list_length_minus_19 = paren_list_length - 19\n        val paren_list_length_minus_20 = paren_list_length - 20\n        val paren_list_length_minus\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292664,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpz9rmbw0s.scala:34:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpz9rmbw0s.scala:34:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(_.max)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292664,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpepe54b0_.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(_.max)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpepe54b0_.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(_.max)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val paren_list = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        val paren_count = paren_list.map(Long.parseLong).reduce(0, (a, b) => a + b)\n        val max_paren_count = paren_count.max()\n        val result = paren_list.map(l -> l.length - max_paren_count).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292666,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpn93xu51x.scala:12:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_count\u001b[0m = paren_list.map(Long.parseLong).reduce(\u001b[31m0\u001b[0m, (\u001b[36ma\u001b[0m, \u001b[36mb\u001b[0m) => a + b)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value parseLong is not a member of object Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmpn93xu51x.scala:12:56 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_count\u001b[0m = paren_list.map(Long.parseLong).reduce(\u001b[31m0\u001b[0m, (\u001b[36ma\u001b[0m, \u001b[36mb\u001b[0m) => a + b)\n\u001b[31m\u001b[31m   |\u001b[0m                                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn93xu51x.scala:14:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = paren_list.map(l -> l.length - max_paren_count).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: l\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpn93xu51x.scala:14:68 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = paren_list.map(l -> l.length - max_paren_count).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpiyfzvtbd.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpiyfzvtbd.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val paren_counts = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[^()]\", \"\")).map(_.replaceAll(\"[^()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292666,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpzylv89fm.scala:11:1145 ---------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_counts\u001b[0m = parens.map(_.trim).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[^()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[^()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m)).map(_.replaceAll(\"[()\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                      ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"(\", \"\").replaceAll(\")\", \"\"))\n        val result_list = result.map(_.split(\"(\")).map(x => x.length - 1).toList\n        result_list.foreach(x => {\n            if (x > 0) {\n                System.out.println(x)\n            }\n        })\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292665,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmplt53g7kd.scala:13:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        result_list.foreach(\u001b[36mx\u001b[0m => {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Unit\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m14 |\u001b[0m            \u001b[33mif\u001b[0m (x > \u001b[31m0\u001b[0m) {\n\u001b[31m15 |\u001b[0m                System.out.println(x)\n\u001b[31m16 |\u001b[0m            }\n\u001b[31m17 |\u001b[0m        })\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val paren_list = paren_string.split(\" \")\n        val result = paren_list.map(Problem.parseNestedParens_)\n        return result\n    }\n\n    def parseNestedParens_ (paren_string : String) : Long = {\n        val paren_list = paren_string.split(\"(\")\n        val result = paren_list.map(Problem.parseNestedParens_)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292666,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6ql01qb0.scala:12:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mreturn\u001b[0m result\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m               Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6ql01qb0.scala:18:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mreturn\u001b[0m result\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m               Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var result = List[Long]()\n        for (i <- 0 until paren_list.length) {\n            var paren_group = paren_list[i]\n            var paren_count = 0\n            for (j <- 0 until paren_group.length) {\n                if (paren_group[j] == '(') {\n                    paren_count += 1\n                } else if (paren_group[j] == ')') {\n                    paren_count -= 1\n                }\n            }\n            result = result.append(paren_count)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292640,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo0yz5gjh.scala:13:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen_group\u001b[0m = paren_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo0yz5gjh.scala:16:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_group[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo0yz5gjh.scala:18:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_group[j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo0yz5gjh.scala:22:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            result = result.append(paren_count)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(p -> p.replaceAll(\"[()]\", \"\"))\n        val result_list = result.map(s -> s.split(\"(\")).map(l -> l.length - 1).toList\n        result_list.sort(Comparator.comparing(l -> l))\n        return result_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292665,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqdfvzljo.scala:11:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(p -> p.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: p\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpqdfvzljo.scala:11:62 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(p -> p.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var paren_count = 0\n        var max_paren_count = 0\n        var max_paren_index = 0\n        for (i <- 0 until paren_list.length) {\n            var paren_count_here = 0\n            var paren_count_here_max = 0\n            for (j <- 0 until paren_list[i].length) {\n                if (paren_list[i][j] == '(') {\n                    paren_count_here += 1\n                } else if (paren_list[i][j] == ')') {\n                    paren_count_here -= 1\n                }\n                if (paren_count_here_max < paren_count_here) {\n                    paren_count_here_max = paren_count_here\n                    max_paren_count = paren_count\n                    max_paren_index = i\n                }\n            }\n        }\n        var result = List[Long](max_paren_count)\n        for (i <- 0 until max_paren_index) {\n            result[i] = max_paren_count - paren_count_here\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292661,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmps507r5_q.scala:32:22 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            result[\u001b[35mi\u001b[0m] = max_paren_count - paren_count_here\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      end of statement expected but '=' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps507r5_q.scala:17:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until paren_list[\u001b[35mi\u001b[0m].length) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps507r5_q.scala:18:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps507r5_q.scala:18:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps507r5_q.scala:20:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps507r5_q.scala:20:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m2",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var max_nesting = 0\n        var max_nesting_index = 0\n        for (i <- 0 until paren_list.length) {\n            var nesting = 0\n            for (j <- 0 until paren_list[i].length) {\n                if (paren_list[i][j] == '(') {\n                    nesting += 1\n                } else if (paren_list[i][j] == ')') {\n                    nesting -= 1\n                }\n                if (nesting > max_nesting) {\n                    max_nesting = nesting\n                    max_nesting_index = i\n                }\n            }\n        }\n        var result = List[Long]()\n        for (i <- 0 until max_nesting_index) {\n            result = result.append(paren_list[i].length())\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292665,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6eapc3r4.scala:15:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until paren_list[\u001b[35mi\u001b[0m].length) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6eapc3r4.scala:16:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6eapc3r4.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6eapc3r4.scala:18:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6eapc3r4.scala:18:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-exp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val paren_counts = parens.map(p -> p.split(\"(\")).map(l -> l.length - 1).toList\n        val max_paren_count = paren_counts.max()\n        val result = paren_counts.map(i -> i - max_paren_count).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292665,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptxdxwrd1.scala:11:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_counts\u001b[0m = parens.map(p -> p.split(\u001b[31m\"(\"\u001b[0m)).map(l -> l.length - \u001b[31m1\u001b[0m).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: p\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmptxdxwrd1.scala:11:56 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_counts\u001b[0m = parens.map(p -> p.split(\u001b[31m\"(\"\u001b[0m)).map(l -> l.length - \u001b[31m1\u001b[0m).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var result = List[Long]()\n        for (i <- 0 until paren_list.length) {\n            var paren_group = paren_list[i]\n            var paren_count = 0\n            for (j <- 0 until paren_group.length) {\n                if (paren_group[j] == \"(\" || paren_group[j] == \"{\") {\n                    paren_count += 1\n                } else if (paren_group[j] == \")\" || paren_group[j] == \"}\") {\n                    paren_count -= 1\n                }\n            }\n            result = result.append(paren_count.toLong)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292653,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_keego6h.scala:13:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen_group\u001b[0m = paren_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_keego6h.scala:16:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_group[\u001b[35mj\u001b[0m] == \u001b[31m\"(\"\u001b[0m || paren_group[\u001b[35mj\u001b[0m] == \u001b[31m\"{\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_keego6h.scala:18:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_group[j] == \u001b[31m\")\"\u001b[0m || paren_group[j] == \u001b[31m\"}\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_keego6h.scala:22:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            result = result.append(paren_count.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.toLong).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"(()())\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:697)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$1(tmp1_0xw5jf.scala:11)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseNestedParens(tmp1_0xw5jf.scala:11)\n\tat Problem$.main(tmp1_0xw5jf.scala:15)\n\tat Problem.main(tmp1_0xw5jf.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(s => {\n            val parens = s.split(\"(\")\n            val depth = parens.length - 1\n            val max_depth = depth.max()\n            return depth.toLong\n        })\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp6sgtd2qw.scala:14:37 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mmax_depth\u001b[0m = depth.max()\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter that of \u001b[33mmethod\u001b[0m \u001b[35mmax\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mRichInt\u001b[0m: (that: Int): Int\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6sgtd2qw.scala:15:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mreturn\u001b[0m depth.toLong\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    Long\n\u001b[31m   |\u001b[0m                   Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mLong\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp6sgtd2qw.scala:16:10 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        })\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          where:    B is a type variable\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParensHelper).reduce(List[Long]::concat)\n        return result\n    }\n\n    // Helper function for parseNestedParens\n    def parseNestedParensHelper(left : String, right : String) : List[Long] = {\n        val left_parens = left.count(\"(\").toLong\n        val right_parens = right.count(\")\").toLong\n        if (left_parens > right_parens) {\n            return List[Long](left_parens.toLong)\n        } else if (left_parens < right_parens) {\n            return List[Long](right_parens.toLong)\n        } else {\n            return List[Long](left_parens.toLong, right_parens.toLong)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292666,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpswvslh1o.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParensHelper).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              value :: is not a member of (String, String) => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpswvslh1o.scala:11:65 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParensHelper).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpswvslh1o.scala:17:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mleft_parens\u001b[0m = left.count(\u001b[31m\"(\"\u001b[0m).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    (\u001b[32m\"(\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                                     Required: Char => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpswvslh1o.scala:18:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mright_parens\u001b[0m = right.count(\u001b[31m\")\"\u001b[0m).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Found:    (\u001b[32m\")\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                                       Required: Char => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens1).reduce(List[Long]::concat)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292665,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu1m1qnul.scala:11:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens1).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue parseNestedParens1 is not a member of object Problem - did you mean Problem.parseNestedParens?\n\u001b[31m\u001b[31m-- Error: /tmp/tmpu1m1qnul.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens1).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var max_nesting = 0\n        var max_nesting_index = 0\n        for (i <- 0 until paren_list.length) {\n            var nesting = 0\n            var nesting_index = 0\n            for (j <- 0 until paren_list[i].length()) {\n                if (paren_list[i][j] == '(') {\n                    nesting += 1\n                    nesting_index = j\n                } else if (paren_list[i][j] == ')') {\n                    nesting -= 1\n                    nesting_index = j\n                }\n                if (nesting == 0) {\n                    break\n                }\n            }\n            if (nesting > max_nesting) {\n                max_nesting = nesting\n                max_nesting_index = i\n            }\n        }\n        var result = List[Long]()\n        for (i <- 0 until max_nesting_index) {\n            result = result.append(Long(paren_list[i].length() - nesting_index))\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292665,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjiwa313k.scala:16:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until paren_list[\u001b[35mi\u001b[0m].length()) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjiwa313k.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjiwa313k.scala:17:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjiwa313k.scala:20:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjiwa313k.scala:20:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-e",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = List[Long]()\n        for (i <- 0 until parens.length) {\n            val paren = parens(i)\n            if (paren.startsWith(\"(\")) {\n                val depth = paren.length - 1\n                val level = depth / 2\n                result = result.append(level.toLong)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292665,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp29534yr3.scala:17:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                result = result.append(level.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var result = List[Long]()\n        for (var i = 0; i < paren_list.length; i++) {\n            var paren_group = paren_list[i]\n            var depth = 0\n            for (var j = 0; j < paren_group.length(); j++) {\n                if (paren_group.charAt(j) == '(') {\n                    depth += 1\n                } else if (paren_group.charAt(j) == ')') {\n                    depth -= 1\n                }\n            }\n            result = result.append(depth.toLong)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292666,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpfjntr36o.scala:12:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < paren_list.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfjntr36o.scala:12:45 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < paren_list.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpfjntr36o.scala:12:50 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < paren_list.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfjntr36o.scala:12:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < paren_list.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var max_nesting = 0\n        var result = List[Long]()\n        for (i <- 0 until paren_list.length) {\n            var paren_group = paren_list[i]\n            var paren_count = 0\n            for (j <- 0 until paren_group.length) {\n                if (paren_group[j] == '(') {\n                    paren_count += 1\n                } else if (paren_group[j] == ')') {\n                    paren_count -= 1\n                }\n                if (paren_count > max_nesting) {\n                    max_nesting = paren_count\n                }\n            }\n            result = result.append(max_nesting)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292640,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcq02xemj.scala:14:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen_group\u001b[0m = paren_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcq02xemj.scala:17:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (paren_group[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcq02xemj.scala:19:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_group[j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcq02xemj.scala:26:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            result = result.append(max_nesting)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var paren_count = 0\n        var max_paren_count = 0\n        var max_paren_list = List[Long]()\n        for (i <- 0 until paren_list.length) {\n            var paren_count_here = 0\n            for (j <- 0 until paren_list[i].length) {\n                if (paren_list[i][j] == '(') {\n                    paren_count_here += 1\n                } else if (paren_list[i][j] == ')') {\n                    paren_count_here -= 1\n                }\n                if (paren_count_here == 0) {\n                    break\n                }\n            }\n            if (paren_count_here > max_paren_count) {\n                max_paren_count = paren_count_here\n                max_paren_list = List[Long](i.toLong, j.toLong)\n            }\n        }\n        return max_paren_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292661,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy7f112mt.scala:16:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until paren_list[\u001b[35mi\u001b[0m].length) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy7f112mt.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy7f112mt.scala:17:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy7f112mt.scala:19:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy7f112mt.scala:19:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-exp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(p -> {\n            val parens = p.split(\"(\")\n            val parens_count = parens.length - 1\n            val max_nesting = parens_count.max()\n            return max_nesting\n        })\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292665,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf_bkpo48.scala:11:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(p -> {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: p\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpf_bkpo48.scala:16:10 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        })\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpiyfzvtbd.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpiyfzvtbd.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(p -> {\n            val parens = p.split(\"(\")\n            val parens_len = parens.length\n            if (parens_len == 1) {\n                return 1l\n            } else {\n                return parens_len\n            }\n        }).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292666,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbv_saftf.scala:11:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(p -> {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: p\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpbv_saftf.scala:19:10 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        }).toList\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(_.maxBy(l -> l))\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292667,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu_jmk6zj.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(_.maxBy(l -> l))\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpu_jmk6zj.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(_.maxBy(l -> l))\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens).reduce(List[Long]())\n        return result\n    }\n\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens2((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens2(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens2).reduce(List[Long]())\n        return result\n    }\n\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens3((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens3(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens3).reduce(List[Long]())\n        return result\n    }\n\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens4\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292676,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp6theoped.scala:48:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6theoped.scala:11:76 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]())\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    List[Long]\n\u001b[31m   |\u001b[0m                        Required: (List[Long], List[Long]) => List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6theoped.scala:22:77 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens2).reduce(List[\u001b[35mLong\u001b[0m]())\n\u001b[31m\u001b[31m   |\u001b[0m                                                                   ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    List[Long]\n\u001b[31m   |\u001b[0m                        Required: (List[Long], List[Long]) => List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6theoped.scala:33:77 --------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens3).reduce(List[\u001b[35mLong\u001b[0m]())\n\u001b[31m\u001b[31m   |\u001b[0m                                                                   ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    List[Long]\n\u001b[31m   |\u001b[0m                        Required: (List[Long], List[Long]) => List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6theoped.scala:43:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m    assert(parseNestedParens((\u001b[31m\"(()()) ((())) () ((())()())\"\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        result.map(_.toLong).toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292654,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.parseNestedParens$$anonfun$1(tmpth3a8rwm.scala:12)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseNestedParens(tmpth3a8rwm.scala:12)\n\tat Problem$.main(tmpth3a8rwm.scala:15)\n\tat Problem.main(tmpth3a8rwm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val paren_list = parens.map(s => s.replaceAll(\"[()]\", \"\"))\n        val paren_list_len = paren_list.length\n        val max_nesting = paren_list_len.max()\n        val result = paren_list.map(s => s.length() - max_nesting)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292673,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp2_43b6xt.scala:13:44 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax_nesting\u001b[0m = paren_list_len.max()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter that of \u001b[33mmethod\u001b[0m \u001b[35mmax\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mRichInt\u001b[0m: (that: Int): Int\n\u001b[31m\u001b[31m-- Error: /tmp/tmp2_43b6xt.scala:14:66 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = paren_list.map(\u001b[36ms\u001b[0m => s.length() - max_nesting)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var result = List[Long]()\n        for (var i = 0; i < paren_list.length; i++) {\n            var paren_group = paren_list[i]\n            var depth = 0\n            for (var j = 0; j < paren_group.length(); j++) {\n                if (paren_group.charAt(j) == '(') {\n                    depth += 1\n                } else if (paren_group.charAt(j) == ')') {\n                    depth -= 1\n                }\n                if (depth < 0) {\n                    throw new RuntimeException(\"Invalid parentheses string\")\n                }\n            }\n            result = result.append(depth)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292677,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpqzoyy3n5.scala:12:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < paren_list.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqzoyy3n5.scala:12:45 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < paren_list.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpqzoyy3n5.scala:12:50 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < paren_list.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqzoyy3n5.scala:12:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < paren_list.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var parens = paren_string.split(\" \")\n        var max_nesting = 0\n        var result = List[Long]()\n        for (i <- 0 until parens.length) {\n            var cur_nesting = 0\n            for (j <- 0 until parens[i].length) {\n                if (parens[i][j] == '(') {\n                    cur_nesting += 1\n                } else if (parens[i][j] == ')') {\n                    cur_nesting -= 1\n                }\n                if (cur_nesting > max_nesting) {\n                    max_nesting = cur_nesting\n                }\n            }\n            result = result.append(max_nesting)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292675,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_fwfmomc.scala:15:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until parens[\u001b[35mi\u001b[0m].length) {\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_fwfmomc.scala:16:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (parens[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_fwfmomc.scala:16:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (parens[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_fwfmomc.scala:18:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (parens[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_fwfmomc.scala:18:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (parens[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_fwfmomc.",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.toLong).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"(()())\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:697)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$1(tmp1_0xw5jf.scala:11)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseNestedParens(tmp1_0xw5jf.scala:11)\n\tat Problem$.main(tmp1_0xw5jf.scala:15)\n\tat Problem.main(tmp1_0xw5jf.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpiyfzvtbd.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpiyfzvtbd.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var paren_count = 0\n        var max_paren_count = 0\n        var result = List[Long]()\n        for (i <- 0 until paren_list.length) {\n            if (paren_list[i] == \"\") continue\n            if (paren_list[i] == \"(\" || paren_list[i] == \"{\" || paren_list[i] == \"[\") {\n                paren_count += 1\n            } else if (paren_list[i] == \")\" || paren_list[i] == \"}\" || paren_list[i] == \"]\") {\n                paren_count -= 1\n            }\n            if (paren_count > max_paren_count) {\n                max_paren_count = paren_count\n            }\n        }\n        for (i <- 0 until paren_list.length) {\n            if (paren_list[i] == \"\") continue\n            if (paren_list[i] == \"(\" || paren_list[i] == \"{\" || paren_list[i] == \"[\") {\n                result = result.append(max_paren_count)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292676,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf36ul2xl.scala:15:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m] == \u001b[31m\"\"\u001b[0m) continue\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf36ul2xl.scala:15:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m] == \u001b[31m\"\"\u001b[0m) continue\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: continue\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf36ul2xl.scala:16:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m] == \u001b[31m\"(\"\u001b[0m || paren_list[\u001b[35mi\u001b[0m] == \u001b[31m\"{\"\u001b[0m || paren_list[\u001b[35mi\u001b[0m] == \u001b[31m\"[\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf36ul2xl.scala:18:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i] == \u001b[31m\")\"\u001b[0m || paren_list[i] == \u001b[31m\"}\"\u001b[0m || paren_list[i] == \u001b[31m\"]\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf36ul2xl.scala:26:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m] == \u001b[31m\"\"\u001b[0m) continue\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer exp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var max_nesting = 0\n        var max_nesting_index = 0\n        for (i <- 0 until paren_list.length) {\n            var nesting = 0\n            for (j <- 0 until paren_list[i].length) {\n                if (paren_list[i][j] == '(') {\n                    nesting += 1\n                } else if (paren_list[i][j] == ')') {\n                    nesting -= 1\n                }\n                if (nesting > max_nesting) {\n                    max_nesting = nesting\n                    max_nesting_index = i\n                }\n            }\n        }\n        var result = List[Long]()\n        for (i <- 0 until max_nesting_index) {\n            result = result.append(max_nesting)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292676,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpc8cynnu6.scala:15:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until paren_list[\u001b[35mi\u001b[0m].length) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpc8cynnu6.scala:16:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpc8cynnu6.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpc8cynnu6.scala:18:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpc8cynnu6.scala:18:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-exp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens1).reduce(List[Long]())\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292677,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpigcm6sln.scala:11:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens1).reduce(List[\u001b[35mLong\u001b[0m]())\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue parseNestedParens1 is not a member of object Problem - did you mean Problem.parseNestedParens?\n\u001b[31m\u001b[31m-- Error: /tmp/tmpigcm6sln.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens1).reduce(List[\u001b[35mLong\u001b[0m]())\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var parens = paren_string.split(\" \")\n        var max_nesting = 0\n        var max_nesting_index = 0\n        for (i <- 0 until parens.length) {\n            var nesting = 0\n            for (j <- 0 until parens[i].length) {\n                if (parens[i][j] == '(') {\n                    nesting += 1\n                } else if (parens[i][j] == ')') {\n                    nesting -= 1\n                }\n                if (nesting > max_nesting) {\n                    max_nesting = nesting\n                    max_nesting_index = i\n                }\n            }\n        }\n        var result = List[Long]()\n        for (i <- 0 until max_nesting_index) {\n            result = result.append(max_nesting)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292677,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqqkx6531.scala:15:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until parens[\u001b[35mi\u001b[0m].length) {\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqqkx6531.scala:16:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (parens[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqqkx6531.scala:16:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (parens[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqqkx6531.scala:18:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (parens[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqqkx6531.scala:18:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (parens[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqqkx6531.",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var paren_count = 0\n        var max_paren_count = 0\n        var max_paren_list = List[Long]()\n        for (i <- 0 until paren_list.length) {\n            var paren_count_here = 0\n            for (j <- 0 until paren_list[i].length) {\n                if (paren_list[i][j] == '(') {\n                    paren_count_here += 1\n                } else if (paren_list[i][j] == ')') {\n                    paren_count_here -= 1\n                }\n                if (paren_count_here == 0) {\n                    break\n                }\n            }\n            if (paren_count_here > max_paren_count) {\n                max_paren_count = paren_count_here\n                max_paren_list = List[Long](i.toLong, j.toLong)\n            }\n        }\n        return max_paren_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292661,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy7f112mt.scala:16:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until paren_list[\u001b[35mi\u001b[0m].length) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy7f112mt.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy7f112mt.scala:17:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy7f112mt.scala:19:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy7f112mt.scala:19:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-exp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens1).reduce(List[Long]::concat)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292678,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpos6n_ism.scala:11:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens1).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue parseNestedParens1 is not a member of object Problem - did you mean Problem.parseNestedParens?\n\u001b[31m\u001b[31m-- Error: /tmp/tmpos6n_ism.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens1).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val paren_list = parens.map(_.trim).map(Problem::parseParens).toList\n        val max_nesting = paren_list.foldLeft(0l, (acc, paren) -> {\n            val depth = paren.count(\"(\") - paren.count(\")\")\n            return depth > acc ? depth : acc\n        })\n        val result = paren_list.map(l -> l.length - max_nesting)\n        return result\n    }\n\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens2((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens2(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val paren_list = parens.map(_.trim).map(Problem::parseParens).toList\n        val max_nesting = paren_list.foldLeft(0l, (acc, paren) -> {\n            val depth = paren.count(\"(\") - paren.count(\")\")\n            return depth > acc ? depth : acc\n        })\n        val result = paren_list.map(l -> l.length - max_nesting)\n        return result\n    }\n\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens3((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292677,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzvxxovhz.scala:48:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzvxxovhz.scala:11:57 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_list\u001b[0m = parens.map(_.trim).map(Problem::parseParens).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Not found: parseParens\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpzvxxovhz.scala:11:69 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_list\u001b[0m = parens.map(_.trim).map(Problem::parseParens).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzvxxovhz.scala:27:57 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_list\u001b[0m = parens.map(_.trim).map(Problem::parseParens).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Not found: parseParens\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpzvxxovhz.scala:27:69 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_list\u001b[0m = parens.map(_.trim).map(Problem::parseParens).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var result = List[Long]()\n        for (i <- 0 until paren_list.length) {\n            var paren_group = paren_list[i].split(\"(\")\n            var paren_depth = paren_group.length - 1\n            for (j <- 0 until paren_depth) {\n                if (paren_group[j].charAt(0) == '(') {\n                    paren_depth = j\n                    break\n                }\n            }\n            result = result.append(paren_depth)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292677,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbbdhtb0z.scala:13:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen_group\u001b[0m = paren_list[\u001b[35mi\u001b[0m].split(\u001b[31m\"(\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbbdhtb0z.scala:16:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_group[\u001b[35mj\u001b[0m].charAt(\u001b[31m0\u001b[0m) == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbbdhtb0z.scala:18:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbbdhtb0z.scala:21:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            result = result.append(paren_depth)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(s => {\n            val parens = s.split(\"(\")\n            val parens_count = parens.length - 1\n            val max_parens_count = parens_count.max()\n            val max_parens_count_index = parens_count.index(max_parens_count)\n            val max_parens_count_count = parens_count.get(max_parens_count_index)\n            val max_parens_count_parens = parens.get(max_parens_count_index)\n            val max_parens_count_parens_count = max_parens_count_parens.length - 1\n            return max_parens_count_parens_count\n        })\n        return result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292679,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp42dqfsh0.scala:14:51 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mmax_parens_count\u001b[0m = parens_count.max()\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter that of \u001b[33mmethod\u001b[0m \u001b[35mmax\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mRichInt\u001b[0m: (that: Int): Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp42dqfsh0.scala:15:54 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mmax_parens_count_index\u001b[0m = parens_count.index(max_parens_count)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      value index is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp42dqfsh0.scala:16:54 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mmax_parens_count_count\u001b[0m = parens_count.get(max_parens_count_index)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value get is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp42dqfsh0.scala:17:49 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mmax_parens_count_parens\u001b[0m = parens.get(max_parens_count_index)\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value get is not a member of Array[String]\n\u001b[31m\u001b[31m-- Error: /tmp/tmp42dqfsh0.scala:20:10 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        })\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          where:    B is a type variable\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var max_nesting = 0\n        var max_nesting_index = 0\n        for (i in 0 until paren_list.length) {\n            var nesting = 0\n            for (j in 0 until i) {\n                if (paren_list[i].charAt(j) == '(') {\n                    nesting += 1\n                } else if (paren_list[i].charAt(j) == ')') {\n                    nesting -= 1\n                }\n                if (nesting > max_nesting) {\n                    max_nesting = nesting\n                    max_nesting_index = j\n                }\n            }\n        }\n        var result = List[Long]()\n        for (i in 0 until max_nesting_index) {\n            result = result.append(Long(paren_list[max_nesting_index].charAt(i) - '0'))\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292679,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpkqtz2f2k.scala:13:45 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mfor\u001b[0m (i in \u001b[31m0\u001b[0m until paren_list.length) {\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but '{' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkqtz2f2k.scala:26:9 -------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m         ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator asScala\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.set asScala\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpiyfzvtbd.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpiyfzvtbd.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val paren_list = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        val paren_counts = paren_list.map(paren_count).toList\n        val max_paren_count = paren_counts.max()\n        val max_paren_index = paren_counts.indexOf(max_paren_count)\n        val max_paren_count_list = paren_counts.take(max_paren_index + 1)\n        val max_paren_count_list_long = max_paren_count_list.map(l.toLong)\n        return max_paren_count_list_long\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292677,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpes2qip10.scala:12:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_counts\u001b[0m = paren_list.map(paren_count).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                          Not found: paren_count\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpes2qip10.scala:12:54 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_counts\u001b[0m = paren_list.map(paren_count).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(Problem::parseNestedParens).reduce(List[Long]::concat)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292678,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_and_y0q.scala:11:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(_.trim).map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmp_and_y0q.scala:11:71 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(_.trim).map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val paren_list = parens.map(p -> p.replaceAll(\"[()]\", \"\"))\n        val paren_count = paren_list.length\n        val result = paren_list.map(p -> p.length() - p.replaceAll(\"[()]\", \"\").length())\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292678,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjszvn7s6.scala:11:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_list\u001b[0m = parens.map(p -> p.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: p\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpjszvn7s6.scala:11:66 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_list\u001b[0m = parens.map(p -> p.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var parens = paren_string.split(\" \")\n        var result = List[Long]()\n        for (i <- 0 until parens.length) {\n            var paren = parens[i]\n            var depth = 0\n            for (j <- 0 until paren.length) {\n                if (paren[j] == '(') {\n                    depth += 1\n                } else if (paren[j] == ')') {\n                    depth -= 1\n                }\n            }\n            result = result.append(depth.toLong)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292678,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxsz8kbrc.scala:13:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen\u001b[0m = parens[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxsz8kbrc.scala:16:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxsz8kbrc.scala:18:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren[j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxsz8kbrc.scala:22:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            result = result.append(depth.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var parens = paren_string.split(\" \")\n        var max_nesting = 0\n        var max_nesting_index = 0\n        for (i <- 0 until parens.length) {\n            var nesting = 0\n            for (j <- 0 until parens[i].length) {\n                if (parens[i][j] == '(') {\n                    nesting += 1\n                } else if (parens[i][j] == ')') {\n                    nesting -= 1\n                }\n                if (nesting > max_nesting) {\n                    max_nesting = nesting\n                    max_nesting_index = i\n                }\n            }\n        }\n        var result = List[Long]()\n        for (i <- 0 until max_nesting_index) {\n            result = result.append(i)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiuhjjogu.scala:15:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until parens[\u001b[35mi\u001b[0m].length) {\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiuhjjogu.scala:16:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (parens[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiuhjjogu.scala:16:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (parens[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiuhjjogu.scala:18:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (parens[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiuhjjogu.scala:18:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (parens[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpiuhjjogu.",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var result = List[Long]()\n        var stack = List[String]()\n        var paren_count = 0\n        var max_paren_count = 0\n        var max_index = 0\n        var max_paren_count_index = 0\n        var paren_count_index = 0\n        var paren_count_stack = List[Long]()\n        var paren_count_stack_index = 0\n        var paren_count_stack_max = 0\n        var paren_count_stack_max_index = 0\n        var paren_count_stack_max_count = 0\n        var paren_count_stack_max_count_index = 0\n        var paren_count_stack_max_count_count = 0\n        var paren_count_stack_max_count_count_index = 0\n        var paren_count_stack_max_count_count_count = 0\n        var paren_count_stack_max_count_count_count_index = 0\n        var paren_count_stack_max_count_count_count_count = 0\n        var paren_count_stack_max_count_count_count_count_index = 0\n        var paren_count_stack_max_count_count_count_count_count = 0\n        var paren_count_stack_max_count_count_count_count_count_index = 0\n        var paren_count_stack_max_count_count_count_count_count_count = 0\n        var paren_count_stack_max_count_count_count_count_count_count_index = 0\n        var paren_count_stack_max_count_count_count_count_count_count_count = 0\n        var paren_count_stack_max_count_count_count_count_count_count_count_index = 0\n        var paren_count_stack_max_count_count_count_count_count_count_count_count = 0\n        var paren_count_stack_max_count_count_count_count_count_count_count_count_index = 0\n        var paren_count_stack_max_count_count_count_count\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292678,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp28y_7j5f.scala:38:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp28y_7j5f.scala:38:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens).reduce(List[Long]::concat)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292649,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzt_qoqms.scala:11:78 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: concat\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpf61ngfhb.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpf61ngfhb.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(s => {\n            val parens = s.split(\"(\")\n            val parens_count = parens.length - 1\n            val max_parens_count = parens_count.max()\n            return max_parens_count\n        }).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292678,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpj0c9n90t.scala:14:51 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mmax_parens_count\u001b[0m = parens_count.max()\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter that of \u001b[33mmethod\u001b[0m \u001b[35mmax\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mRichInt\u001b[0m: (that: Int): Int\n\u001b[31m\u001b[31m-- Error: /tmp/tmpj0c9n90t.scala:16:10 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        }).toList\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(s => s.replaceAll(\"[()]\", \"\"))\n        val result_list = result.map(s => s.split(\"(\")).map(s => s.length - 1).toList\n        result_list.sort((a, b) => a - b)\n        return result_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292679,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdvmt67es.scala:13:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        result_list.sort((\u001b[36ma\u001b[0m, \u001b[36mb\u001b[0m) => a - b)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue sort is not a member of List[Int] - did you mean result_list.sortBy?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdvmt67es.scala:14:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mreturn\u001b[0m result_list\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Found:    (result_list : List[Int])\n\u001b[31m   |\u001b[0m               Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpiyfzvtbd.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpiyfzvtbd.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(s => {\n            val parens = s.split(\"(\")\n            val depth = parens.length - 1\n            val max_depth = depth.max()\n            return max_depth\n        }).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292651,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp72eb6ei6.scala:14:37 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mmax_depth\u001b[0m = depth.max()\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter that of \u001b[33mmethod\u001b[0m \u001b[35mmax\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mRichInt\u001b[0m: (that: Int): Int\n\u001b[31m\u001b[31m-- Error: /tmp/tmp72eb6ei6.scala:16:10 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        }).toList\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var paren_count = 0\n        var max_paren_count = 0\n        var result = List[Long]()\n        for (i <- 0 until paren_list.length) {\n            var paren_count_here = 0\n            for (j <- 0 until paren_list[i].length) {\n                if (paren_list[i][j] == '(') {\n                    paren_count_here += 1\n                } else if (paren_list[i][j] == ')') {\n                    paren_count_here -= 1\n                }\n                if (paren_count_here == 0) {\n                    break\n                }\n            }\n            if (paren_count_here > max_paren_count) {\n                max_paren_count = paren_count_here\n            }\n            if (paren_count_here == 0) {\n                result = result.append(i)\n            }\n        }\n        return result.map(x => x.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292679,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9p55yyrw.scala:16:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until paren_list[\u001b[35mi\u001b[0m].length) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9p55yyrw.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9p55yyrw.scala:17:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9p55yyrw.scala:19:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9p55yyrw.scala:19:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-exp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val paren_list = parens.map(_.trim).filter(s => !s.isEmpty()).toList\n        val paren_counts = paren_list.map(s => s.count(\"(\"))\n        val max_paren_count = paren_counts.max()\n        val max_paren_index = paren_counts.indexOf(max_paren_count)\n        val max_paren_count_list = paren_counts.take(max_paren_index + 1)\n        val max_paren_count_list_long = max_paren_count_list.map(s => s.toLong)\n        return max_paren_count_list_long\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292679,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_1umiz4e.scala:12:55 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_counts\u001b[0m = paren_list.map(\u001b[36ms\u001b[0m => s.count(\u001b[31m\"(\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                       ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                               Found:    (\u001b[32m\"(\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                                               Required: Char => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp_1umiz4e.scala:13:46 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax_paren_count\u001b[0m = paren_counts.max()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter ord of \u001b[33mmethod\u001b[0m \u001b[35mmax\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOnceOps\u001b[0m: (\u001b[33mimplicit \u001b[0mord: Ordering[B]): Int\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        val result_list = result.map(Long::parseLong).toList\n        return result_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292652,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo8xijqtb.scala:12:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult_list\u001b[0m = result.map(Long::parseLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Not found: parseLong\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpo8xijqtb.scala:12:53 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult_list\u001b[0m = result.map(Long::parseLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var max_nesting = 0\n        var max_nesting_index = 0\n        for (i <- 0 until paren_list.length) {\n            var paren_count = 0\n            for (j <- 0 until paren_list[i].length) {\n                if (paren_list[i][j] == '(') {\n                    paren_count += 1\n                } else if (paren_list[i][j] == ')') {\n                    paren_count -= 1\n                }\n                if (paren_count > max_nesting) {\n                    max_nesting = paren_count\n                    max_nesting_index = i\n                }\n            }\n        }\n        var result = List[Long]()\n        for (i <- 0 until max_nesting_index) {\n            result = result.append(i)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292679,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkjudyb8z.scala:15:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until paren_list[\u001b[35mi\u001b[0m].length) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkjudyb8z.scala:16:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkjudyb8z.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkjudyb8z.scala:18:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkjudyb8z.scala:18:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-exp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens_).reduce(List[Long]::concat)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292686,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpn1og5jqy.scala:11:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens_).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue parseNestedParens_ is not a member of object Problem - did you mean Problem.parseNestedParens?\n\u001b[31m\u001b[31m-- Error: /tmp/tmpn1og5jqy.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens_).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val paren_list = parens.map(p -> p.replaceAll(\"[()]\", \"\"))\n        val paren_list_len = paren_list.length\n        val max_nesting = paren_list_len.max()\n        val result = paren_list.map(p -> p.length() - max_nesting)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292688,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0ohhvl2a.scala:11:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_list\u001b[0m = parens.map(p -> p.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: p\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp0ohhvl2a.scala:11:66 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_list\u001b[0m = parens.map(p -> p.replaceAll(\u001b[31m\"[()]\"\u001b[0m, \u001b[31m\"\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens_).reduce(List[Long]::concat)\n        result\n    }\n\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens_(\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens_(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens_).reduce(List[Long]::concat)\n        result\n    }\n\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens_(\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens_1(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens_).reduce(List[Long]::concat)\n        result\n    }\n\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseN\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpyuc97g4o.scala:48:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyuc97g4o.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens_).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpyuc97g4o.scala:11:60 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens_).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyuc97g4o.scala:22:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens_).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpyuc97g4o.scala:22:60 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens_).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyuc97g4o.scala:33:39 ------------------------\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.toLong).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"(()())\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:697)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$1(tmp1_0xw5jf.scala:11)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseNestedParens(tmp1_0xw5jf.scala:11)\n\tat Problem$.main(tmp1_0xw5jf.scala:15)\n\tat Problem.main(tmp1_0xw5jf.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var max_nesting = 0\n        var max_nesting_index = 0\n        for (i <- 0 until paren_list.length) {\n            var paren_count = 0\n            var paren_index = i\n            while (paren_index < paren_list.length) {\n                if (paren_list[paren_index] == \"(\" && paren_count == 0) {\n                    paren_count += 1\n                } else if (paren_list[paren_index] == \")\" && paren_count > 0) {\n                    paren_count -= 1\n                }\n                paren_index += 1\n            }\n            if (paren_count > max_nesting) {\n                max_nesting = paren_count\n                max_nesting_index = i\n            }\n        }\n        var result = List[Long]()\n        for (i <- 0 until max_nesting_index) {\n            result = result.append(i)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292687,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6s1egtld.scala:17:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mparen_index\u001b[0m] == \u001b[31m\"(\"\u001b[0m && paren_count == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type paren_index\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6s1egtld.scala:19:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[paren_index] == \u001b[31m\")\"\u001b[0m && paren_count > \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: type paren_index\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6s1egtld.scala:31:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var max_depth = 0\n        var max_depth_list = List[Long]()\n        for (var i = 0; i < paren_list.length; i++) {\n            var depth = depth(paren_list[i])\n            if (depth > max_depth) {\n                max_depth = depth\n                max_depth_list = List[Long]()\n            }\n            max_depth_list = max_depth_list.append(depth)\n        }\n        return max_depth_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292689,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpxe71ofbu.scala:13:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < paren_list.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpxe71ofbu.scala:13:45 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < paren_list.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpxe71ofbu.scala:13:50 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < paren_list.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxe71ofbu.scala:13:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < paren_list.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens_).reduce(List[Long]::concat)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292653,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpllby_f2h.scala:11:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens_).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue parseNestedParens_ is not a member of object Problem - did you mean Problem.parseNestedParens?\n\u001b[31m\u001b[31m-- Error: /tmp/tmpllby_f2h.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens_).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(_.max)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292664,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpepe54b0_.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(_.max)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpepe54b0_.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(_.max)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var parens = paren_string.split(\" \")\n        var max_nesting = 0\n        var result = List[Long]()\n        for (i in 0 until parens.length) {\n            var paren_group = parens[i]\n            var nesting = 0\n            for (j in 0 until paren_group.length) {\n                if (paren_group[j] == '(') {\n                    nesting += 1\n                } else if (paren_group[j] == ')') {\n                    nesting -= 1\n                }\n                if (nesting > max_nesting) {\n                    max_nesting = nesting\n                }\n            }\n            result = result.append(max_nesting)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292689,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgkjj3dou.scala:13:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mfor\u001b[0m (i in \u001b[31m0\u001b[0m until parens.length) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         '<-' expected, but '{' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgkjj3dou.scala:27:9 -------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m         ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator asScala\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.set asScala\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val paren_list = parens.map(_.trim).map(Problem::parseParens).toList\n        val max_nesting = paren_list.foldLeft(0L, (acc, paren) => acc + paren)\n        val result = paren_list.map(l -> l.length - max_nesting)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292689,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5er5n19_.scala:11:57 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_list\u001b[0m = parens.map(_.trim).map(Problem::parseParens).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Not found: parseParens\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp5er5n19_.scala:11:69 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_list\u001b[0m = parens.map(_.trim).map(Problem::parseParens).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = List[Long]()\n        for (i <- 0 until parens.length) {\n            val paren = parens[i]\n            val paren_count = 0\n            for (j <- 0 until paren.length) {\n                if (paren[j] == '(') {\n                    paren_count += 1\n                } else if (paren[j] == ')') {\n                    paren_count -= 1\n                }\n            }\n            result = result.append(paren_count)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9f_ypu33.scala:13:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mparen\u001b[0m = parens[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9f_ypu33.scala:16:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9f_ypu33.scala:17:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                    paren_count += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value += is not a member of Int - did you mean paren_count.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9f_ypu33.scala:18:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren[j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9f_ypu33.scala:19:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                    paren_count -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value -= is not a member of Int - did you mean paren_count.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9f_ypu33.scala:22:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            result = result.append(paren_count)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.append",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var parens = paren_string.split(\" \")\n        var max_nesting = 0\n        var result = List[Long]()\n        for (i <- 0 until parens.length) {\n            var paren = parens[i]\n            var nesting = 0\n            for (j <- 0 until paren.length) {\n                if (paren[j] == '(') {\n                    nesting += 1\n                } else if (paren[j] == ')') {\n                    nesting -= 1\n                }\n                if (nesting > max_nesting) {\n                    max_nesting = nesting\n                }\n            }\n            result = result.append(max_nesting.toLong)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292688,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjrjg4xj5.scala:14:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen\u001b[0m = parens[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjrjg4xj5.scala:17:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (paren[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjrjg4xj5.scala:19:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren[j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjrjg4xj5.scala:26:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            result = result.append(max_nesting.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var result = List[Long]()\n        var paren_stack = List[String]()\n        var paren_count = 0\n        var paren_index = 0\n        var paren_length = paren_string.length()\n        var paren_char = paren_string.charAt(0)\n        var paren_char_index = 0\n        var paren_char_length = 1\n        var paren_char_count = 0\n        var paren_char_count_max = 0\n        var paren_char_count_min = 0\n        var paren_char_count_diff = 0\n        var paren_char_count_diff_max = 0\n        var paren_char_count_diff_min = 0\n        var paren_char_count_diff_diff = 0\n        var paren_char_count_diff_diff_max = 0\n        var paren_char_count_diff_diff_min = 0\n        var paren_char_count_diff_diff_diff = 0\n        var paren_char_count_diff_diff_diff_max = 0\n        var paren_char_count_diff_diff_diff_min = 0\n        var paren_char_count_diff_diff_diff_diff = 0\n        var paren_char_count_diff_diff_diff_diff_max = 0\n        var paren_char_count_diff_diff_diff_diff_min = 0\n        var paren_char_count_diff_diff_diff_diff_diff = 0\n        var paren_char_count_diff_diff_diff_diff_diff_max = 0\n        var paren_char_count_diff_diff_diff_diff_diff_min = 0\n        var paren_char_count_diff_diff_diff_diff_diff_diff = 0\n        var paren_char_count_diff_diff_diff_diff_diff_diff_max = 0\n        var paren_char_count_diff_diff_diff_diff_diff_diff_min = 0\n        var paren_char_count_diff_diff_diff_diff_diff_diff_diff = 0\n        var paren_char\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292688,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpb4cv_mwv.scala:41:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb4cv_mwv.scala:41:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        val result_list = result.toList\n        val result_list_long = result_list.map(_.toLong)\n        return result_list_long\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292691,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$3(tmpzq_jhh4w.scala:13)\n\tat scala.collection.immutable.List.map(List.scala:246)\n\tat Problem$.parseNestedParens(tmpzq_jhh4w.scala:13)\n\tat Problem$.main(tmpzq_jhh4w.scala:17)\n\tat Problem.main(tmpzq_jhh4w.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var parens = paren_string.split(\" \")\n        var result = List[Long]()\n        for (i <- 0 until parens.length) {\n            var level = 0\n            for (j <- 0 until parens[i].length) {\n                if (parens[i][j] == '(') {\n                    level += 1\n                } else if (parens[i][j] == ')') {\n                    level -= 1\n                }\n                if (level == 0) {\n                    result = result.append(i)\n                    break\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292689,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsiwp9ta0.scala:14:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until parens[\u001b[35mi\u001b[0m].length) {\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsiwp9ta0.scala:15:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                \u001b[33mif\u001b[0m (parens[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsiwp9ta0.scala:15:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                \u001b[33mif\u001b[0m (parens[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsiwp9ta0.scala:17:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (parens[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsiwp9ta0.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (parens[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsiwp9ta0.",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var paren_count = 0\n        var max_paren_count = 0\n        var max_paren_index = 0\n        var paren_list_length = paren_list.length\n        var paren_list_index = 0\n        var paren_list_index_prev = 0\n        var paren_list_index_next = 0\n        var paren_list_index_next_prev = 0\n        var paren_list_index_next_next = 0\n        var paren_list_index_next_next_prev = 0\n        var paren_list_index_next_next_next = 0\n        var paren_list_index_next_next_next_prev = 0\n        var paren_list_index_next_next_next_next = 0\n        var paren_list_index_next_next_next_next_prev = 0\n        var paren_list_index_next_next_next_next_next = 0\n        var paren_list_index_next_next_next_next_next_prev = 0\n        var paren_list_index_next_next_next_next_next_next = 0\n        var paren_list_index_next_next_next_next_next_next_prev = 0\n        var paren_list_index_next_next_next_next_next_next_next = 0\n        var paren_list_index_next_next_next_next_next_next_next_prev = 0\n        var paren_list_index_next_next_next_next_next_next_next_next = 0\n        var paren_list_index_next_next_next_next_next_next_next_next_prev = 0\n        var paren_list_index_next_next_next_next_next_next_next_next_next = 0\n        var paren_list_index_next_next_next_next_next_next_next_next_next_prev = 0\n        var paren_list_index_next_next_next_next_next_next_next_next_next_next = 0\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292689,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5xxjw7i1.scala:36:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var result = List[Long]()\n        var stack = List[String]()\n        var paren_count = 0\n        var max_paren_count = 0\n        var paren_level = 0\n        var paren_level_count = 0\n        var paren_count_stack = List[Long]()\n        var paren_count_stack_index = 0\n        var paren_count_stack_count = 0\n        var paren_count_stack_count_index = 0\n        var paren_count_stack_count_count = 0\n        var paren_count_stack_count_count_index = 0\n        var paren_count_stack_count_count_count = 0\n        var paren_count_stack_count_count_count_index = 0\n        var paren_count_stack_count_count_count_count = 0\n        var paren_count_stack_count_count_count_count_index = 0\n        var paren_count_stack_count_count_count_count_count = 0\n        var paren_count_stack_count_count_count_count_count_index = 0\n        var paren_count_stack_count_count_count_count_count_count = 0\n        var paren_count_stack_count_count_count_count_count_count_index = 0\n        var paren_count_stack_count_count_count_count_count_count_count = 0\n        var paren_count_stack_count_count_count_count_count_count_count_index = 0\n        var paren_count_stack_count_count_count_count_count_count_count_count = 0\n        var paren_count_stack_count_count_count_count_count_count_count_count_index = 0\n        var paren_count_stack_count_count_count_count_count_count_count_count_count = 0\n        var paren_count_stack_count_count_count_count_count_count_count_count_count_index = 0\n        var paren_count_stack_count_count_count_count_count_count_count_count_count_count =\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292689,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpimeic2mx.scala:36:91 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mparen_count_stack_count_count_count_count_count_count_count_count_count_count\u001b[0m =\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpimeic2mx.scala:37:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var parens = paren_string.split(\" \")\n        var max_nesting = 0\n        var max_nesting_index = 0\n        for (i <- 0 until parens.length) {\n            var nesting = 0\n            for (j <- 0 until parens.length) {\n                if (parens[j] == \"(\" && parens[i] == \")\") {\n                    nesting += 1\n                } else if (parens[j] == \")\" && parens[i] == \"(\" && nesting > 0) {\n                    nesting -= 1\n                }\n            }\n            if (nesting > max_nesting) {\n                max_nesting = nesting\n                max_nesting_index = i\n            }\n        }\n        var result = List[Long]()\n        for (i <- 0 until parens.length) {\n            if (parens[i] == \"(\" && parens[max_nesting_index] == \")\") {\n                result = result.append(i.toLong)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292691,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwb7lwzpq.scala:16:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (parens[\u001b[35mj\u001b[0m] == \u001b[31m\"(\"\u001b[0m && parens[\u001b[35mi\u001b[0m] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwb7lwzpq.scala:18:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (parens[j] == \u001b[31m\")\"\u001b[0m && parens[i] == \u001b[31m\"(\"\u001b[0m && nesting > \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwb7lwzpq.scala:29:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mif\u001b[0m (parens[\u001b[35mi\u001b[0m] == \u001b[31m\"(\"\u001b[0m && parens[\u001b[35mmax_nesting_index\u001b[0m] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwb7lwzpq.scala:30:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                result = result.append(i.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(Problem::parseNestedParens).reduce(_.maxBy(Comparator.naturalOrder()))\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl2ty3ecj.scala:11:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(_.trim).map(Problem::parseNestedParens).reduce(_.maxBy(Comparator.naturalOrder()))\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpl2ty3ecj.scala:11:71 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(_.trim).map(Problem::parseNestedParens).reduce(_.maxBy(Comparator.naturalOrder()))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var result = List[Long]()\n        var stack = List[String]()\n        var paren_count = 0\n        var paren_index = 0\n        var paren_level = 0\n        var paren_count_max = 0\n        var paren_count_min = 0\n        var paren_count_diff = 0\n        var paren_count_diff_max = 0\n        var paren_count_diff_min = 0\n        var paren_count_diff_diff = 0\n        var paren_count_diff_diff_max = 0\n        var paren_count_diff_diff_min = 0\n        var paren_count_diff_diff_diff = 0\n        var paren_count_diff_diff_diff_max = 0\n        var paren_count_diff_diff_diff_min = 0\n        var paren_count_diff_diff_diff_diff = 0\n        var paren_count_diff_diff_diff_diff_max = 0\n        var paren_count_diff_diff_diff_diff_min = 0\n        var paren_count_diff_diff_diff_diff_diff = 0\n        var paren_count_diff_diff_diff_diff_diff_max = 0\n        var paren_count_diff_diff_diff_diff_diff_min = 0\n        var paren_count_diff_diff_diff_diff_diff_diff = 0\n        var paren_count_diff_diff_diff_diff_diff_diff_max = 0\n        var paren_count_diff_diff_diff_diff_diff_diff_min = 0\n        var paren_count_diff_diff_diff_diff_diff_diff_diff = 0\n        var paren_count_diff_diff_diff_diff_diff_diff_diff_max = 0\n        var paren_count_diff_diff_diff_diff_diff_diff_diff_min = 0\n        var paren_count_diff_diff_diff_diff_diff_diff_diff_diff = 0\n        var paren_count_diff_diff_diff_diff_diff_diff_diff_diff_max = 0\n        var paren_count\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbs_2bcgm.scala:41:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbs_2bcgm.scala:41:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpiyfzvtbd.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpiyfzvtbd.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpiyfzvtbd.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpiyfzvtbd.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpiyfzvtbd.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpiyfzvtbd.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var max_nesting = 0\n        var max_nesting_index = 0\n        for (i <- 0 until paren_list.length) {\n            var nesting = 0\n            var nesting_index = 0\n            for (j <- 0 until paren_list[i].length()) {\n                if (paren_list[i][j] == '(') {\n                    nesting += 1\n                    nesting_index = j\n                } else if (paren_list[i][j] == ')') {\n                    nesting -= 1\n                    if (nesting == 0) {\n                        break\n                    }\n                }\n            }\n            if (nesting > max_nesting) {\n                max_nesting = nesting\n                max_nesting_index = i\n            }\n        }\n        var result = List[Long]()\n        for (i <- 0 until max_nesting_index) {\n            result = result.append(paren_list[i].length())\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292691,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_jestrqa.scala:16:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until paren_list[\u001b[35mi\u001b[0m].length()) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_jestrqa.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_jestrqa.scala:17:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_jestrqa.scala:20:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_jestrqa.scala:20:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-e",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens1).reduce(List[Long]::concat)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292665,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu1m1qnul.scala:11:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens1).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue parseNestedParens1 is not a member of object Problem - did you mean Problem.parseNestedParens?\n\u001b[31m\u001b[31m-- Error: /tmp/tmpu1m1qnul.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens1).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var max_nesting = 0\n        var max_nesting_index = 0\n        for (i <- 0 until paren_list.length) {\n            var nesting = 0\n            for (j <- i until paren_list.length) {\n                if (paren_list[j] == \"(\" || paren_list[j] == \"{\" || paren_list[j] == \"[\") {\n                    nesting += 1\n                } else if (paren_list[j] == \")\" || paren_list[j] == \"}\" || paren_list[j] == \"]\") {\n                    nesting -= 1\n                }\n                if (nesting > max_nesting) {\n                    max_nesting = nesting\n                    max_nesting_index = j\n                }\n            }\n        }\n        var result = List[Long]()\n        for (i <- 0 until max_nesting_index) {\n            result = result.append(i.toLong)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292691,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp34745w8e.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mj\u001b[0m] == \u001b[31m\"(\"\u001b[0m || paren_list[\u001b[35mj\u001b[0m] == \u001b[31m\"{\"\u001b[0m || paren_list[\u001b[35mj\u001b[0m] == \u001b[31m\"[\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp34745w8e.scala:18:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[j] == \u001b[31m\")\"\u001b[0m || paren_list[j] == \u001b[31m\"}\"\u001b[0m || paren_list[j] == \u001b[31m\"]\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp34745w8e.scala:29:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            result = result.append(i.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens).reduce(List[Long]::concat)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292649,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzt_qoqms.scala:11:78 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: concat\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var result = mutable.List[Long]()\n        var stack = mutable.Stack[String]()\n        var depth = 0\n        var parens = 0\n        var paren_count = 0\n        var paren_index = 0\n        var paren_string_index = 0\n        var paren_string_length = paren_string.length\n        var paren_string_char = paren_string.charAt(paren_string_index)\n        while (paren_string_index < paren_string_length) {\n            if (paren_string_char == '(') {\n                stack.push(paren_string.substring(paren_string_index, paren_string_index + 1))\n                parens += 1\n                paren_count += 1\n                paren_index = paren_string_index\n                paren_string_index += 1\n            } else if (paren_string_char == ')') {\n                stack.pop()\n                parens -= 1\n                paren_count -= 1\n                if (stack.isEmpty()) {\n                    result.append(depth)\n                    depth = 0\n                } else {\n                    depth = depth + 1\n                }\n                paren_index = paren_string_index\n                paren_string_index += 1\n            } else if (paren_string_char == ' ') {\n                if (stack.isEmpty()) {\n                    result.append(depth)\n                    depth = 0\n                } else {\n                    depth = depth + 1\n                }\n                paren_index = paren_string_index\n                paren_string_index += 1\n            } else {\n                paren_index = paren_string_index\n                paren_string_index += 1\n            }\n        }\n        if (paren_count != 0) {\n            throw new RuntimeException(\"Unbalanced parentheses\")\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292687,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphcwxpync.scala:10:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphcwxpync.scala:11:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mstack\u001b[0m = mutable.Stack[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var result = List[Long]()\n        for (i <- 0 until paren_list.length) {\n            var paren_group = paren_list[i].split(\"(\")\n            var paren_depth = 0\n            for (j <- 0 until paren_group.length) {\n                if (paren_group[j].equals(\"(\")) {\n                    paren_depth += 1\n                } else if (paren_group[j].equals(\")\")) {\n                    paren_depth -= 1\n                }\n            }\n            result = result.append(paren_depth.toLong)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292690,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpeo1e6al6.scala:13:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen_group\u001b[0m = paren_list[\u001b[35mi\u001b[0m].split(\u001b[31m\"(\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpeo1e6al6.scala:16:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_group[\u001b[35mj\u001b[0m].equals(\u001b[31m\"(\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpeo1e6al6.scala:18:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_group[j].equals(\u001b[31m\")\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpeo1e6al6.scala:22:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            result = result.append(paren_depth.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val paren_list = paren_string.split(\" \")\n        val result = paren_list.map(s => {\n            val paren_list = s.split(\"(\")\n            val paren_list_len = paren_list.length\n            val max_nesting = 0\n            for (i <- 0 until paren_list_len) {\n                val paren_group = paren_list[i]\n                val paren_group_len = paren_group.length\n                val nesting = 0\n                for (j <- 0 until paren_group_len) {\n                    if (paren_group[j] == '(') {\n                        nesting += 1\n                    } else if (paren_group[j] == ')') {\n                        nesting -= 1\n                    }\n                }\n                if (nesting > max_nesting) {\n                    max_nesting = nesting\n                }\n            }\n            return max_nesting\n        })\n        return result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292692,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmiraov4l.scala:16:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mparen_group\u001b[0m = paren_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmiraov4l.scala:20:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                    \u001b[33mif\u001b[0m (paren_group[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmiraov4l.scala:21:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                        nesting += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              value += is not a member of Int - did you mean nesting.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmiraov4l.scala:22:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                    } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_group[j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmiraov4l.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                        nesting -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              value -= is not a member of Int - did you mean nesting.!=?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpmiraov4l.scala:27:32 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                    max_nesting = nesting\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParensHelper).reduce(_.maxBy(_.toLong))\n        return result\n    }\n\n    // Helper function for parseNestedParens\n    def parseNestedParensHelper(left : String, right : String) : Long = {\n        val left_parens = left.count(\"(\")\n        val right_parens = right.count(\"(\")\n        val left_nesting = left_parens - right_parens\n        val right_nesting = right_parens - left_parens\n        val max_nesting = Math.max(left_nesting, right_nesting)\n        return max_nesting\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292692,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl4a81jqi.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParensHelper).reduce(_.maxBy(_.toLong))\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value :: is not a member of (String, String) => Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmpl4a81jqi.scala:11:65 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParensHelper).reduce(_.maxBy(_.toLong))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl4a81jqi.scala:17:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mleft_parens\u001b[0m = left.count(\u001b[31m\"(\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    (\u001b[32m\"(\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                                     Required: Char => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl4a81jqi.scala:18:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mright_parens\u001b[0m = right.count(\u001b[31m\"(\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Found:    (\u001b[32m\"(\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                                       Required: Char => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        val result_list = result.toList\n        val result_longs = result_list.map(_.toLong)\n        return result_longs\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292693,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$3(tmpa9aolxs6.scala:13)\n\tat scala.collection.immutable.List.map(List.scala:246)\n\tat Problem$.parseNestedParens(tmpa9aolxs6.scala:13)\n\tat Problem$.main(tmpa9aolxs6.scala:17)\n\tat Problem.main(tmpa9aolxs6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpf61ngfhb.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpf61ngfhb.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var result = List[Long]()\n        for (var i = 0; i < paren_list.length; i++) {\n            var paren_group = paren_list[i]\n            var paren_count = 0\n            for (var j = 0; j < paren_group.length(); j++) {\n                if (paren_group.charAt(j) == '(') {\n                    paren_count += 1\n                } else if (paren_group.charAt(j) == ')') {\n                    paren_count -= 1\n                }\n            }\n            result = result.append(paren_count)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292701,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp7uq7x7a1.scala:12:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < paren_list.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7uq7x7a1.scala:12:45 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < paren_list.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp7uq7x7a1.scala:12:50 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < paren_list.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7uq7x7a1.scala:12:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < paren_list.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(Problem::parseNestedParens).reduce(_.maxBy(Comparator.naturalOrder()))\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl2ty3ecj.scala:11:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(_.trim).map(Problem::parseNestedParens).reduce(_.maxBy(Comparator.naturalOrder()))\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpl2ty3ecj.scala:11:71 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(_.trim).map(Problem::parseNestedParens).reduce(_.maxBy(Comparator.naturalOrder()))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var max_depth = 0\n        var max_depth_index = 0\n        for (i <- 0 until paren_list.length) {\n            var depth = 0\n            for (j <- 0 until paren_list[i].length) {\n                if (paren_list[i][j] == '(') depth += 1\n                if (paren_list[i][j] == ')') depth -= 1\n                if (depth > max_depth) {\n                    max_depth = depth\n                    max_depth_index = i\n                }\n            }\n        }\n        var result = List[Long]()\n        for (i <- 0 until max_depth_index) {\n            result = result.append(paren_list[i].length - 1 - max_depth)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292699,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpivvbwi6n.scala:15:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until paren_list[\u001b[35mi\u001b[0m].length) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpivvbwi6n.scala:16:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) depth += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpivvbwi6n.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) depth += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpivvbwi6n.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m')'\u001b[0m) depth -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpivvbwi6n.scala:17:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m')'\u001b[0m) depth -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(s => {\n            val parens = s.split(\"(\")\n            val max_nesting = parens.map(s => {\n                val parens2 = s.split(\")\")\n                val max_nesting2 = parens2.map(s2 => {\n                    val parens3 = s2.split(\"(\")\n                    val max_nesting3 = parens3.map(s3 => {\n                        val parens4 = s3.split(\")\")\n                        val max_nesting4 = parens4.map(s4 => {\n                            val parens5 = s4.split(\"(\")\n                            val max_nesting5 = parens5.map(s5 => {\n                                val parens6 = s5.split(\")\")\n                                val max_nesting6 = parens6.map(s6 => {\n                                    val parens7 = s6.split(\"(\")\n                                    val max_nesting7 = parens7.map(s7 => {\n                                        val parens8 = s7.split(\")\")\n                                        val max_nesting8 = parens8.map(s8 => {\n                                            val parens9 = s8.split(\"(\")\n                                            val max_nesting9 = parens9.map(s9 => {\n                                                val parens10 = s9.split(\")\")\n                                                val max_nesting10 = parens10.map(s10 => {\n                                                    val parens11 = s10.split(\"(\")\n                                                    val max_nesting11 = parens11.map(s11 => {\n                                                        val parens12 = s11.split(\")\")\n                                                        val max_nesting12 = parens12.map(s12 => {\n                                                            val parens13 = s12.split(\"(\")\n                                 \n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292699,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpak0w9s7n.scala:39:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m    ^^^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but 'def' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpak0w9s7n.scala:46:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m')' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpak0w9s7n.scala:45:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val paren_counts = parens.map(s => s.count(\"(\"))\n        val max_paren_count = paren_counts.max()\n        val max_paren_count_index = paren_counts.index(max_paren_count)\n        val max_paren_count_parens = parens.slice(max_paren_count_index)\n        val max_paren_count_parens_count = max_paren_count_parens.count(\"(\")\n        val max_paren_count_parens_count_index = max_paren_count_parens.index(max_paren_count_parens_count)\n        val max_paren_count_parens_count_parens = max_paren_count_parens.slice(max_paren_count_parens_count_index)\n        val max_paren_count_parens_count_parens_count = max_paren_count_parens_count_parens.count(\"(\")\n        val max_paren_count_parens_count_parens_count_index = max_paren_count_parens_count_parens.index(max_paren_count_parens_count_parens_count)\n        val max_paren_count_parens_count_parens_count_parens = max_paren_count_parens_count_parens_count_parens.slice(max_paren_count_parens_count_parens_count_index)\n        val max_paren_count_parens_count_parens_count_parens_count = max_paren_count_parens_count_parens_count_parens_count.count(\"(\")\n        val max_paren_count_parens_count_parens_count_parens_count_index = max_paren_count_parens_count_parens_count_parens_count_parens.index(max_paren_count_parens_count_parens_count_parens_count)\n        val max_paren_count_parens_count_parens_count_parens_count_parens =\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292701,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpndd5r6r6.scala:23:75 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax_paren_count_parens_count_parens_count_parens_count_parens\u001b[0m =\n\u001b[31m\u001b[31m   |\u001b[0m                                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpndd5r6r6.scala:11:51 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_counts\u001b[0m = parens.map(\u001b[36ms\u001b[0m => s.count(\u001b[31m\"(\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                               Found:    (\u001b[32m\"(\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                                               Required: Char => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpndd5r6r6.scala:12:46 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax_paren_count\u001b[0m = paren_counts.max()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter ord of \u001b[33mmethod\u001b[0m \u001b[35mmax\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOnceOps\u001b[0m: (\u001b[33mimplicit \u001b[0mord: Ordering[B]): Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpndd5r6r6.scala:13:49 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax_paren_count_index\u001b[0m = paren_counts.index(max_paren_count)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               value index is not a member of Array[Int]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpndd5r6r6.scala:14:49 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax_paren_count_parens\u001b[0m = parens.slice(max_paren_count_index)\n\u001b[31m\u001b[31m   |\u001b[0m        ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val paren_list = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        val paren_counts = paren_list.map(parens => parens.length()).toSeq\n        val max_paren_count = paren_counts.max()\n        val max_paren_count_index = paren_counts.indexOf(max_paren_count)\n        val max_paren_count_parens = paren_list.take(max_paren_count_index)\n        val max_paren_count_parens_list = max_paren_count_parens.map(parens => parens.length()).toSeq\n        val max_paren_count_parens_list_count = max_paren_count_parens_list.length\n        val max_paren_count_parens_list_list = max_paren_count_parens_list.toSeq\n        val max_paren_count_parens_list_list_count = max_paren_count_parens_list_count.length\n        val max_paren_count_parens_list_list_list = max_paren_count_parens_list_list.toSeq\n        val max_paren_count_parens_list_list_list_count = max_paren_count_parens_list_list_count.length\n        val max_paren_count_parens_list_list_list_list = max_paren_count_parens_list_list_list_count.toSeq\n        val max_paren_count_parens_list_list_list_list_count = max_paren_count_parens_list_list_list_count.length\n        val max_paren_count_parens_list_list_list_list_list = max_paren_count_parens_list_list_list_list_count.toSeq\n        val max_paren_count_parens_list_list_list_list_list_count = max_paren_count_parens_list_list_list_list_count.length\n        \n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292701,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpoun_53hk.scala:13:46 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax_paren_count\u001b[0m = paren_counts.max()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter ord of \u001b[33mmethod\u001b[0m \u001b[35mmax\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOnceOps\u001b[0m: (\u001b[33mimplicit \u001b[0mord: Ordering[B]): Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpoun_53hk.scala:19:87 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax_paren_count_parens_list_list_count\u001b[0m = max_paren_count_parens_list_count.length\n\u001b[31m\u001b[31m   |\u001b[0m                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     value length is not a member of Int\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpoun_53hk.scala:27:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpiyfzvtbd.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpiyfzvtbd.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpf61ngfhb.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpf61ngfhb.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var parens = paren_string.split(\" \")\n        var result = List[Long]()\n        for (i <- 0 until parens.length) {\n            var paren = parens[i]\n            if (paren.equals(\"\")) {\n                continue\n            }\n            var level = 0\n            for (j <- 0 until paren.length) {\n                if (paren[j] == '(') {\n                    level += 1\n                } else if (paren[j] == ')') {\n                    level -= 1\n                }\n                if (level == 0) {\n                    result = result.append(j.toLong)\n                    break\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292701,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmuw54_xh.scala:13:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen\u001b[0m = parens[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmuw54_xh.scala:15:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                continue\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: continue\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmuw54_xh.scala:19:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                \u001b[33mif\u001b[0m (paren[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmuw54_xh.scala:21:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren[j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmuw54_xh.scala:25:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                    result = result.append(j.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmuw54_xh.scala:26:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var result = List[Long]()\n        var parens = paren_string.split(\" \")\n        for (i <- 0 until parens.length) {\n            var paren = parens[i]\n            var depth = 0\n            for (j <- 0 until paren.length) {\n                if (paren[j] == '(') depth += 1\n                if (paren[j] == ')') depth -= 1\n                if (depth < 0) {\n                    throw new RuntimeException(\"Invalid parentheses string\")\n                }\n            }\n            result = result.append(depth.toLong)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292701,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpv7rdir2d.scala:13:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen\u001b[0m = parens[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpv7rdir2d.scala:16:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) depth += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpv7rdir2d.scala:17:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (paren[\u001b[35mj\u001b[0m] == \u001b[31m')'\u001b[0m) depth -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv7rdir2d.scala:22:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            result = result.append(depth.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var paren_count = 0\n        var max_paren_count = 0\n        var max_paren_list = List[Long]()\n        for (i <- 0 until paren_list.length) {\n            if (paren_list[i].equals(\"(\")) {\n                paren_count += 1\n            } else if (paren_list[i].equals(\")\")) {\n                paren_count -= 1\n            }\n            if (paren_count > max_paren_count) {\n                max_paren_count = paren_count\n                max_paren_list = List[Long](i.toLong)\n            }\n        }\n        return max_paren_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292696,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5flrsgjg.scala:15:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m].equals(\u001b[31m\"(\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5flrsgjg.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i].equals(\u001b[31m\")\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val paren_counts = parens.map(_.toLong).toList\n        val max_paren_count = paren_counts.max()\n        val max_paren_count_index = paren_counts.indexOf(max_paren_count)\n        val max_paren_count_parens = parens.slice(max_paren_count_index)\n        val max_paren_count_parens_count = max_paren_count_parens.length\n        val max_paren_count_parens_count_parens = max_paren_count_parens.map(_.toLong).toList\n        val max_paren_count_parens_count_parens_count = max_paren_count_parens_count_parens.max()\n        val max_paren_count_parens_count_parens_count_parens = max_paren_count_parens_count_parens.toList\n        val max_paren_count_parens_count_parens_count_parens_count = max_paren_count_parens_count_parens_count_parens.max()\n        val max_paren_count_parens_count_parens_count_parens_count_parens = max_paren_count_parens_count_parens_count_parens.toList\n        val max_paren_count_parens_count_parens_count_parens_count_parens_count = max_paren_count_parens_count_parens_count_parens_count_parens.max()\n        val max_paren_count_parens_count_parens_count_parens_count_parens_count_parens = max_paren_count_parens_count_parens_count_parens_count_parens.max()\n        val max_paren_count_parens_count_parens_count_parens_count_parens_count_parens_count = max_paren_count_parens_count_parens_count_parens_count_parens_count_parens.max()\n        val max_\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292700,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpibj_ew0r.scala:25:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpibj_ew0r.scala:12:46 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax_paren_count\u001b[0m = paren_counts.max()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter ord of \u001b[33mmethod\u001b[0m \u001b[35mmax\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOnceOps\u001b[0m: (\u001b[33mimplicit \u001b[0mord: Ordering[B]): Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmpibj_ew0r.scala:14:49 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax_paren_count_parens\u001b[0m = parens.slice(max_paren_count_index)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter until of \u001b[33mmethod\u001b[0m \u001b[35mslice\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mArrayOps\u001b[0m: (from: Int, until: Int): Array[String]\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpibj_ew0r.scala:25:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens_).reduce(List[Long]())\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292663,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwsr5t9x2.scala:11:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens_).reduce(List[\u001b[35mLong\u001b[0m]())\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue parseNestedParens_ is not a member of object Problem - did you mean Problem.parseNestedParens?\n\u001b[31m\u001b[31m-- Error: /tmp/tmpwsr5t9x2.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens_).reduce(List[\u001b[35mLong\u001b[0m]())\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpf61ngfhb.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpf61ngfhb.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var result = List[Long]()\n        for (i <- 0 until paren_list.length) {\n            var paren_group = paren_list[i]\n            var paren_count = 0\n            for (j <- 0 until paren_group.length) {\n                if (paren_group[j] == '(') {\n                    paren_count += 1\n                } else if (paren_group[j] == ')') {\n                    paren_count -= 1\n                }\n            }\n            result = result.append(paren_count)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292640,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo0yz5gjh.scala:13:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen_group\u001b[0m = paren_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo0yz5gjh.scala:16:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_group[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo0yz5gjh.scala:18:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_group[j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo0yz5gjh.scala:22:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            result = result.append(paren_count)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(_.max)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292701,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa0sq2gyr.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(_.max)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpa0sq2gyr.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(_.max)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens).reduce(List[Long]())\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4lc2txvn.scala:11:76 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens).reduce(List[\u001b[35mLong\u001b[0m]())\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    List[Long]\n\u001b[31m   |\u001b[0m                        Required: (List[Long], List[Long]) => List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(s => {\n            val parens = s.split(\"(\")\n            val depth = parens.length - 1\n            val max_depth = depth.max()\n            return depth.toLong\n        })\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp6sgtd2qw.scala:14:37 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mmax_depth\u001b[0m = depth.max()\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter that of \u001b[33mmethod\u001b[0m \u001b[35mmax\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mRichInt\u001b[0m: (that: Int): Int\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6sgtd2qw.scala:15:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mreturn\u001b[0m depth.toLong\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    Long\n\u001b[31m   |\u001b[0m                   Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mLong\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp6sgtd2qw.scala:16:10 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        })\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          where:    B is a type variable\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.toLong).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292641,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"(()())\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:697)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$1(tmp1_0xw5jf.scala:11)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseNestedParens(tmp1_0xw5jf.scala:11)\n\tat Problem$.main(tmp1_0xw5jf.scala:15)\n\tat Problem.main(tmp1_0xw5jf.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var max_nesting = 0\n        var max_nesting_index = 0\n        for (i <- 0 until paren_list.length) {\n            var curr_nesting = 0\n            var curr_nesting_index = i\n            for (j <- i until paren_list.length) {\n                if (paren_list[j] == \"(\" && paren_list[j-1] != \"(\" && paren_list[j+1] != \"(\" ) {\n                    curr_nesting += 1\n                    curr_nesting_index = j\n                } else if (paren_list[j] == \")\" && paren_list[j-1] != \"(\" && paren_list[j+1] != \"(\" ) {\n                    curr_nesting -= 1\n                    curr_nesting_index = j\n                }\n            }\n            if (curr_nesting > max_nesting) {\n                max_nesting = curr_nesting\n                max_nesting_index = curr_nesting_index\n            }\n        }\n        var result = List[Long]()\n        for (i <- 0 until max_nesting_index) {\n            result = result.append(i.toLong)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292701,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwrgwgi3m.scala:17:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mj\u001b[0m] == \u001b[31m\"(\"\u001b[0m && paren_list[\u001b[35mj-\u001b[31m1\u001b[0m] != \u001b[31m\"(\"\u001b[0m && paren_list[\u001b[35mj+\u001b[31m1\u001b[0m] != \u001b[31m\"(\"\u001b[0m ) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwrgwgi3m.scala:20:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[j] == \u001b[31m\")\"\u001b[0m && paren_list[j-\u001b[31m1\u001b[0m] != \u001b[31m\"(\"\u001b[0m && paren_list[j+\u001b[31m1\u001b[0m] != \u001b[31m\"(\"\u001b[0m ) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwrgwgi3m.scala:32:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            result = result.append(i.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var max_nesting = 0\n        var result = List[Long]()\n        for (i <- 0 until paren_list.length) {\n            var paren_group = paren_list[i]\n            var nesting = 0\n            for (j <- 0 until paren_group.length) {\n                if (paren_group[j] == '(') {\n                    nesting += 1\n                } else if (paren_group[j] == ')') {\n                    nesting -= 1\n                }\n                if (nesting > max_nesting) {\n                    max_nesting = nesting\n                }\n            }\n            result = result.append(max_nesting.toLong)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292701,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpni0gl5au.scala:14:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen_group\u001b[0m = paren_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpni0gl5au.scala:17:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (paren_group[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpni0gl5au.scala:19:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_group[j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpni0gl5au.scala:26:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            result = result.append(max_nesting.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        val result_list = result.map(_.split(\"(\")).map(_.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        result_list.forEach(x => {\n            val depth = x.length - 1\n            if (depth > maxDepth) maxDepth = depth\n        })\n        return result_list.map(x => x.length - 1).toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292702,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp4i1fnkoe.scala:13:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        result_list.forEach(\u001b[36mx\u001b[0m => {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'.'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp4i1fnkoe.scala:18:4 ------------------------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m    where:    B is a type variable\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4i1fnkoe.scala:18:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(p -> {\n            val parens = p.split(\"(\")\n            val paren_count = parens.length - 1\n            if (paren_count == 0) {\n                return 0l\n            } else {\n                return paren_count\n            }\n        })\n        return result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292702,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpaf5h3v2v.scala:11:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(p -> {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: p\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpaf5h3v2v.scala:19:10 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        })\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var max_nesting = 0\n        var max_nesting_index = 0\n        for (i <- 0 until paren_list.length) {\n            var paren_count = 0\n            var paren_index = 0\n            for (j <- 0 until paren_list[i].length) {\n                if (paren_list[i][j] == '(') {\n                    paren_count += 1\n                } else if (paren_list[i][j] == ')') {\n                    paren_count -= 1\n                }\n                if (paren_count == 0) {\n                    if (paren_count > max_nesting) {\n                        max_nesting = paren_count\n                        max_nesting_index = paren_index\n                    }\n                }\n                paren_index += 1\n            }\n        }\n        var result = List[Long]()\n        for (i <- 0 until max_nesting_index) {\n            result = result.append(max_nesting)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292702,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp334410bw.scala:16:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until paren_list[\u001b[35mi\u001b[0m].length) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp334410bw.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp334410bw.scala:17:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp334410bw.scala:19:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp334410bw.scala:19:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-exp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = List[Long]()\n        for (i <- 0 until parens.length) {\n            val paren = parens(i)\n            val depth = paren.length() - paren.replaceAll(\"[()]\", \"\").length()\n            result = result.append(depth.toLong)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292702,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1idr4bci.scala:15:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            result = result.append(depth.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var paren_list_len = paren_list.length\n        var max_nesting = 0\n        var max_nesting_index = 0\n        for (var i = 0; i < paren_list_len; i++) {\n            var curr_paren_list = paren_list[i].split(\"(\")\n            var curr_paren_list_len = curr_paren_list.length\n            var curr_nesting = 0\n            for (var j = 0; j < curr_paren_list_len; j++) {\n                var curr_paren = curr_paren_list[j]\n                if (curr_paren == \"\") {\n                    curr_nesting = curr_nesting + 1\n                } else {\n                    curr_nesting = curr_nesting - 1\n                }\n                if (curr_nesting > max_nesting) {\n                    max_nesting = curr_nesting\n                    max_nesting_index = j\n                }\n            }\n        }\n        var max_nesting_list = paren_list[max_nesting_index].split(\"(\")\n        var max_nesting_list_len = max_nesting_list.length\n        var max_nesting_list_str = \"\"\n        for (var i = 0; i < max_nesting_list_len; i++) {\n            max_nesting_list_str = max_nesting_list_str + max_nesting_list[i]\n        }\n        return max_nesting_list_str.split(\" \").map(Long::parseLong).toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292704,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp2hsyqmox.scala:14:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < paren_list_len; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp2hsyqmox.scala:14:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < paren_list_len; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp2hsyqmox.scala:14:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < paren_list_len; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                               pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp2hsyqmox.scala:34:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < max_nesting_list_len; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp2hsyqmox.scala:34:48 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < max_nesting_list_len; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp2hsyqmox.scala:34:53 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < max_nesting_list_len; i++) {\n\u001b[31m\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var parens = paren_string.split(\" \")\n        var result = List[Long]()\n        for (i <- 0 until parens.length) {\n            var paren_group = parens[i]\n            var paren_count = 0\n            for (j <- 0 until paren_group.length) {\n                if (paren_group[j] == '(') {\n                    paren_count += 1\n                } else {\n                    paren_count -= 1\n                }\n                if (paren_count == 0) {\n                    result = result.append(j)\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292702,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpc8o2jcxy.scala:13:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen_group\u001b[0m = parens[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpc8o2jcxy.scala:16:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_group[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpc8o2jcxy.scala:22:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                    result = result.append(j)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var max_nesting = 0\n        var max_nesting_index = 0\n        for (i <- 0 until paren_list.length) {\n            var nesting = 0\n            for (j <- 0 until paren_list[i].length) {\n                if (paren_list[i][j] == '(') {\n                    nesting += 1\n                } else if (paren_list[i][j] == ')') {\n                    nesting -= 1\n                }\n                if (nesting > max_nesting) {\n                    max_nesting = nesting\n                    max_nesting_index = i\n                }\n            }\n        }\n        var result = List[Long]()\n        for (i <- 0 until max_nesting_index) {\n            result = result.append(i)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292703,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9wrwmf31.scala:15:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until paren_list[\u001b[35mi\u001b[0m].length) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9wrwmf31.scala:16:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9wrwmf31.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9wrwmf31.scala:18:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9wrwmf31.scala:18:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-exp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        result.map(_.toLong).toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292654,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.parseNestedParens$$anonfun$1(tmpth3a8rwm.scala:12)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseNestedParens(tmpth3a8rwm.scala:12)\n\tat Problem$.main(tmpth3a8rwm.scala:15)\n\tat Problem.main(tmpth3a8rwm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        val result_list = result.map(Long.parseLong).toList\n        result_list.sort(Comparator.naturalOrder())\n        return result_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292703,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp01jhekr2.scala:12:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult_list\u001b[0m = result.map(Long.parseLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value parseLong is not a member of object Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmp01jhekr2.scala:12:52 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult_list\u001b[0m = result.map(Long.parseLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens).reduce(_.maxBy(l -> l))\n        return result\n    }\n\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens2((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens2(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens).reduce(_.maxBy(l -> l))\n        return result\n    }\n\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens3((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens3(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens).reduce(_.maxBy(l -> l))\n        return result\n    }\n\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>>\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292702,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmps2ozqr1r.scala:48:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmps2ozqr1r.scala:11:66 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens).reduce(_.maxBy(l -> l))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 2\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmps2ozqr1r.scala:22:66 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens).reduce(_.maxBy(l -> l))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 2\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmps2ozqr1r.scala:33:66 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseNestedParens).reduce(_.maxBy(l -> l))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 2\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps2ozqr1r.scala:43:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m    assert(parseNestedParens((\u001b[31m\"(()()) ((())) () ((())()())\"\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m1l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: parseNestedParens\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps2ozqr1r.scala:44:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m    assert(parseNestedParens((\u001b[31m\"() (()) ((())) (((())))\"\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var paren_count = 0\n        var max_paren_count = 0\n        var max_paren_list = List[Long]()\n        for (i <- 0 until paren_list.length) {\n            var paren_count_here = 0\n            var paren_list_here = List[Long]()\n            for (j <- 0 until paren_list[i].length) {\n                if (paren_list[i][j] == '(') {\n                    paren_count_here += 1\n                } else if (paren_list[i][j] == ')') {\n                    paren_count_here -= 1\n                }\n                if (paren_count_here == 0) {\n                    paren_list_here.append(j)\n                }\n            }\n            if (paren_count_here > max_paren_count) {\n                max_paren_count = paren_count_here\n                max_paren_list = paren_list_here\n            }\n        }\n        return max_paren_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292703,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb_oyd4kd.scala:17:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mfor\u001b[0m (j <- \u001b[31m0\u001b[0m until paren_list[\u001b[35mi\u001b[0m].length) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb_oyd4kd.scala:18:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb_oyd4kd.scala:18:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m][\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb_oyd4kd.scala:20:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb_oyd4kd.scala:20:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i][j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-exp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = List[Long]()\n        for (i <- 0 until parens.length) {\n            val paren = parens(i)\n            val depth = 0\n            for (j <- 0 until paren.length) {\n                if (paren(j) == '(') {\n                    depth += 1\n                } else if (paren(j) == ')') {\n                    depth -= 1\n                }\n                if (depth < 0) {\n                    throw new RuntimeException(\"Invalid parentheses\")\n                }\n            }\n            result = result.append(depth.toLong)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292705,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0di7htnd.scala:17:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                    depth += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean depth.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0di7htnd.scala:19:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                    depth -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value -= is not a member of Int - did you mean depth.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0di7htnd.scala:25:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            result = result.append(depth.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\")).map(_.split(\"(\")).map(_.map(_.trim).map(_.toLong).toList)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292708,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsclyxfzq.scala:12:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mresult\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mArray\u001b[0m\u001b[1m\u001b[31m[\u001b[0mList[Long\u001b[1m\u001b[31m]\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var result = List[Long]()\n        for (i <- 0 until paren_list.length) {\n            var paren_group = paren_list[i]\n            var paren_count = 0\n            for (j <- 0 until paren_group.length) {\n                if (paren_group[j] == '(') {\n                    paren_count += 1\n                } else if (paren_group[j] == ')') {\n                    paren_count -= 1\n                }\n            }\n            result = result.append(paren_count)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292640,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo0yz5gjh.scala:13:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen_group\u001b[0m = paren_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo0yz5gjh.scala:16:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_group[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo0yz5gjh.scala:18:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_group[j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo0yz5gjh.scala:22:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            result = result.append(paren_count)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var parens = paren_string.split(\" \")\n        var result = List[Long]()\n        for (i <- 0 until parens.length) {\n            var paren_group = parens[i].split(\"(\")\n            var paren_depth = paren_group[0].length()\n            for (j <- 1 until paren_group.length) {\n                if (paren_group[j].length() > paren_depth) {\n                    paren_depth = paren_group[j].length()\n                }\n            }\n            result = result.append(paren_depth.toLong)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292708,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp18j66_es.scala:13:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen_group\u001b[0m = parens[\u001b[35mi\u001b[0m].split(\u001b[31m\"(\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp18j66_es.scala:16:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_group[\u001b[35mj\u001b[0m].length() > paren_depth) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp18j66_es.scala:17:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                    paren_depth = paren_group[\u001b[35mj\u001b[0m].length()\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp18j66_es.scala:20:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            result = result.append(paren_depth.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var parens = paren_string.split(\" \")\n        var result = List[Long]()\n        for (i <- 0 until parens.length) {\n            var paren_group = parens[i]\n            var paren_count = 0\n            for (j <- 0 until paren_group.length) {\n                if (paren_group[j] == '(') {\n                    paren_count += 1\n                } else if (paren_group[j] == ')') {\n                    paren_count -= 1\n                }\n            }\n            result = result.append(paren_count)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292708,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpws72z28x.scala:13:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen_group\u001b[0m = parens[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpws72z28x.scala:16:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_group[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpws72z28x.scala:18:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_group[j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpws72z28x.scala:22:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            result = result.append(paren_count)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val paren_list = parens.map(_.trim).map(Problem::parseParens).toList\n        val result = paren_list.map(l -> l.size()).maxBy(Comparator.naturalOrder())\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292709,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9yow3q87.scala:11:57 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_list\u001b[0m = parens.map(_.trim).map(Problem::parseParens).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Not found: parseParens\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp9yow3q87.scala:11:69 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_list\u001b[0m = parens.map(_.trim).map(Problem::parseParens).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var paren_list_len = paren_list.length\n        var paren_list_len_minus_1 = paren_list_len - 1\n        var paren_list_len_minus_2 = paren_list_len - 2\n        var paren_list_len_minus_3 = paren_list_len - 3\n        var paren_list_len_minus_4 = paren_list_len - 4\n        var paren_list_len_minus_5 = paren_list_len - 5\n        var paren_list_len_minus_6 = paren_list_len - 6\n        var paren_list_len_minus_7 = paren_list_len - 7\n        var paren_list_len_minus_8 = paren_list_len - 8\n        var paren_list_len_minus_9 = paren_list_len - 9\n        var paren_list_len_minus_10 = paren_list_len - 10\n        var paren_list_len_minus_11 = paren_list_len - 11\n        var paren_list_len_minus_12 = paren_list_len - 12\n        var paren_list_len_minus_13 = paren_list_len - 13\n        var paren_list_len_minus_14 = paren_list_len - 14\n        var paren_list_len_minus_15 = paren_list_len - 15\n        var paren_list_len_minus_16 = paren_list_len - 16\n        var paren_list_len_minus_17 = paren_list_len - 17\n        var paren_list_len_minus_18 = paren_list_len - 18\n        var paren_list_len_minus_19 = paren_list_len - 19\n        var paren_list_len_minus_20 = paren_list_len - 20\n        var paren_list_len_minus_21 = paren_list_len - 21\n        var paren_list_len_minus_22 = paren_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292709,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpd80_nouw.scala:34:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var paren_count = 0\n        var paren_stack = List[Long]()\n        for (i <- 0 until paren_list.length) {\n            if (paren_list[i] == \"(\" || paren_list[i] == \"{\" || paren_list[i] == \"[\") {\n                paren_count += 1\n                paren_stack = paren_stack.append(i)\n            } else if (paren_list[i] == \")\" || paren_list[i] == \"}\" || paren_list[i] == \"]\") {\n                paren_count -= 1\n                if (paren_count == 0) {\n                    var paren_index = paren_stack.last()\n                    var paren_level = paren_count\n                    for (j <- paren_index - 1 until paren_index) {\n                        if (paren_list[j] == \"(\" || paren_list[j] == \"{\" || paren_list[j] == \"[\") {\n                            paren_level += 1\n                        } else if (paren_list[j] == \")\" || paren_list[j] == \"}\" || paren_list[j] == \"]\") {\n                            paren_level -= 1\n                        }\n                    }\n                    paren_stack = paren_stack.remove(paren_index)\n                    paren_stack = paren_stack.append(paren_level)\n                }\n            }\n        }\n        return paren_stack\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292710,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuez7ycht.scala:14:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mif\u001b[0m (paren_list[\u001b[35mi\u001b[0m] == \u001b[31m\"(\"\u001b[0m || paren_list[\u001b[35mi\u001b[0m] == \u001b[31m\"{\"\u001b[0m || paren_list[\u001b[35mi\u001b[0m] == \u001b[31m\"[\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuez7ycht.scala:16:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                paren_stack = paren_stack.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuez7ycht.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_list[i] == \u001b[31m\")\"\u001b[0m || paren_list[i] == \u001b[31m\"}\"\u001b[0m || paren_list[i] == \u001b[31m\"]\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpuez7ycht.scala:20:50 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                    \u001b[33mvar\u001b[0m \u001b[36mparen_index\u001b[0m = paren_stack.last()\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mmethod\u001b[0m \u001b[35mlast\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuez7ycht.scala:29:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                    paren_stack = paren_stack.remove(paren_index)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue remove is not a member of List[Long], but could be m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(s -> {\n            val parens = s.split(\"(\")\n            val max_nesting = parens.map(s1 -> {\n                val parens1 = s1.split(\")\")\n                return parens1.length - 1\n            }).max()\n            return max_nesting\n        }).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292709,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpaqbla9o4.scala:11:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(s -> {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: s\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpaqbla9o4.scala:18:10 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        }).toList\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(_.maxBy(l -> l))\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292667,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu_jmk6zj.scala:11:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(_.maxBy(l -> l))\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value :: is not a member of String => List[Long]\n\u001b[31m\u001b[31m-- Error: /tmp/tmpu_jmk6zj.scala:11:59 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem::parseNestedParens).reduce(_.maxBy(l -> l))\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var result = List[Long]()\n        for (i <- 0 until paren_list.length) {\n            var paren_group = paren_list[i]\n            var paren_count = 0\n            for (j <- 0 until paren_group.length) {\n                if (paren_group[j] == '(') {\n                    paren_count += 1\n                } else if (paren_group[j] == ')') {\n                    paren_count -= 1\n                }\n            }\n            result = result.append(paren_count)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292640,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo0yz5gjh.scala:13:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen_group\u001b[0m = paren_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo0yz5gjh.scala:16:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mif\u001b[0m (paren_group[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo0yz5gjh.scala:18:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (paren_group[j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo0yz5gjh.scala:22:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            result = result.append(paren_count)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"(\", \"\").replaceAll(\")\", \"\"))\n        val result_list = result.map(Long::parseLong).toList\n        result_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292709,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxvm_o7s_.scala:12:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult_list\u001b[0m = result.map(Long::parseLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Not found: parseLong\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpxvm_o7s_.scala:12:53 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult_list\u001b[0m = result.map(Long::parseLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseParens).reduce(List[Long]::concat)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292709,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp85ut5_bj.scala:11:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value parseParens is not a member of object Problem\n\u001b[31m\u001b[31m-- Error: /tmp/tmp85ut5_bj.scala:11:52 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = parens.map(Problem.parseParens).reduce(List[\u001b[35mLong\u001b[0m]::concat)\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        val result_list = result.map(_.toLong).toList\n        return result_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292710,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$3(tmp_m_jy3u_.scala:12)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseNestedParens(tmp_m_jy3u_.scala:12)\n\tat Problem$.main(tmp_m_jy3u_.scala:16)\n\tat Problem.main(tmp_m_jy3u_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        val result_list = result.map(Long.parseLong).toList\n        return result_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292652,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpulyo352r.scala:12:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult_list\u001b[0m = result.map(Long.parseLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value parseLong is not a member of object Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmpulyo352r.scala:12:52 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult_list\u001b[0m = result.map(Long.parseLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"(\", \"\").replaceAll(\")\", \"\")).map(_.split(\"(\")).map(x => x.length - 1).toList\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292709,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppmus6_f3.scala:12:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : List[Int])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val paren_list = parens.map(_.trim).map(Problem::parseParens).toList\n        val max_nesting = paren_list.foldLeft(0, (max, parens) => {\n            if (parens.length == 0) return max\n            return parens.length - 1\n        })\n        val result = paren_list.map(l -> l - max_nesting).toList\n        return result\n    }\n\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens2((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens2(paren_string : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n        val paren_list = parens.map(_.trim).map(Problem::parseParens).toList\n        val max_nesting = paren_list.foldLeft(0, (max, parens) => {\n            if (parens.length == 0) return max\n            return parens.length - 1\n        })\n        val result = paren_list.map(l -> l - max_nesting).toList\n        return result\n    }\n\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens3((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292710,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4brhj2n5.scala:48:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4brhj2n5.scala:11:57 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_list\u001b[0m = parens.map(_.trim).map(Problem::parseParens).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Not found: parseParens\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp4brhj2n5.scala:11:69 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_list\u001b[0m = parens.map(_.trim).map(Problem::parseParens).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4brhj2n5.scala:27:57 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_list\u001b[0m = parens.map(_.trim).map(Problem::parseParens).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Not found: parseParens\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp4brhj2n5.scala:27:69 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mparen_list\u001b[0m = parens.map(_.trim).map(Problem::parseParens).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    // For each of the group, output the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens(paren_string : String) : List[Long] = {\n        var paren_list = paren_string.split(\" \")\n        var result = List[Long]()\n        for (i <- 0 until paren_list.length) {\n            var paren_group = paren_list[i].split(\"(\")\n            var max_nesting = 0\n            for (j <- 0 until paren_group.length) {\n                var paren_group_nesting = paren_group[j].length() - paren_group[j].replace(\"(\", \"\").length() - paren_group[j].replace(\")\", \"\").length()\n                if (paren_group_nesting > max_nesting) {\n                    max_nesting = paren_group_nesting\n                }\n            }\n            result = result.append(max_nesting.toLong)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"(()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\")).equals((List[Long](4l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292710,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxdecigx_.scala:13:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mparen_group\u001b[0m = paren_list[\u001b[35mi\u001b[0m].split(\u001b[31m\"(\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxdecigx_.scala:16:54 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mvar\u001b[0m \u001b[36mparen_group_nesting\u001b[0m = paren_group[\u001b[35mj\u001b[0m].length() - paren_group[\u001b[35mj\u001b[0m].replace(\u001b[31m\"(\"\u001b[0m, \u001b[31m\"\"\u001b[0m).length() - paren_group[\u001b[35mj\u001b[0m].replace(\u001b[31m\")\"\u001b[0m, \u001b[31m\"\"\u001b[0m).length()\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                      Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxdecigx_.scala:21:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            result = result.append(max_nesting.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}