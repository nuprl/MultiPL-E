{
  "name": "HumanEval_17_parse_music",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "results": [
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long {\n            if (note_string == \".\") {\n                return 0l\n            } else if (note_string == \"o\") {\n                return 4l\n            } else if (note_string == \"o|\") {\n                return 2l\n            } else {\n                throw new RuntimeException(\"Invalid note: \" + note_string)\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] {\n            var result = List[Long]()\n            var note_count = 0\n            var note_string = \"\"\n            for (i <- 0 until music_string.length) {\n                if (music_string[i] == ' ') {\n                    note_count = note_count + parseNote(note_string)\n                    note_string = \"\"\n                } else {\n                    note_string = note_string + music_string[i]\n                }\n            }\n            note_count = note_count + parseNote(note_string)\n            for (i <- 0 until note_count) {\n                result = result + i\n            }\n            return result\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E103] Syntax Error: /tmp/tmpd11_m4ul.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m (note_string == \u001b[31m\".\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^\u001b[0m\n\u001b[31m   |\u001b[0mIllegal start of declaration (possible cause: missing `=` in front of current method body)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpd11_m4ul.scala:26:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       refinement cannot be a mutable var.\n\u001b[31m   |\u001b[0m       You can use an explicit getter result and setter result_= instead\n\u001b[31m\u001b[31m-- Error: /tmp/tmpd11_m4ul.scala:27:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mnote_count\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrefinement cannot be a mutable var.\n\u001b[31m   |\u001b[0mYou can use an explicit getter note_count and setter note_count_= instead\n\u001b[31m\u001b[31m-- Error: /tmp/tmpd11_m4ul.scala:28:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mnote_string\u001b[0m = \u001b[31m\"\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrefinement cannot be a mutable var.\n\u001b[31m   |\u001b[0mYou can use an explicit getter note_string and setter note_string_= instead\n\u001b[31m\u001b[31m-- [E103] Syntax Error: /tmp/tmpd11_m4ul.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until music_string.length) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^\u001b[0m\n\u001b[31m   |\u001b[0mIllegal start of declaration (possible cause: missing `=` in front of current method body)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E103] Syntax Error: /tmp/tmpd11_m4ul.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            note_count ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.contains(\"o\") {\n                return 4L\n            } else if note_string.contains(\"o|\") {\n                return 2L\n            } else if note_string.contains(\".|\") {\n                return 1L\n            } else {\n                return 0L\n            }\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if beat_string.contains(\".\") {\n                return 1L\n            } else if beat_string.contains(\"|\") {\n                return 2L\n            } else {\n                return 4L\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var beat_counts = mutable.List[Long]()\n            var note_counts = mutable.List[Long]()\n            var beat_index = 0\n            var note_index = 0\n            for(i <- 0 until music_string.length) {\n                if music_string[i] == 'o' {\n                    note_counts = note_counts.append(parseNote(music_string[note_index:i]))\n                    note_index = i + 1\n                } else if music_string[i] == 'o|' {\n                    note_counts = note_counts.append(parseNote(music_string[note_index:i]))\n                    note_counts = note_counts.append(parseNote(music_string[i+1:i+2]))\n                    note_index = i + 2\n                } else if music_string[i] == '.' {\n                    note_counts = note_counts.append(parseNote(music_string[note_index:i]))\n                    note_counts = note_counts.append(parseNote(music_string[i+1:i+2]))\n                    note_counts = note_counts.append(parseNote(music_string[i+2:i+3]))\n                    note_counts = note_counts.append(parseNote(music_string[i+3:i+4]))\n                    \n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292768,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmphvb1_glh.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"o|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmphvb1_glh.scala:28:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m beat_string.contains(\u001b[31m\"|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmphvb1_glh.scala:41:86 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m                    note_counts = note_counts.append(parseNote(music_string[\u001b[35mnote_index\u001b[0m:i]))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             ']' expected, but ':' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmphvb1_glh.scala:43:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m music_string[i] == \u001b[31m'o\u001b[0m|' {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmphvb1_glh.scala:63:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmphvb1_glh.scala:15:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mcontains\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmphvb1_glh.scala:26:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = List[String]()\n        for (i <- 0 until music_string.length) {\n            if (music_string[i] == '.') {\n                music_list = music_list.append(0l)\n            } else if (music_string[i] == '|') {\n                music_list = music_list.append(1l)\n            } else if (music_string[i] == 'o') {\n                music_list = music_list.append(4l)\n            } else if (music_string[i] == 'o|') {\n                music_list = music_list.append(2l)\n            }\n        }\n        val result = List[Long]()\n        for (i <- 0 until music_list.length) {\n            if (music_list[i] == 0) {\n                result = result.append(4l.toLong)\n            } else if (music_list[i] == 1) {\n                result = result.append(2l.toLong)\n            } else if (music_list[i] == 2) {\n                result = result.append(1l.toLong)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292770,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmplb_i8ctv.scala:22:42 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_string[i] == \u001b[31m'o\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0msymbol literal 'o is no longer supported,\n\u001b[31m   |\u001b[0muse a string literal \"o\" or an application Symbol(\"o\") instead,\n\u001b[31m   |\u001b[0mor enclose in braces '{o} if you want a quoted expression.\n\u001b[31m   |\u001b[0mFor now, you can also `import language.deprecated.symbolLiterals` to accept\n\u001b[31m   |\u001b[0mthe idiom, but this possibility might no longer be available in the future.\n\u001b[31m\u001b[31m-- Error: /tmp/tmplb_i8ctv.scala:22:45 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_string[i] == \u001b[31m'o\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             unclosed character literal\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplb_i8ctv.scala:16:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mif\u001b[0m (music_string[\u001b[35mi\u001b[0m] == \u001b[31m'.'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplb_i8ctv.scala:17:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                music_list = music_list.append(\u001b[31m0l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[String] - did you mean music_list.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplb_i8ctv.scala:18:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_string[i] == \u001b[31m'|'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer e",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if (note_string.contains(\"o\")) {\n                return 4l\n            } else if (note_string.contains(\"o|\")) {\n                return 2l\n            } else if (note_string.contains(\".|\")) {\n                return 1l\n            } else {\n                return 0l\n            }\n        }\n        def parseDuration(note_string : String) : Long = {\n            if (note_string.contains(\"o\")) {\n                return 4l\n            } else if (note_string.contains(\"o|\")) {\n                return 2l\n            } else if (note_string.contains(\".|\")) {\n                return 1l\n            } else {\n                return 0l\n            }\n        }\n        def parseMusic(note_string : String) : List[Long] = {\n            var notes = note_string.split(\" \")\n            var result = List[Long]()\n            for (i <- 0 until notes.length) {\n                result = result.append(parseNote(notes[i]))\n                result = result.append(parseDuration(notes[i]))\n            }\n            return result\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292769,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpph7q_lx3.scala:40:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                result = result.append(parseNote(notes[\u001b[35mi\u001b[0m]))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpph7q_lx3.scala:40:55 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                result = result.append(parseNote(notes[\u001b[35mi\u001b[0m]))\n\u001b[31m\u001b[31m   |\u001b[0m                                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpph7q_lx3.scala:41:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m                result = result.append(parseDuration(notes[\u001b[35mi\u001b[0m]))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpph7q_lx3.scala:41:59 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m                result = result.append(parseDuration(notes[\u001b[35mi\u001b[0m]))\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asScalaBuffer(music_string.split(\" \")).toList\n        val result = mutable.List[Long]()\n        for (i <- 0 until music_list.length) {\n            val note = music_list(i)\n            if (note.contains(\"o\")) {\n                result.append(4l)\n            } else if (note.contains(\"o|\")) {\n                result.append(2l)\n            } else if (note.contains(\".|\")) {\n                result.append(1l)\n            } else {\n                result.append(0l)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292768,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3gljlp9b.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(music_string.split(\u001b[31m\" \"\u001b[0m)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3gljlp9b.scala:15:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        val beats = mutable.List[Long]()\n        for (i <- 0 until music_list.length) {\n            val note = music_list[i]\n            if (note.equals(\".\")) {\n                beats.append(1l)\n            } else if (note.equals(\"o\")) {\n                beats.append(4l)\n            } else if (note.equals(\"o|\")) {\n                beats.append(2l)\n            }\n        }\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292768,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpw6iw7nqc.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpw6iw7nqc.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpw6iw7nqc.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnote\u001b[0m = music_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.replaceAll(\"[^0-9.]\", \"\"))\n        val result = beats.map(_.toLong).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292770,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$3(tmp8xtub72i.scala:16)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseMusic(tmp8xtub72i.scala:16)\n\tat Problem$.main(tmp8xtub72i.scala:20)\n\tat Problem.main(tmp8xtub72i.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        val beats = notes.map(note -> {\n            val note_parts = note.split(\"|\")\n            val note_length = note_parts[0].length()\n            val note_type = note_parts[0].charAt(note_length - 1)\n            return note_length - 1\n        }).toList\n        val beats_count = beats.map(beat_count -> beat_count + 1).toList\n        return beats_count\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292768,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp683qvp9k.scala:14:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnotes\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value JavaConversions is not a member of collection\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var music_list = mutable.List[Long]()\n        var current_note = mutable.StringBuilder()\n        var current_duration = mutable.StringBuilder()\n        var current_duration_count = mutable.Long()\n        var current_duration_count_temp = mutable.Long()\n        var current_duration_count_temp_temp = mutable.Long()\n        var current_duration_count_temp_temp_temp = mutable.Long()\n        var current_duration_count_temp_temp_temp_temp = mutable.Long()\n        var current_duration_count_temp_temp_temp_temp_temp = mutable.Long()\n        var current_duration_count_temp_temp_temp_temp_temp_temp = mutable.Long()\n        var current_duration_count_temp_temp_temp_temp_temp_temp_temp = mutable.Long()\n        var current_duration_count_temp_temp_temp_temp_temp_temp_temp_temp = mutable.Long()\n        var current_duration_count_temp_temp_temp_temp_temp_temp_temp_temp_temp = mutable.Long()\n        var current_duration_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = mutable.Long()\n        var current_duration_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = mutable.Long()\n        var current_duration_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = mutable.Long()\n        var current_duration_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = mutable.Long()\n        var current_duration_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = mutable.Long()\n        var current_duration_count_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = mutable.Long()\n        var current_duration_count\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292768,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvujc217g.scala:34:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvujc217g.scala:14:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmusic_list\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvujc217g.scala:15:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_note\u001b[0m = mutable.StringBuilder()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvujc217g.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration\u001b[0m = mutable.StringBuilder()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvujc217g.scala:17:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration_count\u001b[0m = mutable.Long()\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvujc217g.scala:18:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration_count_temp\u001b[0m = mutable.Long()\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.contains(\"o\") {\n                return 4l\n            } else if note_string.contains(\"o|\") {\n                return 2l\n            } else if note_string.contains(\".|\") {\n                return 1l\n            } else {\n                return 0l\n            }\n        }\n        def parseBeat(note_string : String) : Long = {\n            if note_string.contains(\"o\") {\n                return 4l\n            } else if note_string.contains(\"o|\") {\n                return 2l\n            } else if note_string.contains(\".|\") {\n                return 1l\n            } else {\n                return 0l\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var beat_counts = mutable.List[Long]()\n            var note_counts = mutable.List[Long]()\n            var beat_index = 0\n            var note_index = 0\n            for(i <- 0 until music_string.length) {\n                if music_string[i] == '.' {\n                    beat_counts.append(parseBeat(music_string[beat_index:i]))\n                    beat_index = i + 1\n                } else if music_string[i] == '|' {\n                    note_counts.append(parseNote(music_string[note_index:i]))\n                    note_index = i + 1\n                }\n            }\n            beat_counts.append(parseBeat(music_string[beat_index:]))\n            note_counts.append(parseNote(music_string[note_index:]))\n            return beat_counts.toSeq().toList()\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292765,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpx0l0x2xl.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"o|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpx0l0x2xl.scala:28:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"o|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpx0l0x2xl.scala:43:72 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m                    beat_counts.append(parseBeat(music_string[\u001b[35mbeat_index\u001b[0m:i]))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             ']' expected, but ':' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpx0l0x2xl.scala:45:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m music_string[i] == \u001b[31m'|'\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpx0l0x2xl.scala:50:64 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m            beat_counts.append(parseBeat(music_string[\u001b[35mbeat_index\u001b[0m:]))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             ']' expected, but ':' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpx0l0x2xl.scala:51:64 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m            note_counts.append(parseNote(music_string[\u001b[35mnote_index\u001b[0m:]))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             ']' expected, but ':' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpx0l0x2xl.scala:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.charAt(0) == 'o' {\n                return 4l\n            } else if note_string.charAt(0) == 'o|' {\n                return 2l\n            } else if note_string.charAt(0) == '.' {\n                return 1l\n            } else {\n                return 0l\n            }\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if beat_string.charAt(0) == 'o' {\n                return 4l\n            } else if beat_string.charAt(0) == 'o|' {\n                return 2l\n            } else if beat_string.charAt(0) == '.' {\n                return 1l\n            } else {\n                return 0l\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var beat_counts = mutable.List[Long]()\n            var note_counts = mutable.List[Long]()\n            var beat_index = 0\n            var note_index = 0\n            for(i <- 0 until music_string.length) {\n                if music_string.charAt(i) == ' ' {\n                    beat_index += 1\n                    note_index += 1\n                } else {\n                    beat_counts += beat_index * parseBeat(music_string.substring(beat_index, i))\n                    note_counts += note_index * parseNote(music_string.substring(note_index, i))\n                    beat_index = i\n                    note_index = i\n                }\n            }\n            beat_counts += beat_index * parseBeat(music_string.substring(beat_index, music_string.length))\n            note_counts += note_index * parseNote(music_string.substring(note_index, music_string.length))\n            return beat_counts + note_counts\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292765,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpcomznmv4.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'o\u001b[0m|' {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpcomznmv4.scala:28:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m beat_string.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'o\u001b[0m|' {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpcomznmv4.scala:45:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m                } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpcomznmv4.scala:15:40 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'o'\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     expression does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpcomznmv4.scala:26:40 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m beat_string.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'o'\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     expression does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcomznmv4.scala:37:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mbeat_counts\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if (note_string.contains(\"o\")) {\n                return 4l\n            } else if (note_string.contains(\"o|\")) {\n                return 2l\n            } else if (note_string.contains(\".|\")) {\n                return 1l\n            } else {\n                return 0l\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var result = List[Long]()\n            var note_count = 0\n            var note_index = 0\n            var note_string = \"\"\n            for (i <- 0 until music_string.length) {\n                if (music_string[i] == '.') {\n                    note_count += parseNote(note_string)\n                    note_string = \"\"\n                } else {\n                    note_string += music_string[i]\n                }\n                if (music_string[i] == '|') {\n                    note_count += parseNote(note_string)\n                    note_string = \"\"\n                }\n                if (music_string[i] == 'o') {\n                    note_count += parseNote(note_string)\n                    note_string = \"\"\n                }\n                if (music_string[i] == 'o') {\n                    note_count += parseNote(note_string)\n                    note_string = \"\"\n                }\n                if (music_string[i] == 'o') {\n                    note_count += parseNote(note_string)\n                    note_string = \"\"\n                }\n                if (music_string[i] == 'o') {\n                    note_count += parseNote(note_string)\n                    note_string = \"\"\n                }\n                if (music_string[i] == 'o') {\n                    note_count += parseNote(note_string)\n                    note_string = \"\"\n                }\n                if (music_string[i] == 'o') {\n                    note_count += parseNote(note_string)\n                    note_string = \"\"\n                }\n                if (music_string[i] == 'o') {\n                    note_count += parseNote(note_string)\n\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292771,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmplq0gnad6.scala:78:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplq0gnad6.scala:31:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                \u001b[33mif\u001b[0m (music_string[\u001b[35mi\u001b[0m] == \u001b[31m'.'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplq0gnad6.scala:32:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    note_count += parseNote(note_string)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplq0gnad6.scala:35:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                    note_string += music_string[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplq0gnad6.scala:35:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                    note_string += music_string[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplq0gnad6.scala:37:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                \u001b[33mif\u001b[0m (music_string[\u001b[35mi\u001b[0m] == \u001b[31m'|'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        val result = mutable.List[Long]()\n        for (i <- 0 until music_list.length - 1) {\n            val note = music_list.get(i)\n            if (note.equals(\".\")) {\n                result.append(1l)\n            } else if (note.equals(\"o\")) {\n                result.append(4l)\n            } else if (note.equals(\"o|\")) {\n                result.append(2l)\n            } else {\n                result.append(0l)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292768,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptz9e58bl.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptz9e58bl.scala:15:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.endsWith(\"|\") {\n                return note_string.substring(0, note_string.length() - 1).toLong\n            } else {\n                return note_string.toLong\n            }\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if beat_string.endsWith(\"|\") {\n                return beat_string.substring(0, beat_string.length() - 1).toLong\n            } else {\n                return beat_string.toLong\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var beat_counts = mutable.List[Long]()\n            var note_counts = mutable.List[Long]()\n            var beat_index = 0\n            var note_index = 0\n            var beat_count = 0\n            var note_count = 0\n            var note_count_in_beat = 0\n            var beat_count_in_note = 0\n            for (i <- 0 until music_string.length) {\n                if (music_string[i] == '.') {\n                    note_count_in_beat = note_count_in_beat + 1\n                    note_count = note_count + 1\n                    note_counts = note_counts + note_count_in_beat\n                    beat_count = beat_count + beat_count_in_note\n                    beat_counts = beat_counts + beat_count_in_beat\n                    note_index = note_index + 1\n                    beat_index = beat_index + 1\n                    note_count_in_beat = 0\n                    note_count = 0\n                    beat_count = 0\n                } else if (music_string[i] == 'o') {\n                    note_count_in_beat = note_count_in_beat + 1\n                    note_count = note_count + 1\n                    note_counts = note_counts + note_count_in_beat\n                    beat_count = beat_count + beat_count_in_note\n                    beat_counts = beat_counts + beat_count_in\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292769,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpn4qvc18e.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpn4qvc18e.scala:24:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpn4qvc18e.scala:65:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m65 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpn4qvc18e.scala:15:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.endsWith(\u001b[31m\"|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mendsWith\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpn4qvc18e.scala:22:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m beat_string.endsWith(\u001b[31m\"|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mendsWith\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn4qvc18e.scala:29:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mbeat_counts\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn4qvc18e.scala:30:30 ------------------------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        val beats = mutable.List[Long]()\n        for (i <- 0 until music_list.length) {\n            if (music_list(i).equals(\".\")) {\n                beats.append(0l)\n            } else if (music_list(i).equals(\"o\")) {\n                beats.append(4l)\n            } else if (music_list(i).equals(\"o|\")) {\n                beats.append(2l)\n            } else {\n                beats.append(1l)\n            }\n        }\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292768,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdtmwc8sq.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdtmwc8sq.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.replaceAll(\"[^0-9.]\", \"\")).map(_.toLong).toList\n        val result = beats.map(b -> b.toLong)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292766,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp26mt5u14.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = beats.map(b -> b.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: b\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var result = mutable.List[Long]()\n        var current_note = \"\"\n        var current_duration = 0\n        var current_beat = 0\n        var current_note_count = 0\n        for (i <- 0 until music_string.length) {\n            if (music_string[i] == '.') {\n                current_note = current_note + music_string[i]\n                current_note_count += 1\n                if (current_note_count == 1) {\n                    current_duration = 4\n                } else if (current_note_count == 2) {\n                    current_duration = 2\n                } else if (current_note_count == 3) {\n                    current_duration = 1\n                }\n                current_note_count = 0\n            } else if (music_string[i] == '|') {\n                current_note = current_note + music_string[i]\n                current_note_count += 1\n                if (current_note_count == 1) {\n                    current_duration = 2\n                } else if (current_note_count == 2) {\n                    current_duration = 1\n                }\n                current_note_count = 0\n            } else if (music_string[i] == 'o') {\n                current_note = current_note + music_string[i]\n                current_note_count += 1\n                if (current_note_count == 1) {\n                    current_duration = 4\n                } else if (current_note_count == 2) {\n                    current_duration = 2\n                } else if (current_note_count == 3) {\n                    current_duration = 1\n                }\n                current_note_count = 0\n            } else if (music_string[i] == 'o') {\n                current_note = current_note + music_string[i]\n                current_note_count += 1\n                if (current_note_count == 1) {\n                    current_duration = 4\n                } else if (current_note_count == 2) {\n                    current_duration = 2\n                } else if (current_note_count == 3) {\n                    current_duration = 1\n                }\n                current_note_count = 0\n            }\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292769,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5lfs0aqq.scala:73:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5lfs0aqq.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5lfs0aqq.scala:20:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mif\u001b[0m (music_string[\u001b[35mi\u001b[0m] == \u001b[31m'.'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5lfs0aqq.scala:21:59 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                current_note = current_note + music_string[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5lfs0aqq.scala:31:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_string[i] == \u001b[31m'|'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5lfs0aqq.scala:32:59 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                current_note = current_note + music_string[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.contains(\".\") {\n                return note_string.replace(\".\", \"\").replace(\"|\", \"\").replace(\"o\", \"\").toLong\n            } else {\n                return note_string.replace(\"o\", \"\").replace(\"|\", \"\").toLong\n            }\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if beat_string.contains(\".\") {\n                return beat_string.replace(\".\", \"\").replace(\"|\", \"\").toLong\n            } else {\n                return beat_string.toLong\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var beat_counts = mutable.List[Long]()\n            var beat_count = 0\n            for (i <- 0 until music_string.length) {\n                if (music_string[i] == \".\") {\n                    beat_count += 1\n                } else if (music_string[i] == \"|\") {\n                    beat_count += 1\n                } else if (music_string[i] == \"o\") {\n                    beat_count += 4\n                } else {\n                    beat_count += 1\n                }\n                if (beat_count > beat_counts.length) {\n                    beat_counts.append(beat_count)\n                } else {\n                    beat_counts[beat_count] += 1\n                }\n                beat_count = 0\n            }\n            return beat_counts\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292765,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzepmfzg7.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzepmfzg7.scala:24:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpzepmfzg7.scala:15:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\".\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mcontains\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpzepmfzg7.scala:22:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m beat_string.contains(\u001b[31m\".\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mcontains\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzepmfzg7.scala:29:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mbeat_counts\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzepmfzg7.scala:32:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                \u001b[33mif\u001b[0m (music_string[\u001b[35mi\u001b[0m] == \u001b[31m\".\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m             ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.length() == 1 {\n                return _.toLong(note_string)\n            } else {\n                return _.toLong(note_string.substring(0, note_string.length() - 1))\n            }\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if beat_string.length() == 1 {\n                return _.toLong(beat_string)\n            } else {\n                return _.toLong(beat_string.substring(0, beat_string.length() - 1))\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var beat_counts = List[Long]()\n            var beat_count = 0\n            var note_count = 0\n            var note_counts = List[Long]()\n            var note_counts_count = 0\n            var note_counts_counts = List[Long]()\n            var note_counts_counts_count = 0\n            var note_counts_counts_counts = List[Long]()\n            var note_counts_counts_counts_count = 0\n            var note_counts_counts_counts_counts = List[Long]()\n            var note_counts_counts_counts_counts_count = 0\n            var note_counts_counts_counts_counts_counts = List[Long]()\n            var note_counts_counts_counts_counts_counts_count = 0\n            var note_counts_counts_counts_counts_counts_counts = List[Long]()\n            var note_counts_counts_counts_counts_counts_counts_count = 0\n            var note_counts_counts_counts_counts_counts_counts_counts = List[Long]()\n            for (i <- 0 until music_string.length) {\n                if (music_string[i] == '.') {\n                    note_counts_counts_counts_counts_\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292769,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp871_ski_.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp871_ski_.scala:24:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp871_ski_.scala:58:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp871_ski_.scala:15:39 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.length() == \u001b[31m1\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     expression does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmp871_ski_.scala:16:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33mreturn\u001b[0m _.toLong(note_string)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$1 of expanded function:\n\u001b[31m   |\u001b[0m   _$1 => _$1.toLong(note_string).\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp871_ski_.scala:22:39 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m beat_string.length() == \u001b[31m1\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     expression does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmp871_ski_.scala:23:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                \u001b[33mreturn\u001b[0m _.toLong(beat_stri",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if (note_string == \".\") {\n                return 0l\n            } else if (note_string == \"o\") {\n                return 4l\n            } else if (note_string == \"o|\") {\n                return 2l\n            } else {\n                return 1l\n            }\n        }\n        def parseMusic(note_string : String) : List[Long] = {\n            var result = List[Long]()\n            var note = parseNote(note_string)\n            for (i <- 0 until note) {\n                result = result.append(note)\n            }\n            return result\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292769,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvivfmo2j.scala:28:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until note) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (note : Long)\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvivfmo2j.scala:29:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                result = result.append(note)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.replaceAll(\"[^0-9.]\", \"\")).map(_.toLong).toList\n        val result = beats.map(_.toLong).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292771,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$3(tmpq5ma97of.scala:15)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseMusic(tmpq5ma97of.scala:15)\n\tat Problem$.main(tmpq5ma97of.scala:20)\n\tat Problem.main(tmpq5ma97of.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var result = mutable.List[Long]()\n        var current_note = mutable.List[String]()\n        var current_duration = mutable.List[Long]()\n        var current_duration_index = mutable.List[Long]()\n        var current_duration_index_index = mutable.List[Long]()\n        var current_duration_index_index_index = mutable.List[Long]()\n        var current_duration_index_index_index_index = mutable.List[Long]()\n        var current_duration_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_index_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_index_index_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_index_index_index_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_index_index_index_index_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_index_index_index_index_index_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_index_index_index_index_index_index_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292768,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7ngwd052.scala:33:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7ngwd052.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7ngwd052.scala:15:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_note\u001b[0m = mutable.List[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7ngwd052.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7ngwd052.scala:17:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration_index\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7ngwd052.scala:18:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration_index_index\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var result = mutable.List[Long]()\n        var current_note = mutable.List[String]()\n        var current_duration = mutable.List[Long]()\n        var current_duration_index = mutable.List[Long]()\n        var current_duration_index_index = mutable.List[Long]()\n        var current_duration_index_index_index = mutable.List[Long]()\n        var current_duration_index_index_index_index = mutable.List[Long]()\n        var current_duration_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_index_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_index_index_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_index_index_index_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_index_index_index_index_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_index_index_index_index_index_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_index_index_index_index_index_index_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292768,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7ngwd052.scala:33:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7ngwd052.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7ngwd052.scala:15:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_note\u001b[0m = mutable.List[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7ngwd052.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7ngwd052.scala:17:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration_index\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7ngwd052.scala:18:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration_index_index\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.equals(\".\") {\n                return 0l\n            } else if note_string.equals(\"o\") {\n                return 4l\n            } else if note_string.equals(\"o|\") {\n                return 2l\n            } else {\n                return 1l\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var result = List[Long]()\n            var note_count = 0\n            var note_index = 0\n            for (i <- 0 until music_string.length) {\n                if (music_string[i] == '.') {\n                    note_count = note_count + parseNote(music_string[note_index:i])\n                    note_index = i + 1\n                }\n            }\n            note_count = note_count + parseNote(music_string[note_index:])\n            for (i <- 0 until note_count) {\n                result = result + i\n            }\n            return result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292770,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp465jnlo1.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp465jnlo1.scala:31:79 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                    note_count = note_count + parseNote(music_string[\u001b[35mnote_index\u001b[0m:i])\n\u001b[31m\u001b[31m   |\u001b[0m                                                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             ']' expected, but ':' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp465jnlo1.scala:35:71 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            note_count = note_count + parseNote(music_string[\u001b[35mnote_index\u001b[0m:])\n\u001b[31m\u001b[31m   |\u001b[0m                                                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             ']' expected, but ':' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp465jnlo1.scala:15:33 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\".\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             \u001b[33mmethod\u001b[0m \u001b[35mequals\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp465jnlo1.scala:30:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                \u001b[33mif\u001b[0m (music_string[\u001b[35mi\u001b[0m] == \u001b[31m'.'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp465jnlo1.scala:37:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                result = result + i\n\u001b[31",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var result = mutable.List[Long]()\n        var note_count = mutable.List[String]()\n        var note_duration = mutable.List[Long]()\n        var note_duration_count = mutable.List[Long]()\n        var note_duration_count_sum = mutable.List[Long]()\n        var note_duration_count_sum_sum = mutable.List[Long]()\n        var note_duration_count_sum_sum_sum = mutable.List[Long]()\n        var note_duration_count_sum_sum_sum_sum = mutable.List[Long]()\n        var note_duration_count_sum_sum_sum_sum_sum = mutable.List[Long]()\n        var note_duration_count_sum_sum_sum_sum_sum_sum = mutable.List[Long]()\n        var note_duration_count_sum_sum_sum_sum_sum_sum_sum = mutable.List[Long]()\n        var note_duration_count_sum_sum_sum_sum_sum_sum_sum_sum = mutable.List[Long]()\n        var note_duration_count_sum_sum_sum_sum_sum_sum_sum_sum_sum = mutable.List[Long]()\n        var note_duration_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = mutable.List[Long]()\n        var note_duration_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = mutable.List[Long]()\n        var note_duration_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = mutable.List[Long]()\n        var note_duration_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = mutable.List[Long]()\n        var note_duration_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = mutable.List[Long]()\n        var note_\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292776,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpd1a5vb_r.scala:33:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd1a5vb_r.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd1a5vb_r.scala:15:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mnote_count\u001b[0m = mutable.List[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd1a5vb_r.scala:16:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mnote_duration\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd1a5vb_r.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mnote_duration_count\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd1a5vb_r.scala:18:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mnote_duration_count_sum\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asScalaBuffer(music_string.split(\" \")).toList\n        val result = mutable.List[Long]()\n        for (i <- 0 until music_list.length) {\n            val note = music_list(i)\n            if (note.contains(\"o\")) {\n                result.append(4l)\n            } else if (note.contains(\"o|\")) {\n                result.append(2l)\n            } else if (note.contains(\".|\")) {\n                result.append(1l)\n            } else {\n                result.append(0l)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292768,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3gljlp9b.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(music_string.split(\u001b[31m\" \"\u001b[0m)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3gljlp9b.scala:15:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asScalaBuffer(music_string.split(\" \")).toList\n        val beats = mutable.List[Long]()\n        for (i <- 0 until music_list.size) {\n            val note = music_list.get(i).replaceAll(\"[^o|.|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292777,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp_8jrg91z.scala:17:52 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnote\u001b[0m = music_list.get(i).replaceAll(\"[^o|.|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                 unclosed string literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmp_8jrg91z.scala:19:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 end of statement expected but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_8jrg91z.scala:28:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_8jrg91z.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(music_string.split(\u001b[31m\" \"\u001b[0m)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_8jrg91z.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        val result = new ArrayList[Long]()\n        for (i <- 0 until music_list.size()) {\n            val note = music_list.get(i)\n            if (note.equals(\".\")) {\n                result.add(0l)\n            } else if (note.equals(\"o\")) {\n                result.add(4l)\n            } else if (note.equals(\"o|\")) {\n                result.add(2l)\n            } else {\n                result.add(1l)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292778,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5g8rqquy.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5g8rqquy.scala:15:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArrayList\u001b[0m[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type ArrayList\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var result = mutable.List[Long]()\n        var current_note = \"\"\n        var current_duration = 0\n        var current_beat = 0\n        var current_beat_duration = 0\n        var current_beat_duration_count = 0\n        var current_beat_duration_count_max = 0\n        var current_beat_duration_count_min = 0\n        var current_beat_duration_count_sum = 0\n        var current_beat_duration_count_sum_max = 0\n        var current_beat_duration_count_sum_min = 0\n        var current_beat_duration_count_sum_sum = 0\n        var current_beat_duration_count_sum_sum_max = 0\n        var current_beat_duration_count_sum_sum_min = 0\n        var current_beat_duration_count_sum_sum_sum = 0\n        var current_beat_duration_count_sum_sum_sum_max = 0\n        var current_beat_duration_count_sum_sum_sum_min = 0\n        var current_beat_duration_count_sum_sum_sum_sum = 0\n        var current_beat_duration_count_sum_sum_sum_sum_max = 0\n        var current_beat_duration_count_sum_sum_sum_sum_min = 0\n        var current_beat_duration_count_sum_sum_sum_sum_sum = 0\n        var current_beat_duration_count_sum_sum_sum_sum_sum_max = 0\n        var current_beat_duration_count_sum_sum_sum_sum_sum_min = 0\n        var current_beat_duration_count_sum_sum_sum_sum_sum_sum = 0\n        var current_beat_duration_count_sum_sum_sum_sum_sum_sum_max = 0\n        var current_beat_duration_count_sum_sum_sum_sum_sum_sum_min = 0\n        var current_beat_duration_count_sum_sum_sum_sum_sum_sum_sum = 0\n        var current_beat_duration_count_sum_sum_sum_sum_sum_sum_sum_max = 0\n        var current_beat\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292777,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpo59lx_wo.scala:43:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo59lx_wo.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpo59lx_wo.scala:43:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.contains(\"o\") {\n                return 4L\n            } else if note_string.contains(\"o|\") {\n                return 2L\n            } else if note_string.contains(\".|\") {\n                return 1L\n            } else {\n                return 0L\n            }\n        }\n        def parseBeat(note_string : String) : Long = {\n            if note_string.contains(\".\") {\n                return 1L\n            } else {\n                return 0L\n            }\n        }\n        def parse(note_string : String) : Long = {\n            return note_string.length() * parseNote(note_string) + parseBeat(note_string)\n        }\n        def parseMusic(note_string : String) : List[Long] = {\n            var beat_counts = mutable.List[Long]()\n            for (i <- 0 until note_string.length) {\n                beat_counts = beat_counts.append(parse(note_string.substring(i, i + 1)))\n            }\n            return beat_counts\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292774,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfu5gnr2k.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"o|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfu5gnr2k.scala:28:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfu5gnr2k.scala:15:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mcontains\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfu5gnr2k.scala:26:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\".\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mcontains\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfu5gnr2k.scala:36:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mbeat_counts\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- [E129] Potential Issue Warning: /tmp/tmpfu5gnr2k.scala:24:8 -----------------\u001b[0m\u001b[0m\n\u001b[33m23 |\u001b[0m            }\n\u001b[33m24 |\u001b[0m        }\n\u001b[33m\u001b[33m   |\u001b[0m             ^\u001b[0m\n\u001b[33m   |\u001b[0mA pure expression doe",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.charAt(0) == 'o' {\n                return 4L\n            } else if note_string.charAt(0) == 'o|' {\n                return 2L\n            } else if note_string.charAt(0) == '.' {\n                return 1L\n            } else {\n                return 0L\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var beat_counts = mutable.List[Long]()\n            var current_beat = 0L\n            var current_note = 0L\n            for i in range(0, len(music_string)) {\n                if music_string.charAt(i) == 'o' {\n                    current_note = parseNote(music_string.substring(i, i + 2))\n                    current_beat += current_note\n                } else if music_string.charAt(i) == 'o|' {\n                    current_note = parseNote(music_string.substring(i, i + 2))\n                    current_beat += current_note\n                } else if music_string.charAt(i) == '.' {\n                    current_note = parseNote(music_string.substring(i, i + 1))\n                    current_beat += current_note\n                }\n                beat_counts.append(current_beat)\n                current_beat = 0L\n                current_note = 0L\n            }\n            return beat_counts\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292781,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpt68pckaz.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'o\u001b[0m|' {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpt68pckaz.scala:29:49 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mfor\u001b[0m i in range(\u001b[31m0\u001b[0m, len(music_string)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but '{' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpt68pckaz.scala:15:40 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'o'\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     expression does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt68pckaz.scala:26:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mbeat_counts\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt68pckaz.scala:43:13 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m            }\n\u001b[31m\u001b[31m   |\u001b[0m             ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.equals(\".\") {\n                return 0l\n            } else if note_string.equals(\"o\") {\n                return 4l\n            } else if note_string.equals(\"o|\") {\n                return 2l\n            } else {\n                return 1l\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var result = List[Long]()\n            var note_count = 0\n            var note_index = 0\n            var note_string = \"\"\n            for(i <- 0 until music_string.length) {\n                if(music_string[i] == ' ') {\n                    note_count += parseNote(note_string)\n                    note_string = \"\"\n                    note_index = 0\n                } else {\n                    note_string += music_string[i]\n                    note_index += 1\n                }\n            }\n            note_count += parseNote(note_string)\n            for(i <- 0 until note_count) {\n                result = append(result, note_count - i)\n            }\n            return result\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292780,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpy9o49r6u.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpy9o49r6u.scala:15:33 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\".\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             \u001b[33mmethod\u001b[0m \u001b[35mequals\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy9o49r6u.scala:31:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                \u001b[33mif\u001b[0m(music_string[\u001b[35mi\u001b[0m] == \u001b[31m' '\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy9o49r6u.scala:32:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    note_count += parseNote(note_string)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy9o49r6u.scala:36:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    note_string += music_string[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy9o49r6u.scala:36:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    note_string += music_string[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var notes = List[String]()\n        var beats = List[Long]()\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292779,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp65ojtgdd.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mi\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mi is already defined as \u001b[33mvariable\u001b[0m \u001b[35mi\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp65ojtgdd.scala:43:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mj\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mj is already defined as \u001b[33mvariable\u001b[0m \u001b[35mj\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp65ojtgdd.scala:44:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mk\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mk is already defined as \u001b[33mvariable\u001b[0m \u001b[35mk\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp65ojtgdd.scala:45:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36ml\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0ml is already defined as \u001b[33mvariable\u001b[0m \u001b[35ml\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp65ojtgdd.scala:46:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mm\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mm is already defined as \u001b[33mvariable\u001b[0m \u001b[35mm\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp65ojtgdd.scala:47:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mn\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(note -> {\n            val note_parts = note.split(\"|\")\n            val note_length = note_parts[0].length()\n            val note_beats = note_parts.length - 1\n            return note_length * note_beats\n        }).toList\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292779,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4ihl7ngm.scala:15:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = notes.map(note -> {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: note\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp4ihl7ngm.scala:20:10 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        }).toList\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = music_string.split(\" \")\n        val beats = mutable.List[Long]()\n        for (i <- 0 until music_list.length) {\n            if (music_list[i].equals(\".\")) {\n                beats.append(0l)\n            } else if (music_list[i].equals(\"o\")) {\n                beats.append(4l)\n            } else if (music_list[i].equals(\"o|\")) {\n                beats.append(2l)\n            } else {\n                beats.append(1l)\n            }\n        }\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292776,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3y764_94.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3y764_94.scala:17:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mif\u001b[0m (music_list[\u001b[35mi\u001b[0m].equals(\u001b[31m\".\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3y764_94.scala:19:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_list[i].equals(\u001b[31m\"o\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3y764_94.scala:21:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_list[i].equals(\u001b[31m\"o|\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.contains(\"o\") {\n                return 4l\n            } else if note_string.contains(\"o|\") {\n                return 2l\n            } else if note_string.contains(\".|\") {\n                return 1l\n            } else {\n                return 0l\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var result = mutable.List[Long]()\n            var note_count = 0\n            var note_index = 0\n            for (i <- 0 until music_string.length) {\n                if (music_string[i] == '.') {\n                    note_count += 1\n                    note_index = i\n                } else if (music_string[i] == '|') {\n                    note_count += 1\n                    note_index = i\n                } else if (music_string[i] == 'o') {\n                    note_count += 1\n                    note_index = i\n                } else if (music_string[i] == 'o|') {\n                    note_count += 1\n                    note_index = i\n                } else if (music_string[i] == '.'|') {\n                    note_count += 1\n                    note_index = i\n                } else if (music_string[i] == 'o.') {\n                    note_count += 1\n                    note_index = i\n                } else if (music_string[i] == 'o|.') {\n                    note_count += 1\n                    note_index = i\n                } else if (music_string[i] == 'o|o') {\n                    note_count += 1\n                    note_index = i\n                } else if (music_string[i] == 'o|o|') {\n                    note_count += 1\n                    note_index = i\n                } else if (music_string[i] == 'o|o|.') {\n                    note_count += 1\n                    note_index = i\n                } else if (music_string[i] == 'o|o|o') {\n                    note_count += 1\n                    note_index = i\n\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292780,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpb9ash6ww.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"o|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpb9ash6ww.scala:39:46 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_string[i] == \u001b[31m'o\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0msymbol literal 'o is no longer supported,\n\u001b[31m   |\u001b[0muse a string literal \"o\" or an application Symbol(\"o\") instead,\n\u001b[31m   |\u001b[0mor enclose in braces '{o} if you want a quoted expression.\n\u001b[31m   |\u001b[0mFor now, you can also `import language.deprecated.symbolLiterals` to accept\n\u001b[31m   |\u001b[0mthe idiom, but this possibility might no longer be available in the future.\n\u001b[31m\u001b[31m-- Error: /tmp/tmpb9ash6ww.scala:39:49 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_string[i] == \u001b[31m'o\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              unclosed character literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmpb9ash6ww.scala:42:50 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_string[i] == \u001b[31m'.'\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              unclosed character literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmpb9ash6ww.scala:45:49 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_string[i] == \u001b[31m'o\u001b[0m.') {\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              unclosed character literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmpb9ash6ww.scala:48:50 ----",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string == \"o\" {\n                return 4l\n            } else if note_string == \"o|\" {\n                return 2l\n            } else if note_string == \".|\" {\n                return 1l\n            } else {\n                throw new RuntimeException(\"Invalid note string: \" + note_string)\n            }\n        }\n        def parseDuration(note_string : String) : Long = {\n            if note_string == \"o\" {\n                return 4l\n            } else if note_string == \"o|\" {\n                return 2l\n            } else if note_string == \".|\" {\n                return 1l\n            } else {\n                throw new RuntimeException(\"Invalid note string: \" + note_string)\n            }\n        }\n        def parseBeat(note_string : String) : Long = {\n            if note_string == \"o\" {\n                return 4l\n            } else if note_string == \"o|\" {\n                return 2l\n            } else if note_string == \".|\" {\n                return 1l\n            } else {\n                throw new RuntimeException(\"Invalid note string: \" + note_string)\n            }\n        }\n        def parseMusic(note_string : String) : List[Long] = {\n            def parseNote(note_string : String) : Long = {\n                if note_string == \"o\" {\n                    return 4l\n                } else if note_string == \"o|\" {\n                    return 2l\n                } else if note_string == \".|\" {\n                    return 1l\n                } else {\n                    throw new RuntimeException(\"Invalid note string: \" + note_string)\n                }\n            }\n            def parseDuration(note_string : String) : Long = {\n                if note_string == \"o\" {\n                    return 4l\n                } else if note_string == \"o|\" {\n                    return 2l\n                } else if note_string == \".|\" {\n                    return 1l\n                } else {\n                    throw new RuntimeException(\"Invalid note string: \" + note_string)\n                }\n            }\n            def parseBeat(note_string\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292782,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpj5zxlkeb.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpj5zxlkeb.scala:28:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpj5zxlkeb.scala:39:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpj5zxlkeb.scala:51:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpj5zxlkeb.scala:62:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpj5zxlkeb.scala:71:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ':' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpj5zxlkeb.scala:81:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpj5zxlkeb.scala:15:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m        Valu",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(note => {\n            val note_parts = note.split(\"|\")\n            val note_length = note_parts.length\n            val note_beats = note_length - 1\n            return note_beats\n        })\n        val beats_list = beats.toList\n        return beats_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292780,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp30i6wcko.scala:19:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mreturn\u001b[0m note_beats\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (note_beats : Int)\n\u001b[31m   |\u001b[0m                   Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp30i6wcko.scala:20:10 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        })\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.endsWith(\"|\") {\n                return note_string.substring(0, note_string.length() - 1).toLong\n            } else {\n                return note_string.toLong\n            }\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if beat_string.endsWith(\"|\") {\n                return beat_string.substring(0, beat_string.length() - 1).toLong\n            } else {\n                return beat_string.toLong\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var beat_counts = mutable.List[Long]()\n            var beat_count = 0\n            var note_count = 0\n            var note_count_prev = 0\n            for (i <- 0 until music_string.length) {\n                if (music_string[i] == '.') {\n                    beat_count += parseBeat(music_string[i + 1])\n                    note_count_prev = note_count\n                    note_count = 0\n                } else if (music_string[i] == 'o') {\n                    beat_count += parseBeat(music_string[i + 1])\n                    note_count += parseNote(music_string[i + 1])\n                }\n                beat_counts += beat_count\n                beat_count = 0\n            }\n            beat_counts += beat_count\n            beat_counts += note_count_prev\n            return beat_counts\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292781,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpz2d0g3j1.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpz2d0g3j1.scala:24:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpz2d0g3j1.scala:15:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.endsWith(\u001b[31m\"|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mendsWith\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpz2d0g3j1.scala:22:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m beat_string.endsWith(\u001b[31m\"|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mendsWith\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz2d0g3j1.scala:29:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mbeat_counts\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz2d0g3j1.scala:34:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                \u001b[33mif\u001b[0m (music_string[\u001b[35mi\u001b[0m] == \u001b[31m'.'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m             ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asScalaBuffer(Arrays.asList(music_string.split(\" \")))\n        val result = mutable.ListBuffer[Long]()\n        for (i <- 0 until music_list.length) {\n            val note = music_list.get(i).toLowerCase()\n            if (note.equals(\".\")) {\n                result.append(1l)\n            } else if (note.equals(\"o\")) {\n                result.append(4l)\n            } else if (note.equals(\"o|\")) {\n                result.append(2l)\n            } else {\n                throw new IllegalArgumentException(\"Invalid note: \" + note)\n            }\n        }\n        return result.toList()\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292780,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppiuyfofy.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(Arrays.asList(music_string.split(\u001b[31m\" \"\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppiuyfofy.scala:15:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.replaceAll(\"[^0-9.]\", \"\")).map(_.toLong).toList\n        val result = beats.map(b => b.toLong)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292784,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$3(tmpun5j8ar8.scala:15)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseMusic(tmpun5j8ar8.scala:15)\n\tat Problem$.main(tmpun5j8ar8.scala:20)\n\tat Problem.main(tmpun5j8ar8.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asScalaBuffer(music_string.split(\" \")).toList\n        val beats = scala.collection.mutable.ArrayBuffer.empty()\n        for (i <- 0 until music_list.length) {\n            val note = music_list(i)\n            if (note.equals(\".\")) {\n                beats.append(0l)\n            } else if (note.equals(\"o\")) {\n                beats.append(4l)\n            } else if (note.equals(\"o|\")) {\n                beats.append(2l)\n            } else {\n                throw new IllegalArgumentException(\"Invalid note: \" + note)\n            }\n        }\n        return scala.collection.JavaConversions.asJavaList(beats.toList)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292783,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyy9kxgnu.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(music_string.split(\u001b[31m\" \"\u001b[0m)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- Error: /tmp/tmpyy9kxgnu.scala:15:62 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = scala.collection.mutable.ArrayBuffer.empty()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mArrayBuffer\u001b[0m: (n: Int): A\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyy9kxgnu.scala:28:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mreturn\u001b[0m scala.collection.JavaConversions.asJavaList(beats.toList)\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               value JavaConversions is not a member of collection\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string == \"o\" {\n                return 4L\n            } else if note_string == \"o|\" {\n                return 2L\n            } else if note_string == \".|\" {\n                return 1L\n            } else {\n                throw new IllegalArgumentException(\"Invalid note string: \" + note_string)\n            }\n        }\n        def parseDuration(note_string : String) : Long = {\n            if note_string == \"o\" {\n                return 4L\n            } else if note_string == \"o|\" {\n                return 2L\n            } else if note_string == \".|\" {\n                return 1L\n            } else {\n                throw new IllegalArgumentException(\"Invalid note string: \" + note_string)\n            }\n        }\n        def parseBeat(note_string : String) : Long = {\n            if note_string == \"o\" {\n                return 4L\n            } else if note_string == \"o|\" {\n                return 2L\n            } else if note_string == \".|\" {\n                return 1L\n            } else {\n                throw new IllegalArgumentException(\"Invalid note string: \" + note_string)\n            }\n        }\n        def parseMusic(note_string : String) : List[Long] = {\n            if note_string == \"o\" {\n                return List(4L)\n            } else if note_string == \"o|\" {\n                return List(2L)\n            } else if note_string == \".|\" {\n                return List(1L)\n            } else {\n                throw new IllegalArgumentException(\"Invalid note string: \" + note_string)\n            }\n        }\n        def parseMusic(note_string : String) : List[Long] = {\n            if note_string == \"o\" {\n                return List(4L)\n            } else if note_string == \"o|\" {\n                return List(2L)\n            } else if note_string == \".|\" {\n                return List(1L)\n            } else {\n                throw new IllegalArgumentException(\"Invalid note string: \" + note_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292781,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpnwhpzeqr.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpnwhpzeqr.scala:28:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpnwhpzeqr.scala:39:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpnwhpzeqr.scala:50:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpnwhpzeqr.scala:61:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpnwhpzeqr.scala:77:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpnwhpzeqr.scala:15:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m16 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31m4L\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m-- ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.endsWith(\"|\") {\n                return note_string.substring(0, note_string.length() - 1).toLong\n            } else {\n                return note_string.toLong\n            }\n        }\n        def parseDuration(note_string : String) : Long = {\n            if note_string.endsWith(\"|\") {\n                return note_string.substring(0, note_string.length() - 1).toLong\n            } else {\n                return note_string.toLong\n            }\n        }\n        def parseBeat(note_string : String) : Long = {\n            if note_string.endsWith(\"|\") {\n                return note_string.substring(0, note_string.length() - 1).toLong\n            } else {\n                return note_string.toLong\n            }\n        }\n        def parseMusic(note_string : String) : List[Long] = {\n            var beat_count = 0\n            var note_count = 0\n            var note_duration = 0\n            var note_beat = 0\n            var note_note = 0\n            var note_index = 0\n            var note_list = []\n            for (i <- 0 until note_string.length) {\n                if note_string[i] == '.' {\n                    note_duration = parseDuration(note_string[note_index:i])\n                    note_index = i + 1\n                } else if note_string[i] == 'o' {\n                    note_note = parseNote(note_string[note_index:i])\n                    note_index = i + 1\n                    note_beat = parseBeat(note_string[note_index:i])\n                    note_index = i + 1\n                    note_count += 1\n                    note_list.append(note_note * note_duration * note_beat)\n                }\n            }\n            note_count += 1\n            note_list.append(note_note * note_duration * note_beat)\n            return note_list\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292782,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpxabxt3g3.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpxabxt3g3.scala:24:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpxabxt3g3.scala:31:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpxabxt3g3.scala:42:29 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mnote_list\u001b[0m = []\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             an identifier expected, but ']' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpxabxt3g3.scala:43:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until note_string.length) {\n\u001b[31m\u001b[31m   |\u001b[0m^^^\u001b[0m\n\u001b[31m   |\u001b[0m'=>' expected, but 'end of statement' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpxabxt3g3.scala:45:72 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m                    note_duration = parseDuration(note_string[\u001b[35mnote_index\u001b[0m:i])\n\u001b[31m\u001b[31m   |\u001b[0m                                                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             ']' expected, but ':' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpxabxt3g3.scala:47:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string[i] == \u001b[31m'o'\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpxabxt3g3.scala:15:35 -----------------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if (note_string.charAt(0) == 'o') {\n                return 4l\n            } else if (note_string.charAt(0) == 'o|') {\n                return 2l\n            } else if (note_string.charAt(0) == '.') {\n                return 1l\n            } else {\n                return 0l\n            }\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if (beat_string.charAt(0) == 'o') {\n                return 4l\n            } else if (beat_string.charAt(0) == 'o|') {\n                return 2l\n            } else if (beat_string.charAt(0) == '.') {\n                return 1l\n            } else {\n                return 0l\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var beat_counts = mutable.List[Long]()\n            var note_counts = mutable.List[Long]()\n            var beat_index = 0\n            var note_index = 0\n            var beat_count = 0\n            var note_count = 0\n            for (i <- 0 until music_string.length) {\n                if (music_string.charAt(i) == 'o') {\n                    note_counts.append(note_count)\n                    note_count = 0\n                    note_index = i\n                } else if (music_string.charAt(i) == 'o|') {\n                    note_counts.append(note_count)\n                    note_count = 0\n                    note_index = i\n                } else if (music_string.charAt(i) == '.') {\n                    note_counts.append(note_count)\n                    note_count = 0\n                    note_index = i\n                } else if (music_string.charAt(i) == '|') {\n                    beat_counts.append(beat_count)\n                    beat_count = 0\n                    beat_index = i\n                } else {\n                    beat_count += parseBeat(music_\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292782,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpxiq_psh6.scala:17:48 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (note_string.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'o\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0msymbol literal 'o is no longer supported,\n\u001b[31m   |\u001b[0muse a string literal \"o\" or an application Symbol(\"o\") instead,\n\u001b[31m   |\u001b[0mor enclose in braces '{o} if you want a quoted expression.\n\u001b[31m   |\u001b[0mFor now, you can also `import language.deprecated.symbolLiterals` to accept\n\u001b[31m   |\u001b[0mthe idiom, but this possibility might no longer be available in the future.\n\u001b[31m\u001b[31m-- Error: /tmp/tmpxiq_psh6.scala:17:51 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (note_string.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'o\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              unclosed character literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmpxiq_psh6.scala:28:48 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (beat_string.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'o\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0msymbol literal 'o is no longer supported,\n\u001b[31m   |\u001b[0muse a string literal \"o\" or an application Symbol(\"o\") instead,\n\u001b[31m   |\u001b[0mor enclose in braces '{o} if you want a quoted expression.\n\u001b[31m   |\u001b[0mFor now, you can also `import language.deprecated.symbolLiterals` to accept\n\u001b[31m   |\u001b[0mthe idiom, but this possibility might no longer be available in the future.\n\u001b[31m\u001b[31m-- Error: /tmp/tmpxiq_psh6.scala:28:51 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (beat_string.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'o\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              unclosed character literal\n\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string == \"o\" {\n                return 4l\n            } else if note_string == \"o|\" {\n                return 2l\n            } else if note_string == \".|\" {\n                return 1l\n            } else {\n                throw new RuntimeException(\"Invalid note string: \" + note_string)\n            }\n        }\n        def parseDuration(note_string : String) : Long = {\n            if note_string == \"o\" {\n                return 4l\n            } else if note_string == \"o|\" {\n                return 2l\n            } else if note_string == \".|\" {\n                return 1l\n            } else {\n                throw new RuntimeException(\"Invalid note string: \" + note_string)\n            }\n        }\n        def parseMusic(note_string : String) : List[Long] = {\n            def parseNote(note_string : String) : Long = {\n                if note_string == \"o\" {\n                    return 4l\n                } else if note_string == \"o|\" {\n                    return 2l\n                } else if note_string == \".|\" {\n                    return 1l\n                } else {\n                    throw new RuntimeException(\"Invalid note string: \" + note_string)\n                }\n            }\n            def parseDuration(note_string : String) : Long = {\n                if note_string == \"o\" {\n                    return 4l\n                } else if note_string == \"o|\" {\n                    return 2l\n                } else if note_string == \".|\" {\n                    return 1l\n                } else {\n                    throw new RuntimeException(\"Invalid note string: \" + note_string)\n                }\n            }\n            def parseMusic(note_string : String) : List[Long] = {\n                def parseNote(note_string : String) : Long = {\n                    if note_string == \"o\" {\n                        return 4l\n                    } else if note_string == \"o|\" {\n                        return 2l\n                    } else if note_string == \".|\" {\n                        return 1l\n                    } else {\n                        throw new RuntimeException(\"Invalid note string: \" +\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292783,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmps6ubm0h9.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmps6ubm0h9.scala:28:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmps6ubm0h9.scala:40:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmps6ubm0h9.scala:51:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmps6ubm0h9.scala:63:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m                    } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmps6ubm0h9.scala:79:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- Error: /tmp/tmps6ubm0h9.scala:15:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m16 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31m4l\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string == \".\" {\n                return 0l\n            } else if note_string == \"o\" {\n                return 4l\n            } else if note_string == \"o|\" {\n                return 2l\n            } else {\n                return 1l\n            }\n        }\n        def parseDuration(duration_string : String) : Long = {\n            if duration_string == \".\" {\n                return 0l\n            } else if duration_string == \"o\" {\n                return 4l\n            } else if duration_string == \"o|\" {\n                return 2l\n            } else {\n                return 1l\n            }\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if beat_string == \".\" {\n                return 0l\n            } else if beat_string == \"o\" {\n                return 4l\n            } else if beat_string == \"o|\" {\n                return 2l\n            } else {\n                return 1l\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var beat_counts = mutable.List[Long]()\n            var note_counts = mutable.List[Long]()\n            var beat_count = 0l\n            var note_count = 0l\n            for i in range(0, len(music_string)) {\n                var note = music_string[i]\n                var duration = parseDuration(music_string[i + 1])\n                var beat = parseBeat(music_string[i + 2])\n                if note == \".\" {\n                    note_count += 1\n                } else if note == \"o\" {\n                    note_count += 1\n                    beat_count += 1\n                } else if note == \"o|\" {\n                    note_count += 1\n                    beat_count += 1\n                } else {\n                    note_count += 1\n                }\n                beat_counts += beat\n                note_counts += note_count\n            }\n            return beat_counts\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292785,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpxqa2no9z.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpxqa2no9z.scala:28:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m duration_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpxqa2no9z.scala:39:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m beat_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpxqa2no9z.scala:52:49 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m            \u001b[33mfor\u001b[0m i in range(\u001b[31m0\u001b[0m, len(music_string)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but '{' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpxqa2no9z.scala:15:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string == \u001b[31m\".\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m16 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31m0l\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m-- Error: /tmp/tmpxqa2no9z.scala:26:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m duration_string == \u001b[31m\".\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m27 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31m0l\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m duration_string ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var result = mutable.List[Long]()\n        var current_note = mutable.List[String]()\n        var current_duration = mutable.List[Long]()\n        var current_duration_count = mutable.List[Long]()\n        var current_duration_count_count = mutable.List[Long]()\n        var current_duration_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292782,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5efqvz3p.scala:33:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5efqvz3p.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5efqvz3p.scala:15:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_note\u001b[0m = mutable.List[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5efqvz3p.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5efqvz3p.scala:17:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration_count\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5efqvz3p.scala:18:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration_count_count\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.equals(\".\") {\n                return 0l\n            } else if note_string.equals(\"o\") {\n                return 4l\n            } else if note_string.equals(\"o|\") {\n                return 2l\n            } else {\n                return 1l\n            }\n        }\n        def parseMusic(note_list : List[String]) : List[Long] = {\n            var result = List[Long]()\n            for (note_string <- note_list) {\n                result = result.append(parseNote(note_string))\n            }\n            return result\n        }\n        return parseMusic(music_string.split(\" \"))\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292788,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmprgd4pxa3.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmprgd4pxa3.scala:15:33 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\".\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             \u001b[33mmethod\u001b[0m \u001b[35mequals\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprgd4pxa3.scala:28:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                result = result.append(parseNote(note_string))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprgd4pxa3.scala:32:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mreturn\u001b[0m parseMusic(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    \u001b[1m\u001b[31mArray\u001b[0m[String]\n\u001b[31m   |\u001b[0m                          Required: \u001b[1m\u001b[32mList\u001b[0m[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- [E129] Potential Issue Warning: /tmp/tmprgd4pxa3.scala:24:8 -----------------\u001b[0m\u001b[0m\n\u001b[33m23 |\u001b[0m            }\n\u001b[33m24 |\u001b[0m        }\n\u001b[33m\u001b[33m   |\u001b[0m             ^\u001b[0m\n\u001b[33m   |\u001b[0mA pure expression does nothing in statement position; you may be omitting necessary parentheses\n\u001b[33m   |\u001b[0m\n\u001b[33m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 warning found\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.length() == 1 {\n                return 1l\n            } else if note_string.length() == 2 {\n                return 2l\n            } else if note_string.length() == 3 {\n                return 4l\n            } else {\n                throw new RuntimeException(\"Invalid note string: \" + note_string)\n            }\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if beat_string.length() == 1 {\n                return 1l\n            } else if beat_string.length() == 2 {\n                return 2l\n            } else if beat_string.length() == 3 {\n                return 4l\n            } else {\n                throw new RuntimeException(\"Invalid beat string: \" + beat_string)\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var result = List[Long]()\n            var current_beat = 1l\n            var current_note = 1l\n            var current_note_string = \"\"\n            var current_beat_string = \"\"\n            for (i <- 0 until music_string.length) {\n                if (music_string[i] == '.') {\n                    current_note_string += music_string[i]\n                    current_note = parseNote(current_note_string)\n                    current_note_string = \"\"\n                } else if (music_string[i] == '|') {\n                    current_beat_string += music_string[i]\n                    current_beat = parseBeat(current_beat_string)\n                    current_beat_string = \"\"\n                } else {\n                    current_note_string += music_string[i]\n                }\n                if (i == music_string.length - 1) {\n                    result = append(result, current_note * current_beat)\n                }\n            }\n            return result\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292790,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpnfmwgkuz.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.length() == \u001b[31m2\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpnfmwgkuz.scala:28:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m beat_string.length() == \u001b[31m2\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpnfmwgkuz.scala:15:39 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.length() == \u001b[31m1\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     expression does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpnfmwgkuz.scala:26:39 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m beat_string.length() == \u001b[31m1\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     expression does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnfmwgkuz.scala:43:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m                \u001b[33mif\u001b[0m (music_string[\u001b[35mi\u001b[0m] == \u001b[31m'.'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnfmwgkuz.scala:44:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m                    current_note_string += music_string[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.contains(\".\") {\n                def parseQuater(note_string : String) : Long = {\n                    if note_string.contains(\"|\") {\n                        return 1l\n                    } else {\n                        return 0l\n                    }\n                }\n                return 4l * parseQuater(note_string)\n            } else if note_string.contains(\"|\") {\n                return 2l\n            } else {\n                return 1l\n            }\n        }\n        return List(0l).map(i => parseNote(music_string.substring(i, i + 1)))\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292789,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_trv2ssg.scala:19:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                    } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_trv2ssg.scala:24:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp_trv2ssg.scala:15:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\".\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mcontains\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp_trv2ssg.scala:17:43 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                    \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mcontains\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_trv2ssg.scala:30:66 --------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mreturn\u001b[0m List(\u001b[31m0l\u001b[0m).map(\u001b[36mi\u001b[0m => parseNote(music_string.substring(i, i + \u001b[31m1\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (i : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m--",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        val beats = mutable.List[Long]()\n        for (i <- 0 until music_list.length) {\n            val note = music_list[i]\n            if (note.equals(\".\")) {\n                beats.append(1l)\n            } else if (note.equals(\"o\")) {\n                beats.append(4l)\n            } else if (note.equals(\"o|\")) {\n                beats.append(2l)\n            } else {\n                throw new IllegalArgumentException(\"Invalid note: \" + note)\n            }\n        }\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292789,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_prr8iq2.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_prr8iq2.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_prr8iq2.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnote\u001b[0m = music_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.toLong).toList\n        val result = beats.map(b -> b / 4).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292787,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbm4b6xil.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = beats.map(b -> b / \u001b[31m4\u001b[0m).toList\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: b\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long {\n            if note_string.length() == 0 {\n                return 0l\n            }\n            if note_string.charAt(0) == 'o' {\n                return 4l\n            }\n            if note_string.charAt(0) == 'o' {\n                return 2l\n            }\n            if note_string.charAt(0) == '.' {\n                return 1l\n            }\n            return 0l\n        }\n        def parseBeat(beat_string : String) : Long {\n            if beat_string.length() == 0 {\n                return 0l\n            }\n            if beat_string.charAt(0) == 'o' {\n                return 4l\n            }\n            if beat_string.charAt(0) == 'o' {\n                return 2l\n            }\n            if beat_string.charAt(0) == '.' {\n                return 1l\n            }\n            return 0l\n        }\n        def parseMusic(music_string : String) : List[Long] {\n            var result = mutable.List[Long]()\n            var beat_count = 0l\n            var note_count = 0l\n            for (i <- 0 until music_string.length) {\n                if music_string.charAt(i) == '.' {\n                    beat_count += parseBeat(music_string.substring(i + 1, i + 2))\n                    note_count += parseNote(music_string.substring(i + 1, i + 2))\n                    i += 2\n                } else if music_string.charAt(i) == '|' {\n                    beat_count += parseBeat(music_string.substring(i + 1, i + 2))\n                    note_count += parseNote(music_string.substring(i + 1, i + 2))\n                    i += 2\n                } else {\n                    beat_count += parseBeat(music_string.substring(i, i + 1))\n                    note_count += parseNote(music_string.substring(i, i + 1))\n                    i += 1\n                }\n                result += note_count * beat_count\n                note_count =\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292789,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E103] Syntax Error: /tmp/tmp822odik2.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.length() == \u001b[31m0\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^\u001b[0m\n\u001b[31m   |\u001b[0mIllegal start of declaration (possible cause: missing `=` in front of current method body)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E103] Syntax Error: /tmp/tmp822odik2.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mif\u001b[0m note_string.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'o'\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^\u001b[0m\n\u001b[31m   |\u001b[0mIllegal start of declaration (possible cause: missing `=` in front of current method body)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E103] Syntax Error: /tmp/tmp822odik2.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mif\u001b[0m note_string.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'o'\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^\u001b[0m\n\u001b[31m   |\u001b[0mIllegal start of declaration (possible cause: missing `=` in front of current method body)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E103] Syntax Error: /tmp/tmp822odik2.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m note_string.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'.'\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^\u001b[0m\n\u001b[31m   |\u001b[0mIllegal start of declaration (possible cause: missing `=` in front of current method body)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E103] Syntax Error: /tmp/tmp822odik2.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mreturn\u001b[0m \u001b[31m0l\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mIllegal start of declaration (possible cause: missing `=` in front of current method body)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E103]",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var result = mutable.List[Long]()\n        var current_note = mutable.StringBuilder()\n        var current_duration = mutable.StringBuilder()\n        var current_duration_count = mutable.StringBuilder()\n        var current_duration_count_count = mutable.StringBuilder()\n        var current_duration_count_count_count = mutable.StringBuilder()\n        var current_duration_count_count_count_count = mutable.StringBuilder()\n        var current_duration_count_count_count_count_count = mutable.StringBuilder()\n        var current_duration_count_count_count_count_count_count = mutable.StringBuilder()\n        var current_duration_count_count_count_count_count_count_count = mutable.StringBuilder()\n        var current_duration_count_count_count_count_count_count_count_count = mutable.StringBuilder()\n        var current_duration_count_count_count_count_count_count_count_count_count = mutable.StringBuilder()\n        var current_duration_count_count_count_count_count_count_count_count_count_count = mutable.StringBuilder()\n        var current_duration_count_count_count_count_count_count_count_count_count_count_count = mutable.StringBuilder()\n        var current_duration_count_count_count_count_count_count_count_count_count_count_count_count = mutable.StringBuilder()\n        var current_duration_count_count_count_count_count_count_count_count_count_count_count_count_count = mutable.StringBuilder()\n        var current_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count = mutable.StringBuilder()\n        var current_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count = mutable.StringBuilder()\n        var current_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count =\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292791,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpe8i0ok3f.scala:32:126 --------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count\u001b[0m =\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe8i0ok3f.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe8i0ok3f.scala:15:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_note\u001b[0m = mutable.StringBuilder()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe8i0ok3f.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration\u001b[0m = mutable.StringBuilder()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe8i0ok3f.scala:17:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration_count\u001b[0m = mutable.StringBuilder()\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = List[String]()\n        val music_string_list = List[String](music_string.split(\" \"))\n        for (i <- 0 until music_string_list.length) {\n            val note = music_string_list[i]\n            if (note.equals(\".\")) {\n                music_list = append(music_list, 0l)\n            } else if (note.equals(\"o\")) {\n                music_list = append(music_list, 4l)\n            } else if (note.equals(\"o|\")) {\n                music_list = append(music_list, 2l)\n            } else {\n                music_list = append(music_list, 1l)\n            }\n        }\n        return music_list.map(x -> x.toLong).toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292791,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptqiql5im.scala:15:63 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_string_list\u001b[0m = List[\u001b[35mString\u001b[0m](music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                             Found:    \u001b[1m\u001b[31mArray\u001b[0m\u001b[1m\u001b[31m[\u001b[0mString\u001b[1m\u001b[31m]\u001b[0m\n\u001b[31m   |\u001b[0m                                             Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptqiql5im.scala:17:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnote\u001b[0m = music_string_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptqiql5im.scala:19:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                music_list = append(music_list, \u001b[31m0l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: append\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptqiql5im.scala:21:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                music_list = append(music_list, \u001b[31m4l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: append\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptqiql5im.scala:23:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                music_list = append(music_list, \u001b[31m2l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: appen",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        val beats = mutable.List[Long]()\n        for (i <- 0 until music_list.length) {\n            val note = music_list[i]\n            if (note.equals(\".\")) {\n                beats.append(0l)\n            } else if (note.equals(\"o\")) {\n                beats.append(4l)\n            } else if (note.equals(\"o|\")) {\n                beats.append(2l)\n            } else {\n                throw new IllegalArgumentException(\"Invalid note: \" + note)\n            }\n        }\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkntxb22r.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkntxb22r.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkntxb22r.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnote\u001b[0m = music_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(note -> {\n            val note_string = note.replaceAll(\"[^o|.]\", \"\")\n            val note_count = note_string.split(\"\").length\n            return note_count\n        })\n        val beats_list = beats.toList\n        val beats_list_length = beats_list.length\n        val beats_list_last = beats_list.last\n        val beats_list_last_value = beats_list_last.get\n        val beats_list_last_value_as_long = beats_list_last_value.toLong\n        val beats_list_length_as_long = beats_list_length.toLong\n        val beats_list_last_as_long = beats_list_last_value_as_long\n        val beats_list_last_as_long_as_long = beats_list_last_as_long.toLong\n        val beats_list_last_as_long_as_long_as_long = beats_list_last_as_long_as_long.toLong\n        val beats_list_last_as_long_as_long_as_long_as_long = beats_list_last_as_long_as_long_as_long.toLong\n        val beats_list_last_as_long_as_long_as_long_as_long_as_long = beats_list_last_as_long_as_long_as_long_as_long.toLong\n        val beats_list_last_as_long_as_long_as_long_as_long_as_long_as_long = beats_list_last_as_long_as_long_as_long_as_long_as_long.toLong\n        val beats_list_last_as_long_as_long_as_long_as_long_as_long_as_long_as_long = beats_list_last_as_long_as_long_as_long_as_long_as_long_as_long.toLong\n        val beats_list_last_as_long_as_long_as_long_as_\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpl3sx_qtr.scala:34:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl3sx_qtr.scala:15:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = notes.map(note -> {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: note\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpl3sx_qtr.scala:19:10 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        })\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          where:    B is a type variable\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl3sx_qtr.scala:34:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.replaceAll(\"[^0-9.]\", \"\")).map(_.toLong).toList\n        val result = beats.map(b -> b.toLong).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292790,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpussqtf_7.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = beats.map(b -> b.toLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: b\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.equals(\".\") {\n                return 0l\n            } else if note_string.equals(\"o\") {\n                return 4l\n            } else if note_string.equals(\"o|\") {\n                return 2l\n            } else {\n                return 1l\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            def parseNote(note_string : String) : Long = {\n                if note_string.equals(\".\") {\n                    return 0l\n                } else if note_string.equals(\"o\") {\n                    return 4l\n                } else if note_string.equals(\"o|\") {\n                    return 2l\n                } else {\n                    return 1l\n                }\n            }\n            def parseMusic(music_string : String) : List[Long] = {\n                def parseNote(note_string : String) : Long = {\n                    if note_string.equals(\".\") {\n                        return 0l\n                    } else if note_string.equals(\"o\") {\n                        return 4l\n                    } else if note_string.equals(\"o|\") {\n                        return 2l\n                    } else {\n                        return 1l\n                    }\n                }\n                def parseMusic(music_string : String) : List[Long] = {\n                    def parseNote(note_string : String) : Long = {\n                        if note_string.equals(\".\") {\n                            return 0l\n                        } else if note_string.equals(\"o\") {\n                            return 4l\n                        } else if note_string.equals(\"o|\") {\n                            return 2l\n                        } else {\n                            return 1l\n                        }\n                    }\n                    def parseMusic(music_string : String) : List[Long] = {\n                        def parseNote(note_string : String) : Long = {\n                            if note_string.equals(\".\") {\n                                return 0l\n                            } else if note_string.equals(\"o\") {\n                                return 4l\n                            } else if note_string.equals(\"o|\") {\n                                return 2l\n                            }\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292794,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpsyhl852n.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpsyhl852n.scala:29:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpsyhl852n.scala:41:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m                    } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpsyhl852n.scala:53:26 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m                        } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpsyhl852n.scala:65:30 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m65 |\u001b[0m                            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpsyhl852n.scala:80:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpsyhl852n.scala:15:33 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\".\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             \u001b[33mmethod\u001b[0m \u001b[35mequals\u001b[0m in \u001b[33mclass\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.replaceAll(\"[^0-9.]\", \"\"))\n        val beats_list = beats.map(_.toLong).toList\n        return beats_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292795,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$3(tmpvfwnqud3.scala:16)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseMusic(tmpvfwnqud3.scala:16)\n\tat Problem$.main(tmpvfwnqud3.scala:20)\n\tat Problem.main(tmpvfwnqud3.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.replaceAll(\"[^0-9.]\", \"\"))\n        val beats_list = beats.map(Long.parseLong).toList\n        return beats_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292794,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptkx6fze5.scala:16:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats_list\u001b[0m = beats.map(Long.parseLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value parseLong is not a member of object Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmptkx6fze5.scala:16:50 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats_list\u001b[0m = beats.map(Long.parseLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        val result = mutable.List[Long]()\n        for (i <- 0 until music_list.size()) {\n            val note = music_list.get(i)\n            if (note.equals(\".\")) {\n                result.append(1l)\n            } else if (note.equals(\"|\")) {\n                result.append(2l)\n            } else if (note.equals(\"o\")) {\n                result.append(4l)\n            } else if (note.equals(\"o|\")) {\n                result.append(2l)\n            } else {\n                result.append(0l)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprxrdo895.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprxrdo895.scala:15:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string == \".\" {\n                return 0l\n            } else if note_string == \"o\" {\n                return 4l\n            } else if note_string == \"o|\" {\n                return 2l\n            } else {\n                return 1l\n            }\n        }\n        def parseDuration(note_string : String) : Long = {\n            if note_string == \"o\" {\n                return 4l\n            } else if note_string == \"o|\" {\n                return 2l\n            } else if note_string == \".|\" {\n                return 1l\n            } else {\n                return 0l\n            }\n        }\n        def parseBeat(note_string : String) : Long = {\n            if note_string == \"o\" {\n                return 4l\n            } else if note_string == \"o|\" {\n                return 2l\n            } else if note_string == \".|\" {\n                return 1l\n            } else {\n                return 0l\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var result = List[Long]()\n            var current_note = \"\"\n            var current_duration = 0l\n            var current_beat = 0l\n            for i in range(0, len(music_string)) {\n                if music_string[i] == \"o\" {\n                    current_note = current_note + \"o\"\n                    current_duration = current_duration + parseDuration(current_note)\n                    current_beat = current_beat + parseBeat(current_note)\n                    current_note = \"\"\n                } else if music_string[i] == \"o|\" {\n                    current_note = current_note + \"o|\"\n                    current_duration = current_duration + parseDuration(current_note)\n                    current_beat = current_beat + parseBeat(current_note)\n                    current_note = \"\"\n                } else if music_string[i] == \".|\" {\n                    current_note = current_note + \".|\"\n                    current_duration = current_duration + parseDuration(current_note)\n                    \n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292795,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmppagb2vq0.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmppagb2vq0.scala:28:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmppagb2vq0.scala:39:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmppagb2vq0.scala:52:49 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m            \u001b[33mfor\u001b[0m i in range(\u001b[31m0\u001b[0m, len(music_string)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but '{' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmppagb2vq0.scala:15:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string == \u001b[31m\".\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m16 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31m0l\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m-- Error: /tmp/tmppagb2vq0.scala:26:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m note_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m27 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31m4l\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.length() == 1 {\n                return note_string.charAt(0) - '0'\n            } else if note_string.length() == 2 {\n                return note_string.charAt(0) - '0' + (note_string.charAt(1) - '0') * 2\n            } else {\n                return note_string.charAt(0) - '0' + (note_string.charAt(1) - '0') * 2 + (note_string.charAt(2) - '0') * 4\n            }\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if beat_string.length() == 1 {\n                return beat_string.charAt(0) - '0'\n            } else if beat_string.length() == 2 {\n                return beat_string.charAt(0) - '0' + (beat_string.charAt(1) - '0') * 2\n            } else {\n                return beat_string.charAt(0) - '0' + (beat_string.charAt(1) - '0') * 2 + (beat_string.charAt(2) - '0') * 4\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var result = List[Long]()\n            var current_beat = 0\n            var current_note = 0\n            var current_note_string = \"\"\n            var current_note_string_length = 0\n            var current_note_string_index = 0\n            for (i <- 0 until music_string.length) {\n                if (music_string.charAt(i) == ' ') {\n                    current_note_string_length = current_note_string_length + 1\n                    if (current_note_string_length == 1) {\n                        current_note_string_index = i + 1\n                    } else if (current_note_string_length == 2) {\n                        current_note_string_index = i + 1\n                        current_note_string = current_note_string + \" \"\n                    } else\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292795,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpjdhtf537.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.length() == \u001b[31m2\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpjdhtf537.scala:26:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m beat_string.length() == \u001b[31m2\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpjdhtf537.scala:47:26 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m                    } \u001b[33melse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpjdhtf537.scala:58:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjdhtf537.scala:15:39 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.length() == \u001b[31m1\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     expression does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjdhtf537.scala:24:39 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m beat_string.length() == \u001b[31m1\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     expression does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjdhtf537.scala:57:1 ---------------------\u001b[0m\u001b[0m\n\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string == \".\" {\n                return 0l\n            } else if note_string == \"o\" {\n                return 4l\n            } else if note_string == \"o|\" {\n                return 2l\n            } else {\n                return 1l\n            }\n        }\n        def parseMusic(note_list : List[String]) : List[Long] = {\n            if note_list == nil {\n                return nil\n            } else {\n                return note_list.map(parseNote).toList\n            }\n        }\n        return parseMusic(music_string.split(\" \"))\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292795,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpmnmzrnlb.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpmnmzrnlb.scala:28:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpmnmzrnlb.scala:15:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string == \u001b[31m\".\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m16 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31m0l\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmnmzrnlb.scala:26:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m note_list == nil {\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: nil\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmnmzrnlb.scala:27:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                \u001b[33mreturn\u001b[0m nil\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: nil\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmnmzrnlb.scala:32:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mreturn\u001b[0m parseMusic(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    \u001b[1m\u001b[31mArray\u001b[0m[String]\n\u001b[31m   |\u001b[0m                          Required: \u001b[1m\u001b[32mList\u001b[0m[Stri",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asScalaBuffer(Arrays.asList(music_string.split(\" \")))\n        val music_seq = scala.collection.mutable.Seq.apply(music_list.size())\n        for (i <- 0 until music_list.size()) {\n            val note = music_list.apply(i)\n            if (note.contains(\"o\")) {\n                val note_list = note.split(\"o\")\n                val note_seq = scala.collection.mutable.Seq.apply(note_list.length())\n                for (j <- 0 until note_list.length()) {\n                    val note_part = note_list.apply(j)\n                    if (note_part.contains(\"|\")) {\n                        val note_part_list = note_part.split(\"|\")\n                        val note_part_seq = scala.collection.mutable.Seq.apply(note_part_list.length())\n                        for (k <- 0 until note_part_list.length()) {\n                            val note_part_part = note_part_list.apply(k)\n                            if (note_part_part.contains(\".\")) {\n                                val note_part_part_list = note_part_part.split(\".\")\n                                val note_part_part_seq = scala.collection.mutable.Seq.apply(note_part_part_list.length())\n                                for (l <- 0 until note_part_part_list.length()) {\n                                    val note_part_part_part = note_part_part_list.apply(l)\n                                    note_part_part_seq.apply(l) = note_part_part_part.toLong\n                                }\n                                note_part_seq.apply(k) = note_part_part_seq\n                            } else {\n                                note_part_seq.apply(k) = note_part_part.toLong\n                            }\n                        }\n                        note_seq.apply(j) = note_part_seq\n                    } else {\n                        note_seq.apply(j) = note_part.toLong\n                    }\n                }\n                music_seq.\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292796,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp2cjv6t91.scala:46:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp2cjv6t91.scala:56:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2cjv6t91.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(Arrays.asList(music_string.split(\u001b[31m\" \"\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2cjv6t91.scala:33:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                                    note_part_part_seq.apply(l) = note_part_part_part.toLong\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value update is not a member of Int => Nothing\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2cjv6t91.scala:35:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                                note_part_seq.apply(k) = note_part_part_seq\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value update is not a member of Int => Nothing\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2cjv6t91.scala:37:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                                note_part_seq.apply(k) = note_part_part.toLong\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value update is not a member of Int => Nothing\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2cjv6t91.scala:40:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                        note_seq.apply(j) = note_part_seq\n\u001b[31m\u001b[31",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(note => {\n            val note_parts = note.split(\"|\")\n            val note_len = note_parts.length\n            val note_len_str = note_len.toString()\n            val note_len_int = note_len_str.replace(\"1\", \"\").replace(\"2\", \"\").replace(\"3\", \"\").replace(\"4\", \"\").replace(\"5\", \"\").replace(\"6\", \"\").replace(\"7\", \"\").replace(\"8\", \"\").replace(\"9\", \"\").replace(\"10\", \"\").replace(\"11\", \"\").replace(\"12\", \"\").replace(\"13\", \"\").replace(\"14\", \"\").replace(\"15\", \"\").replace(\"16\", \"\").replace(\"17\", \"\").replace(\"18\", \"\").replace(\"19\", \"\").replace(\"20\", \"\").replace(\"21\", \"\").replace(\"22\", \"\").replace(\"23\", \"\").replace(\"24\", \"\").replace(\"25\", \"\").replace(\"26\", \"\").replace(\"27\", \"\").replace(\"28\", \"\").replace(\"29\", \"\").replace(\"30\", \"\").replace(\"31\", \"\").replace(\"32\", \"\").replace(\"33\", \"\").replace(\"34\", \"\").replace(\"35\", \"\").replace(\"36\", \"\").replace(\"37\", \"\").replace(\"38\", \"\").replace(\"39\", \"\").replace(\"40\", \"\").replace(\"41\", \"\").replace(\"42\", \"\").replace(\"43\", \"\").replace(\"44\", \"\").replace(\"45\", \"\").replace(\"46\", \"\").replace(\"47\", \"\").replace(\"48\", \"\").replace(\"49\", \"\").replace(\"50\", \"\").replace(\"51\", \"\").replace(\"52\", \"\").replace(\"53\", \"\").replace(\"54\", \"\").replace(\"55\", \"\").replace(\"56\", \"\").replace(\"57\", \"\").replace(\"58\", \"\").replace(\"59\", \"\").replace(\"60\", \"\").replace(\"61\", \"\").replace(\"62\", \"\").replace(\"63\", \"\").replace(\"64\", \"\").replace(\"65\", \"\").replace(\"66\", \"\").replace(\"67\", \"\").replace(\"68\", \"\").replace(\"69\", \"\").replace(\"70\", \"\").replace(\"71\", \"\").replace(\"72\", \"\").\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292795,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpi4w0yyh2.scala:20:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpi4w0yyh2.scala:21:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m    ^^^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but 'def' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpi4w0yyh2.scala:30:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpi4w0yyh2.scala:29:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).filter(_.nonEmpty).map(_.toLong).toList\n        val result = beats.map(_.toLong).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292796,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"o\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$3(tmpp4atlo5e.scala:15)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseMusic(tmpp4atlo5e.scala:15)\n\tat Problem$.main(tmpp4atlo5e.scala:21)\n\tat Problem.main(tmpp4atlo5e.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.endsWith(\"|\") {\n                return note_string.substring(0, note_string.length() - 1).toLong\n            } else {\n                return note_string.toLong\n            }\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if beat_string.endsWith(\"|\") {\n                return beat_string.substring(0, beat_string.length() - 1).toLong\n            } else {\n                return beat_string.toLong\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var beat_counts : List[Long] = List.empty\n            var beat_count : Long = 0\n            for (i <- 0 until music_string.length) {\n                if (music_string[i] == '.') {\n                    beat_count += 1\n                } else if (music_string[i] == 'o') {\n                    beat_count += 4\n                } else if (music_string[i] == 'o|') {\n                    beat_count += 2\n                }\n                if (beat_count > beat_counts.length) {\n                    beat_counts = beat_counts.append(beat_count)\n                } else {\n                    beat_counts = beat_counts.update(beat_count)\n                }\n            }\n            return beat_counts\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292794,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpolej1z2i.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpolej1z2i.scala:24:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpolej1z2i.scala:36:46 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_string[i] == \u001b[31m'o\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0msymbol literal 'o is no longer supported,\n\u001b[31m   |\u001b[0muse a string literal \"o\" or an application Symbol(\"o\") instead,\n\u001b[31m   |\u001b[0mor enclose in braces '{o} if you want a quoted expression.\n\u001b[31m   |\u001b[0mFor now, you can also `import language.deprecated.symbolLiterals` to accept\n\u001b[31m   |\u001b[0mthe idiom, but this possibility might no longer be available in the future.\n\u001b[31m\u001b[31m-- Error: /tmp/tmpolej1z2i.scala:36:49 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_string[i] == \u001b[31m'o\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              unclosed character literal\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpolej1z2i.scala:15:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.endsWith(\u001b[31m\"|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mendsWith\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpolej1z2i.scala:22:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m     ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.replaceAll(\"[^0-9.]\", \"\"))\n        val result = beats.map(_.toLong).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292770,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$3(tmp8xtub72i.scala:16)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseMusic(tmp8xtub72i.scala:16)\n\tat Problem$.main(tmp8xtub72i.scala:20)\n\tat Problem.main(tmp8xtub72i.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asScalaBuffer(music_string.split(\" \")).toList\n        val result = mutable.List.empty[Long]\n        for (i <- 0 until music_list.size) {\n            val note = music_list.get(i)\n            if (note.contains(\"o\")) {\n                result = result.append(4l)\n            } else if (note.contains(\"o|\")) {\n                result = result.append(2l)\n            } else if (note.contains(\".|\")) {\n                result = result.append(1l)\n            } else {\n                result = result.append(0l)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292796,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8l3jd2kg.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(music_string.split(\u001b[31m\" \"\u001b[0m)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8l3jd2kg.scala:15:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp8l3jd2kg.scala:19:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                result = result.append(\u001b[31m4l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp8l3jd2kg.scala:21:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                result = result.append(\u001b[31m2l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp8l3jd2kg.scala:23:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(\u001b[31m1l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp8l3jd2kg.scala:25:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                result = result",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.replaceAll(\"[^0-9.]\", \"\")).map(_.toLong).toList\n        val result = beats.map(b -> b.toLong)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292766,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp26mt5u14.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = beats.map(b -> b.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: b\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var result = mutable.List[Long]()\n        var current_note = mutable.StringBuilder()\n        var current_duration = mutable.StringBuilder()\n        var current_duration_count = 0\n        var current_duration_value = 0\n        var current_duration_type = 0\n        var current_note_value = 0\n        var current_note_type = 0\n        var current_note_count = 0\n        var current_note_count_value = 0\n        var current_note_count_type = 0\n        var current_note_count_count = 0\n        var current_note_count_count_value = 0\n        var current_note_count_count_type = 0\n        var current_note_count_count_count = 0\n        var current_note_count_count_count_value = 0\n        var current_note_count_count_count_type = 0\n        var current_note_count_count_count_count = 0\n        var current_note_count_count_count_count_value = 0\n        var current_note_count_count_count_count_type = 0\n        var current_note_count_count_count_count_count = 0\n        var current_note_count_count_count_count_count_value = 0\n        var current_note_count_count_count_count_count_type = 0\n        var current_note_count_count_count_count_count_count = 0\n        var current_note_count_count_count_count_count_count_value = 0\n        var current_note_count_count_count_count_count_count_type = 0\n        var current_note_count_count_count_count_count_count_count = 0\n        var current_note_count_count_count_count_count_count_count_value = 0\n        var current_note_count_count_count_count_count_count_count_type = 0\n        var current_note_count_count_count_count_count_count_count_count = 0\n        var current_note_count_count_count_count_count_count_count_count_value = 0\n        var current_note_count_count\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292799,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpjge0phmx.scala:46:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjge0phmx.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjge0phmx.scala:15:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_note\u001b[0m = mutable.StringBuilder()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjge0phmx.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration\u001b[0m = mutable.StringBuilder()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjge0phmx.scala:46:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string == \"o\" {\n                return 4L\n            } else if note_string == \"o|\" {\n                return 2L\n            } else if note_string == \".|\" {\n                return 1L\n            } else {\n                throw new IllegalArgumentException(\"Invalid note string: \" + note_string)\n            }\n        }\n        def parseDuration(duration_string : String) : Long = {\n            if duration_string == \"o\" {\n                return 4L\n            } else if duration_string == \"o|\" {\n                return 2L\n            } else if duration_string == \".|\" {\n                return 1L\n            } else {\n                throw new IllegalArgumentException(\"Invalid note string: \" + duration_string)\n            }\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if beat_string == \"o\" {\n                return 1L\n            } else if beat_string == \"o|\" {\n                return 2L\n            } else if beat_string == \".|\" {\n                return 4L\n            } else {\n                throw new IllegalArgumentException(\"Invalid note string: \" + beat_string)\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            def parseNote(note_string : String) : Long = {\n                if note_string == \"o\" {\n                    return 4L\n                } else if note_string == \"o|\" {\n                    return 2L\n                } else if note_string == \".|\" {\n                    return 1L\n                } else {\n                    throw new IllegalArgumentException(\"Invalid note string: \" + note_string)\n                }\n            }\n            def parseDuration(duration_string : String) : Long = {\n                if duration_string == \"o\" {\n                    return 4L\n                } else if duration_string == \"o|\" {\n                    return 2L\n                } else if duration_string == \".|\" {\n                    return 1L\n                } else {\n                    throw new IllegalArgumentException(\"Invalid note string: \" + duration_string)\n                }\n            \n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292800,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpy1sgm448.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpy1sgm448.scala:28:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m duration_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpy1sgm448.scala:39:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m beat_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpy1sgm448.scala:51:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpy1sgm448.scala:62:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m duration_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpy1sgm448.scala:80:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpy1sgm448.scala:15:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m16 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31m4L\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var notes = scala.collection.mutable.ListBuffer[Long]()\n        var current_note = 0\n        var current_beat = 0\n        for (i <- 0 until music_string.length) {\n            if (music_string[i] == '.') {\n                current_beat += 1\n            } else if (music_string[i] == '|') {\n                current_beat += 2\n            } else if (music_string[i] == 'o') {\n                current_beat += 4\n            } else if (music_string[i] == 'o|') {\n                current_beat += 2\n            } else {\n                current_note += 1\n            }\n            if (current_beat == 4) {\n                notes.append(current_note)\n                current_note = 0\n                current_beat = 0\n            }\n        }\n        notes.append(current_note)\n        return notes.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292797,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpuo0jzc4m.scala:24:42 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_string[i] == \u001b[31m'o\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0msymbol literal 'o is no longer supported,\n\u001b[31m   |\u001b[0muse a string literal \"o\" or an application Symbol(\"o\") instead,\n\u001b[31m   |\u001b[0mor enclose in braces '{o} if you want a quoted expression.\n\u001b[31m   |\u001b[0mFor now, you can also `import language.deprecated.symbolLiterals` to accept\n\u001b[31m   |\u001b[0mthe idiom, but this possibility might no longer be available in the future.\n\u001b[31m\u001b[31m-- Error: /tmp/tmpuo0jzc4m.scala:24:45 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_string[i] == \u001b[31m'o\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             unclosed character literal\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuo0jzc4m.scala:18:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mif\u001b[0m (music_string[\u001b[35mi\u001b[0m] == \u001b[31m'.'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuo0jzc4m.scala:20:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_string[i] == \u001b[31m'|'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuo0jzc4m.scala:22:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_string[i] == \u001b[31m'o'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                      ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if (note_string.length() == 0) {\n                return 0l\n            } else {\n                var note_char = note_string.charAt(0)\n                if (note_char == 'o') {\n                    return 4l\n                } else if (note_char == 'o|') {\n                    return 2l\n                } else if (note_char == '.') {\n                    return 1l\n                } else {\n                    throw new IllegalArgumentException(\"Unknown note character: \" + note_char)\n                }\n            }\n        }\n        var notes = music_string.split(\" \")\n        var beats = notes.map(note -> parseNote(note)).toList\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmps7hr3kwu.scala:21:40 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (note_char == \u001b[31m'o\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^\u001b[0m\n\u001b[31m   |\u001b[0msymbol literal 'o is no longer supported,\n\u001b[31m   |\u001b[0muse a string literal \"o\" or an application Symbol(\"o\") instead,\n\u001b[31m   |\u001b[0mor enclose in braces '{o} if you want a quoted expression.\n\u001b[31m   |\u001b[0mFor now, you can also `import language.deprecated.symbolLiterals` to accept\n\u001b[31m   |\u001b[0mthe idiom, but this possibility might no longer be available in the future.\n\u001b[31m\u001b[31m-- Error: /tmp/tmps7hr3kwu.scala:21:43 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (note_char == \u001b[31m'o\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           unclosed character literal\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps7hr3kwu.scala:31:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mbeats\u001b[0m = notes.map(note -> parseNote(note)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: note\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmps7hr3kwu.scala:31:54 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mbeats\u001b[0m = notes.map(note -> parseNote(note)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n\u001b[33m\u001b[33m-- [E129] Potential Issue Warning: /tmp/tmps7hr3kwu.scala:28:12 ----------------\u001b[0m\u001b[0m\n\u001b[33m27 |\u001b[0m                }\n\u001b[33m28 |\u001b[0m            }\n\u001b[33m\u001b[33m   |\u001b[0m                 ^\u001b[0m\n\u001b[33m   |\u001b[0mA pure expression ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.replaceAll(\"[^0-9.]\", \"\"))\n        val result = beats.map(_.toLong).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292770,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$3(tmp8xtub72i.scala:16)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseMusic(tmp8xtub72i.scala:16)\n\tat Problem$.main(tmp8xtub72i.scala:20)\n\tat Problem.main(tmp8xtub72i.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var result = mutable.List[Long]()\n        var note_count = mutable.List[String]()\n        var note_duration = mutable.List[String]()\n        var note_beat = mutable.List[String]()\n        var note_beat_count = mutable.List[Long]()\n        var note_beat_count_sum = mutable.List[Long]()\n        var note_beat_count_sum_sum = mutable.List[Long]()\n        var note_beat_count_sum_sum_sum = mutable.List[Long]()\n        var note_beat_count_sum_sum_sum_sum = mutable.List[Long]()\n        var note_beat_count_sum_sum_sum_sum_sum = mutable.List[Long]()\n        var note_beat_count_sum_sum_sum_sum_sum_sum = mutable.List[Long]()\n        var note_beat_count_sum_sum_sum_sum_sum_sum_sum = mutable.List[Long]()\n        var note_beat_count_sum_sum_sum_sum_sum_sum_sum_sum = mutable.List[Long]()\n        var note_beat_count_sum_sum_sum_sum_sum_sum_sum_sum_sum = mutable.List[Long]()\n        var note_beat_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = mutable.List[Long]()\n        var note_beat_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = mutable.List[Long]()\n        var note_beat_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = mutable.List[Long]()\n        var note_beat_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = mutable.List[Long]()\n        var note_beat_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292801,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9su6zikx.scala:33:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9su6zikx.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9su6zikx.scala:15:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mnote_count\u001b[0m = mutable.List[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9su6zikx.scala:16:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mnote_duration\u001b[0m = mutable.List[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9su6zikx.scala:17:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mnote_beat\u001b[0m = mutable.List[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9su6zikx.scala:18:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mnote_beat_count\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asScalaBuffer(music_string.split(\" \")).toList\n        val beats_list = scala.collection.JavaConversions.asScalaBuffer(music_list.map(x => x.replaceAll(\"[^0-9.]\", \"\"))).toList\n        val beats_count = scala.collection.JavaConversions.asScalaBuffer(music_list.map(x => x.replaceAll(\"[^0-9.]\", \"\"))).toList\n        val beats_count_list = scala.collection.JavaConversions.asScalaBuffer(beats_count.map(x => x.toLong)).toList\n        val beats_count_list_sorted = scala.collection.JavaConversions.asScalaBuffer(beats_count_list.sorted()).toList\n        val beats_count_list_sorted_sorted = scala.collection.JavaConversions.asScalaBuffer(beats_count_list_sorted.sorted()).toList\n        val beats_count_list_sorted_sorted_sorted = scala.collection.JavaConversions.asScalaBuffer(beats_count_list_sorted_sorted.sorted()).toList\n        val beats_count_list_sorted_sorted_sorted_sorted = scala.collection.JavaConversions.asScalaBuffer(beats_count_list_sorted_sorted_sorted.sorted()).toList\n        val beats_count_list_sorted_sorted_sorted_sorted_sorted = scala.collection.JavaConversions.asScalaBuffer(beats_count_list_sorted_sorted_sorted_sorted.sorted()).toList\n        val beats_count_list_sorted_sorted_sorted_sorted_sorted_sorted = scala.collection.JavaConversions.asScalaBuffer(beats_count_list_sorted_sorted_sorted_sorted_sorted.sorted()).toList\n        val beats_count_list_sorted_sorted_sorted_sorted_sorted_sorted_\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292803,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfzapbc33.scala:25:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfzapbc33.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(music_string.split(\u001b[31m\" \"\u001b[0m)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfzapbc33.scala:15:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats_list\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(music_list.map(\u001b[36mx\u001b[0m => x.replaceAll(\u001b[31m\"[^0-9.]\"\u001b[0m, \u001b[31m\"\"\u001b[0m))).toList\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfzapbc33.scala:16:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats_count\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(music_list.map(\u001b[36mx\u001b[0m => x.replaceAll(\u001b[31m\"[^0-9.]\"\u001b[0m, \u001b[31m\"\"\u001b[0m))).toList\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfzapbc33.scala:17:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats_count_list\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(beats_count.map(\u001b[36mx\u001b[0m => x.toLong)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfzapbc33.scala:18:55 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var result = mutable.List[Long]()\n        var i = 0\n        while (i < music_string.length) {\n            var note = music_string[i]\n            var count = 1\n            if (note == '.') {\n                count = 2\n            } else if (note == '|') {\n                count = 4\n            }\n            result = result.append(count.toLong)\n            i += 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292798,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj39or618.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj39or618.scala:17:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mnote\u001b[0m = music_string[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var notes = music_string.split(\" \")\n        var beats = []\n        for (i <- 0 until notes.length) {\n            var note = notes[i]\n            if (note.equals(\".\")) {\n                beats.append(1l)\n            } else if (note.equals(\"o\")) {\n                beats.append(4l)\n            } else if (note.equals(\"o|\")) {\n                beats.append(2l)\n            } else {\n                throw new RuntimeException(\"Unknown note \" + note)\n            }\n        }\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292803,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp93t32a_.scala:15:21 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mbeats\u001b[0m = []\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     an identifier expected, but ']' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp93t32a_.scala:16:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until notes.length) {\n\u001b[31m\u001b[31m   |\u001b[0m^^^\u001b[0m\n\u001b[31m   |\u001b[0m'=>' expected, but 'end of statement' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp93t32a_.scala:17:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mnote\u001b[0m = notes[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpp93t32a_.scala:19:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                beats.append(\u001b[31m1l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value append is not a member of Null\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpp93t32a_.scala:21:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                beats.append(\u001b[31m4l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToScala.list asScalaBuffer\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpp93t32a_.scala:23:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                beats.append(\u001b[31m2l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of Null, but could be made available as an extensio",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var notes = new ArrayList[String]()\n        var beats = new ArrayList[Long]()\n        var i = 0\n        while (i < music_string.length) {\n            var note = music_string[i]\n            if (note == '.') {\n                i += 1\n                continue\n            }\n            if (note == '|') {\n                i += 1\n                continue\n            }\n            if (note == 'o') {\n                i += 1\n                beats.add(4l)\n                continue\n            }\n            if (note == 'o|') {\n                i += 1\n                beats.add(2l)\n                continue\n            }\n            if (note == '.'|') {\n                i += 1\n                beats.add(1l)\n                continue\n            }\n            notes.add(note)\n            i += 1\n        }\n        var result = new ArrayList[Long]()\n        for (var note : notes) {\n            result.add(beats.get(notes.indexOf(note)))\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292799,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp3_ee6cm6.scala:32:27 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mif\u001b[0m (note == \u001b[31m'o\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           unclosed character literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmp3_ee6cm6.scala:37:28 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mif\u001b[0m (note == \u001b[31m'.'\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                            unclosed character literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmp3_ee6cm6.scala:32:24 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mif\u001b[0m (note == \u001b[31m'o\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0msymbol literal 'o is no longer supported,\n\u001b[31m   |\u001b[0muse a string literal \"o\" or an application Symbol(\"o\") instead,\n\u001b[31m   |\u001b[0mor enclose in braces '{o} if you want a quoted expression.\n\u001b[31m   |\u001b[0mFor now, you can also `import language.deprecated.symbolLiterals` to accept\n\u001b[31m   |\u001b[0mthe idiom, but this possibility might no longer be available in the future.\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3_ee6cm6.scala:14:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mnotes\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArrayList\u001b[0m[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type ArrayList\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3_ee6cm6.scala:15:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mbeats\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArrayList\u001b[0m[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type ArrayList\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3_ee6cm6.scala:18:36 -------------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.endsWith(\"|\") {\n                return note_string.substring(0, note_string.length() - 1).toLong\n            } else {\n                return note_string.toLong\n            }\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if beat_string.endsWith(\"|\") {\n                return beat_string.substring(0, beat_string.length() - 1).toLong\n            } else {\n                return beat_string.toLong\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var beat_counts = mutable.List[Long]()\n            var beat_count = 0\n            for(i <- 0 until music_string.length) {\n                if(music_string[i] == '.') {\n                    beat_count += 1\n                } else if(music_string[i] == 'o') {\n                    beat_count += 4\n                } else if(music_string[i] == 'o|') {\n                    beat_count += 2\n                }\n                if(beat_count > beat_counts.length) {\n                    beat_counts.append(beat_count)\n                } else {\n                    beat_counts[beat_count] += 1\n                }\n                beat_count = 0\n            }\n            return beat_counts\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292800,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpy9qayc1u.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpy9qayc1u.scala:24:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpy9qayc1u.scala:36:45 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m(music_string[i] == \u001b[31m'o\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0msymbol literal 'o is no longer supported,\n\u001b[31m   |\u001b[0muse a string literal \"o\" or an application Symbol(\"o\") instead,\n\u001b[31m   |\u001b[0mor enclose in braces '{o} if you want a quoted expression.\n\u001b[31m   |\u001b[0mFor now, you can also `import language.deprecated.symbolLiterals` to accept\n\u001b[31m   |\u001b[0mthe idiom, but this possibility might no longer be available in the future.\n\u001b[31m\u001b[31m-- Error: /tmp/tmpy9qayc1u.scala:36:48 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m(music_string[i] == \u001b[31m'o\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              unclosed character literal\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpy9qayc1u.scala:15:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.endsWith(\u001b[31m\"|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mendsWith\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpy9qayc1u.scala:22:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m         ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string == \".\" {\n                return 0l\n            }\n            if note_string == \"o\" {\n                return 4l\n            }\n            if note_string == \"o|\" {\n                return 2l\n            }\n            throw new RuntimeException(\"Unknown note \" + note_string)\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if beat_string == \".\" {\n                return 0l\n            }\n            if beat_string == \"o\" {\n                return 1l\n            }\n            if beat_string == \"o|\" {\n                return 2l\n            }\n            throw new RuntimeException(\"Unknown beat \" + beat_string)\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var result = mutable.List[Long]()\n            var current_beat = 0l\n            var current_note = 0l\n            var current_note_string = \"\"\n            for i in range(0, len(music_string)) {\n                if music_string[i] == '.' {\n                    current_note_string = current_note_string + music_string[i]\n                    current_note = parseNote(current_note_string)\n                    current_note_string = \"\"\n                    current_beat += current_note\n                    result.append(current_beat)\n                    current_beat = 0l\n                } else if music_string[i] == 'o' {\n                    current_note_string = current_note_string + music_string[i]\n                    current_note = parseNote(current_note_string)\n                    current_note_string = \"\"\n                    current_beat += current_note\n                    result.append(current_beat)\n                    current_beat = 0l\n                } else if music_string[i] == '|' {\n                    current_note_string = current_note_string + music_string[i]\n                    current_note = parseNote(current_note_string)\n                    current_note_string = \"\"\n                    current_beat += current_note\n                    result.append(current_beat)\n                    current_beat\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292806,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3nw2q23d.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mif\u001b[0m note_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^\u001b[0m\n\u001b[31m   |\u001b[0m            'then' expected, but 'if' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3nw2q23d.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mthrow\u001b[0m \u001b[33mnew\u001b[0m \u001b[35mRuntimeException\u001b[0m(\u001b[31m\"Unknown note \"\u001b[0m + note_string)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            'then' expected, but 'throw' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3nw2q23d.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            \u001b[33mif\u001b[0m beat_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^\u001b[0m\n\u001b[31m   |\u001b[0m            'then' expected, but 'if' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3nw2q23d.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            \u001b[33mthrow\u001b[0m \u001b[33mnew\u001b[0m \u001b[35mRuntimeException\u001b[0m(\u001b[31m\"Unknown beat \"\u001b[0m + beat_string)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            'then' expected, but 'throw' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3nw2q23d.scala:43:49 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m            \u001b[33mfor\u001b[0m i in range(\u001b[31m0\u001b[0m, len(music_string)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but '{' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmp3nw2q23d.scala:15:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string == \u001b[31m\".\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m16 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31m0l\u001b[0m\n\u001b[31m17 |\u001b[0m            }\n\u001b[31m\u001b[31m-- Error: /tmp/tmp3nw2q23d.scala:21:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.endsWith(\"|\") {\n                return note_string.substring(0, note_string.length() - 1).toLong\n            } else {\n                return note_string.toLong\n            }\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if beat_string.endsWith(\"|\") {\n                return beat_string.substring(0, beat_string.length() - 1).toLong\n            } else {\n                return beat_string.toLong\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var result = mutable.List[Long]()\n            var beat_count = 0\n            for (i <- 0 until music_string.length) {\n                var note_count = 0\n                var note_string = music_string[i]\n                while (note_string.startsWith(\"o\") && note_count < 4) {\n                    note_count += 1\n                    note_string = music_string[i + note_count]\n                }\n                if note_string.startsWith(\".\") {\n                    note_count += 1\n                    note_string = music_string[i + note_count]\n                }\n                if note_string.startsWith(\"o\") {\n                    note_count += 1\n                    note_string = music_string[i + note_count]\n                }\n                result = result.append(parseNote(note_string) * beat_count)\n                beat_count += parseBeat(music_string[i + note_count])\n            }\n            return result\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292805,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgylcvfnz.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgylcvfnz.scala:24:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgylcvfnz.scala:42:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m                \u001b[33mif\u001b[0m note_string.startsWith(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^\u001b[0m\n\u001b[31m   |\u001b[0m                'then' expected, but 'if' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpgylcvfnz.scala:15:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.endsWith(\u001b[31m\"|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mendsWith\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpgylcvfnz.scala:22:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m beat_string.endsWith(\u001b[31m\"|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mendsWith\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgylcvfnz.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = List[String]()\n        for (i <- 0 until music_string.length) {\n            if (music_string[i] == '.') {\n                music_list = music_list.append(0l)\n            } else if (music_string[i] == '|') {\n                music_list = music_list.append(1l)\n            } else if (music_string[i] == 'o') {\n                music_list = music_list.append(4l)\n            } else {\n                music_list = music_list.append(2l)\n            }\n        }\n        val result = List[Long]()\n        for (i <- 0 until music_list.length) {\n            if (music_list[i] == 0) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292806,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp124vmq5f.scala:16:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mif\u001b[0m (music_string[\u001b[35mi\u001b[0m] == \u001b[31m'.'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp124vmq5f.scala:17:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                music_list = music_list.append(\u001b[31m0l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[String] - did you mean music_list.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp124vmq5f.scala:18:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_string[i] == \u001b[31m'|'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp124vmq5f.scala:19:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                music_list = music_list.append(\u001b[31m1l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[String] - did you mean music_list.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp124vmq5f.scala:20:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_string[i] == \u001b[31m'o'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp124vmq5f.scala:21:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                music_list = music_list.append(\u001b[31m4l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asScalaBuffer(Arrays.asList(music_string.split(\" \")))\n        val music_list_as_scala_collection_mutable_ = scala.collection.mutable.Buffer[String]()\n        music_list.foreach(x => music_list_as_scala_collection_mutable_.append(x))\n        val music_list_as_scala_collection_mutable_as_scala_collection_mutable_ = scala.collection.mutable.Buffer[scala.collection.mutable.StringBuilder]()\n        music_list_as_scala_collection_mutable_.foreach(x => {\n            val sb = x.toStringBuilder()\n            val sb_as_scala_collection_mutable_ = scala.collection.mutable.Buffer[scala.collection.mutable.StringBuilder]()\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \")\n            sb.append(\" \"\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292806,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpa8ueso_l.scala:58:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpa8ueso_l.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m    ^^^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but 'def' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpa8ueso_l.scala:68:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa8ueso_l.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(Arrays.asList(music_string.split(\u001b[31m\" \"\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa8ueso_l.scala:19:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36msb\u001b[0m = x.toStringBuilder()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value toStringBuilder is not a member of String\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string == \"o\" {\n                return 4l\n            } else if note_string == \"o|\" {\n                return 2l\n            } else if note_string == \".\" {\n                return 1l\n            } else {\n                throw new IllegalArgumentException(\"Invalid note string: \" + note_string)\n            }\n        }\n        def parseMusic(note_string : String) : List[Long] = {\n            var note_count = 0l\n            var note_beats = List[Long]()\n            for note_string in note_string.split(\" \") {\n                note_count += parseNote(note_string)\n                note_beats = note_beats.append(note_count)\n            }\n            return note_beats\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292808,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4a4elzl6.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4a4elzl6.scala:28:54 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mfor\u001b[0m note_string in note_string.split(\u001b[31m\" \"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but '{' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmp4a4elzl6.scala:15:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m16 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31m4l\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4a4elzl6.scala:31:13 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            }\n\u001b[31m\u001b[31m   |\u001b[0m             ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator asScala\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        val result = mutable.List[Long]()\n        for (i <- 0 until music_list.length) {\n            val note = music_list[i]\n            if (note.equals(\".\")) {\n                result.append(1l)\n            } else if (note.equals(\"o\")) {\n                result.append(4l)\n            } else if (note.equals(\"o|\")) {\n                result.append(2l)\n            } else {\n                result.append(0l)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292807,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_ruou_4u.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_ruou_4u.scala:15:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_ruou_4u.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnote\u001b[0m = music_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music = music_string.split(\" \")\n        val result = mutable.List[Long]()\n        for (i <- 0 until music.length) {\n            val note = music[i]\n            if (note.equals(\".\")) {\n                result.append(1l)\n            } else if (note.equals(\"o\")) {\n                result.append(4l)\n            } else if (note.equals(\"o|\")) {\n                result.append(2l)\n            } else {\n                result.append(0l)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292804,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4biaw6w2.scala:15:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4biaw6w2.scala:17:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnote\u001b[0m = music[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = scala.collection.JavaConversions.asScalaBuffer(Arrays.asList(music_string.split(\" \")))\n        val result = notes.map(note -> {\n            val note_str = note.toString()\n            val note_len = note_str.length()\n            val note_len_int = note_len.toInt\n            val note_len_long = note_len_int.toLong\n            return note_len_long\n        }).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292807,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwqrgqbnk.scala:14:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnotes\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(Arrays.asList(music_string.split(\u001b[31m\" \"\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value JavaConversions is not a member of collection\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(note => {\n            val note_string = note.replace(\".\", \"\")\n            val note_length = note_string.length()\n            val note_value = note_string.charAt(note_length - 1)\n            if (note_value == \"o\") {\n                return 4l\n            } else if (note_value == \"o|\") {\n                return 2l\n            } else if (note_value == \".|\") {\n                return 1l\n            } else {\n                throw new RuntimeException(\"Invalid note: \" + note)\n            }\n        }).toList\n        return beats.map(beat => beat.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292809,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp5oqp4bv5.scala:19:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mif\u001b[0m (note_value == \u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5oqp4bv5.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31m4l\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (\u001b[31m4L\u001b[0m : Long)\n\u001b[31m   |\u001b[0m                       Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp5oqp4bv5.scala:21:23 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (note_value == \u001b[31m\"o|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5oqp4bv5.scala:22:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31m2l\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    (\u001b[31m2L\u001b[0m : Long)\n\u001b[31m   |\u001b[0m                       Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp5oqp4bv5.scala:23:23 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (note_value == \u001b[31m\".|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5oqp4bv5.scala:24:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31m1l\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^\u001b[0m\n\u001b[31m   |\u001b[0m                      ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(note => {\n            val note_parts = note.split(\"|\")\n            val note_length = note_parts.length\n            val note_beats = note_length - 1\n            val note_beat_count = note_beats.toLong\n            return note_beat_count\n        }).toList\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292809,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpat_28dqu.scala:20:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mreturn\u001b[0m note_beat_count\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (note_beat_count : Long)\n\u001b[31m   |\u001b[0m                   Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpat_28dqu.scala:21:10 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        }).toList\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asScalaBuffer(music_string.split(\" \")).toList\n        val beats = mutable.List[Long]()\n        for (i <- 0 until music_list.length) {\n            val note = music_list(i)\n            if (note.equals(\".\")) {\n                beats.append(0l)\n            } else if (note.equals(\"|\")) {\n                beats.append(1l)\n            } else if (note.equals(\"o\")) {\n                beats.append(4l)\n            } else if (note.equals(\"o|\")) {\n                beats.append(2l)\n            } else {\n                throw new IllegalArgumentException(\"Invalid note: \" + note)\n            }\n        }\n        return beats.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292808,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdl1fl2nl.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(music_string.split(\u001b[31m\" \"\u001b[0m)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdl1fl2nl.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = List.of(music_string.split(\" \"))\n        val result = List.empty[Long]\n        for (i <- 0 until music_list.length) {\n            val note = music_list[i]\n            if (note.contains(\".\")) {\n                val note_list = note.split(\".\")\n                val note_length = note_list[1].length()\n                val note_count = note_length.toLong\n                result = result.append(note_count)\n            } else {\n                val note_count = note.length().toLong\n                result = result.append(note_count)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292809,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfudjtkm6.scala:14:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = List.of(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value of is not a member of object scala.collection.immutable.List\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfudjtkm6.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnote\u001b[0m = music_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfudjtkm6.scala:22:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                result = result.append(note_count)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfudjtkm6.scala:25:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                result = result.append(note_count)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asScalaBuffer(music_string.split(\" \")).toList\n        val result = mutable.List.empty()\n        for (i <- 0 until music_list.length) {\n            val note = music_list(i)\n            if (note.contains(\"o\")) {\n                result = result.append(4l)\n            } else if (note.contains(\"o|\")) {\n                result = result.append(2l)\n            } else if (note.contains(\".|\")) {\n                result = result.append(1l)\n            } else {\n                result = result.append(0l)\n            }\n        }\n        return result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292809,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7rk02h1j.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(music_string.split(\u001b[31m\" \"\u001b[0m)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7rk02h1j.scala:15:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp7rk02h1j.scala:19:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                result = result.append(\u001b[31m4l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp7rk02h1j.scala:21:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                result = result.append(\u001b[31m2l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp7rk02h1j.scala:23:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(\u001b[31m1l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp7rk02h1j.scala:25:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                result = result.append(\u001b[31m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = List.ofAll(music_string.split(\" \"))\n        val beats = List.ofAll(music_list.map(Problem.parseMusicString).toList)\n        return beats\n    }\n\n    // This function parses a string representing a musical note.\n    // Your task is to parse this string and return a tuple representing the note.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusicString(\"o o| .| o| o| .| .| .| .| o o\")\n    // (Tuple2(Tuple2(1l.toLong, 4l.toLong), Tuple2(1l.toLong, 2l.toLong)))\n    def parseMusicString(music_string : String) : Tuple2[Tuple2[Long, Long], Tuple2[Long, Long]] = {\n        val note_list = List.ofAll(music_string.split(\" \"))\n        val note_tuple = Tuple2(Tuple2(note_list.map(Problem.parseNote).toList.head, note_list.map(Problem.parseNote).toList.tail.head), Tuple2(note_list.map(Problem.parseNote).toList.tail.tail.head, note_list.map(Problem.parseNote).toList.tail.tail.tail.head))\n        return note_tuple\n    }\n\n    // This function parses a string representing a musical note.\n    // Your task is to parse this string and return a tuple representing the note.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseNote(\"o o| .| o| o| .| .| .| .| o o\")\n    // (Tuple2(1l.toLong, 4l.toLong))\n    def parseNote(note_string : String) : Tuple2[Long, Long] =\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292810,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpxnd_wpby.scala:41:62 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mparseNote\u001b[0m(\u001b[36mnote_string\u001b[0m : \u001b[35mString\u001b[0m) : \u001b[35mTuple2\u001b[0m[\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m] =\n\u001b[31m\u001b[31m   |\u001b[0m                                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpxnd_wpby.scala:51:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxnd_wpby.scala:14:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = List.ofAll(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue ofAll is not a member of object scala.collection.immutable.List - did you mean List.fill?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxnd_wpby.scala:15:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = List.ofAll(music_list.map(Problem.parseMusicString).toList)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue ofAll is not a member of object scala.collection.immutable.List - did you mean List.fill?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxnd_wpby.scala:28:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnote_list\u001b[0m = List.ofAll(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue ofAll is not a member of object scala.collection.immutable.List - did you mean List.fill?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxnd_wpby.scala:44:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m    assert(parseMusic((\u001b[31m\"\"\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m]())));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not fou",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long {\n            if (note_string == \".\") {\n                return 0l\n            } else if (note_string == \"o\") {\n                return 4l\n            } else if (note_string == \"o|\") {\n                return 2l\n            } else {\n                throw new RuntimeException(\"Unknown note: \" + note_string)\n            }\n        }\n        def parseDuration(note_string : String) : Long {\n            if (note_string == \"o\") {\n                return 4l\n            } else if (note_string == \"o|\") {\n                return 2l\n            } else if (note_string == \".|\") {\n                return 1l\n            } else {\n                throw new RuntimeException(\"Unknown note: \" + note_string)\n            }\n        }\n        def parseMusic(note_string : String) : List[Long] {\n            var result = List[Long]()\n            var note = parseNote(note_string)\n            var duration = parseDuration(note_string)\n            for (i <- 0 until note) {\n                result = result.append(duration)\n            }\n            return result\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292807,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E103] Syntax Error: /tmp/tmpcvf_ytov.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m (note_string == \u001b[31m\".\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^\u001b[0m\n\u001b[31m   |\u001b[0mIllegal start of declaration (possible cause: missing `=` in front of current method body)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E103] Syntax Error: /tmp/tmpcvf_ytov.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (note_string == \u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^\u001b[0m\n\u001b[31m   |\u001b[0mIllegal start of declaration (possible cause: missing `=` in front of current method body)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpcvf_ytov.scala:37:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       refinement cannot be a mutable var.\n\u001b[31m   |\u001b[0m       You can use an explicit getter result and setter result_= instead\n\u001b[31m\u001b[31m-- Error: /tmp/tmpcvf_ytov.scala:38:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mnote\u001b[0m = parseNote(note_string)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           refinement cannot be a mutable var.\n\u001b[31m   |\u001b[0m           You can use an explicit getter note and setter note_= instead\n\u001b[31m\u001b[31m-- Error: /tmp/tmpcvf_ytov.scala:39:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mduration\u001b[0m = parseDuration(note_string)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m   refinement cannot be a mutable var.\n\u001b[31m   |\u001b[0m   You can use an explicit getter duration and setter duration_= instead\n\u001b[31m\u001b[31m-- [E103] Syntax Error: /tmp/tmpcvf_ytov.scala:40:12 ------------------------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.replaceAll(\"[^0-9.]\", \"\")).map(_.toLong).toList\n        val result = beats.map(b => b.toLong)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292784,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$3(tmpun5j8ar8.scala:15)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseMusic(tmpun5j8ar8.scala:15)\n\tat Problem$.main(tmpun5j8ar8.scala:20)\n\tat Problem.main(tmpun5j8ar8.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = music_string.split(\" \")\n        val beats = mutable.List[Long]()\n        for (i <- 0 until music_list.length) {\n            val note = music_list[i]\n            if (note.equals(\".\")) {\n                beats.append(1l)\n            } else if (note.equals(\"o\")) {\n                beats.append(4l)\n            } else if (note.equals(\"o|\")) {\n                beats.append(2l)\n            } else {\n                throw new IllegalArgumentException(\"Invalid note: \" + note)\n            }\n        }\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292808,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpw8c_w0o1.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpw8c_w0o1.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnote\u001b[0m = music_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.contains(\".\") {\n                return (note_string.replace(\".\", \"\")).toLong\n            } else {\n                return (note_string.replace(\"o\", \"\")).toLong\n            }\n        }\n        def parseDuration(note_string : String) : Long = {\n            if note_string.contains(\"|\") {\n                return (note_string.replace(\"|\", \"\")).toLong\n            } else {\n                return (note_string.replace(\"o\", \"\")).toLong\n            }\n        }\n        def parseBeat(note_string : String) : Long = {\n            if note_string.contains(\".\") {\n                return (note_string.replace(\".\", \"\")).toLong\n            } else {\n                return (note_string.replace(\"o\", \"\")).toLong\n            }\n        }\n        def parseMusic(note_string : String) : List[Long] = {\n            if note_string.contains(\".\") {\n                return List(parseNote(note_string.replace(\".\", \"\")), parseDuration(note_string.replace(\".\", \"\")), parseBeat(note_string.replace(\".\", \"\")))\n            } else {\n                return List(parseNote(note_string.replace(\"o\", \"\")), parseDuration(note_string.replace(\"o\", \"\")), parseBeat(note_string.replace(\"o\", \"\")))\n            }\n        }\n        def parseMusic(note_string : String) : List[Long] = {\n            if note_string.contains(\".\") {\n                return List(parseNote(note_string.replace(\".\", \"\")), parseDuration(note_string.replace(\".\", \"\")), parseBeat(note_string.replace(\".\", \"\")))\n            } else {\n                return List(parseNote(note_string.replace(\"o\", \"\")), parseDuration(note_string.replace(\"o\", \"\")), parseBeat(note_string.replace(\"o\", \"\")))\n            }\n        }\n        def parseMusic(note_string : String) : List[Long] = {\n            if note_string.contains(\".\") {\n                \n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292811,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpk3oae8bk.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpk3oae8bk.scala:24:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpk3oae8bk.scala:31:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpk3oae8bk.scala:38:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpk3oae8bk.scala:45:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpk3oae8bk.scala:53:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m    ^^^\u001b[0m\n\u001b[31m   |\u001b[0m    'then' expected, but 'def' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpk3oae8bk.scala:62:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpk3oae8bk.scala:15:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\".\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mcontains\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asScalaBuffer(List.of(music_string.split(\" \")))\n        val music_string_list = scala.collection.JavaConversions.asScalaBuffer(List.of(music_string.split(\" \")))\n        val music_list_length = music_list.length()\n        val music_string_list_length = music_string_list.length()\n        val music_list_iterator = scala.collection.JavaConversions.asScalaIterator(music_list.iterator())\n        val music_string_list_iterator = scala.collection.JavaConversions.asScalaIterator(music_string_list.iterator())\n        val music_list_iterator_length = music_list_iterator.length()\n        val music_string_list_iterator_length = music_string_list_iterator.length()\n        val music_list_iterator_index = 0\n        val music_string_list_iterator_index = 0\n        val music_list_iterator_index_max = music_list_iterator_length - 1\n        val music_string_list_iterator_index_max = music_string_list_iterator_length - 1\n        val music_list_iterator_index_min = 0\n        val music_string_list_iterator_index_min = 0\n        val music_list_iterator_index_min_max = music_list_iterator_index_max - 1\n        val music_string_list_iterator_index_min_max = music_string_list_iterator_index_max - 1\n        val music_list_iterator_index_min_min = 0\n        val music_string_list_iterator_index_min_min = 0\n        val music_list_iterator_index_min_min_max = music_list_iterator_index_min_max - 1\n        val music_string_list_iterator_index_min_min_max = music_string_list_iterator_index_min_max - 1\n        val music_list_iterator_index_min_min_min = 0\n        val music_string_list_iterator_index_min_min_min = 0\n        val music_list_iterator_index_\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4wal1vdk.scala:37:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4wal1vdk.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(List.of(music_string.split(\u001b[31m\" \"\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4wal1vdk.scala:15:49 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_string_list\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(List.of(music_string.split(\u001b[31m\" \"\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4wal1vdk.scala:18:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list_iterator\u001b[0m = scala.collection.JavaConversions.asScalaIterator(music_list.iterator())\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4wal1vdk.scala:19:58 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_string_list_iterator\u001b[0m = scala.collection.JavaConversions.asScalaIterator(music_string_list.iterator())\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4wal1vdk.scala:37:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Uni",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asScalaBuffer(Arrays.asList(music_string.split(\" \")))\n        val result = mutable.List[Long]()\n        for (i <- 0 until music_list.length) {\n            val note = music_list.get(i)\n            if (note.equals(\".\")) {\n                result.append(1l)\n            } else if (note.equals(\"|\")) {\n                result.append(2l)\n            } else if (note.equals(\"o\")) {\n                result.append(4l)\n            } else {\n                result.append(0l)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292812,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8hx4njon.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(Arrays.asList(music_string.split(\u001b[31m\" \"\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8hx4njon.scala:15:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(note -> {\n            val note_parts = note.split(\"|\")\n            val note_len = note_parts.length\n            val note_len_int = note_len.toInt\n            val note_len_long = note_len_int.toLong\n            return note_len_long\n        }).toList\n        val beats_list = beats.map(beat -> beat.toLong).toList\n        return beats_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292813,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkxu6i3nd.scala:15:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = notes.map(note -> {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: note\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpkxu6i3nd.scala:21:10 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        }).toList\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        val result = mutable.List[Long]()\n        for (i <- 0 until music_list.length) {\n            val note = music_list[i]\n            if (note.equals(\".\")) {\n                result.append(1l)\n            } else if (note.equals(\"o\")) {\n                result.append(4l)\n            } else if (note.equals(\"o|\")) {\n                result.append(2l)\n            } else {\n                result.append(0l)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292807,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_ruou_4u.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_ruou_4u.scala:15:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_ruou_4u.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnote\u001b[0m = music_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = List.ofAll(music_string.split(\" \"))\n        val beats = List.ofAll(music_list.map(Problem.parseMusic_).toJavaList)\n        return beats\n    }\n\n    // Parses one note from the music string.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic_(\"o o| .| o| o| .| .| .| .| o o\")\n    // (Long(4l.toLong), Long(2l.toLong), Long(1l.toLong), Long(2l.toLong), Long(2l.toLong), Long(1l.toLong), Long(1l.toLong), Long(1l.toLong), Long(1l.toLong), Long(4l.toLong), Long(4l.toLong))\n    def parseMusic_ (note : String) : Long = {\n        val note_list = List.ofAll(note.split(\"\\\\|\"))\n        val note_duration = note_list.map(Problem.parseMusic_).toJavaList\n        return note_duration.reduce(0l)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292814,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp603tx_xj.scala:14:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = List.ofAll(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue ofAll is not a member of object scala.collection.immutable.List - did you mean List.fill?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp603tx_xj.scala:15:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = List.ofAll(music_list.map(Problem.parseMusic_).toJavaList)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue ofAll is not a member of object scala.collection.immutable.List - did you mean List.fill?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp603tx_xj.scala:27:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnote_list\u001b[0m = List.ofAll(note.split(\u001b[31m\"\\\\|\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue ofAll is not a member of object scala.collection.immutable.List - did you mean List.fill?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string == \"o\" {\n                return 4l\n            } else if note_string == \"o|\" {\n                return 2l\n            } else if note_string == \".|\" {\n                return 1l\n            } else {\n                throw new RuntimeException(\"Unknown note: \" + note_string)\n            }\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if beat_string == \"o\" {\n                return 4l\n            } else if beat_string == \"o|\" {\n                return 2l\n            } else if beat_string == \".|\" {\n                return 1l\n            } else {\n                throw new RuntimeException(\"Unknown beat: \" + beat_string)\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var beat_counts = mutable.List[Long]()\n            for (i <- 0 until music_string.length) {\n                var note_count = parseNote(music_string[i])\n                var beat_count = parseBeat(music_string[i + 1])\n                beat_counts = beat_counts.append(beat_count)\n                i += 2\n            }\n            return beat_counts\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292817,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0glb7vs6.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0glb7vs6.scala:28:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m beat_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmp0glb7vs6.scala:15:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m16 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31m4l\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m-- Error: /tmp/tmp0glb7vs6.scala:26:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m beat_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m27 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31m4l\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m beat_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0glb7vs6.scala:37:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mbeat_counts\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0glb7vs6.scala:39:56 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                \u001b[33mvar\u001b[0m \u001b[36mnote_count\u001b[0m = parseNote(music_string[\u001b[35mi\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        val beats = mutable.List[Long]()\n        for (i <- 0 until music_list.length) {\n            if (music_list(i).equals(\".\")) {\n                beats.append(0l)\n            } else if (music_list(i).equals(\"o\")) {\n                beats.append(4l)\n            } else if (music_list(i).equals(\"o|\")) {\n                beats.append(2l)\n            } else {\n                beats.append(1l)\n            }\n        }\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292768,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdtmwc8sq.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdtmwc8sq.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asScalaBuffer(Arrays.asList(music_string.split(\" \")))\n        val music_seq = scala.collection.mutable.Buffer[String]()\n        for (i <- 0 until music_list.length) {\n            if (music_list(i).equals(\".\")) {\n                music_seq += music_list(i)\n            } else {\n                music_seq += music_list(i) + \" \"\n            }\n        }\n        val music_seq_list = scala.collection.JavaConversions.asScalaBuffer(music_seq.toList())\n        val music_seq_seq = scala.collection.mutable.Buffer[String]()\n        for (i <- 0 until music_seq_list.length) {\n            if (music_seq_list(i).equals(\".\")) {\n                music_seq_seq += music_seq_list(i)\n            } else {\n                music_seq_seq += music_seq_list(i) + \" \"\n            }\n        }\n        val music_seq_seq_list = scala.collection.JavaConversions.asScalaBuffer(music_seq_seq.toList())\n        val music_seq_seq_seq = scala.collection.mutable.Buffer[String]()\n        for (i <- 0 until music_seq_seq_list.length) {\n            if (music_seq_seq_list(i).equals(\".\")) {\n                music_seq_seq_seq += music_seq_seq_list(i)\n            } else {\n                music_seq_seq_seq += music_seq_seq_list(i) + \" \"\n            }\n        }\n        val music_seq_seq_seq_list = scala.collection.JavaConversions.asScalaBuffer(music_seq_seq_seq.toList())\n        val music_seq_seq_seq_seq = scala.collection.mutable.Buffer[String]()\n        for (i <- 0 until music_seq_seq_seq_list.length) {\n            if (music_seq_seq_seq_list(i).equals(\".\"\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292818,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzxs246f1.scala:45:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzxs246f1.scala:55:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzxs246f1.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(Arrays.asList(music_string.split(\u001b[31m\" \"\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzxs246f1.scala:23:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_seq_list\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(music_seq.toList())\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzxs246f1.scala:32:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_seq_seq_list\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(music_seq_seq.toList())\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzxs246f1.scala:41:54 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_seq_seq_seq_list\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(music_seq_seq_seq.toList())\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        val result = mutable.List.empty[Long]\n        for (i <- 0 until music_list.length) {\n            val note = music_list.get(i)\n            if (note.equals(\".\")) {\n                result = result.append(1l)\n            } else if (note.equals(\"o\")) {\n                result = result.append(4l)\n            } else if (note.equals(\"o|\")) {\n                result = result.append(2l)\n            } else {\n                result = result.append(0l)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292816,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqs8ntu8y.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqs8ntu8y.scala:15:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpqs8ntu8y.scala:19:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                result = result.append(\u001b[31m1l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpqs8ntu8y.scala:21:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                result = result.append(\u001b[31m4l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpqs8ntu8y.scala:23:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(\u001b[31m2l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpqs8ntu8y.scala:25:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                result = result.append(\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.equals(\".\") {\n                return 0l\n            } else if note_string.equals(\"o\") {\n                return 4l\n            } else if note_string.equals(\"o|\") {\n                return 2l\n            } else {\n                return 1l\n            }\n        }\n        def parseDuration(note_string : String) : Long = {\n            if note_string.equals(\".\") {\n                return 0l\n            } else if note_string.equals(\"o\") {\n                return 4l\n            } else if note_string.equals(\"o|\") {\n                return 2l\n            } else {\n                return 1l\n            }\n        }\n        def parseMusic(note_string : String) : List[Long] = {\n            def parseNote(note_string : String) : Long = {\n                if note_string.equals(\".\") {\n                    return 0l\n                } else if note_string.equals(\"o\") {\n                    return 4l\n                } else if note_string.equals(\"o|\") {\n                    return 2l\n                } else {\n                    return 1l\n                }\n            }\n            def parseDuration(note_string : String) : Long = {\n                if note_string.equals(\".\") {\n                    return 0l\n                } else if note_string.equals(\"o\") {\n                    return 4l\n                } else if note_string.equals(\"o|\") {\n                    return 2l\n                } else {\n                    return 1l\n                }\n            }\n            def parseMusic(note_string : String) : List[Long] = {\n                def parseNote(note_string : String) : Long = {\n                    if note_string.equals(\".\") {\n                        return 0l\n                    } else if note_string.equals(\"o\") {\n                        return 4l\n                    } else if note_string.equals(\"o|\") {\n                        return 2l\n                    } else {\n                        return 1l\n                    }\n                }\n                def parseDuration(note_string : String) : Long = {\n                    if note_string.equals\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292819,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp5h4uq0u.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp5h4uq0u.scala:28:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp5h4uq0u.scala:40:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp5h4uq0u.scala:51:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp5h4uq0u.scala:63:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m                    } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp5h4uq0u.scala:73:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    'then' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp5h4uq0u.scala:83:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpp5h4uq0u.scala:15:33 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\".\"\u001b[0m) {\n\u001b[31m\u001b[31m  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string == \"o\" {\n                return 4l\n            } else if note_string == \"o|\" {\n                return 2l\n            } else if note_string == \".|\" {\n                return 1l\n            } else {\n                throw new RuntimeException(\"Invalid note string: \" + note_string)\n            }\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if beat_string == \".\" {\n                return 1l\n            } else if beat_string == \"o\" {\n                return 4l\n            } else if beat_string == \"o|\" {\n                return 2l\n            } else {\n                throw new RuntimeException(\"Invalid beat string: \" + beat_string)\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var beat_counts = mutable.List[Long]()\n            var beat_index = 0\n            var note_index = 0\n            for(i <- 0 until music_string.length) {\n                if music_string[i] == \".\" {\n                    beat_counts.append(parseBeat(music_string[beat_index:i]))\n                    beat_index = i + 1\n                } else if music_string[i] == \"o\" {\n                    beat_counts.append(parseBeat(music_string[beat_index:i]))\n                    beat_counts.append(parseBeat(music_string[i+1:i+4]))\n                    beat_index = i + 4\n                } else if music_string[i] == \"o|\" {\n                    beat_counts.append(parseBeat(music_string[beat_index:i]))\n                    beat_counts.append(parseBeat(music_string[i+1:i+2]))\n                    beat_index = i + 2\n                }\n            }\n            beat_counts.append(parseBeat(music_string[beat_index:]))\n            return beat_counts\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7fqpw90p.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7fqpw90p.scala:28:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m beat_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7fqpw90p.scala:42:72 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m                    beat_counts.append(parseBeat(music_string[\u001b[35mbeat_index\u001b[0m:i]))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             ']' expected, but ':' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7fqpw90p.scala:44:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m music_string[i] == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7fqpw90p.scala:54:64 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m            beat_counts.append(parseBeat(music_string[\u001b[35mbeat_index\u001b[0m:]))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             ']' expected, but ':' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmp7fqpw90p.scala:15:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m16 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31m4l\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        val beats = mutable.List[Long]()\n        for (i <- 0 until music_list.length) {\n            val note = music_list.get(i)\n            if (note.equals(\".\")) {\n                beats.append(1l)\n            } else if (note.equals(\"o\")) {\n                beats.append(4l)\n            } else if (note.equals(\"o|\")) {\n                beats.append(2l)\n            } else {\n                throw new IllegalArgumentException(\"Invalid note: \" + note)\n            }\n        }\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292819,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpajd3d25v.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpajd3d25v.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.contains(\"o\") {\n                return 4l\n            } else if note_string.contains(\"o|\") {\n                return 2l\n            } else if note_string.contains(\".|\") {\n                return 1l\n            } else {\n                return 0l\n            }\n        }\n        def parseBeat(note_string : String) : Long = {\n            if note_string.contains(\"o\") {\n                return 4l\n            } else if note_string.contains(\"o|\") {\n                return 2l\n            } else if note_string.contains(\".|\") {\n                return 1l\n            } else {\n                return 0l\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var beat_list : List[Long] = List[Long]()\n            var note_list : List[Long] = List[Long]()\n            var beat_count : Long = 0l\n            var note_count : Long = 0l\n            var beat_index : Long = 0l\n            var note_index : Long = 0l\n            var beat_string : String = \"\"\n            var note_string : String = \"\"\n            for (i <- 0 until music_string.length) {\n                if (music_string[i] == \" \") {\n                    if (note_count > 0) {\n                        note_list = note_list.append(note_count)\n                        note_count = 0l\n                    }\n                    if (beat_count > 0) {\n                        beat_list = beat_list.append(beat_count)\n                        beat_count = 0l\n                    }\n                    beat_index = i + 1\n                } else if (music_string[i] == \".\") {\n                    note_count = note_count + parseNote(note_string)\n                    note_string = \"\"\n                    note_index = i + 1\n                } else if (music_string[i] == \"|\") {\n                    beat_count = beat_count + parseBeat(beat_string)\n                    beat_string = \"\"\n                    beat_index = i\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm448rlei.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"o|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm448rlei.scala:28:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"o|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm448rlei.scala:74:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpm448rlei.scala:15:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mcontains\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpm448rlei.scala:26:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mcontains\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm448rlei.scala:46:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m                \u001b[33mif\u001b[0m (music_string[\u001b[35mi\u001b[0m] == \u001b[31m\" \"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.toLong).toList\n        val result = beats.map(b -> b.toLong)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292815,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzbd31wvk.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = beats.map(b -> b.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: b\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).filter(_.nonEmpty).map(_.toLong).toList\n        val result = beats.map(b => b / 4).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"o\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$3(tmpttag4nf7.scala:15)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseMusic(tmpttag4nf7.scala:15)\n\tat Problem$.main(tmpttag4nf7.scala:21)\n\tat Problem.main(tmpttag4nf7.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.contains(\".\") {\n                return _.toLong(note_string.replace(\".\", \"\"))\n            } else {\n                return _.toLong(note_string)\n            }\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if beat_string.contains(\"|\") {\n                return _.toLong(beat_string.replace(\"|\", \"\"))\n            } else {\n                return _.toLong(beat_string)\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            def parseNote(note_string : String) : Long = {\n                if note_string.contains(\".\") {\n                    return _.toLong(note_string.replace(\".\", \"\"))\n                } else {\n                    return _.toLong(note_string)\n                }\n            }\n            def parseBeat(beat_string : String) : Long = {\n                if beat_string.contains(\"|\") {\n                    return _.toLong(beat_string.replace(\"|\", \"\"))\n                } else {\n                    return _.toLong(beat_string)\n                }\n            }\n            def parseMusic(music_string : String) : List[Long] = {\n                def parseNote(note_string : String) : Long = {\n                    if note_string.contains(\".\") {\n                        return _.toLong(note_string.replace(\".\", \"\"))\n                    } else {\n                        return _.toLong(note_string)\n                    }\n                }\n                def parseBeat(beat_string : String) : Long = {\n                    if beat_string.contains(\"|\") {\n                        return _.toLong(beat_string.replace(\"|\", \"\"))\n                    } else {\n                        return _.toLong(beat_string)\n                    }\n                }\n                def parseMusic(music_string : String) : List[Long] = {\n                    def parseNote(note_string : String) : Long = {\n                        if note_string.contains(\".\") {\n                            return _.toLong(note_string.replace(\"\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292818,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpob4cl05i.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpob4cl05i.scala:24:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpob4cl05i.scala:32:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpob4cl05i.scala:39:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpob4cl05i.scala:47:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m                    } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpob4cl05i.scala:54:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m                    } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpob4cl05i.scala:61:64 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m                            \u001b[33mreturn\u001b[0m _.toLong(note_string.replace(\"\n\u001b[31m\u001b[31m   |\u001b[0m                                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                 unclosed string literal\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpob4cl05i.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36marg",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(note -> {\n            val note_parts = note.split(\"|\")\n            val note_length = note_parts[0].length()\n            val note_beats = note_parts[0].count(\".\")\n            val note_beat_length = note_parts[0].replaceAll(\"[o.]\", \"\").length()\n            val note_beats_count = note_beats * note_beat_length\n            return note_length * note_beats_count\n        }).toList\n        val beats_count = beats.map(beat -> beat.toLong).toList\n        return beats_count\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp60b5_dcp.scala:15:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = notes.map(note -> {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: note\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp60b5_dcp.scala:22:10 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        }).toList\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var beat_counts = mutable.List[Long]()\n        var beat_count = 0\n        var note_count = 0\n        var note_count_prev = 0\n        var note_count_prev_prev = 0\n        var note_count_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0o9jdu55.scala:35:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0o9jdu55.scala:14:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mbeat_counts\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0o9jdu55.scala:35:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var result = mutable.List[Long]()\n        var current_note = mutable.List[String]()\n        var current_duration = mutable.List[String]()\n        var current_duration_count = mutable.List[Long]()\n        var current_duration_count_index = mutable.List[Long]()\n        var current_duration_count_index_index = mutable.List[Long]()\n        var current_duration_count_index_index_index = mutable.List[Long]()\n        var current_duration_count_index_index_index_index = mutable.List[Long]()\n        var current_duration_count_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_count_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_count_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_count_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_count_index_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_count_index_index_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_count_index_index_index_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_count_index_index_index_index_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_count_index_index_index_index_index_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_count_index_index_index_index_index_index_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpk3sow8w_.scala:33:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpk3sow8w_.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpk3sow8w_.scala:15:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_note\u001b[0m = mutable.List[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpk3sow8w_.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration\u001b[0m = mutable.List[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpk3sow8w_.scala:17:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration_count\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpk3sow8w_.scala:18:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration_count_index\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = List.of(music_string.split(\" \"))\n        val beats = List.of(0l)\n        for (i <- 0 until music_list.length) {\n            val note = music_list[i]\n            if (note.contains(\".\")) {\n                val note_list = note.split(\".\")\n                val note_length = note_list[1].length()\n                val note_beats = note_length.toLong * 4\n                beats = beats.append(note_beats)\n            } else if (note.contains(\"|\")) {\n                val note_list = note.split(\"|\")\n                val note_length = note_list[1].length()\n                val note_beats = note_length.toLong * 2\n                beats = beats.append(note_beats)\n            } else {\n                val note_length = note.length()\n                val note_beats = note_length.toLong * 1\n                beats = beats.append(note_beats)\n            }\n        }\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmaolg8rb.scala:14:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = List.of(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value of is not a member of object scala.collection.immutable.List\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmaolg8rb.scala:15:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = List.of(\u001b[31m0l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value of is not a member of object scala.collection.immutable.List\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmaolg8rb.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnote\u001b[0m = music_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpmaolg8rb.scala:22:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                beats = beats.append(note_beats)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val beats\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpmaolg8rb.scala:27:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                beats = beats.append(note_beats)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val beats\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpmaolg8rb.scala:31:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                beats = beats.append(note_beats)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reass",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        val result = mutable.List[Long]()\n        for (i <- 0 until music_list.size()) {\n            val note = music_list.apply(i)\n            if (note.contains(\".\")) {\n                result.append(1l.toLong)\n            } else if (note.contains(\"|\")) {\n                result.append(2l.toLong)\n            } else if (note.contains(\"o\")) {\n                result.append(4l.toLong)\n            } else {\n                result.append(0l.toLong)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuviyg8cd.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuviyg8cd.scala:15:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val result = notes.map(_.trim).map(_.replaceAll(\"[^0-9.]\", \"\")).map(_.toLong).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$3(tmp2aeknl2g.scala:15)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseMusic(tmp2aeknl2g.scala:15)\n\tat Problem$.main(tmp2aeknl2g.scala:19)\n\tat Problem.main(tmp2aeknl2g.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var result = mutable.List[Long]()\n        var note_count = mutable.List[String]()\n        var note_duration = mutable.List[Long]()\n        var note_index = mutable.List[Long]()\n        var note_index_count = mutable.List[Long]()\n        var note_index_duration = mutable.List[Long]()\n        var note_index_index = mutable.List[Long]()\n        var note_index_index_count = mutable.List[Long]()\n        var note_index_index_duration = mutable.List[Long]()\n        var note_index_index_index = mutable.List[Long]()\n        var note_index_index_index_count = mutable.List[Long]()\n        var note_index_index_index_duration = mutable.List[Long]()\n        var note_index_index_index_index = mutable.List[Long]()\n        var note_index_index_index_index_count = mutable.List[Long]()\n        var note_index_index_index_index_duration = mutable.List[Long]()\n        var note_index_index_index_index_index = mutable.List[Long]()\n        var note_index_index_index_index_index_count = mutable.List[Long]()\n        var note_index_index_index_index_index_duration = mutable.List[Long]()\n        var note_index_index_index_index_index_index = mutable.List[Long]()\n        var note_index_index_index_index_index_index_count = mutable.List[Long]()\n        var note_index_index_index_index_index_index_duration = mutable.List[Long]()\n        var note_index_index_index_index_index_index_index = mutable.List[Long]()\n        var note_index_index_index_index_index_index_index_count = mutable.List[Long]()\n        var note_index_index_index_index_index_index_index_duration = mutable.List[Long]()\n\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz3s5nlet.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz3s5nlet.scala:15:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mnote_count\u001b[0m = mutable.List[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz3s5nlet.scala:16:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mnote_duration\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz3s5nlet.scala:17:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mnote_index\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz3s5nlet.scala:18:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mnote_index_count\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz3s5nlet.scala:19:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        val beats = mutable.List[Long]()\n        for (i <- 0 until music_list.length) {\n            val note = music_list[i]\n            if (note.equals(\".\")) {\n                beats.append(1l)\n            } else if (note.equals(\"o\")) {\n                beats.append(4l)\n            } else if (note.equals(\"o|\")) {\n                beats.append(2l)\n            } else {\n                throw new IllegalArgumentException(\"Invalid note: \" + note)\n            }\n        }\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292789,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_prr8iq2.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_prr8iq2.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_prr8iq2.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnote\u001b[0m = music_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.length() == 0 {\n                return 0l\n            }\n            if note_string.charAt(0) == 'o' {\n                return 4l\n            }\n            if note_string.charAt(0) == '.' {\n                return 1l\n            }\n            if note_string.charAt(0) == '|' {\n                return 2l\n            }\n            return 0l\n        }\n        def parseDuration(note_string : String) : Long = {\n            if note_string.length() == 0 {\n                return 0l\n            }\n            if note_string.charAt(0) == 'o' {\n                return 4l\n            }\n            if note_string.charAt(0) == '.' {\n                return 1l\n            }\n            if note_string.charAt(0) == '|' {\n                return 2l\n            }\n            return 0l\n        }\n        def parseMusic(note_string : String) : List[Long] = {\n            if note_string.length() == 0 {\n                return List[Long]()\n            }\n            if note_string.charAt(0) == 'o' {\n                return List[Long](parseDuration(note_string.substring(1)), parseDuration(note_string.substring(1)))\n            }\n            if note_string.charAt(0) == '.' {\n                return List[Long](parseDuration(note_string.substring(1)))\n            }\n            if note_string.charAt(0) == '|' {\n                return List[Long](parseDuration(note_string.substring(1)))\n            }\n            return List[Long](parseDuration(note_string))\n        }\n        return List[Long](parseNote(music_string.substring(0, music_string.length() - 1)),\n                          parseMusic(music_string.substring(music_string.length() - 1)))\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3_jb4dy3.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mif\u001b[0m note_string.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'o'\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^\u001b[0m\n\u001b[31m   |\u001b[0m            'then' expected, but 'if' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3_jb4dy3.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m note_string.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'|'\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^\u001b[0m\n\u001b[31m   |\u001b[0m            'then' expected, but 'if' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3_jb4dy3.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            \u001b[33mif\u001b[0m note_string.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'o'\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^\u001b[0m\n\u001b[31m   |\u001b[0m            'then' expected, but 'if' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3_jb4dy3.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            \u001b[33mif\u001b[0m note_string.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'|'\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^\u001b[0m\n\u001b[31m   |\u001b[0m            'then' expected, but 'if' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3_jb4dy3.scala:48:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m            \u001b[33mif\u001b[0m note_string.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'o'\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^\u001b[0m\n\u001b[31m   |\u001b[0m            'then' expected, but 'if' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3_jb4dy3.scala:54:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m            \u001b[33mif\u001b[0m note_string.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'|'\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^\u001b[0m\n\u001b[31m   |\u001b[0m            'then' expected, but 'if' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp3_jb4dy3.scala:15:39 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.length() == \u001b[31m0\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     expression does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation avail",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var notes = music_string.split(\" \")\n        var beats = List[Long]()\n        for (i <- 0 until notes.length) {\n            var note = notes[i]\n            var note_count = 0\n            var note_length = 0\n            if (note.contains(\"o\")) {\n                note_count = 4\n                note_length = 4\n            } else if (note.contains(\"o|\")) {\n                note_count = 2\n                note_length = 2\n            } else if (note.contains(\".|\")) {\n                note_count = 1\n                note_length = 1\n            }\n            beats = beats.append(note_count * note_length)\n        }\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292823,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwc22zezg.scala:17:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mnote\u001b[0m = notes[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwc22zezg.scala:30:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            beats = beats.append(note_count * note_length)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if (note_string.length() == 0) {\n                return 0l\n            }\n            if (note_string.charAt(0) == '.') {\n                return 1l\n            }\n            if (note_string.charAt(0) == '|') {\n                return 2l\n            }\n            if (note_string.charAt(0) == 'o') {\n                return 4l\n            }\n            return 0l\n        }\n        def parseDuration(note_string : String) : Long = {\n            if (note_string.length() == 0) {\n                return 0l\n            }\n            if (note_string.charAt(0) == '.') {\n                return 1l\n            }\n            if (note_string.charAt(0) == '|') {\n                return 2l\n            }\n            if (note_string.charAt(0) == 'o') {\n                return 4l\n            }\n            return 0l\n        }\n        def parseBeat(note_string : String) : Long = {\n            if (note_string.length() == 0) {\n                return 0l\n            }\n            if (note_string.charAt(0) == '.') {\n                return 1l\n            }\n            if (note_string.charAt(0) == '|') {\n                return 2l\n            }\n            if (note_string.charAt(0) == 'o') {\n                return 4l\n            }\n            return 0l\n        }\n        def parseMusic(note_string : String) : List[Long] = {\n            var beat_count : Long = 0l\n            var note_count : Long = 0l\n            var note_duration : Long = 0l\n            var note_beat : Long = 0l\n            var note_string_copy : String = note_string\n            while (note_string_copy.length() > 0) {\n                note_count += 1\n                note_duration = parseDuration(note_string_copy)\n                note_beat = parseBeat(note_string_copy)\n                beat_count += note_beat\n                \n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292824,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfgn_mdm5.scala:81:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfgn_mdm5.scala:80:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpfgn_mdm5.scala:72:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m72 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var beat_counts = mutable.List[Long]()\n        var beat_count = 0\n        var note_count = 0\n        var note_count_prev = 0\n        var note_count_prev_prev = 0\n        var note_count_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var note_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292820,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0o9jdu55.scala:35:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0o9jdu55.scala:14:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mbeat_counts\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0o9jdu55.scala:35:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string == \"o\" {\n                return 4l\n            } else if note_string == \"o|\" {\n                return 2l\n            } else if note_string == \".|\" {\n                return 1l\n            } else {\n                return 0l\n            }\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if beat_string == \"o\" {\n                return 4l\n            } else if beat_string == \"o|\" {\n                return 2l\n            } else if beat_string == \".|\" {\n                return 1l\n            } else {\n                return 0l\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var beat_counts : List[Long] = List.empty()\n            var beat_count : Long = 0l\n            var note_count : Long = 0l\n            var note_count_prev : Long = 0l\n            var note_count_prev_prev : Long = 0l\n            for(i <- 0 until music_string.length) {\n                var note_count_prev_prev_prev : Long = note_count_prev_prev\n                var note_count_prev : Long = note_count\n                var note_count : Long = parseNote(music_string[i])\n                if note_count > 0 {\n                    beat_count += note_count\n                    note_count_prev = note_count\n                }\n                if note_count_prev_prev_prev > 0 {\n                    beat_count += note_count_prev_prev_prev\n                    note_count_prev_prev = note_count_prev\n                }\n                if beat_count > beat_counts.last {\n                    beat_counts = beat_counts.append(beat_count)\n                }\n            }\n            return beat_counts\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292826,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpa4p3zghl.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpa4p3zghl.scala:28:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m beat_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpa4p3zghl.scala:50:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m                \u001b[33mif\u001b[0m note_count_prev_prev_prev > \u001b[31m0\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^\u001b[0m\n\u001b[31m   |\u001b[0m                'then' expected, but 'if' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpa4p3zghl.scala:57:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m            }\n\u001b[31m\u001b[31m   |\u001b[0m            ^\u001b[0m\n\u001b[31m   |\u001b[0m            'then' expected, but '}' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpa4p3zghl.scala:15:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m16 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31m4l\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m-- Error: /tmp/tmpa4p3zghl.scala:26:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m beat_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m27 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31m4l\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m beat_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m-- Error: /tmp/tmpa4p3zghl.scala:37:53 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.contains(\".\") {\n                def parseQuater(note_string : String) : Long = {\n                    if note_string.contains(\"|\") {\n                        return 1l\n                    } else {\n                        return 0l\n                    }\n                }\n                return 4l * parseQuater(note_string)\n            } else if note_string.contains(\"|\") {\n                return 2l\n            } else {\n                return 1l\n            }\n        }\n        return List(music_string.split(\" \").map(note_string => parseNote(note_string)).toSeq.toList)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292826,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmps170ey7x.scala:19:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                    } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmps170ey7x.scala:24:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmps170ey7x.scala:15:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\".\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mcontains\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmps170ey7x.scala:17:43 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                    \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mcontains\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmps170ey7x.scala:30:93 --------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mreturn\u001b[0m List(music_string.split(\u001b[31m\" \"\u001b[0m).map(\u001b[36mnote_string\u001b[0m => parseNote(note_string)).toSeq.toList)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Found:    \u001b[1m\u001b[31mList\u001b[0m\u001b[1m\u001b[31m[\u001b[0mLong\u001b[1m\u001b[31m]\u001b[0m\n\u001b[31m   |\u001b[0m                    Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.equals(\".\") {\n                return 0l\n            } else if note_string.equals(\"o\") {\n                return 4l\n            } else if note_string.equals(\"o|\") {\n                return 2l\n            } else {\n                return 1l\n            }\n        }\n        def parseMusic(note_list : List[String]) : List[Long] = {\n            var beats = List[Long]()\n            for (note_string : note_list) {\n                beats = beats.append(parseNote(note_string))\n            }\n            return beats\n        }\n        return parseMusic(music_string.split(\" \"))\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292828,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpsbo_yi50.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpsbo_yi50.scala:27:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mfor\u001b[0m (note_string : \u001b[35mnote_list\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          '<-' expected, but '{' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpsbo_yi50.scala:15:33 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\".\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             \u001b[33mmethod\u001b[0m \u001b[35mequals\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsbo_yi50.scala:29:13 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            }\n\u001b[31m\u001b[31m   |\u001b[0m             ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator asScala\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.map AsScala",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if (note_string.length() == 1) {\n                return 1l\n            } else if (note_string.charAt(1) == '|') {\n                return 2l\n            } else if (note_string.charAt(1) == '.') {\n                return 4l\n            } else {\n                return 1l\n            }\n        }\n        def parseDuration(note_string : String) : Long = {\n            if (note_string.charAt(0) == 'o') {\n                return 4l\n            } else if (note_string.charAt(0) == 'o') {\n                return 2l\n            } else if (note_string.charAt(0) == '.') {\n                return 1l\n            } else {\n                return 1l\n            }\n        }\n        def parseBeat(note_string : String) : Long = {\n            return note_string.length() / 2\n        }\n        def parseMusic(note_string : String) : List[Long] = {\n            var notes = note_string.split(\" \")\n            var beats = notes.map(parseNote).toSeq.toList\n            var durations = notes.map(parseDuration).toSeq.toList\n            var beats_and_durations = zip(beats, durations).toSeq.toList\n            var beats_and_durations_and_beat = zip(beats_and_durations, beats).toSeq.toList\n            var beats_and_durations_and_beat_and_beat = zip(beats_and_durations_and_beat, beats_and_durations).toSeq.toList\n            var beats_and_durations_and_beat_and_beat_and_beat = zip(beats_and_durations_and_beat_and_beat, beats_and_durations_and_beat).toSeq.toList\n            var beats_and_durations_and_beat_and_beat_and_beat_and_beat = zip(beats_and_durations_and_beat_and_beat_and_beat, beats_\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292830,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpq_vpcej3.scala:48:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpq_vpcej3.scala:58:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq_vpcej3.scala:43:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mbeats_and_durations\u001b[0m = zip(beats, durations).toSeq.toList\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Not found: zip\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq_vpcej3.scala:44:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mbeats_and_durations_and_beat\u001b[0m = zip(beats_and_durations, beats).toSeq.toList\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                               Not found: zip\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq_vpcej3.scala:45:56 ------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mbeats_and_durations_and_beat_and_beat\u001b[0m = zip(beats_and_durations_and_beat, beats_and_durations).toSeq.toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                        Not found: zip\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq_vpcej3.scala:46:65 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mbeats_and_durations_and_beat_and_beat_and_beat\u001b[0m = zip(beats_and_durations_and_beat_and_beat, beats_and_durations_and_beat).toSeq.toList\n\u001b[31m\u001b[31m ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if (note_string == \".\") {\n                return 0l\n            } else if (note_string == \"o\") {\n                return 4l\n            } else if (note_string == \"o|\") {\n                return 2l\n            } else {\n                throw new IllegalArgumentException(\"Invalid note: \" + note_string)\n            }\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if (beat_string == \".\") {\n                return 0l\n            } else if (beat_string == \"o\") {\n                return 1l\n            } else if (beat_string == \"o|\") {\n                return 2l\n            } else {\n                throw new IllegalArgumentException(\"Invalid beat: \" + beat_string)\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var result = List[Long]()\n            var beat_count = 0\n            var note_count = 0\n            var note_index = 0\n            var beat_index = 0\n            for (i <- 0 until music_string.length) {\n                if (music_string[i] == '.') {\n                    result = append(result, note_count)\n                    note_count = 0\n                    beat_count += 1\n                    note_index = i + 1\n                    beat_index = 0\n                } else if (music_string[i] == 'o') {\n                    note_count += 1\n                    beat_count += 1\n                    beat_index = i + 1\n                } else if (music_string[i] == 'o|') {\n                    note_count += 1\n                    beat_count += 2\n                    beat_index = i + 1\n                }\n            }\n            result = append(result, note_count)\n            return result\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292826,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp2l5b2usv.scala:53:46 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_string[i] == \u001b[31m'o\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0msymbol literal 'o is no longer supported,\n\u001b[31m   |\u001b[0muse a string literal \"o\" or an application Symbol(\"o\") instead,\n\u001b[31m   |\u001b[0mor enclose in braces '{o} if you want a quoted expression.\n\u001b[31m   |\u001b[0mFor now, you can also `import language.deprecated.symbolLiterals` to accept\n\u001b[31m   |\u001b[0mthe idiom, but this possibility might no longer be available in the future.\n\u001b[31m\u001b[31m-- Error: /tmp/tmp2l5b2usv.scala:53:49 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_string[i] == \u001b[31m'o\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              unclosed character literal\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2l5b2usv.scala:43:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m                \u001b[33mif\u001b[0m (music_string[\u001b[35mi\u001b[0m] == \u001b[31m'.'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2l5b2usv.scala:44:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m                    result = append(result, note_count)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: append\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2l5b2usv.scala:49:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_string[i] == \u001b[31m'o'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m              ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.equals(\".\") {\n                return 0l\n            } else if note_string.equals(\"o\") {\n                return 4l\n            } else if note_string.equals(\"o|\") {\n                return 2l\n            } else {\n                return 1l\n            }\n        }\n        def parseDuration(note_string : String) : Long = {\n            if note_string.equals(\".\") {\n                return 0l\n            } else if note_string.equals(\"o\") {\n                return 4l\n            } else if note_string.equals(\"o|\") {\n                return 2l\n            } else {\n                return 1l\n            }\n        }\n        def parseMusic(note_string : String) : List[Long] = {\n            def parseNote(note_string : String) : Long = {\n                if note_string.equals(\".\") {\n                    return 0l\n                } else if note_string.equals(\"o\") {\n                    return 4l\n                } else if note_string.equals(\"o|\") {\n                    return 2l\n                } else {\n                    return 1l\n                }\n            }\n            def parseDuration(note_string : String) : Long = {\n                if note_string.equals(\".\") {\n                    return 0l\n                } else if note_string.equals(\"o\") {\n                    return 4l\n                } else if note_string.equals(\"o|\") {\n                    return 2l\n                } else {\n                    return 1l\n                }\n            }\n            def parseMusic(note_string : String) : List[Long] = {\n                def parseNote(note_string : String) : Long = {\n                    if note_string.equals(\".\") {\n                        return 0l\n                    } else if note_string.equals(\"o\") {\n                        return 4l\n                    } else if note_string.equals(\"o|\") {\n                        return 2l\n                    } else {\n                        return 1l\n                    }\n                }\n                def parseDuration(note_string : String) : Long = {\n                    if note_string.equals\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292819,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp5h4uq0u.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp5h4uq0u.scala:28:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp5h4uq0u.scala:40:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp5h4uq0u.scala:51:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp5h4uq0u.scala:63:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m                    } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp5h4uq0u.scala:73:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    'then' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp5h4uq0u.scala:83:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m83 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpp5h4uq0u.scala:15:33 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\".\"\u001b[0m) {\n\u001b[31m\u001b[31m  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var result = mutable.List[Long]()\n        var current_note = mutable.List[String]()\n        var current_duration = mutable.List[Long]()\n        var current_duration_count = mutable.List[Long]()\n        var current_duration_count_count = mutable.List[Long]()\n        var current_duration_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292782,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5efqvz3p.scala:33:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5efqvz3p.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5efqvz3p.scala:15:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_note\u001b[0m = mutable.List[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5efqvz3p.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5efqvz3p.scala:17:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration_count\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5efqvz3p.scala:18:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration_count_count\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asScalaBuffer(music_string.split(\" \")).toList\n        val beats = mutable.List[Long]()\n        for (i <- 0 until music_list.size) {\n            val note = music_list(i)\n            if (note.contains(\"o\")) {\n                beats.append(4l)\n            } else if (note.contains(\"o|\")) {\n                beats.append(2l)\n            } else if (note.contains(\".|\")) {\n                beats.append(1l)\n            } else {\n                beats.append(0l)\n            }\n        }\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9z98xnp0.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(music_string.split(\u001b[31m\" \"\u001b[0m)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9z98xnp0.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        val beats = mutable.List[Long]()\n        for (i <- 0 until music_list.length) {\n            if (music_list[i].equals(\".\")) {\n                beats.append(1l)\n            } else if (music_list[i].equals(\"o\")) {\n                beats.append(4l)\n            } else if (music_list[i].equals(\"o|\")) {\n                beats.append(2l)\n            } else {\n                beats.append(0l)\n            }\n        }\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292830,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwrzlrang.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwrzlrang.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwrzlrang.scala:17:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mif\u001b[0m (music_list[\u001b[35mi\u001b[0m].equals(\u001b[31m\".\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwrzlrang.scala:19:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_list[i].equals(\u001b[31m\"o\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwrzlrang.scala:21:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_list[i].equals(\u001b[31m\"o|\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.replaceAll(\"[^0-9]\", \"\")).map(_.toLong).toList\n        val result = beats.map(b -> b / 4).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292827,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpik56wb9f.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = beats.map(b -> b / \u001b[31m4\u001b[0m).toList\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: b\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        val beats = mutable.List[Long]()\n        for (i <- 0 until music_list.length) {\n            val note = music_list[i]\n            if (note.equals(\".\")) {\n                beats.append(1l)\n            } else if (note.equals(\"o\")) {\n                beats.append(4l)\n            } else if (note.equals(\"o|\")) {\n                beats.append(2l)\n            } else {\n                throw new RuntimeException(\"Invalid note: \" + note)\n            }\n        }\n        return beats.toSeq().toList()\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292829,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1ndl196x.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1ndl196x.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1ndl196x.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnote\u001b[0m = music_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var result = mutable.List[Long]()\n        var current_note = \"\"\n        var current_duration = 0\n        var current_duration_count = 0\n        var current_duration_count_start = 0\n        var current_duration_count_end = 0\n        var current_duration_count_start_end = 0\n        var current_duration_count_start_end_end = 0\n        var current_duration_count_start_end_end_end = 0\n        var current_duration_count_start_end_end_end_end = 0\n        var current_duration_count_start_end_end_end_end_end = 0\n        var current_duration_count_start_end_end_end_end_end_end = 0\n        var current_duration_count_start_end_end_end_end_end_end_end = 0\n        var current_duration_count_start_end_end_end_end_end_end_end_end = 0\n        var current_duration_count_start_end_end_end_end_end_end_end_end_end = 0\n        var current_duration_count_start_end_end_end_end_end_end_end_end_end_end = 0\n        var current_duration_count_start_end_end_end_end_end_end_end_end_end_end_end = 0\n        var current_duration_count_start_end_end_end_end_end_end_end_end_end_end_end_end = 0\n        var current_duration_count_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n        var current_duration_count_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n        var current_duration_count_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0\n        var current_duration_count_start_end_end_end_end_end_end_end_end_end_end\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp32t22pav.scala:36:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp32t22pav.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp32t22pav.scala:36:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var result = mutable.List[Long]()\n        var current_note = mutable.StringBuilder()\n        var current_duration = mutable.StringBuilder()\n        var current_duration_count = 0\n        var current_duration_value = 0\n        var current_duration_value_count = 0\n        var current_duration_value_value = 0\n        var current_duration_value_value_count = 0\n        var current_duration_value_value_value = 0\n        var current_duration_value_value_value_count = 0\n        var current_duration_value_value_value_value = 0\n        var current_duration_value_value_value_value_count = 0\n        var current_duration_value_value_value_value_value = 0\n        var current_duration_value_value_value_value_value_count = 0\n        var current_duration_value_value_value_value_value_value = 0\n        var current_duration_value_value_value_value_value_value_count = 0\n        var current_duration_value_value_value_value_value_value_value = 0\n        var current_duration_value_value_value_value_value_value_value_count = 0\n        var current_duration_value_value_value_value_value_value_value_value = 0\n        var current_duration_value_value_value_value_value_value_value_value_count = 0\n        var current_duration_value_value_value_value_value_value_value_value_value = 0\n        var current_duration_value_value_value_value_value_value_value_value_value_count = 0\n        var current_duration_value_value_value_value_value_value_value_value_value_value = 0\n        var current_duration_value_value_value_value_value_value_value_value_value_value_count = 0\n        var current_duration_value_value_value_value_value_value_value_value_value_value_value = 0\n        var current_duration_value_value_value_value_value_value_value_value_value_value_value_count = 0\n        \n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwd6u1o7l.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwd6u1o7l.scala:15:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_note\u001b[0m = mutable.StringBuilder()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwd6u1o7l.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration\u001b[0m = mutable.StringBuilder()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwd6u1o7l.scala:41:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.replaceAll(\"[^0-9.]\", \"\"))\n        val beats_list = beats.map(Long.parseLong).toList\n        return beats_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292794,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptkx6fze5.scala:16:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats_list\u001b[0m = beats.map(Long.parseLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value parseLong is not a member of object Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmptkx6fze5.scala:16:50 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats_list\u001b[0m = beats.map(Long.parseLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).filter(_.nonEmpty).map(_.toLong).toList\n        val result = beats.map(_.toLong).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292796,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"o\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$3(tmpp4atlo5e.scala:15)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseMusic(tmpp4atlo5e.scala:15)\n\tat Problem$.main(tmpp4atlo5e.scala:21)\n\tat Problem.main(tmpp4atlo5e.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.replaceAll(\"[^0-9.]\", \"\"))\n        val result = beats.map(noteToBeats).reduce(_.add)\n        return result\n    }\n\n    // Converts note to number of beats\n    def noteToBeats(note : String) : Long = {\n        val note_parts = note.split(\".\")\n        val note_part_1 = note_parts[0]\n        val note_part_2 = note_parts.length > 1 ? note_parts[1] : \"\"\n        val note_part_3 = note_parts.length > 2 ? note_parts[2] : \"\"\n        val note_part_4 = note_parts.length > 3 ? note_parts[3] : \"\"\n        val note_part_5 = note_parts.length > 4 ? note_parts[4] : \"\"\n        val note_part_6 = note_parts.length > 5 ? note_parts[5] : \"\"\n        val note_part_7 = note_parts.length > 6 ? note_parts[6] : \"\"\n        val note_part_8 = note_parts.length > 7 ? note_parts[7] : \"\"\n        val note_part_9 = note_parts.length > 8 ? note_parts[8] : \"\"\n        val note_part_10 = note_parts.length > 9 ? note_parts[9] : \"\"\n        val note_part_11 = note_parts.length > 10 ? note_parts[10] : \"\"\n        val note_part_12 = note_parts.length > 11 ? note_parts[11] : \"\"\n        val note_part_13 = note_parts.length > 12 ? note_parts[12] : \"\"\n        val note_part_14 = note_parts.length > 13 ? note_parts[13] : \"\"\n        val note_part_15 = note_parts.length > 14 ? note_parts[14] : \"\"\n        val note_part_16 = note_parts.length > 15 ? note_parts[15] : \"\"\n        val note_part_17 = note_parts.length > 16 ?\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292834,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpobsj5p4h.scala:39:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnote_part_17\u001b[0m = note_parts.length > \u001b[31m16\u001b[0m ?\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpobsj5p4h.scala:16:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = beats.map(noteToBeats).reduce(_.add)\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 2\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpobsj5p4h.scala:17:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mreturn\u001b[0m result\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Found:    (result : Long)\n\u001b[31m   |\u001b[0m               Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpobsj5p4h.scala:23:36 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnote_part_1\u001b[0m = note_parts[\u001b[31m0\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mArray\u001b[0m does not take type parameters\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpobsj5p4h.scala:24:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnote_part_2\u001b[0m = note_parts.length > \u001b[31m1\u001b[0m ? note_parts[\u001b[31m1\u001b[0m] : \u001b[31m\"\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                          value ? is not a member of Int\n\u001b[31m\u001b[31m-- Error: /tmp/tmpobsj5p4h.scala:24:60 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var notes = scala.collection.immutable.List.empty\n        for (i <- 0 until music_string.length) {\n            var note = music_string.charAt(i)\n            if (note == 'o') {\n                notes = notes.append(4l)\n            } else if (note == 'o|') {\n                notes = notes.append(2l)\n            } else if (note == '.') {\n                notes = notes.append(1l)\n            }\n        }\n        return notes.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292831,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp7don0il4.scala:19:31 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (note == \u001b[31m'o\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0msymbol literal 'o is no longer supported,\n\u001b[31m   |\u001b[0muse a string literal \"o\" or an application Symbol(\"o\") instead,\n\u001b[31m   |\u001b[0mor enclose in braces '{o} if you want a quoted expression.\n\u001b[31m   |\u001b[0mFor now, you can also `import language.deprecated.symbolLiterals` to accept\n\u001b[31m   |\u001b[0mthe idiom, but this possibility might no longer be available in the future.\n\u001b[31m\u001b[31m-- Error: /tmp/tmp7don0il4.scala:19:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (note == \u001b[31m'o\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  unclosed character literal\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7don0il4.scala:18:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                notes = notes.append(\u001b[31m4l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Nothing] - did you mean List[Nothing].appended?\n\u001b[33m\u001b[33m-- [E129] Potential Issue Warning: /tmp/tmp7don0il4.scala:24:8 -----------------\u001b[0m\u001b[0m\n\u001b[33m23 |\u001b[0m            }\n\u001b[33m24 |\u001b[0m        }\n\u001b[33m\u001b[33m   |\u001b[0m             ^\u001b[0m\n\u001b[33m   |\u001b[0mA pure expression does nothing in statement position; you may be omitting necessary parentheses\n\u001b[33m   |\u001b[0m\n\u001b[33m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 warning found\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.replaceAll(\"[^0-9.]\", \"\")).map(_.toLong).toList\n        val result = beats.map(b -> b / 4).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292830,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2pcu1kve.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = beats.map(b -> b / \u001b[31m4\u001b[0m).toList\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: b\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.contains(\"o\") {\n                return 4L\n            } else if note_string.contains(\"o|\") {\n                return 2L\n            } else if note_string.contains(\".|\") {\n                return 1L\n            } else {\n                return 0L\n            }\n        }\n        def parseBeat(note_string : String) : Long = {\n            if note_string.contains(\"o\") {\n                return 4L\n            } else if note_string.contains(\"o|\") {\n                return 2L\n            } else if note_string.contains(\".|\") {\n                return 1L\n            } else {\n                return 0L\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var beat_counts : List[Long] = List.empty()\n            var beat_count : Long = 0L\n            var note_count : Long = 0L\n            var note_count_in_beat : Long = 0L\n            var note_count_in_beat_in_beat : Long = 0L\n            var note_count_in_beat_in_beat_in_beat : Long = 0L\n            var note_count_in_beat_in_beat_in_beat_in_beat : Long = 0L\n            var note_count_in_beat_in_beat_in_beat_in_beat_in_beat : Long = 0L\n            var note_count_in_beat_in_beat_in_beat_in_beat_in_beat_in_beat : Long = 0L\n            var note_count_in_beat_in_beat_in_beat_in_beat_in_beat_in_beat_in_beat : Long = 0L\n            var note_count_in_beat_in_beat_in_beat_in_beat_in_beat_in_beat_in_beat_in_beat : Long = 0L\n            var note_count_in_beat_in_beat_in_beat_in_beat_in_beat_in_beat_in_beat_in_beat_\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292834,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpces6_1a5.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"o|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpces6_1a5.scala:28:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"o|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpces6_1a5.scala:49:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpces6_1a5.scala:59:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpces6_1a5.scala:15:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mcontains\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpces6_1a5.scala:26:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mcontains\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpces6_1a5.scala:37:53 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mbeat_counts\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = List.empty()",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.replaceAll(\"[^0-9.]\", \"\")).map(_.toLong).toList\n        val result = beats.map(b -> b.toLong)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292766,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp26mt5u14.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = beats.map(b -> b.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: b\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.charAt(0) == 'o' {\n                return 4l\n            } else if note_string.charAt(0) == 'o|' {\n                return 2l\n            } else if note_string.charAt(0) == '.' {\n                return 1l\n            } else {\n                return 0l\n            }\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if beat_string.charAt(0) == 'o' {\n                return 4l\n            } else if beat_string.charAt(0) == 'o|' {\n                return 2l\n            } else if beat_string.charAt(0) == '.' {\n                return 1l\n            } else {\n                return 0l\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var beat_counts : List[Long] = List.empty()\n            var beat_count : Long = 0l\n            var note_count : Long = 0l\n            var note_count_prev : Long = 0l\n            var note_count_prev_prev : Long = 0l\n            var note_count_prev_prev_prev : Long = 0l\n            var note_count_prev_prev_prev_prev : Long = 0l\n            var note_count_prev_prev_prev_prev_prev : Long = 0l\n            var note_count_prev_prev_prev_prev_prev_prev : Long = 0l\n            var note_count_prev_prev_prev_prev_prev_prev_prev : Long = 0l\n            var note_count_prev_prev_prev_prev_prev_prev_prev_prev : Long = 0l\n            var note_count_prev_prev_prev_prev_prev_prev_prev_prev_prev : Long = 0l\n            var note_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev : Long = 0l\n            var note_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev : Long =\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292833,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmps5ye3t5v.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'o\u001b[0m|' {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmps5ye3t5v.scala:28:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m beat_string.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'o\u001b[0m|' {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmps5ye3t5v.scala:50:90 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mnote_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev\u001b[0m : \u001b[35mLong\u001b[0m =\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmps5ye3t5v.scala:61:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmps5ye3t5v.scala:15:40 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'o'\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     expression does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmps5ye3t5v.scala:26:40 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m beat_string.charAt(\u001b[31m0\u001b[0m) == \u001b[31m'o'\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     expressio",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(note -> {\n            val note_chars = note.split(\"|\")\n            val note_length = note_chars.length\n            val note_beats = note_length - 1\n            val note_beat_length = note_chars[note_length - 1]\n            return note_beat_length.toLong\n        })\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292832,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplmry5dat.scala:15:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = notes.map(note -> {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: note\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmplmry5dat.scala:21:10 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        })\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.equals(\".\") {\n                return 0l\n            } else if note_string.equals(\"o\") {\n                return 4l\n            } else if note_string.equals(\"o|\") {\n                return 2l\n            } else {\n                return 1l\n            }\n        }\n        def parseMusic(note_list : List[String]) : List[Long] = {\n            if note_list.length == 0 {\n                return List[Long]()\n            } else {\n                return List[Long](parseNote(note_list[0]), parseMusic(note_list[1:]))\n            }\n        }\n        return parseMusic(music_string.split(\" \"))\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292833,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpflytq1kz.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpflytq1kz.scala:28:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpflytq1kz.scala:15:33 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\".\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             \u001b[33mmethod\u001b[0m \u001b[35mequals\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpflytq1kz.scala:26:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m note_list.length == \u001b[31m0\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   expression does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpflytq1kz.scala:32:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mreturn\u001b[0m parseMusic(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    \u001b[1m\u001b[31mArray\u001b[0m[String]\n\u001b[31m   |\u001b[0m                          Required: \u001b[1m\u001b[32mList\u001b[0m[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- [E129] Potential Issue Warning: /tmp/tmpflytq1kz.scala:24:8 -----------------\u001b[0m\u001b[0m\n\u001b[33m23 |\u001b[0m            }\n\u001b[33m24 |\u001b[0m        }\n\u001b[33m\u001b[33m   |\u001b[0m             ^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asScalaBuffer(List.of(music_string.split(\" \")))\n        val music_scala = scala.collection.mutable.Buffer[String]()\n        for (i <- 0 until music_list.length) {\n            val note = music_list.get(i)\n            if (note.contains(\".\")) {\n                val note_list = note.split(\"\\\\.\")\n                val note_scala = scala.collection.mutable.Buffer[String]()\n                for (j <- 0 until note_list.length) {\n                    note_scala.append(note_list[j])\n                }\n                music_scala.append(note_scala.toList())\n            } else {\n                music_scala.append(note)\n            }\n        }\n        val music_scala_list = scala.collection.JavaConversions.asScalaBuffer(music_scala.toList())\n        val music_list_scala = scala.collection.mutable.Buffer[Long]()\n        for (i <- 0 until music_scala_list.length) {\n            val note_scala = music_scala_list.get(i)\n            val note_list = note_scala.toList()\n            val note_list_scala = scala.collection.mutable.Buffer[Long]()\n            for (j <- 0 until note_list.length) {\n                note_list_scala.append(note_list[j].toLong)\n            }\n            music_list_scala.append(note_list_scala.toList())\n        }\n        val music_list_scala_list = scala.collection.JavaConversions.asScalaBuffer(music_list_scala.toList())\n        val music_list_scala_list_list = scala.collection.JavaConversions.asScalaBuffer(music_list_scala_list.toList())\n        val music_list_scala_list_list_list = scala.collection.JavaConversions.asScalaBuffer(music_list_scala_list_list.toList())\n\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292836,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl65dybac.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(List.of(music_string.split(\u001b[31m\" \"\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl65dybac.scala:22:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                    note_scala.append(note_list[\u001b[35mj\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpl65dybac.scala:24:52 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                music_scala.append(note_scala.toList())\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl65dybac.scala:29:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_scala_list\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(music_scala.toList())\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl65dybac.scala:36:49 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                note_list_scala.append(note_list[\u001b[35mj\u001b[0m].toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                 Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(note => {\n            val note_str = note.replaceAll(\"[^o|.|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292834,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp31xaiapm.scala:16:43 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnote_str\u001b[0m = note.replaceAll(\"[^o|.|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|o|\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           unclosed string literal\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp31xaiapm.scala:18:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp31xaiapm.scala:27:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- Error: /tmp/tmp31xaiapm.scala:18:13 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m         too many arguments for \u001b[33mconstructor\u001b[0m \u001b[35mmain\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mmain\u001b[0m: (): main\n\u001b[31m\u001b[31m-- Error: /tmp/tmp31xaiapm.scala:24:5 ------------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m     where:    B is a type variable\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp31xaiapm.scala:26:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m}\n\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.replaceAll(\"[^0-9.]\", \"\"))\n        val result = beats.map(_.toLong).toList\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292837,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$3(tmpkhwehzxm.scala:16)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseMusic(tmpkhwehzxm.scala:16)\n\tat Problem$.main(tmpkhwehzxm.scala:20)\n\tat Problem.main(tmpkhwehzxm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        val beats = mutable.List[Long]()\n        for (i <- 0 until music_list.length) {\n            val note = music_list[i]\n            if (note.equals(\".\")) {\n                beats.append(1l)\n            } else if (note.equals(\"o\")) {\n                beats.append(4l)\n            } else if (note.equals(\"o|\")) {\n                beats.append(2l)\n            } else {\n                throw new IllegalArgumentException(\"Unknown note: \" + note)\n            }\n        }\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292836,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpn1eofdf_.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn1eofdf_.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn1eofdf_.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnote\u001b[0m = music_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var notes = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        var beats = scala.collection.mutable.ListBuffer[Long]()\n        for (note_index in notes.size()) {\n            var note = notes.get(note_index)\n            var note_length = note.length()\n            var note_beats = note_length / 4\n            if (note_length % 4 > 0) {\n                note_beats = note_beats + 1\n            }\n            beats.append(note_beats.toLong)\n        }\n        return beats.toList()\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292839,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp494oag6a.scala:16:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mfor\u001b[0m (note_index in notes.size()) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         '<-' expected, but '{' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp494oag6a.scala:14:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mnotes\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp494oag6a.scala:24:9 -------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m         ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator asScala\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.set asScala\n\u001b[31m   |\u001b[0m\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.contains(\"o\") {\n                return 4l\n            } else if note_string.contains(\"o|\") {\n                return 2l\n            } else if note_string.contains(\".|\") {\n                return 1l\n            } else {\n                return 0l\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var result = List[Long]()\n            var current_note = 0l\n            var current_beat = 0l\n            var current_note_count = 0l\n            for i in range(0, len(music_string)) {\n                if music_string[i] == '.' {\n                    current_note_count = parseNote(music_string[i + 1:i + 4])\n                    current_note = current_note + current_note_count\n                    current_beat = current_beat + current_note_count\n                    i = i + 4\n                } else if music_string[i] == '|' {\n                    current_note_count = parseNote(music_string[i + 1:i + 2])\n                    current_note = current_note + current_note_count\n                    current_beat = current_beat + current_note_count\n                    i = i + 2\n                } else {\n                    current_note_count = parseNote(music_string[i:i + 1])\n                    current_note = current_note + current_note_count\n                    current_beat = current_beat + current_note_count\n                }\n                if current_note_count > 0l {\n                    result = result + List[Long](current_beat)\n                    current_beat = 0l\n                    current_note = 0l\n                    current_note_count = 0l\n                }\n            }\n            return result\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292838,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpebp00x_y.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"o|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpebp00x_y.scala:30:49 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            \u001b[33mfor\u001b[0m i in range(\u001b[31m0\u001b[0m, len(music_string)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but '{' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpebp00x_y.scala:15:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mcontains\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpebp00x_y.scala:52:13 ------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m            }\n\u001b[31m\u001b[31m   |\u001b[0m             ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator asScala\n\u001b[31m   |\u001b[0m  import collection.convert.Implicit",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(note -> {\n            val note_length = note.length()\n            if (note_length == 1) {\n                return 1l\n            } else if (note_length == 2) {\n                return 2l\n            } else if (note_length == 3) {\n                return 4l\n            } else {\n                throw new IllegalArgumentException(\"Invalid note length: \" + note_length)\n            }\n        }).toList\n        return beats.map(b -> b.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292839,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0u6etrp2.scala:15:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = notes.map(_.trim).map(note -> {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                          Not found: note\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp0u6etrp2.scala:26:10 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        }).toList\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.contains(\".\") {\n                return note_string.replace(\".\", \"\").replace(\"|\", \"\").replace(\"o\", \"\").toLong\n            } else {\n                return note_string.replace(\"o\", \"\").replace(\"|\", \"\").toLong\n            }\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if beat_string.contains(\".\") {\n                return beat_string.replace(\".\", \"\").replace(\"|\", \"\").toLong\n            } else {\n                return beat_string.toLong\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var beat_counts = mutable.List[Long]()\n            var beat_count = 0\n            var note_count = 0\n            var note_counts = mutable.List[Long]()\n            var note_counts_count = 0\n            var note_counts_counts = mutable.List[Long]()\n            var note_counts_counts_count = 0\n            var note_counts_counts_counts = mutable.List[Long]()\n            var note_counts_counts_counts_count = 0\n            for (i <- 0 until music_string.length) {\n                if (music_string[i] == \".\") {\n                    beat_counts.append(beat_count)\n                    beat_count = 0\n                    note_counts_counts_counts_count = 0\n                    note_counts_counts_counts_count = 0\n                    note_counts_counts_counts_count = 0\n                    note_counts_counts_counts_count = 0\n                    note_counts_counts_counts_count = 0\n                    note_counts_counts_counts_count = 0\n                    note_counts_counts_counts_count = 0\n                    note_counts_counts_counts_count = 0\n                    note_counts_counts_counts_count = 0\n                    note_counts_counts_counts_count = 0\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292840,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5hqapfp4.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5hqapfp4.scala:24:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5hqapfp4.scala:62:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m62 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp5hqapfp4.scala:15:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\".\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mcontains\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp5hqapfp4.scala:22:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m beat_string.contains(\u001b[31m\".\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mcontains\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5hqapfp4.scala:29:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mbeat_counts\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5hqapfp4.scala:32:30 ------------------------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.endsWith(\"|\") {\n                return note_string.substring(0, note_string.length() - 1).toLong\n            } else {\n                return note_string.toLong\n            }\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if beat_string.endsWith(\"|\") {\n                return beat_string.substring(0, beat_string.length() - 1).toLong\n            } else {\n                return beat_string.toLong\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var beat_counts = mutable.List[Long]()\n            var note_counts = mutable.List[Long]()\n            var beat_index = 0\n            var note_index = 0\n            for (i <- 0 until music_string.length) {\n                if (music_string[i] == '.') {\n                    note_counts = note_counts.append(parseNote(music_string[note_index:i]))\n                    note_index = i + 1\n                } else if (music_string[i] == 'o') {\n                    beat_counts = beat_counts.append(parseBeat(music_string[beat_index:i]))\n                    beat_index = i + 1\n                }\n            }\n            beat_counts = beat_counts.append(parseBeat(music_string[beat_index:music_string.length]))\n            note_counts = note_counts.append(parseNote(music_string[note_index:music_string.length]))\n            return (beat_counts, note_counts)\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292840,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwvw2zw8y.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwvw2zw8y.scala:24:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwvw2zw8y.scala:35:86 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                    note_counts = note_counts.append(parseNote(music_string[\u001b[35mnote_index\u001b[0m:i]))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             ']' expected, but ':' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwvw2zw8y.scala:38:86 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                    beat_counts = beat_counts.append(parseBeat(music_string[\u001b[35mbeat_index\u001b[0m:i]))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             ']' expected, but ':' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwvw2zw8y.scala:42:78 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m            beat_counts = beat_counts.append(parseBeat(music_string[\u001b[35mbeat_index\u001b[0m:music_string.length]))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             ']' expected, but ':' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwvw2zw8y.scala:43:78 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m            note_counts = note_counts.append(parseNote(music_string[\u001b[35mnote_index\u001b[0m:music_string.length]))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                              ^\u001b[0m\n\u001b[31m ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.replaceAll(\"[^0-9.]\", \"\")).map(_.toLong).toList\n        val result = beats.map(b -> b.toLong).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292790,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpussqtf_7.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = beats.map(b -> b.toLong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: b\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(note -> {\n            val note_parts = note.split(\"|\")\n            val note_len = note_parts.length\n            if (note_len == 1) {\n                return 4l\n            } else if (note_len == 2) {\n                return 2l\n            } else if (note_len == 3) {\n                return 1l\n            } else {\n                throw new IllegalArgumentException(\"Invalid note: \" + note)\n            }\n        })\n        return beats.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292840,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6rzz9i5c.scala:15:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = notes.map(note -> {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: note\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp6rzz9i5c.scala:27:10 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        })\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m          where:    B is a type variable\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.replaceAll(\"[^0-9.]\", \"\")).map(_.toLong).toList\n        val result = beats.map(b -> b / 4).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292830,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2pcu1kve.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = beats.map(b -> b / \u001b[31m4\u001b[0m).toList\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: b\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        val beats = mutable.List[Long]()\n        for (i <- 0 until music_list.length) {\n            val note = music_list[i]\n            if (note.equals(\".\")) {\n                beats.append(0l)\n            } else if (note.equals(\"o\")) {\n                beats.append(4l)\n            } else if (note.equals(\"o|\")) {\n                beats.append(2l)\n            } else {\n                throw new IllegalArgumentException(\"Invalid note: \" + note)\n            }\n        }\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkntxb22r.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkntxb22r.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkntxb22r.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnote\u001b[0m = music_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var result = mutable.List[Long]()\n        var current_note = 0\n        var current_duration = 0\n        var current_beat = 0\n        var current_measure = 0\n        var current_measure_duration = 0\n        var current_measure_beat = 0\n        var current_measure_note = 0\n        var current_measure_duration_note = 0\n        var current_measure_duration_note_beat = 0\n        var current_measure_duration_note_beat_duration = 0\n        var current_measure_duration_note_beat_duration_note = 0\n        var current_measure_duration_note_beat_duration_note_beat = 0\n        var current_measure_duration_note_beat_duration_note_beat_duration = 0\n        var current_measure_duration_note_beat_duration_note_beat_duration_note = 0\n        var current_measure_duration_note_beat_duration_note_beat_duration_note_beat = 0\n        var current_measure_duration_note_beat_duration_note_beat_duration_note_beat_duration = 0\n        var current_measure_duration_note_beat_duration_note_beat_duration_note_beat_duration_note = 0\n        var current_measure_duration_note_beat_duration_note_beat_duration_note_beat_duration_note_beat = 0\n        var current_measure_duration_note_beat_duration_note_beat_duration_note_beat_duration_note_beat_duration = 0\n        var current_measure_duration_note_beat_duration_note_beat_duration_note_beat_duration_note_beat_duration_note = 0\n        var current_measure_duration_note_beat_duration_note_beat_duration_note_beat_duration_note_beat_duration_note_beat = 0\n        var current_measure_duration_note_beat_duration_note_beat_duration_note_beat_duration_note_beat_duration_note_beat_duration_note = 0\n        var current_measure_duration_note_beat_duration_note_beat_duration_note_beat_duration\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292841,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5fvyjbvb.scala:38:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5fvyjbvb.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5fvyjbvb.scala:38:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var result = mutable.List[Long]()\n        var note = \"\"\n        var beats = 0\n        var beat = 0\n        for(i <- 0 until music_string.length) {\n            if(music_string[i] == '.') {\n                note = note + \".\"\n                beat = beat + 1\n            } else if(music_string[i] == '|') {\n                note = note + \"|\"\n                beat = beat + 1\n            } else if(music_string[i] == 'o') {\n                note = note + \"o\"\n                beats = beats + beat\n                beat = 0\n            }\n        }\n        result = result + beats\n        result = result + note.toLong\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292839,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5mya9tzu.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5mya9tzu.scala:19:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mif\u001b[0m(music_string[\u001b[35mi\u001b[0m] == \u001b[31m'.'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5mya9tzu.scala:22:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m(music_string[i] == \u001b[31m'|'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5mya9tzu.scala:25:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m(music_string[i] == \u001b[31m'o'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).filter(_.nonEmpty).map(_.toLong).toList\n        val result = beats.map(b -> b / 4).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292839,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptsm5sh4j.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = beats.map(b -> b / \u001b[31m4\u001b[0m).toList\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: b\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.replaceAll(\"[^0-9.]\", \"\")).map(_.toLong).toList\n        val result = beats.map(b -> b / 4).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292830,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2pcu1kve.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = beats.map(b -> b / \u001b[31m4\u001b[0m).toList\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: b\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asScalaBuffer(music_string.split(\" \")).toList\n        val result = mutable.List[Long]()\n        for (i <- 0 until music_list.size) {\n            val note = music_list.get(i)\n            if (note.equals(\".\")) {\n                result.append(1l)\n            } else if (note.equals(\"o\")) {\n                result.append(4l)\n            } else if (note.equals(\"o|\")) {\n                result.append(2l)\n            } else {\n                result.append(0l)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292841,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy8zyol4f.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(music_string.split(\u001b[31m\" \"\u001b[0m)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy8zyol4f.scala:15:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var result = mutable.List[Long]()\n        var note_count = 0\n        var note_length = 0\n        var note_beats = 0\n        var note_index = 0\n        var note_index_prev = 0\n        var note_index_next = 0\n        var note_index_next_prev = 0\n        var note_index_next_next = 0\n        var note_index_next_next_prev = 0\n        var note_index_next_next_next = 0\n        var note_index_next_next_next_prev = 0\n        var note_index_next_next_next_next = 0\n        var note_index_next_next_next_next_prev = 0\n        var note_index_next_next_next_next_next = 0\n        var note_index_next_next_next_next_next_prev = 0\n        var note_index_next_next_next_next_next_next = 0\n        var note_index_next_next_next_next_next_next_prev = 0\n        var note_index_next_next_next_next_next_next_next = 0\n        var note_index_next_next_next_next_next_next_next_prev = 0\n        var note_index_next_next_next_next_next_next_next_next = 0\n        var note_index_next_next_next_next_next_next_next_next_prev = 0\n        var note_index_next_next_next_next_next_next_next_next_next = 0\n        var note_index_next_next_next_next_next_next_next_next_next_prev = 0\n        var note_index_next_next_next_next_next_next_next_next_next_next = 0\n        var note_index_next_next_next_next_next_next_next_next_next_next_prev = 0\n        var note_index_next_next_next_next_next_next_next_next_next_next_next = 0\n        var note_index_next_next_next_next_next_next_next_next_next_next_\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292842,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7lot9pwy.scala:42:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7lot9pwy.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7lot9pwy.scala:42:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = music_string.split(\" \")\n        val beats = mutable.List[Long]()\n        for (i <- 0 until music_list.length) {\n            val note = music_list[i]\n            if (note.equals(\".\")) {\n                beats.append(1l)\n            } else if (note.equals(\"o\")) {\n                beats.append(4l)\n            } else if (note.equals(\"o|\")) {\n                beats.append(2l)\n            } else {\n                throw new IllegalArgumentException(\"Invalid note: \" + note)\n            }\n        }\n        return beats.toList\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292840,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp86dz1amd.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp86dz1amd.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnote\u001b[0m = music_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var result = mutable.List[Long]()\n        var current_note = mutable.List[String]()\n        var current_beat = mutable.List[Long]()\n        var current_duration = mutable.List[Long]()\n        var current_duration_count = mutable.List[Long]()\n        var current_duration_count_index = mutable.List[Long]()\n        var current_duration_count_index_index = mutable.List[Long]()\n        var current_duration_count_index_index_index = mutable.List[Long]()\n        var current_duration_count_index_index_index_index = mutable.List[Long]()\n        var current_duration_count_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_count_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_count_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_count_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_count_index_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_count_index_index_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_count_index_index_index_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_count_index_index_index_index_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_count_index_index_index_index_index_index_index_index_index_index_index_index_index = mutable.List[Long]()\n        var current_duration_count_index_index_index_index_index_index_index_index_index_index_index_index_index_\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292843,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp1mvjmgiq.scala:33:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1mvjmgiq.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1mvjmgiq.scala:15:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_note\u001b[0m = mutable.List[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1mvjmgiq.scala:16:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_beat\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1mvjmgiq.scala:17:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1mvjmgiq.scala:18:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration_count\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long {\n            if note_string.length() == 1 {\n                return 1l.toLong\n            } else if note_string.length() == 2 {\n                return 2l.toLong\n            } else if note_string.length() == 3 {\n                return 4l.toLong\n            } else {\n                throw new RuntimeException(\"Invalid note string: \" + note_string)\n            }\n        }\n        def parseBeat(beat_string : String) : Long {\n            if beat_string.length() == 1 {\n                return 1l.toLong\n            } else if beat_string.length() == 2 {\n                return 2l.toLong\n            } else if beat_string.length() == 3 {\n                return 4l.toLong\n            } else {\n                throw new RuntimeException(\"Invalid beat string: \" + beat_string)\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] {\n            var result = List[Long]()\n            var current_beat = 1l.toLong\n            var current_note = 1l.toLong\n            var current_note_string = \"\"\n            var current_beat_string = \"\"\n            for (i <- 0 until music_string.length) {\n                if (music_string[i] == ' ') {\n                    current_note_string += music_string[i]\n                } else if (music_string[i] == '.') {\n                    current_note_string += music_string[i]\n                    current_note = parseNote(current_note_string)\n                    current_note_string = \"\"\n                } else if (music_string[i] == '|') {\n                    current_beat_string += music_string[i]\n                    current_beat = parseBeat(current_beat_string)\n                    current_beat_string = \"\"\n                } else {\n                    current_beat_string += music_string[i]\n                }\n            }\n            result = append(result, current_note * current_beat)\n            return result\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292840,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E103] Syntax Error: /tmp/tmpuk5b36hr.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.length() == \u001b[31m1\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^\u001b[0m\n\u001b[31m   |\u001b[0mIllegal start of declaration (possible cause: missing `=` in front of current method body)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E103] Syntax Error: /tmp/tmpuk5b36hr.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m beat_string.length() == \u001b[31m1\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^\u001b[0m\n\u001b[31m   |\u001b[0mIllegal start of declaration (possible cause: missing `=` in front of current method body)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpuk5b36hr.scala:37:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       refinement cannot be a mutable var.\n\u001b[31m   |\u001b[0m       You can use an explicit getter result and setter result_= instead\n\u001b[31m\u001b[31m-- Error: /tmp/tmpuk5b36hr.scala:38:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mcurrent_beat\u001b[0m = \u001b[31m1l\u001b[0m.toLong\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrefinement cannot be a mutable var.\n\u001b[31m   |\u001b[0mYou can use an explicit getter current_beat and setter current_beat_= instead\n\u001b[31m\u001b[31m-- Error: /tmp/tmpuk5b36hr.scala:39:16 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mcurrent_note\u001b[0m = \u001b[31m1l\u001b[0m.toLong\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrefinement cannot be a mutable var.\n\u001b[31m   |\u001b[0mYou can use an explicit getter current_note and setter current_note_= instead\n\u001b[31m\u001b[31m-- Error: /tmp/tmpuk5b36hr.scala:40:16 -----------------------------------------\u001b[0m\u001b[0m\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.replaceAll(\"[^0-9.]\", \"\")).map(_.toLong).toList\n        val result = beats.map(b => b.toLong)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292784,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$3(tmpun5j8ar8.scala:15)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseMusic(tmpun5j8ar8.scala:15)\n\tat Problem$.main(tmpun5j8ar8.scala:20)\n\tat Problem.main(tmpun5j8ar8.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        val beats = mutable.List[Long]()\n        for (i <- 0 until music_list.length) {\n            val note = music_list.apply(i)\n            if (note.equals(\".\")) {\n                beats.append(1l)\n            } else if (note.equals(\"o\")) {\n                beats.append(4l)\n            } else if (note.equals(\"o|\")) {\n                beats.append(2l)\n            } else {\n                throw new RuntimeException(\"Unknown note: \" + note)\n            }\n        }\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp522gnwog.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp522gnwog.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        val beats = mutable.List[Long]()\n        for (i <- 0 until music_list.length) {\n            val note = music_list.get(i).replaceAll(\"[^0-9]\", \"\")\n            if (note.equals(\".\")) {\n                beats.append(0l)\n            } else if (note.equals(\"o\")) {\n                beats.append(4l)\n            } else if (note.equals(\"o|\")) {\n                beats.append(2l)\n            } else if (note.equals(\".|\")) {\n                beats.append(1l)\n            } else {\n                throw new IllegalArgumentException(\"Invalid note: \" + note)\n            }\n        }\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292844,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpum9vc3zc.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpum9vc3zc.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        val beats = mutable.List[Long]()\n        for (i <- 0 until music_list.length - 1) {\n            val note = music_list.get(i)\n            if (note.equals(\".\")) {\n                beats.append(1l)\n            } else if (note.equals(\"o\")) {\n                beats.append(4l)\n            } else if (note.equals(\"o|\")) {\n                beats.append(2l)\n            }\n        }\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292845,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp67wzbgmo.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp67wzbgmo.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.replaceAll(\"[^0-9.]\", \"\"))\n        val beats_list = beats.map(_.toLong).toList\n        return beats_list\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292795,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$3(tmpvfwnqud3.scala:16)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseMusic(tmpvfwnqud3.scala:16)\n\tat Problem$.main(tmpvfwnqud3.scala:20)\n\tat Problem.main(tmpvfwnqud3.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.contains(\"o\") {\n                return 4l\n            } else if note_string.contains(\"o|\") {\n                return 2l\n            } else if note_string.contains(\".|\") {\n                return 1l\n            } else {\n                return 0l\n            }\n        }\n        def parseDuration(note_string : String) : Long = {\n            if note_string.contains(\"o\") {\n                return 4l\n            } else if note_string.contains(\"o|\") {\n                return 2l\n            } else if note_string.contains(\".|\") {\n                return 1l\n            } else {\n                return 0l\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var beat_count = 0l\n            var beat_duration = 0l\n            var beat_duration_prev = 0l\n            var beat_count_prev = 0l\n            var beat_count_next = 0l\n            var beat_duration_next = 0l\n            var beat_duration_next_prev = 0l\n            var beat_count_next_prev = 0l\n            var beat_count_next_next = 0l\n            var beat_duration_next_next = 0l\n            var beat_duration_next_next_prev = 0l\n            var beat_count_next_next_prev = 0l\n            var beat_count_next_next_next = 0l\n            var beat_duration_next_next_next = 0l\n            var beat_duration_next_next_next_prev = 0l\n            var beat_count_next_next_next_prev = 0l\n            var beat_count_next_next_next_next = 0l\n            var beat_duration_next_next_next_next = 0l\n            var beat_duration_next_next_next_next_prev = 0l\n            var beat_count_next_next_next_next_next = 0l\n            var beat_duration_next_next_next_next_next_prev = 0l\n            var beat_count_next_\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292847,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4mwgq3xh.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"o|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4mwgq3xh.scala:28:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"o|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4mwgq3xh.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4mwgq3xh.scala:69:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp4mwgq3xh.scala:15:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mcontains\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp4mwgq3xh.scala:26:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mcontains\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4mwgq3xh.scala:59:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Requi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var notes = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        var beats = scala.collection.mutable.ListBuffer[Long]()\n        for (i <- 0 until notes.length) {\n            var note = notes[i]\n            var beat = 0\n            if (note.contains(\"o\")) {\n                beat = 4\n            } else if (note.contains(\"o|\")) {\n                beat = 2\n            } else if (note.contains(\".|\")) {\n                beat = 1\n            }\n            beats.append(beat)\n        }\n        return beats.toList()\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphxhbxzpr.scala:14:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mnotes\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphxhbxzpr.scala:17:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mnote\u001b[0m = notes[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmphxhbxzpr.scala:28:27 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mreturn\u001b[0m beats.toList()\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): Long\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.replaceAll(\"[^0-9.]\", \"\")).map(_.toLong).toList\n        val result = beats.map(b -> b / 4).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292830,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2pcu1kve.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = beats.map(b -> b / \u001b[31m4\u001b[0m).toList\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: b\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.replaceAll(\"[^0-9.]\", \"\")).map(_.toLong).toList\n        val result = beats.map(_.toLong).toList\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292771,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$3(tmpq5ma97of.scala:15)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseMusic(tmpq5ma97of.scala:15)\n\tat Problem$.main(tmpq5ma97of.scala:20)\n\tat Problem.main(tmpq5ma97of.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.contains(\"o\") {\n                return 4L\n            } else if note_string.contains(\"o|\") {\n                return 2L\n            } else if note_string.contains(\".|\") {\n                return 1L\n            } else {\n                return 0L\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var result = mutable.List[Long]()\n            var note_count = mutable.List[Long]()\n            var note_index = 0\n            var note_string = \"\"\n            for (i <- 0 until music_string.length) {\n                if (music_string[i] == ' ') {\n                    note_count.update(parseNote(note_string))\n                    note_string = \"\"\n                    note_index += 1\n                } else {\n                    note_string += music_string[i]\n                }\n            }\n            note_count.update(parseNote(note_string))\n            for (i <- 0 until note_count.length) {\n                result.update(note_count[i])\n            }\n            return result\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4n3qf524.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"o|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp4n3qf524.scala:15:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mcontains\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4n3qf524.scala:26:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4n3qf524.scala:27:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mnote_count\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4n3qf524.scala:31:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                \u001b[33mif\u001b[0m (music_string[\u001b[35mi\u001b[0m] == \u001b[31m' '\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4n3qf524.scala:36:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    no",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var notes = new ArrayList[String]()\n        var beats = new ArrayList[Long]()\n        var beat_count = 0\n        var beat_count_prev = 0\n        var beat_count_prev_prev = 0\n        var beat_count_prev_prev_prev = 0\n        var beat_count_prev_prev_prev_prev = 0\n        var beat_count_prev_prev_prev_prev_prev = 0\n        var beat_count_prev_prev_prev_prev_prev_prev = 0\n        var beat_count_prev_prev_prev_prev_prev_prev_prev = 0\n        var beat_count_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var beat_count_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var beat_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var beat_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var beat_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var beat_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var beat_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var beat_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var beat_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var beat_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n        var beat_count_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292846,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwqg9y6gq.scala:35:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwqg9y6gq.scala:14:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mnotes\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArrayList\u001b[0m[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type ArrayList\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwqg9y6gq.scala:15:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mbeats\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArrayList\u001b[0m[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type ArrayList\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwqg9y6gq.scala:35:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if (note_string == \".\") {\n                return 0l\n            } else if (note_string == \"o\") {\n                return 4l\n            } else if (note_string == \"o|\") {\n                return 2l\n            } else {\n                return 1l\n            }\n        }\n        def parseMusic(note_list : List[String]) : List[Long] = {\n            var result = List[Long]()\n            for (note_string <- note_list) {\n                result = append(result, parseNote(note_string))\n            }\n            return result\n        }\n        return parseMusic(music_string.split(\" \"))\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292847,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7cv81dco.scala:28:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                result = append(result, parseNote(note_string))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: append\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7cv81dco.scala:32:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mreturn\u001b[0m parseMusic(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    \u001b[1m\u001b[31mArray\u001b[0m[String]\n\u001b[31m   |\u001b[0m                          Required: \u001b[1m\u001b[32mList\u001b[0m[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string == \"o\" {\n                return 4l\n            } else if note_string == \"o|\" {\n                return 2l\n            } else if note_string == \".|\" {\n                return 1l\n            } else {\n                throw new RuntimeException(\"Unknown note: \" + note_string)\n            }\n        }\n        def parseDuration(duration_string : String) : Long = {\n            if duration_string == \"o\" {\n                return 4l\n            } else if duration_string == \"o|\" {\n                return 2l\n            } else if duration_string == \".|\" {\n                return 1l\n            } else {\n                throw new RuntimeException(\"Unknown note: \" + duration_string)\n            }\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if beat_string == \"o\" {\n                return 1l\n            } else if beat_string == \"o|\" {\n                return 2l\n            } else if beat_string == \".|\" {\n                return 4l\n            } else {\n                throw new RuntimeException(\"Unknown note: \" + beat_string)\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var beat_counts = mutable.List[Long]()\n            var beat_count = 0l\n            for (i <- 0 until music_string.length) {\n                var note_count = parseNote(music_string[i])\n                var duration_count = parseDuration(music_string[i + 1])\n                var beat_count = beat_count + parseBeat(music_string[i + 2])\n                beat_counts = beat_counts.append(beat_count)\n                i = i + 3\n            }\n            return beat_counts\n        }\n        return parseMusic(music_string)\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292848,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbs0drcer.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbs0drcer.scala:28:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m duration_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbs0drcer.scala:39:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m beat_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpbs0drcer.scala:15:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m16 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31m4l\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m-- Error: /tmp/tmpbs0drcer.scala:26:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m duration_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m27 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31m4l\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m duration_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m-- Error: /tmp/tmpbs0drcer.scala:37:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mif\u001b[0m beat_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m38 |\u001b[0m             ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        val beats = mutable.List[Long]()\n        for (i <- 0 until music_list.length) {\n            val note = music_list[i]\n            if (note.equals(\".\")) {\n                beats.append(0l)\n            } else if (note.equals(\"o\")) {\n                beats.append(4l)\n            } else if (note.equals(\"o|\")) {\n                beats.append(2l)\n            } else {\n                throw new IllegalArgumentException(\"Unknown note: \" + note)\n            }\n        }\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292848,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnv7zhfll.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnv7zhfll.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnv7zhfll.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnote\u001b[0m = music_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asScalaBuffer(music_string.split(\" \")).toList\n        val result = mutable.List[Long]()\n        for (i <- 0 until music_list.length) {\n            val note = music_list(i)\n            if (note.contains(\"o\")) {\n                result.append(4l)\n            } else if (note.contains(\"o|\")) {\n                result.append(2l)\n            } else if (note.contains(\".|\")) {\n                result.append(1l)\n            } else {\n                result.append(0l)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292768,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3gljlp9b.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asScalaBuffer(music_string.split(\u001b[31m\" \"\u001b[0m)).toList\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3gljlp9b.scala:15:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.equals(\".\") {\n                return 0l\n            } else if note_string.equals(\"o\") {\n                return 4l\n            } else if note_string.equals(\"o|\") {\n                return 2l\n            } else {\n                return 1l\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var result = mutable.List[Long]()\n            var current_note = 0l\n            var current_beat = 0l\n            var current_note_length = 0l\n            var current_note_length_count = 0l\n            for (i <- 0 until music_string.length) {\n                if (music_string[i] == '.') {\n                    current_note_length_count = 0\n                    current_note_length = 0\n                    current_note = parseNote(music_string[i + 1])\n                    current_beat = current_beat + current_note_length\n                    current_note_length_count = current_note_length_count + 1\n                    i = i + 1\n                } else if (music_string[i] == 'o') {\n                    current_note_length_count = 0\n                    current_note_length = 0\n                    current_note = parseNote(music_string[i + 1])\n                    current_beat = current_beat + current_note_length\n                    current_note_length_count = current_note_length_count + 1\n                    i = i + 1\n                } else if (music_string[i] == 'o|') {\n                    current_note_length_count = 0\n                    current_note_length = 0\n                    current_note = parseNote(music_string[i + 1])\n                    current_beat = current_beat + current_note_length\n                    current_note_length_count = current_note_length_count + 1\n                    i = i + 1\n                } else {\n                    current_note_length_count = current_note_length_count + 1\n                }\n                if (current_note_length_count == 4) {\n                    result = result.append(\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292847,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpsc2w57kk.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\"o\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpsc2w57kk.scala:46:46 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_string[i] == \u001b[31m'o\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0msymbol literal 'o is no longer supported,\n\u001b[31m   |\u001b[0muse a string literal \"o\" or an application Symbol(\"o\") instead,\n\u001b[31m   |\u001b[0mor enclose in braces '{o} if you want a quoted expression.\n\u001b[31m   |\u001b[0mFor now, you can also `import language.deprecated.symbolLiterals` to accept\n\u001b[31m   |\u001b[0mthe idiom, but this possibility might no longer be available in the future.\n\u001b[31m\u001b[31m-- Error: /tmp/tmpsc2w57kk.scala:46:49 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_string[i] == \u001b[31m'o\u001b[0m|') {\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              unclosed character literal\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpsc2w57kk.scala:68:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpsc2w57kk.scala:15:33 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.equals(\u001b[31m\".\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             \u001b[33mmethod\u001b[0m \u001b[35mequals\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsc2w57kk.scala:26:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = List[String]()\n        for (i <- 0 until music_string.length) {\n            if (music_string[i] == '.') {\n                music_list = music_list.append(0l)\n            } else if (music_string[i] == '|') {\n                music_list = music_list.append(1l)\n            } else if (music_string[i] == 'o') {\n                music_list = music_list.append(4l)\n            } else {\n                music_list = music_list.append(2l)\n            }\n        }\n        val result = List[Long]()\n        for (i <- 0 until music_list.length) {\n            if (music_list[i] == 0) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292806,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp124vmq5f.scala:16:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mif\u001b[0m (music_string[\u001b[35mi\u001b[0m] == \u001b[31m'.'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp124vmq5f.scala:17:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                music_list = music_list.append(\u001b[31m0l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[String] - did you mean music_list.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp124vmq5f.scala:18:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_string[i] == \u001b[31m'|'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp124vmq5f.scala:19:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                music_list = music_list.append(\u001b[31m1l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[String] - did you mean music_list.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp124vmq5f.scala:20:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (music_string[i] == \u001b[31m'o'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp124vmq5f.scala:21:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                music_list = music_list.append(\u001b[31m4l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        val beats = mutable.List[Long]()\n        for (i <- 0 until music_list.length) {\n            if (music_list(i) == \".\") {\n                beats.append(0l)\n            } else if (music_list(i) == \"o\") {\n                beats.append(4l)\n            } else if (music_list(i) == \"o|\") {\n                beats.append(2l)\n            } else {\n                beats.append(1l)\n            }\n        }\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292848,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpn5rnojgz.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn5rnojgz.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim).map(_.replaceAll(\"[^0-9.]\", \"\"))\n        val result = beats.map(_.toLong).toList\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292837,
      "stdout": "",
      "stderr": "java.lang.NumberFormatException: For input string: \"\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\tat java.base/java.lang.Long.parseLong(Long.java:721)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.$anonfun$3(tmpkhwehzxm.scala:16)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.parseMusic(tmpkhwehzxm.scala:16)\n\tat Problem$.main(tmpkhwehzxm.scala:20)\n\tat Problem.main(tmpkhwehzxm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val notes = music_string.split(\" \")\n        val beats = notes.map(_.trim()).map(_.replaceAll(\"[^0-9.]\", \"\")).map(_.toLong).toList\n        val result = beats.map(b -> b.toLong)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292847,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphwkixea3.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = beats.map(b -> b.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: b\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        var result = mutable.List[Long]()\n        var current_note = mutable.List[String]()\n        var current_duration = mutable.List[Long]()\n        var current_duration_count = mutable.List[Long]()\n        var current_duration_count_count = mutable.List[Long]()\n        var current_duration_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_duration_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count = mutable.List[Long]()\n        var current_\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292782,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5efqvz3p.scala:33:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5efqvz3p.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5efqvz3p.scala:15:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_note\u001b[0m = mutable.List[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5efqvz3p.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5efqvz3p.scala:17:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration_count\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5efqvz3p.scala:18:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mcurrent_duration_count_count\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = music_string.split(\" \")\n        val beats = List[Long]()\n        for (i <- 0 until music_list.length) {\n            val note = music_list[i]\n            if (note.contains(\".\")) {\n                val note_list = note.split(\".\")\n                val note_length = note_list[0].toLong\n                val note_count = note_list[1].toLong\n                for (j <- 0 until note_count) {\n                    beats = beats.append(note_length)\n                }\n            } else {\n                val note_length = note.toLong\n                beats = beats.append(note_length)\n            }\n        }\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292848,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpimmxu0gi.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnote\u001b[0m = music_list[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpimmxu0gi.scala:23:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                    beats = beats.append(note_length)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean beats.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpimmxu0gi.scala:27:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                beats = beats.append(note_length)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean beats.appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string == \"o\" {\n                return 4l\n            } else if note_string == \"o|\" {\n                return 2l\n            } else if note_string == \".|\" {\n                return 1l\n            } else {\n                throw new RuntimeException(\"Invalid note string: \" + note_string)\n            }\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if beat_string == \"o\" {\n                return 4l\n            } else if beat_string == \"o|\" {\n                return 2l\n            } else if beat_string == \".|\" {\n                return 1l\n            } else {\n                throw new RuntimeException(\"Invalid beat string: \" + beat_string)\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            var beat_counts = mutable.List[Long]()\n            var beat_count = 0l\n            var note_count = 0l\n            var note_count_prev = 0l\n            var note_count_prev_prev = 0l\n            for (i <- 0 until music_string.length) {\n                if (music_string[i] == '.') {\n                    beat_count += parseBeat(music_string[i + 1])\n                    note_count += parseNote(music_string[i + 2])\n                    note_count_prev += parseNote(music_string[i + 3])\n                    note_count_prev_prev += parseNote(music_string[i + 4])\n                    i += 4\n                } else if (music_string[i] == '|') {\n                    beat_count += parseBeat(music_string[i + 1])\n                    note_count += parseNote(music_string[i + 2])\n                    note_count_prev += parseNote(music_string[i + 3])\n                    note_count_prev_prev += parseNote(music_string[i + 4])\n                    i += 4\n                } else if (music_string[i] == 'o') {\n                    beat_count += parseBeat(music_string[i + 1])\n                    note\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292849,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpw6bmu6ei.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpw6bmu6ei.scala:28:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m beat_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpw6bmu6ei.scala:68:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpw6bmu6ei.scala:15:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m16 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31m4l\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m note_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m-- Error: /tmp/tmpw6bmu6ei.scala:26:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m beat_string == \u001b[31m\"o\"\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m27 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31m4l\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m beat_string == \u001b[31m\"o|\"\u001b[0m {\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpw6bmu6ei.scala:37:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mbeat_counts\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        def parseNote(note_string : String) : Long = {\n            if note_string.contains(\"|\") {\n                return note_string.split(\"|\")[0].replace(\".\", \"\").replace(\"o\", \"\").toLong\n            } else {\n                return note_string.replace(\".\", \"\").replace(\"o\", \"\").toLong\n            }\n        }\n        def parseBeat(beat_string : String) : Long = {\n            if beat_string.contains(\"|\") {\n                return beat_string.split(\"|\")[1].replace(\".\", \"\").replace(\"o\", \"\").toLong\n            } else {\n                return beat_string.replace(\".\", \"\").replace(\"o\", \"\").toLong\n            }\n        }\n        def parseDuration(duration_string : String) : Long = {\n            if duration_string.contains(\"|\") {\n                return duration_string.split(\"|\")[1].replace(\".\", \"\").replace(\"o\", \"\").toLong\n            } else {\n                return duration_string.replace(\".\", \"\").replace(\"o\", \"\").toLong\n            }\n        }\n        def parseMusic(music_string : String) : List[Long] = {\n            def parseNote(note_string : String) : Long = {\n                if note_string.contains(\"|\") {\n                    return note_string.split(\"|\")[0].replace(\".\", \"\").replace(\"o\", \"\").toLong\n                } else {\n                    return note_string.replace(\".\", \"\").replace(\"o\", \"\").toLong\n                }\n            }\n            def parseBeat(beat_string : String) : Long = {\n                if beat_string.contains(\"|\") {\n                    return beat_string.split(\"|\")[1].replace(\".\", \"\").replace(\"o\", \"\").toLong\n                } else {\n                    return beat_string.replace(\".\", \"\").replace(\"o\", \"\").toLong\n                }\n            }\n            def parseDuration(duration_string : String) : Long = {\n                if duration_string.contains(\"|\") {\n                    return duration_string.split(\"|\")[1].replace(\".\", \"\").replace(\"o\", \"\").toLong\n                }\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292848,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvl4rwnr2.scala:17:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvl4rwnr2.scala:24:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvl4rwnr2.scala:31:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvl4rwnr2.scala:39:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvl4rwnr2.scala:46:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m                } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  'then' expected, but 'else' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvl4rwnr2.scala:54:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    'then' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvl4rwnr2.scala:64:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpvl4rwnr2.scala:15:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m note_string.contains(\u001b[31m\"|\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mcontains\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m does not take more parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling wi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input to this function is a string representing musical notes in a special ASCII format.\n    // Your task is to parse this string and return list of integers corresponding to how many beats does each\n    // not last.\n    // Here is a legend:\n    // 'o' - whole note, lasts four beats\n    // 'o|' - half note, lasts two beats\n    // '.|' - quater note, lasts one beat\n    // >>> parseMusic((\"o o| .| o| o| .| .| .| .| o o\"))\n    // (List[Long](4l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))\n    def parseMusic(music_string : String) : List[Long] = {\n        val music_list = scala.collection.JavaConversions.asJavaList(music_string.split(\" \"))\n        val beats = mutable.List[Long]()\n        for (i <- 0 until music_list.size()) {\n            if (music_list.get(i).equals(\".\")) {\n                beats.append(0l)\n            } else if (music_list.get(i).equals(\"o\")) {\n                beats.append(4l)\n            } else if (music_list.get(i).equals(\"o|\")) {\n                beats.append(2l)\n            } else {\n                beats.append(1l)\n            }\n        }\n        return beats\n    }\n    def main(args: Array[String]) = {\n    assert(parseMusic((\"\")).equals((List[Long]())));\n    assert(parseMusic((\"o o o o\")).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\".| .| .| .|\")).equals((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))));\n    assert(parseMusic((\"o| o| .| .| o o o o\")).equals((List[Long](2l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(parseMusic((\"o| .| o| .| o o| o o|\")).equals((List[Long](2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 4l.toLong, 2l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664292848,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv33447r8.scala:14:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmusic_list\u001b[0m = scala.collection.JavaConversions.asJavaList(music_string.split(\u001b[31m\" \"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value JavaConversions is not a member of collection\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpv33447r8.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbeats\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}