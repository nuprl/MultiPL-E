name: HumanEval_21_rescale_to_unit
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given list of numbers (of at least two elements), apply a linear transform\
  \ to that list,\n    // such that the smallest number will become 0 and the largest\
  \ will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
  \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
  \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
  \ : List[Float]) : List[Float] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
  \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
  \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
  \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
  \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
  \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
  \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
  \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
completions: ["        var min = numbers.head\n        var max = numbers.head\n  \
    \      for (i <- numbers.size - 1) {\n            if (numbers[i] < min) {\n  \
    \              min = numbers[i]\n            }\n            if (numbers[i] > max)\
    \ {\n                max = numbers[i]\n            }\n        }\n        var scale\
    \ = 1.0 / (max - min)\n        var result = mutable.List[Float]()\n        for\
    \ (i <- numbers.size) {\n            result.append(numbers[i] - min) * scale\n\
    \        }\n        return result", "        var min = numbers.min()\n       \
    \ var max = numbers.max()\n        var scale = 1.0 / (max - min)\n        return\
    \ numbers.map(x => (x - min) * scale)", "        var min = numbers.min()\n   \
    \     var max = numbers.max()\n        var scale = 1.0 / (max - min)\n       \
    \ return numbers.map(x => (x - min) * scale)", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n       \
    \ var result = List[Float](0.0)\n        for (i <- numbers.size) {\n         \
    \   result = result.updated(i, (numbers[i] - min) * scale)\n        }\n      \
    \  return result", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            if (numbers[i] < min) {\n\
    \                min = numbers[i]\n            }\n            if (numbers[i] >\
    \ max) {\n                max = numbers[i]\n            }\n        }\n       \
    \ var scale = 1.0 / (max - min)\n        var result = mutable.List[Float]()\n\
    \        for (i <- numbers.size) {\n            result = result.append(numbers[i]\
    \ - min * scale)\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) {\n                min = numbers[i]\n          \
    \  }\n            if (numbers[i] > max) {\n                max = numbers[i]\n\
    \            }\n        }\n        var scale = 1.0 / (max - min)\n        var\
    \ result = List[Float](0.0)\n        for (i <- numbers.size) {\n            result\
    \ = result.updated(i, numbers[i] * scale - min * scale)\n        }\n        return\
    \ result", "        var min = numbers.head\n        var max = numbers.head\n \
    \       for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min =\
    \ numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        var result = List[Float](0.0)\n\
    \        for (i <- numbers.size) {\n            result = result.updated(i, numbers[i]\
    \ * scale - min)\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) {\n                min = numbers[i]\n          \
    \  }\n            if (numbers[i] > max) {\n                max = numbers[i]\n\
    \            }\n        }\n        var scale = 1.0 / (max - min)\n        var\
    \ result = List[Float](0.0)\n        for (i <- numbers.size) {\n            result\
    \ = result.updated(i, (numbers[i] - min) * scale)\n        }\n        return result",
  "        var min = numbers.head\n        var max = numbers.head\n        for (i\
    \ <- numbers.size - 1) {\n            if (numbers[i] < min) min = numbers[i]\n\
    \            if (numbers[i] > max) max = numbers[i]\n        }\n        var scale\
    \ = 1.0 / (max - min)\n        var result = List[Float](0.0f.toFloat)\n      \
    \  for (i <- numbers.size) {\n            result = result.updated(i, (numbers[i]\
    \ - min) * scale)\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] > max) max = numbers[i]\n            if (numbers[i] < min)\
    \ min = numbers[i]\n        }\n        var scale = 1.0f / (max - min)\n      \
    \  for (i <- numbers.size) {\n            numbers[i] = numbers[i] * scale - min\n\
    \        }\n        return numbers", "        var min = numbers.head\n       \
    \ var max = numbers.head\n        for (i <- numbers.size - 1) {\n            if\
    \ (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max) max =\
    \ numbers[i]\n        }\n        var scale = 1.0f / (max - min)\n        for (i\
    \ <- numbers.size) {\n            numbers[i] = numbers[i] - min\n            numbers[i]\
    \ = numbers[i] * scale\n        }\n        return numbers", "        var min =\
    \ numbers.min()\n        var max = numbers.max()\n        var scale = 1.0 / (max\
    \ - min)\n        var result = List[Float]().setAll(min)\n        for (i <- numbers.size)\
    \ {\n            result = result.updated(i, (numbers[i] - min) * scale)\n    \
    \    }\n        return result\n    }\n\n    // Given list of numbers (of at least\
    \ two elements), apply a linear transform to that list,\n    // such that the\
    \ smallest number will become 0 and the largest will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var min = numbers.min()\n        var\
    \ max = numbers.max()\n        var scale = 1.0 / (max - min)\n        var result\
    \ = List[Float]().setAll(min)\n        for (i <- numbers.size) {\n           \
    \ result = result.updated(i, (numbers[i] - min) * scale)\n        }\n        return\
    \ result\n    }\n\n    // Given list of numbers (of at least two elements), apply\
    \ a linear transform to that list,\n    // such that the smallest number will\
    \ become 0 and the largest will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var min = numbers.min()", "      \
    \  var min = numbers.head\n        var max = numbers.head\n        for (i <- numbers.size\
    \ - 1) {\n            if (numbers[i] < min) {\n                min = numbers[i]\n\
    \            }\n            if (numbers[i] > max) {\n                max = numbers[i]\n\
    \            }\n        }\n        var scale = 1.0 / (max - min)\n        var\
    \ result = mutable.List[Float]()\n        for (i <- numbers.size) {\n        \
    \    result.append(numbers[i] - min) * scale\n        }\n        return result",
  "        var min = numbers.head\n        var max = numbers.head\n        for (i\
    \ <- numbers.size - 1) {\n            if (numbers[i] < min) min = numbers[i]\n\
    \            if (numbers[i] > max) max = numbers[i]\n        }\n        var scale\
    \ = 1.0 / (max - min)\n        var result = List[Float](0.0)\n        for (i <-\
    \ numbers.size) {\n            result = result.updated(i, numbers[i] - min * scale)\n\
    \        }\n        return result", "        var min = numbers.head\n        var\
    \ max = numbers.head\n        for (i <- numbers.size - 1) {\n            if (numbers[i]\
    \ > max) max = numbers[i]\n            if (numbers[i] < min) min = numbers[i]\n\
    \        }\n        var scale = 1.0 / (max - min)\n        var result = List[Float]()\n\
    \        for (i <- numbers.size) {\n            result = result.append(numbers[i]\
    \ - min)\n        }\n        for (i <- result.size - 1) {\n            result[i]\
    \ = result[i] * scale\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0f / (max - min)\n      \
    \  for (i <- numbers.size) {\n            numbers[i] = numbers[i] * scale - min\n\
    \        }\n        return numbers", "        var min = numbers.head\n       \
    \ var max = numbers.head\n        for (i <- numbers.size - 1) {\n            if\
    \ (numbers[i] > max) max = numbers[i]\n            if (numbers[i] < min) min =\
    \ numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n        var result\
    \ = List[Float](0.0f.toFloat)\n        for (i <- numbers.size) {\n           \
    \ result = result.updated(i, numbers[i] - min * scale)\n        }\n        return\
    \ result", "        var min = numbers.head\n        var max = numbers.head\n \
    \       for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min =\
    \ numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        var result = List[Float](0.0f.toFloat)\n\
    \        for (i <- numbers.size) {\n            result = result.updated(i, (numbers[i]\
    \ - min) * scale)\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n       \
    \ var result = List[Float](0.0f.toFloat)\n        for (i <- numbers.size) {\n\
    \            result = result.updated(i, numbers[i] - min * scale)\n        }\n\
    \        return result", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min\
    \ = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        var result = List[Float](0.0f.toFloat)\n\
    \        for (i <- numbers.size) {\n            result = result.updated(i, numbers[i]\
    \ - min * scale)\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n       \
    \ var result = List[Float](0.0)\n        for (i <- numbers.size) {\n         \
    \   result = result.updated(i, numbers[i] - min * scale)\n        }\n        return\
    \ result", "        var min = numbers.head\n        var max = numbers.head\n \
    \       for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min =\
    \ numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        var result = List[Float](0.0)\n\
    \        for (i <- numbers.size) {\n            result = result.updated(i, (numbers[i]\
    \ - min) * scale)\n        }\n        return result\n    }\n\n    // Given a list\
    \ of numbers, return a list of the same length, where each element is the\n  \
    \  // product of the elements before it in the list.\n    // >>> productBefore(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // (List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 6.0f.toFloat, 24.0f.toFloat, 120.0f.toFloat))\n    def productBefore(numbers\
    \ : List[Float]) : List[Float] = {\n        var result = List[Float](1.0)\n  \
    \      for (i <- numbers.size - 1) {\n            result = result.updated(i, result.updated(i,\
    \ numbers[i]))\n        }\n        return result\n    }\n\n    // Given a list\
    \ of numbers, return a list of the same length, where each element is the\n  \
    \  // product of the elements after it in the list.\n    // >>> productAfter(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // (List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    def productAfter(numbers\
    \ : List[Float]) : List[Float] = {\n        var result = List[Float](1", "   \
    \     var min = numbers.head\n        var max = numbers.head\n        for (i <-\
    \ numbers.size - 1) {\n            if (numbers[i] < min) min = numbers[i]\n  \
    \          if (numbers[i] > max) max = numbers[i]\n        }\n        var scale\
    \ = 1.0f / (max - min)\n        var result = List[Float](0.0f)\n        for (i\
    \ <- numbers.size) {\n            result = result.append(numbers[i] - min * scale)\n\
    \        }\n        return result", "        var min = numbers.head\n        var\
    \ max = numbers.head\n        for (i <- numbers.size - 1) {\n            if (numbers[i]\
    \ < min) min = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n\
    \        }\n        var scale = 1.0 / (max - min)\n        for (i <- numbers.size)\
    \ {\n            numbers[i] = numbers[i] - min\n            numbers[i] = numbers[i]\
    \ * scale\n        }\n        return numbers", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n       \
    \ var result = List[Float](0.0)\n        for (i <- numbers.size) {\n         \
    \   result = result.updated(i, numbers[i] - min * scale)\n        }\n        return\
    \ result", "        var min = numbers.head\n        var max = numbers.head\n \
    \       for (i <- numbers.size - 1) {\n            min = min.min(numbers.apply(i))\n\
    \            max = max.max(numbers.apply(i))\n        }\n        var scale = 1.0\
    \ / (max - min)\n        var offset = -min * scale\n        return numbers.map(x\
    \ => (x - min) * scale + offset)\n    }\n\n    // Given a list of numbers, return\
    \ a list of numbers that are the same length as the input,\n    // but where the\
    \ values are the average of the values in the input list\n    // >>> average(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // (List[Float](2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 5.0f.toFloat))\n    def average(numbers\
    \ : List[Float]) : List[Float] = {\n        var sum = numbers.foldLeft(0.0f, (x,\
    \ y) => x + y)\n        var avg = sum / numbers.size\n        return numbers.map(x\
    \ => x - avg)\n    }\n\n    // Given a list of numbers, return a list of numbers\
    \ that are the same length as the input,\n    // but where the values are the\
    \ sum of the values in the input list\n    // >>> sum(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // (List[Float](6.0f.toFloat,\
    \ 9.0f.toFloat, 12.0f.toFloat, 15.0f.toFloat, 20.0f.toFloat))\n    def sum(numbers\
    \ : List[Float]) : List[Float] = {\n        var sum = numbers.foldLeft(0.0f, (x,\
    \ y) => x + y)\n        return numbers.map(x => x + sum)\n    }", "        var\
    \ min = numbers.head\n        var max = numbers.head\n        for (i <- numbers.size\
    \ - 1) {\n            if (numbers[i] < min) {\n                min = numbers[i]\n\
    \            }\n            if (numbers[i] > max) {\n                max = numbers[i]\n\
    \            }\n        }\n        var scale = 1.0f / (max - min)\n        var\
    \ result = List[Float](0.0f)\n        for (i <- numbers.size) {\n            result\
    \ = result.append(numbers[i] - min) * scale\n        }\n        return result\n\
    \    }\n\n    // Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n    // such that the smallest number will become 0\
    \ and the largest will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var min = numbers.head\n        var\
    \ max = numbers.head\n        for (i <- numbers.size - 1) {\n            if (numbers[i]\
    \ < min) {\n                min = numbers[i]\n            }\n            if (numbers[i]\
    \ > max) {\n                max = numbers[i]\n            }\n        }\n     \
    \   var scale = 1.0f / (max - min)\n        var result = List[Float](0.0f)\n \
    \       for (i <- numbers.size) {\n            result = result.append(numbers[i]\
    \ - min) * scale\n        }\n        return result\n    }\n\n    // Given list\
    \ of numbers (of at least two elements), apply a linear transform to that list,\n\
    \    // such that the smallest number will become 0 and the largest will become\
    \ 1\n    // >>> rescaleToUnit((List[Float](1.0", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] > max) max = numbers[i]\n            if (numbers[i] < min)\
    \ min = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n       \
    \ var result = List[Float]()\n        for (i <- numbers.size) {\n            result\
    \ = result.append(numbers[i] - min) * scale\n        }\n        return result\n\
    \    }\n\n    // Given a list of numbers, return a list of the same length where\
    \ the first element is the\n    // sum of the elements and each subsequent element\
    \ is the sum of the previous two elements.\n    // >>> sumOfTwoNumbers((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](6.0f.toFloat,\
    \ 12.0f.toFloat, 18.0f.toFloat, 24.0f.toFloat, 30.0f.toFloat))\n    def sumOfTwoNumbers(numbers\
    \ : List[Float]) : List[Float] = {\n        var result = List[Float]()\n     \
    \   var sum = 0.0\n        for (i <- numbers.size) {\n            sum = sum +\
    \ numbers[i]\n            result = result.append(sum)\n        }\n        return\
    \ result\n    }\n\n    // Given a list of numbers, return a list of the same length\
    \ where the first element is the\n    // sum of the elements and each subsequent\
    \ element is the sum of the previous two elements.\n    // >>> sumOfTwoNumbers((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](6.0f.toFloat,\
    \ 12.0f.toFloat, 18.0f.toFloat, 24.0f.toFloat, 30.0f.toFloat))\n    def sumOfTwoNumbers2(numbers\
    \ : List[Float", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min\
    \ = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        var result = List[Float]()\n \
    \       for (i <- numbers.size) {\n            result = result.append(numbers[i]\
    \ - min)\n        }\n        for (i <- result.size - 1) {\n            result[i]\
    \ = result[i] * scale\n        }\n        return result", "        var min = numbers.min()\n\
    \        var max = numbers.max()\n        var scale = 1.0f / (max - min)\n   \
    \     return numbers.map(x -> (x - min) * scale)\n    }\n\n    // Given a list\
    \ of numbers, return a list of the same length where the values have been\n  \
    \  // normalized to the range [0, 1]\n    // >>> normalize((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def normalize(numbers\
    \ : List[Float]) : List[Float] = {\n        var min = numbers.min()\n        var\
    \ max = numbers.max()\n        var scale = 1.0f / (max - min)\n        return\
    \ numbers.map(x -> (x - min) * scale)\n    }\n\n    // Given a list of numbers,\
    \ return a list of the same length where the values have been\n    // normalized\
    \ to the range [-1, 1]\n    // >>> normalizeToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](-1.0f.toFloat,\
    \ -0.25f.toFloat, -0.5f.toFloat, -0.75f.toFloat, 1.0f.toFloat))\n    def normalizeToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var min = numbers.min()\n        var\
    \ max = numbers.max()\n        var scale = 2.0f / (max - min)\n        return\
    \ numbers.map(x -> (x - min) * scale)\n    }\n\n    // Given a list of numbers,\
    \ return a list of the same length where the values have been\n    // normalized\
    \ to the range [0, 1] and then scaled by a factor of 2\n", "        var min =\
    \ numbers.head\n        var max = numbers.head\n        for (i <- numbers.size\
    \ - 1) {\n            if (numbers[i] < min) {\n                min = numbers[i]\n\
    \            }\n            if (numbers[i] > max) {\n                max = numbers[i]\n\
    \            }\n        }\n        var scale = 1.0f / (max - min)\n        var\
    \ result = List[Float](0.0f)\n        for (i <- numbers.size) {\n            result\
    \ = result.updated(i, (numbers[i] - min) * scale)\n        }\n        return result",
  "        var min = numbers.head\n        var max = numbers.head\n        for (i\
    \ <- numbers.size - 1) {\n            if (numbers[i] < min) {\n              \
    \  min = numbers[i]\n            }\n            if (numbers[i] > max) {\n    \
    \            max = numbers[i]\n            }\n        }\n        var scale = 1.0\
    \ / (max - min)\n        var result = List[Float](0.0)\n        for (i <- numbers.size)\
    \ {\n            result = result.append(numbers[i] - min * scale)\n        }\n\
    \        return result", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min\
    \ = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        var result = List[Float]()\n \
    \       for (i <- numbers.size) {\n            result = result.append(numbers[i]\
    \ - min)\n        }\n        for (i <- result.size) {\n            result[i] =\
    \ result[i] * scale\n        }\n        return result\n    }\n\n    // Given a\
    \ list of numbers, return a list of the same length, where each number is the\
    \ sum of\n    // the two numbers immediately before it in the list.\n    // >>>\
    \ sumTwoNumbersBefore(List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat,\
    \ 5.0f.toFloat))\n    // (List[Float](1.0f.toFloat, 3.0f.toFloat, 6.0f.toFloat,\
    \ 10.0f.toFloat, 15.0f.toFloat))\n    def sumTwoNumbersBefore(numbers : List[Float])\
    \ : List[Float] = {\n        var result = List[Float]()\n        for (i <- numbers.size)\
    \ {\n            result = result.append(numbers[i - 1] + numbers[i - 2])\n   \
    \     }\n        return result\n    }\n\n    // Given a list of numbers, return\
    \ a list of the same length, where each number is the sum of\n    // the two numbers\
    \ immediately after it in the list.\n    // >>> sumTwoNumbersAfter(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // (List[Float](3.0f.toFloat,\
    \ 6.0f.toFloat, 12.0f.toFloat, 20.0f.toFloat, 30.0f.toFloat))\n    def sumTwoNumbers",
  "        var min = numbers.head\n        var max = numbers.head\n        for (i\
    \ <- numbers.size - 1) {\n            if (numbers[i] < min) min = numbers[i]\n\
    \            if (numbers[i] > max) max = numbers[i]\n        }\n        var scale\
    \ = 1.0 / (max - min)\n        var result = List[Float](0.0)\n        for (i <-\
    \ numbers.size) {\n            result = result.updated(i, (numbers[i] - min) *\
    \ scale)\n        }\n        return result", "        var min = numbers.min()\n\
    \        var max = numbers.max()\n        var scale = 1.0 / (max - min)\n    \
    \    return numbers.map(x => (x - min) * scale)", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0f / (max - min)\n      \
    \  var result = List[Float]()\n        for (i <- numbers.size) {\n           \
    \ result = result.append(numbers[i] - min * scale)\n        }\n        return\
    \ result", "        var min = numbers.min()\n        var max = numbers.max()\n\
    \        var scale = 1.0 / (max - min)\n        return numbers.map(x => (x - min)\
    \ * scale)", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min\
    \ = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        var result = List[Float](0.0)\n\
    \        for (i <- numbers.size) {\n            result = result.updated(i, numbers[i]\
    \ * scale - min * scale)\n        }\n        return result", "        var min\
    \ = numbers.head\n        var max = numbers.head\n        for (i <- numbers.size\
    \ - 1) {\n            if (numbers[i] < min) min = numbers[i]\n            if (numbers[i]\
    \ > max) max = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n\
    \        var result = List[Float](0.0)\n        for (i <- numbers.size) {\n  \
    \          result = result.append(numbers[i] - min)\n        }\n        for (i\
    \ <- result.size - 1) {\n            result[i] = result[i] * scale\n        }\n\
    \        return result", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min\
    \ = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        for (i <- numbers.size) {\n  \
    \          numbers[i] = numbers[i] - min\n            numbers[i] = numbers[i]\
    \ * scale\n        }\n        return numbers\n    }\n\n    // Given a list of\
    \ numbers, compute the sum of the squares of those numbers\n    // >>> squareSum(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 30.0f\n   \
    \ def squareSum(numbers : List[Float]) : Float = {\n        var sum = 0.0\n  \
    \      for (i <- numbers.size) {\n            sum += numbers[i] * numbers[i]\n\
    \        }\n        return sum\n    }\n\n    // Given a list of numbers, compute\
    \ the sum of the squares of those numbers\n    // >>> squareSum(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 30.0f\n   \
    \ def squareSum2(numbers : List[Float]) : Float = {\n        var sum = 0.0\n \
    \       for (i <- numbers.size) {\n            sum += numbers[i] * numbers[i]\n\
    \        }\n        return sum\n    }\n\n    // Given a list of numbers, compute\
    \ the sum of the squares of those numbers\n    // >>> squareSum(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 30.0f\n   \
    \ def squareSum3(numbers : List[Float]) : Float = {\n        var sum = 0.0\n \
    \       for (i <- numbers.size", "        var min = numbers.head\n        var\
    \ max = numbers.head\n        for (i <- numbers.size - 1) {\n            if (numbers[i]\
    \ < min) {\n                min = numbers[i]\n            }\n            if (numbers[i]\
    \ > max) {\n                max = numbers[i]\n            }\n        }\n     \
    \   var scale = 1.0f / (max - min)\n        var result = List[Float](0.0f)\n \
    \       for (i <- numbers.size) {\n            result = result.updated(i, numbers[i]\
    \ * scale - min * scale)\n        }\n        return result", "        var min\
    \ = numbers.head\n        var max = numbers.head\n        for (i <- numbers.size\
    \ - 1) {\n            if (numbers[i] < min) min = numbers[i]\n            if (numbers[i]\
    \ > max) max = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n\
    \        var result = List[Float](0.0)\n        for (i <- numbers.size) {\n  \
    \          result = result.updated(i, numbers[i] - min * scale)\n        }\n \
    \       return result", "        var min = numbers.min()\n        var max = numbers.max()\n\
    \        var scale = 1.0f / (max - min)\n        return numbers.map(x => (x -\
    \ min) * scale)", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            min = min.min(numbers.apply(i))\n\
    \            max = max.max(numbers.apply(i))\n        }\n        var scale = 1.0\
    \ / (max - min)\n        var result = mutable.List[Float]()\n        for (i <-\
    \ numbers.size) {\n            result = result.append(numbers.apply(i).toFloat\
    \ * scale)\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n       \
    \ var result = List[Float](0.0)\n        for (i <- numbers.size) {\n         \
    \   result = result.append(numbers[i] - min) * scale\n        }\n        return\
    \ result", "        var min = numbers.min()\n        var max = numbers.max()\n\
    \        var scale = 1.0 / (max - min)\n        return numbers.map(x => (x - min)\
    \ * scale)", "        var min = numbers.min()\n        var max = numbers.max()\n\
    \        var scale = 1.0f / (max - min)\n        return numbers.map(x => (x -\
    \ min) * scale)\n    }\n\n    // Given a list of numbers, return the sum of the\
    \ squares of those numbers\n    // >>> squareSum(List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 30.0f\n    def squareSum(numbers\
    \ : List[Float]) : Float = {\n        var sum = 0.0f\n        for (var x : numbers)\
    \ {\n            sum += x * x\n        }\n        return sum\n    }\n\n    //\
    \ Given a list of numbers, return the sum of the products of those numbers\n \
    \   // >>> productSum(List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat,\
    \ 5.0f.toFloat))\n    // 30.0f\n    def productSum(numbers : List[Float]) : Float\
    \ = {\n        var sum = 0.0f\n        for (var x : numbers) {\n            sum\
    \ += x * x\n        }\n        return sum\n    }\n\n    // Given a list of numbers,\
    \ return the sum of the squares of those numbers\n    // >>> squareSum(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 30.0f\n   \
    \ def squareSum(numbers : List[Float]) : Float = {\n        var sum = 0.0f\n \
    \       for (var x : numbers) {\n            sum += x * x\n        }\n       \
    \ return sum\n    }\n\n    // Given a list of numbers, return the sum of the products\
    \ of those numbers\n    // >>> productSum(List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 30", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0f / (max - min)\n      \
    \  var result = mutable.List[Float]()\n        for (i <- numbers.size) {\n   \
    \         result.append(numbers[i] - min) * scale\n        }\n        return result",
  "        var min = numbers.head\n        var max = numbers.head\n        for (i\
    \ <- numbers.size - 1) {\n            if (numbers[i] > max) max = numbers[i]\n\
    \            if (numbers[i] < min) min = numbers[i]\n        }\n        var scale\
    \ = 1.0 / (max - min)\n        var result = List[Float](0.0f.toFloat)\n      \
    \  for (i <- numbers.size) {\n            result = result.updated(i, numbers[i]\
    \ - min * scale)\n        }\n        return result\n    }\n\n    // Given a list\
    \ of numbers, return a list of the same size, where each element is the\n    //\
    \ sum of the elements before it in the list.\n    // >>> sumUp(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // (List[Float](6.0f.toFloat,\
    \ 12.0f.toFloat, 18.0f.toFloat, 24.0f.toFloat, 30.0f.toFloat))\n    def sumUp(numbers\
    \ : List[Float]) : List[Float] = {\n        var result = List[Float](0.0f.toFloat)\n\
    \        for (i <- numbers.size) {\n            result = result.updated(i, numbers[i]\
    \ + result.get(i - 1))\n        }\n        return result\n    }\n\n    // Given\
    \ a list of numbers, return a list of the same size, where each element is the\n\
    \    // product of the elements before it in the list.\n    // >>> productUp(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // (List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 6.0f.toFloat, 24.0f.toFloat, 120.0f.toFloat))\n    def productUp(numbers\
    \ : List[Float]) : List[Float] = {\n        var result =", "        var min =\
    \ numbers.head\n        var max = numbers.head\n        for (i <- numbers.size\
    \ - 1) {\n            if (numbers[i] < min) min = numbers[i]\n            if (numbers[i]\
    \ > max) max = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n\
    \        var result = List[Float](0.0)\n        for (i <- numbers.size) {\n  \
    \          result = result.append(numbers[i] - min)\n        }\n        for (i\
    \ <- result.size - 1) {\n            result[i] = result[i] * scale\n        }\n\
    \        return result", "        var min = numbers.min()\n        var max = numbers.max()\n\
    \        var scale = 1.0 / (max - min)\n        return numbers.map(x => (x - min)\
    \ * scale)", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min\
    \ = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        var result = List[Float](0.0)\n\
    \        for (i <- numbers.size) {\n            result = result.append(numbers[i]\
    \ - min) * scale\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n       \
    \ var result = List[Float](0.0)\n        for (i <- numbers.size) {\n         \
    \   result = result.updated(i, numbers[i] - min * scale)\n        }\n        return\
    \ result", "        var min = numbers.head\n        var max = numbers.head\n \
    \       for (i <- numbers.size - 1) {\n            if (numbers[i] < min) {\n \
    \               min = numbers[i]\n            }\n            if (numbers[i] >\
    \ max) {\n                max = numbers[i]\n            }\n        }\n       \
    \ var scale = 1.0f / (max - min)\n        var result = mutable.List[Float]()\n\
    \        for (i <- numbers.size) {\n            result.append(numbers[i] - min)\
    \ * scale\n        }\n        return result", "        var min = numbers.min()\n\
    \        var max = numbers.max()\n        var scale = 1.0 / (max - min)\n    \
    \    return numbers.map(x => (x - min) * scale)\n    }\n\n    // Given a list\
    \ of numbers, find the sum of the squares of those numbers\n    // >>> squareSum(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 30.0\n    def\
    \ squareSum(numbers : List[Float]) : Float = {\n        var sum = 0.0\n      \
    \  numbers.foreach(x => sum += x * x)\n        return sum\n    }\n\n    // Given\
    \ a list of numbers, find the sum of the products of those numbers\n    // >>>\
    \ productSum(List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat,\
    \ 5.0f.toFloat))\n    // 120.0\n    def productSum(numbers : List[Float]) : Float\
    \ = {\n        var sum = 0.0\n        numbers.foreach(x => sum += x * x)\n   \
    \     return sum\n    }\n\n    // Given a list of numbers, find the sum of the\
    \ differences between those numbers\n    // >>> differenceSum(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 15.0\n    def\
    \ differenceSum(numbers : List[Float]) : Float = {\n        var sum = 0.0\n  \
    \      numbers.foreach(x => sum += x)\n        return sum\n    }\n\n    // Given\
    \ a list of numbers, find the sum of the squares of those numbers\n    // >>>\
    \ squareSum(List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat,\
    \ 5.0f.toFloat))\n    // 30.0\n    def squareSum(numbers : List[Float]) : Float\
    \ = {\n        ", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            if (numbers[i] > max) max\
    \ = numbers[i]\n            if (numbers[i] < min) min = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        var result = List[Float](0.0f.toFloat)\n\
    \        for (i <- numbers.size) {\n            result = result.updated(i, numbers[i]\
    \ - min * scale)\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) {\n                min = numbers[i]\n          \
    \  }\n            if (numbers[i] > max) {\n                max = numbers[i]\n\
    \            }\n        }\n        var scale = 1.0 / (max - min)\n        var\
    \ result = List[Float](0.0)\n        for (i <- numbers.size) {\n            result\
    \ = result.updated(i, numbers[i] - min * scale)\n        }\n        return result",
  "        var min = numbers.head\n        var max = numbers.head\n        for (i\
    \ <- numbers.size - 1) {\n            if (numbers[i] < min) {\n              \
    \  min = numbers[i]\n            }\n            if (numbers[i] > max) {\n    \
    \            max = numbers[i]\n            }\n        }\n        var scale = 1.0\
    \ / (max - min)\n        var result = mutable.List[Float]()\n        for (i <-\
    \ numbers.size) {\n            result = result.append(numbers[i] - min * scale)\n\
    \        }\n        return result", "        var min = numbers.head\n        var\
    \ max = numbers.head\n        for (i <- numbers.size - 1) {\n            if (numbers[i]\
    \ < min) min = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n\
    \        }\n        var scale = 1.0 / (max - min)\n        for (i <- numbers.size)\
    \ {\n            numbers[i] = numbers[i] - min\n            numbers[i] = numbers[i]\
    \ * scale\n        }\n        return numbers", "        var min = numbers.min()\n\
    \        var max = numbers.max()\n        var scale = 1.0 / (max - min)\n    \
    \    return numbers.map(x => (x - min) * scale)", "        var min = numbers.min()\n\
    \        var max = numbers.max()\n        var scale = 1.0 / (max - min)\n    \
    \    var result = List[Float]().setAll(min)\n        for (var i = 0; i < numbers.size();\
    \ i++) {\n            result = result.update(i, numbers.apply(i) * scale)\n  \
    \      }\n        return result", "        var min = numbers.head\n        var\
    \ max = numbers.head\n        for (i <- numbers.tail) {\n            if (i < min)\
    \ min = i\n            if (i > max) max = i\n        }\n        var scale = 1.0f\
    \ / (max - min)\n        var result = List[Float](0.0f)\n        for (i <- numbers)\
    \ {\n            result = result.append(i.toFloat - min.toFloat * scale)\n   \
    \     }\n        return result\n    }\n\n    // Given a list of numbers, return\
    \ a list of the same length where each number is the\n    // sum of the numbers\
    \ in the original list that are to the left of it.\n    // >>> sumLeft(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // (List[Float](1.0f.toFloat,\
    \ 3.0f.toFloat, 6.0f.toFloat, 10.0f.toFloat, 15.0f.toFloat))\n    def sumLeft(numbers\
    \ : List[Float]) : List[Float] = {\n        var result = List[Float](0.0f)\n \
    \       for (i <- numbers) {\n            result = result.append(i.toFloat + numbers.head.toFloat)\n\
    \        }\n        return result\n    }\n\n    // Given a list of numbers, return\
    \ a list of the same length where each number is the\n    // sum of the numbers\
    \ in the original list that are to the right of it.\n    // >>> sumRight(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // (List[Float](6.0f.toFloat,\
    \ 10.0f.toFloat, 15.0f.toFloat, 20.0f.toFloat, 25.0f.toFloat))\n    def sumRight(numbers\
    \ : List[Float]) : List[Float] = {\n        var result = List[Float](0.0f)\n \
    \       for (i <- numbers.", "        var min = numbers.head\n        var max\
    \ = numbers.head\n        for (i <- numbers.size - 1) {\n            if (numbers[i]\
    \ < min) min = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n\
    \        }\n        var scale = 1.0 / (max - min)\n        var result = List[Float](0.0f.toFloat)\n\
    \        for (i <- numbers.size) {\n            result = result.updated(i, (numbers[i]\
    \ - min) * scale)\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n       \
    \ var result = List[Float](0.0)\n        for (i <- numbers.size) {\n         \
    \   result = result.updated(i, (numbers[i] - min) * scale)\n        }\n      \
    \  return result", "        var min = numbers.min()\n        var max = numbers.max()\n\
    \        var scale = 1.0f / (max - min)\n        return numbers.map(x => (x -\
    \ min) * scale)", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min\
    \ = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        var result = mutable.List[Float]()\n\
    \        for (i <- numbers.size) {\n            result.append(numbers[i] - min)\
    \ * scale\n        }\n        return result", "        var min = numbers.min()\n\
    \        var max = numbers.max()\n        var scale = 1.0 / (max - min)\n    \
    \    return numbers.map(x => (x - min) * scale)", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n       \
    \ var result = List[Float](0.0)\n        for (i <- numbers.size) {\n         \
    \   result = result.updated(i, (numbers[i] - min) * scale)\n        }\n      \
    \  return result", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min\
    \ = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        var offset = -min * scale\n  \
    \      return numbers.map(x => (x - offset) * scale)", "        val min = numbers.min()\n\
    \        val max = numbers.max()\n        val scale = 1.0 / (max - min)\n    \
    \    val result = numbers.map(x => (x - min) * scale)\n        return result\n\
    \    }\n\n    // Given a list of numbers, compute the sum of the squares of those\
    \ numbers\n    // >>> squareSum(List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat,\
    \ 4.0f.toFloat, 5.0f.toFloat))\n    // 30.0f\n    def squareSum(numbers : List[Float])\
    \ : Float = {\n        val result = numbers.map(x => x * x).sum()\n        return\
    \ result\n    }\n\n    // Given a list of numbers, compute the sum of the products\
    \ of those numbers\n    // >>> productSum(List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 120.0f\n    def productSum(numbers\
    \ : List[Float]) : Float = {\n        val result = numbers.map(x => x * x).sum()\n\
    \        return result\n    }\n\n    // Given a list of numbers, compute the sum\
    \ of the squares of those numbers\n    // >>> squareSum(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 30.0f\n   \
    \ def squareSum(numbers : List[Float]) : Float = {\n        val result = numbers.map(x\
    \ => x * x).sum()\n        return result\n    }\n\n    // Given a list of numbers,\
    \ compute the sum of the products of those numbers\n    // >>> productSum(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 120.0f\n  \
    \  def productSum(numbers : List[Float]) : Float = {\n        val result = numbers.map(x\
    \ =>", "        var min = numbers.head\n        var max = numbers.head\n     \
    \   for (i <- numbers.size - 1) {\n            if (numbers[i] < min) {\n     \
    \           min = numbers[i]\n            }\n            if (numbers[i] > max)\
    \ {\n                max = numbers[i]\n            }\n        }\n        var scale\
    \ = 1.0f / (max - min)\n        var result = List[Float](0.0f)\n        for (i\
    \ <- numbers.size) {\n            result = result.updated(i, numbers[i] * scale\
    \ - min * scale)\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0f / (max - min)\n      \
    \  var result = List[Float](0.0f)\n        for (i <- numbers.size) {\n       \
    \     result = result.append(numbers[i] - min)\n            result = result.append(numbers[i]\
    \ - min)\n        }\n        for (i <- result.size - 1) {\n            result[i]\
    \ = result[i] * scale\n        }\n        return result", "        val min = numbers.min()\n\
    \        val max = numbers.max()\n        val scale = 1.0 / (max - min)\n    \
    \    val result = mutable.List[Float]()\n        for (i <- numbers.size) {\n \
    \           result.append(scale * (numbers.apply(i) - min))\n        }\n     \
    \   return result", "        var min = numbers.min()\n        var max = numbers.max()\n\
    \        var scale = 1.0 / (max - min)\n        return numbers.map(x => (x - min)\
    \ * scale)\n    }\n\n    // Given a list of numbers, return a list of the squares\
    \ of those numbers\n    // >>> squareList((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](1.0f.toFloat,\
    \ 4.0f.toFloat, 9.0f.toFloat, 16.0f.toFloat, 25.0f.toFloat))\n    def squareList(numbers\
    \ : List[Float]) : List[Float] = {\n        return numbers.map(x => x * x)\n \
    \   }\n\n    // Given a list of numbers, return a list of the cubes of those numbers\n\
    \    // >>> cubeList((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat,\
    \ 5.0f.toFloat)))\n    // (List[Float](1.0f.toFloat, 8.0f.toFloat, 27.0f.toFloat,\
    \ 64.0f.toFloat, 125.0f.toFloat))\n    def cubeList(numbers : List[Float]) : List[Float]\
    \ = {\n        return numbers.map(x => x * x * x)\n    }\n\n    // Given a list\
    \ of numbers, return a list of the squares of those numbers\n    // >>> squareList((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](1.0f.toFloat,\
    \ 4.0f.toFloat, 9.0f.toFloat, 16.0f.toFloat, 25.0f.toFloat))\n    def squareList(numbers\
    \ : List[Float]) : List[Float] = {\n        return numbers.map(x => x * x)\n \
    \   }", "        var min = numbers.head\n        var max = numbers.head\n    \
    \    for (i <- numbers.size - 1) {\n            if (numbers[i] > max) max = numbers[i]\n\
    \            if (numbers[i] < min) min = numbers[i]\n        }\n        var scale\
    \ = 1.0 / (max - min)\n        var offset = -min * scale\n        var result =\
    \ List[Float]().setAll(offset)\n        for (i <- numbers.size - 1) {\n      \
    \      result = result.updated(i, numbers[i] * scale)\n        }\n        return\
    \ result", "        var min = numbers.head\n        var max = numbers.head\n \
    \       for (i <- numbers.size - 1) {\n            if (numbers[i] < min) {\n \
    \               min = numbers[i]\n            }\n            if (numbers[i] >\
    \ max) {\n                max = numbers[i]\n            }\n        }\n       \
    \ var scale = 1.0 / (max - min)\n        var result = List[Float](0.0)\n     \
    \   for (i <- numbers.size) {\n            result = result.append(numbers[i] -\
    \ min)\n        }\n        return result.map(x => x * scale)", "        var min\
    \ = numbers.head\n        var max = numbers.head\n        for (i <- numbers.size\
    \ - 1) {\n            if (numbers[i] < min) min = numbers[i]\n            if (numbers[i]\
    \ > max) max = numbers[i]\n        }\n        var scale = 1.0f / (max - min)\n\
    \        var result = List[Float](0.0f)\n        for (i <- numbers.size) {\n \
    \           result = result.append(numbers[i] - min * scale)\n        }\n    \
    \    return result", "        var min = numbers.min()\n        var max = numbers.max()\n\
    \        var scale = 1.0 / (max - min)\n        return numbers.map(x => (x - min)\
    \ * scale)\n    }\n\n    // Given a list of numbers, return a list of the same\
    \ length where the values have been\n    // transformed by a linear transform\
    \ such that the smallest number will become 0 and the\n    // largest will become\
    \ 1\n    // >>> rescaleToUnit(List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat,\
    \ 4.0f.toFloat, 5.0f.toFloat))\n    // (List[Float](0.0f.toFloat, 0.25f.toFloat,\
    \ 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers :\
    \ List[Float]) : List[Float] = {\n        var min = numbers.min()\n        var\
    \ max = numbers.max()\n        var scale = 1.0 / (max - min)\n        return numbers.map(x\
    \ => (x - min) * scale)\n    }\n\n    // Given a list of numbers, return a list\
    \ of the same length where the values have been\n    // transformed by a linear\
    \ transform such that the smallest number will become 0 and the\n    // largest\
    \ will become 1\n    // >>> rescaleToUnit(List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var min = numbers.min()\n        var\
    \ max = numbers.max()\n        var scale = 1.0 / (max - min)\n        return numbers.map(x\
    \ => (x - min) * scale)\n    }\n\n    // Given a list of numbers, return a list\
    \ of the same length where the values", "        var min = numbers.min()\n   \
    \     var max = numbers.max()\n        var scale = 1.0 / (max - min)\n       \
    \ return numbers.map(x => (x - min) * scale)", "        var min = numbers.min()\n\
    \        var max = numbers.max()\n        var scale = 1.0 / (max - min)\n    \
    \    return numbers.map(x => (x - min) * scale)", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n       \
    \ var result = List[Float](0.0)\n        for (i <- numbers.size) {\n         \
    \   result = result.updated(i, numbers[i] * scale)\n        }\n        return\
    \ result", "        val min = numbers.min()\n        val max = numbers.max()\n\
    \        val scale = 1.0 / (max - min)\n        val result = numbers.map(x =>\
    \ (x - min) * scale)\n        return result\n    }\n\n    // Given a list of numbers,\
    \ return a list of numbers that are the result of applying the\n    // given linear\
    \ transform to each number in the original list\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescale(numbers\
    \ : List[Float], scale : List[Float]) : List[Float] = {\n        val result =\
    \ numbers.map(x => (x - min) * scale)\n        return result\n    }\n\n    //\
    \ Given a list of numbers, return a list of numbers that are the result of applying\
    \ the\n    // given linear transform to each number in the original list\n   \
    \ // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat,\
    \ 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat, 0.25f.toFloat,\
    \ 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers :\
    \ List[Float]) : List[Float] = {\n        val min = numbers.min()\n        val\
    \ max = numbers.max()\n        val scale = 1.0 / (max - min)\n        val result\
    \ = numbers.map(x => (x - min) * scale)\n        return result\n    }\n\n    //\
    \ Given a list of numbers, return a list of numbers that are the result of applying\
    \ the\n    // given linear transform to each number in the original list\n   \
    \ // >>> rescaleToUnit((List[Float](1.0f.to", "        var min = numbers.min()\n\
    \        var max = numbers.max()\n        var scale = 1.0f / (max - min)\n   \
    \     return numbers.map(x => (x - min) * scale)\n    }\n\n    // Given a list\
    \ of numbers, return a list of numbers that are the same as the input\n    //\
    \ except that the first number is 0 and the last number is 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var min = numbers.min()\n        var\
    \ max = numbers.max()\n        var scale = 1.0f / (max - min)\n        return\
    \ numbers.map(x => (x - min) * scale)\n    }\n\n    // Given a list of numbers,\
    \ return a list of numbers that are the same as the input\n    // except that\
    \ the first number is 0 and the last number is 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var min = numbers.min()\n        var\
    \ max = numbers.max()\n        var scale = 1.0f / (max - min)\n        return\
    \ numbers.map(x => (x - min) * scale)\n    }\n\n    // Given a list of numbers,\
    \ return a list of numbers that are the same as the input\n    // except that\
    \ the first number is 0 and the last", "        var min = numbers.min()\n    \
    \    var max = numbers.max()\n        var scale = 1.0 / (max - min)\n        return\
    \ numbers.map(x => (x - min) * scale)\n    }\n\n    // Given list of numbers (of\
    \ at least two elements), apply a linear transform to that list,\n    // such\
    \ that the smallest number will become 0 and the largest will become 1\n    //\
    \ >>> rescaleToUnit((List[Double](1.0, 2.0, 3.0, 4.0, 5.0)))\n    // (List[Double](0.0,\
    \ 0.25, 0.5, 0.75, 1.0))\n    def rescaleToUnit(numbers : List[Double]) : List[Double]\
    \ = {\n        var min = numbers.min()\n        var max = numbers.max()\n    \
    \    var scale = 1.0 / (max - min)\n        return numbers.map(x => (x - min)\
    \ * scale)\n    }\n\n    // Given list of numbers (of at least two elements),\
    \ apply a linear transform to that list,\n    // such that the smallest number\
    \ will become 0 and the largest will become 1\n    // >>> rescaleToUnit((List[Int](1,\
    \ 2, 3, 4, 5)))\n    // (List[Int](0, 0, 0, 0, 0))\n    def rescaleToUnit(numbers\
    \ : List[Int]) : List[Int] = {\n        var min = numbers.min()\n        var max\
    \ = numbers.max()\n        var scale = 1.0 / (max - min)\n        return numbers.map(x\
    \ => (x - min) * scale)\n    }\n\n    // Given list of numbers (of at least two\
    \ elements), apply a linear transform to that list,\n    // such that the smallest\
    \ number will become 0 and the largest will become 1\n    // >>> rescaleToUnit((List[Long](1L,\
    \ 2L, 3L, 4L, 5L)))\n    // (List[Long](0L, 0L, 0L, 0L, 0L))\n    def rescaleToUnit(numbers\
    \ : List[Long]) : List[Long] = {\n        var min = numbers.min()\n        var\
    \ max = numbers.max()\n        var", "        var min = numbers.min()\n      \
    \  var max = numbers.max()\n        var scale = (max - min) / (max - min)\n  \
    \      return numbers.map(x => (x - min) * scale + min)", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n       \
    \ for (i <- numbers.size) {\n            numbers[i] = numbers[i] - min\n     \
    \       numbers[i] = numbers[i] * scale\n        }\n        return numbers", " \
    \       var min = numbers.head\n        var max = numbers.head\n        for (i\
    \ <- numbers.size - 1) {\n            if (numbers[i] < min) min = numbers[i]\n\
    \            if (numbers[i] > max) max = numbers[i]\n        }\n        var scale\
    \ = 1.0 / (max - min)\n        var result = List[Float](0.0)\n        for (i <-\
    \ numbers.size) {\n            result = result.updated(i, (numbers[i] - min) *\
    \ scale)\n        }\n        return result", "        var min = numbers.min()\n\
    \        var max = numbers.max()\n        var scale = 1.0 / (max - min)\n    \
    \    var result = List[Float]().setAll(min)\n        for (i <- numbers.size) {\n\
    \            result = result.updated(i, (numbers.apply(i) - min) * scale)\n  \
    \      }\n        return result", "        var min = numbers.head\n        var\
    \ max = numbers.head\n        for (i <- numbers.size - 1) {\n            if (numbers[i]\
    \ < min) min = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n\
    \        }\n        var scale = 1.0 / (max - min)\n        var result = List[Float](0.0)\n\
    \        for (i <- numbers.size) {\n            result = result.updated(i, numbers[i]\
    \ * scale)\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       min = min._min(numbers.apply(i))\n            max = max._max(numbers.apply(i))\n\
    \        }\n        var scale = 1.0 / (max - min)\n        var offset = -min *\
    \ scale\n        return numbers.map(x => (x - min) * scale + offset)", "     \
    \   var min = numbers.head\n        var max = numbers.head\n        for (i <-\
    \ numbers.size - 1) {\n            if (numbers[i] < min) min = numbers[i]\n  \
    \          if (numbers[i] > max) max = numbers[i]\n        }\n        var scale\
    \ = 1.0 / (max - min)\n        var result = List[Float](0.0)\n        for (i <-\
    \ numbers.size) {\n            result = result.append(numbers[i] - min)\n    \
    \    }\n        for (i <- result.size - 1) {\n            result[i] = result[i]\
    \ * scale\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] > max) max = numbers[i]\n            if (numbers[i] < min)\
    \ min = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n       \
    \ var result = List[Float](0.0f.toFloat)\n        for (i <- numbers.size) {\n\
    \            result = result.append(numbers[i] - min * scale)\n        }\n   \
    \     return result", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min\
    \ = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        var result = List[Float]()\n \
    \       for (i <- numbers.size) {\n            result = result.append(numbers[i]\
    \ - min)\n        }\n        for (i <- result.size - 1) {\n            result[i]\
    \ = result[i] * scale\n        }\n        return result\n    }\n\n    // Given\
    \ a list of numbers, return a list of the same length where the first element\
    \ is the\n    // smallest and the last element is the largest\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var min = numbers.head\n        var\
    \ max = numbers.head\n        for (i <- numbers.size - 1) {\n            if (numbers[i]\
    \ < min) min = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n\
    \        }\n        var scale = 1.0 / (max - min)\n        var result = List[Float]()\n\
    \        for (i <- numbers.size) {\n            result = result.append(numbers[i]\
    \ - min)\n        }\n        for (i <- result.size - 1) {\n            result[i]\
    \ = result[i] * scale\n        }\n        return result\n    }\n\n    // Given\
    \ a list of numbers, return a list of the same length where the first element\
    \ is the\n    // smallest and the last element is the largest\n    // >>> rescaleToUnit",
  "        var min = numbers.head\n        var max = numbers.head\n        for (i\
    \ <- numbers.size - 1) {\n            if (numbers[i] > max) max = numbers[i]\n\
    \            if (numbers[i] < min) min = numbers[i]\n        }\n        var scale\
    \ = 1.0 / (max - min)\n        var result = List[Float](0.0f.toFloat)\n      \
    \  for (i <- numbers.size) {\n            result = result.append(numbers[i] -\
    \ min * scale)\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       min = min.min(numbers.apply(i))\n            max = max.max(numbers.apply(i))\n\
    \        }\n        var scale = 1.0 / (max - min)\n        var offset = -min *\
    \ scale\n        return numbers.map(x => (x - min) * scale + offset)", "     \
    \   var min = numbers.head\n        var max = numbers.head\n        for (i <-\
    \ numbers.size - 1) {\n            if (numbers[i] < min) min = numbers[i]\n  \
    \          if (numbers[i] > max) max = numbers[i]\n        }\n        var scale\
    \ = 1.0 / (max - min)\n        for (i <- numbers.size) {\n            numbers[i]\
    \ = numbers[i] * scale - min\n        }\n        return numbers", "        var\
    \ min = numbers.min()\n        var max = numbers.max()\n        var scale = 1.0\
    \ / (max - min)\n        return numbers.map(x => (x - min) * scale)", "      \
    \  var min = numbers.head\n        var max = numbers.head\n        for (i <- numbers.size\
    \ - 1) {\n            if (numbers[i] < min) min = numbers[i]\n            if (numbers[i]\
    \ > max) max = numbers[i]\n        }\n        var scale = 1.0f / (max - min)\n\
    \        var result = List[Float](0.0f)\n        for (i <- numbers.size) {\n \
    \           result = result.append(numbers[i] - min * scale)\n        }\n    \
    \    return result", "        var min = numbers.min()\n        var max = numbers.max()\n\
    \        var scale = 1.0 / (max - min)\n        var result = List[Float](0.0f.toFloat)\n\
    \        for (i <- numbers.size) {\n            result = result.updated(i, (numbers[i]\
    \ - min) * scale)\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n       \
    \ var result = List[Float](0.0)\n        for (i <- numbers.size) {\n         \
    \   result = result.updated(i, numbers[i] * scale)\n        }\n        return\
    \ result", "        var min = numbers.head\n        var max = numbers.head\n \
    \       for (i <- numbers.size - 1) {\n            min = min.min(numbers.apply(i))\n\
    \            max = max.max(numbers.apply(i))\n        }\n        var scale = 1.0\
    \ / (max - min)\n        var offset = -min * scale\n        return numbers.map(x\
    \ => (x - min) * scale + offset)", "        var min = numbers.head\n        var\
    \ max = numbers.head\n        for (i <- numbers.size - 1) {\n            if (numbers[i]\
    \ < min) min = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n\
    \        }\n        var scale = 1.0f / (max - min)\n        var result = List[Float]()\n\
    \        for (i <- numbers.size) {\n            result = result.append(numbers[i]\
    \ - min) * scale\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n       \
    \ var result = List[Float](0.0)\n        for (i <- numbers.size) {\n         \
    \   result = result.updated(i, (numbers[i] - min) * scale)\n        }\n      \
    \  return result", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min\
    \ = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        var result = List[Float]()\n \
    \       for (i <- numbers.size) {\n            result = result.append(numbers[i]\
    \ - min)\n        }\n        for (i <- result.size - 1) {\n            result[i]\
    \ = result[i] * scale\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n       \
    \ var result = List[Float](0.0)\n        for (i <- numbers.size) {\n         \
    \   result = result.updated(i, (numbers[i] - min) * scale)\n        }\n      \
    \  return result", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            if (numbers[i] < min) {\n\
    \                min = numbers[i]\n            }\n            if (numbers[i] >\
    \ max) {\n                max = numbers[i]\n            }\n        }\n       \
    \ var scale = 1.0 / (max - min)\n        var result = List[Float](0.0)\n     \
    \   for (i <- numbers.size) {\n            result = result.append(numbers[i] -\
    \ min * scale)\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n       \
    \ var result = List[Float](0.0)\n        for (i <- numbers.size) {\n         \
    \   result = result.updated(i, (numbers[i] - min) * scale)\n        }\n      \
    \  return result", "        val min = numbers.min()\n        val max = numbers.max()\n\
    \        val scale = 1.0 / (max - min)\n        val result = numbers.map(x =>\
    \ (x - min) * scale)\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) {\n                min = numbers[i]\n          \
    \  }\n            if (numbers[i] > max) {\n                max = numbers[i]\n\
    \            }\n        }\n        var scale = 1.0f / (max - min)\n        var\
    \ result = List[Float]()\n        for (i <- numbers.size) {\n            result\
    \ = result.append(numbers[i] - min * scale)\n        }\n        return result",
  "        val min = numbers.min()\n        val max = numbers.max()\n        val scale\
    \ = 1.0f / (max - min)\n        val result = numbers.map(x => (x - min) * scale)\n\
    \        return result", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            if (numbers[i] < min) {\n\
    \                min = numbers[i]\n            }\n            if (numbers[i] >\
    \ max) {\n                max = numbers[i]\n            }\n        }\n       \
    \ var scale = 1.0 / (max - min)\n        var result = List[Float]()\n        for\
    \ (i <- numbers.size) {\n            result = result.append(numbers[i] - min)\n\
    \        }\n        for (i <- result.size - 1) {\n            result[i] = result[i]\
    \ * scale\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n       \
    \ for (i <- numbers.size) {\n            numbers[i] = numbers[i] - min\n     \
    \       numbers[i] = numbers[i] * scale\n        }\n        return numbers", " \
    \       val min = numbers.min()\n        val max = numbers.max()\n        val\
    \ scale = (max - min) / (max - min)\n        val result = numbers.map(x => x *\
    \ scale + min)\n        return result", "        var min = numbers.head\n    \
    \    var max = numbers.head\n        for (i <- numbers.size - 1) {\n         \
    \   if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n       \
    \ var result = List[Float]()\n        for (i <- numbers.size) {\n            result\
    \ += numbers[i] - min\n            result *= scale\n        }\n        return\
    \ result", "        var min = numbers.head\n        var max = numbers.head\n \
    \       for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min =\
    \ numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        var result = List[Float](0.0)\n\
    \        for (i <- numbers.size) {\n            result = result.updated(i, numbers[i]\
    \ - min * scale)\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0f / (max - min)\n      \
    \  var result = List[Float](0.0f)\n        for (i <- numbers.size) {\n       \
    \     result = result.append(numbers[i] - min) * scale\n        }\n        return\
    \ result", "        var min = numbers.head\n        var max = numbers.head\n \
    \       for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min =\
    \ numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        var result = List[Float]()\n \
    \       for (i <- numbers.size) {\n            result = result.append(numbers[i]\
    \ - min)\n        }\n        for (i <- result.size - 1) {\n            result[i]\
    \ = result[i] * scale\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) {\n                min = numbers[i]\n          \
    \  }\n            if (numbers[i] > max) {\n                max = numbers[i]\n\
    \            }\n        }\n        var scale = 1.0 / (max - min)\n        var\
    \ result = List[Float](0.0)\n        for (i <- numbers.size) {\n            result\
    \ = result.updated(i, numbers[i] * scale - min * scale)\n        }\n        return\
    \ result", "        var min = numbers.head\n        var max = numbers.head\n \
    \       for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min =\
    \ numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        var result = mutable.List[Float]()\n\
    \        for (i <- numbers.size) {\n            result.append(numbers[i] - min)\
    \ * scale\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) {\n                min = numbers[i]\n          \
    \  }\n            if (numbers[i] > max) {\n                max = numbers[i]\n\
    \            }\n        }\n        var scale = 1.0 / (max - min)\n        var\
    \ result = List[Float]()\n        for (i <- numbers.size) {\n            result\
    \ = result.append(numbers[i] - min)\n        }\n        for (i <- result.size\
    \ - 1) {\n            result[i] = result[i] * scale\n        }\n        return\
    \ result", "        var min = numbers.min()\n        var max = numbers.max()\n\
    \        var scale = 1.0 / (max - min)\n        return numbers.map(x => (x - min)\
    \ * scale)", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min\
    \ = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        var result = List[Float](0.0)\n\
    \        for (i <- numbers.size) {\n            result = result.updated(i, (numbers[i]\
    \ - min) * scale)\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) {\n                min = numbers[i]\n          \
    \  }\n            if (numbers[i] > max) {\n                max = numbers[i]\n\
    \            }\n        }\n        var scale = 1.0f / (max - min)\n        var\
    \ result = List[Float](0.0f)\n        for (i <- numbers.size) {\n            result\
    \ = result.append(numbers[i] - min)\n        }\n        for (i <- result.size\
    \ - 1) {\n            result[i] = result[i] * scale\n        }\n        return\
    \ result", "        var min = numbers.min()\n        var max = numbers.max()\n\
    \        var scale = 1.0 / (max - min)\n        var result = mutable.List[Float]()\n\
    \        for (i <- numbers.size) {\n            result.append(numbers.apply(i)\
    \ - min) * scale\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) {\n                min = numbers[i]\n          \
    \  }\n            if (numbers[i] > max) {\n                max = numbers[i]\n\
    \            }\n        }\n        var scale = 1.0f / (max - min)\n        var\
    \ result = mutable.List[Float]()\n        for (i <- numbers.size) {\n        \
    \    result = result.append(numbers[i] - min)\n        }\n        for (i <- result.size\
    \ - 1) {\n            result[i] = result[i] * scale\n        }\n        return\
    \ result", "        var min = numbers.head\n        var max = numbers.head\n \
    \       for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min =\
    \ numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0f / (max - min)\n        var result = List[Float](0.0f)\n\
    \        for (i <- numbers.size) {\n            result = result.updated(i, (numbers[i]\
    \ - min) * scale)\n        }\n        return result", "        var min = numbers.min()\n\
    \        var max = numbers.max()\n        var scale = 1.0 / (max - min)\n    \
    \    var result = List[Float]().setAll(min)\n        for (var i = 0; i < numbers.size();\
    \ i++) {\n            result = result.updated(i, numbers.apply(i) * scale)\n \
    \       }\n        return result\n    }\n\n    // Given a list of numbers, compute\
    \ the sum of the squares of the numbers\n    // >>> squareSum(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 30.0f\n   \
    \ def squareSum(numbers : List[Float]) : Float = {\n        var result = 0.0\n\
    \        for (var i = 0; i < numbers.size(); i++) {\n            result = result\
    \ + numbers.apply(i) * numbers.apply(i)\n        }\n        return result\n  \
    \  }\n\n    // Given a list of numbers, compute the sum of the products of the\
    \ numbers\n    // >>> productSum(List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat,\
    \ 4.0f.toFloat, 5.0f.toFloat))\n    // 120.0f\n    def productSum(numbers : List[Float])\
    \ : Float = {\n        var result = 1.0\n        for (var i = 0; i < numbers.size();\
    \ i++) {\n            result = result * numbers.apply(i)\n        }\n        return\
    \ result\n    }\n\n    // Given a list of numbers, compute the sum of the absolute\
    \ values of the numbers\n    // >>> absSum(List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 5.0f\n    def absSum(numbers\
    \ : List[Float]) : Float = {\n        var result = 0.0\n        for (var i = 0;\
    \ i < numbers.size(); i++) {\n            result = result + Math.abs(", "    \
    \    var min = numbers.head\n        var max = numbers.head\n        for (i <-\
    \ numbers.size - 1) {\n            if (numbers[i] < min) min = numbers[i]\n  \
    \          if (numbers[i] > max) max = numbers[i]\n        }\n        var scale\
    \ = 1.0 / (max - min)\n        var result = List[Float](0.0)\n        for (i <-\
    \ numbers.size) {\n            result = result.updated(i, numbers[i] - min * scale)\n\
    \        }\n        return result\n    }\n\n    // Given a list of numbers, return\
    \ a list of the same length where each number is the\n    // sum of the numbers\
    \ in the original list that are less than it.\n    // >>> sumUpTo(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // (List[Float](0.0f.toFloat,\
    \ 1.0f.toFloat, 3.0f.toFloat, 6.0f.toFloat, 10.0f.toFloat))\n    def sumUpTo(numbers\
    \ : List[Float]) : List[Float] = {\n        var result = List[Float](0.0)\n  \
    \      for (i <- numbers.size) {\n            result = result.updated(i, numbers[i]\
    \ + sumUpTo(numbers.updated(i + 1, _)).head)\n        }\n        return result\n\
    \    }\n\n    // Given a list of numbers, return a list of the same length where\
    \ each number is the\n    // product of the numbers in the original list that\
    \ are less than it.\n    // >>> productUpTo(List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // (List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 6.0f.toFloat, 24.0f.toFloat, 120.0f.toFloat))\n    def productUpTo(numbers\
    \ : List[Float]) :", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min\
    \ = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        for (i <- numbers.size) {\n  \
    \          numbers[i] = numbers[i] - min\n            numbers[i] = numbers[i]\
    \ * scale\n        }\n        return numbers", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0f / (max - min)\n      \
    \  var result = List[Float](0.0f)\n        for (i <- numbers.size) {\n       \
    \     result = result.append(numbers[i] - min) * scale\n        }\n        return\
    \ result", "        var min = numbers.head\n        var max = numbers.head\n \
    \       for (i <- numbers.size - 1) {\n            if (numbers[i] > max) max =\
    \ numbers[i]\n            if (numbers[i] < min) min = numbers[i]\n        }\n\
    \        var scale = 1.0f / (max - min)\n        var result = List[Float]()\n\
    \        for (i <- numbers.size) {\n            result = result.append(numbers[i]\
    \ - min) * scale\n        }\n        return result\n    }\n\n    // Given a list\
    \ of numbers, return a list of the squares of those numbers\n    // >>> squareList(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // (List[Float](1.0f.toFloat,\
    \ 4.0f.toFloat, 9.0f.toFloat, 16.0f.toFloat, 25.0f.toFloat))\n    def squareList(numbers\
    \ : List[Float]) : List[Float] = {\n        var result = List[Float]()\n     \
    \   for (i <- numbers.size) {\n            result = result.append(numbers[i] *\
    \ numbers[i])\n        }\n        return result\n    }\n\n    // Given a list\
    \ of numbers, return a list of the cubes of those numbers\n    // >>> cubeList(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // (List[Float](1.0f.toFloat,\
    \ 8.0f.toFloat, 27.0f.toFloat, 64.0f.toFloat, 125.0f.toFloat))\n    def cubeList(numbers\
    \ : List[Float]) : List[Float] = {\n        var result = List[Float]()\n     \
    \   for (i <- numbers.size) {\n            result = result.append(numbers[i] *\
    \ numbers[i] * numbers[i])\n        }\n        return result\n    }\n\n    //\
    \ Given", "        var min = numbers.min()\n        var max = numbers.max()\n\
    \        var scale = 1.0 / (max - min)\n        return numbers.map(x => (x - min)\
    \ * scale)", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            if (numbers[i] < min) {\n\
    \                min = numbers[i]\n            }\n            if (numbers[i] >\
    \ max) {\n                max = numbers[i]\n            }\n        }\n       \
    \ var scale = 1.0 / (max - min)\n        var result = mutable.List[Float]()\n\
    \        for (i <- numbers.size) {\n            result += numbers[i] * scale\n\
    \        }\n        return result", "        var min = numbers.head\n        var\
    \ max = numbers.head\n        for (i <- numbers.size - 1) {\n            if (numbers[i]\
    \ < min) min = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n\
    \        }\n        var scale = 1.0 / (max - min)\n        var result = List[Float](0.0)\n\
    \        for (i <- numbers.size) {\n            result = result.updated(i, numbers[i]\
    \ * scale)\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0f / (max - min)\n      \
    \  var result = List[Float](0.0f.toFloat)\n        for (i <- numbers.size) {\n\
    \            result = result.updated(i, (numbers[i] - min) * scale)\n        }\n\
    \        return result\n    }\n\n    // Given a list of numbers, return the sum\
    \ of the squares of those numbers\n    // >>> squareSum(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 30.0f\n   \
    \ def squareSum(numbers : List[Float]) : Float = {\n        var result = 0.0f\n\
    \        for (i <- numbers.size) {\n            result = result + numbers[i] *\
    \ numbers[i]\n        }\n        return result\n    }\n\n    // Given a list of\
    \ numbers, return the sum of the products of those numbers\n    // >>> productSum(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 120.0f\n  \
    \  def productSum(numbers : List[Float]) : Float = {\n        var result = 0.0f\n\
    \        for (i <- numbers.size) {\n            result = result + numbers[i] *\
    \ numbers[i]\n        }\n        return result\n    }\n\n    // Given a list of\
    \ numbers, return the sum of the squares of those numbers\n    // >>> squareSum(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 30.0f\n   \
    \ def squareSum(numbers : List[Float]) : Float = {\n", "        var min = numbers.min()\n\
    \        var max = numbers.max()\n        var scale = 1.0 / (max - min)\n    \
    \    return numbers.map(x => (x - min) * scale)", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n       \
    \ var result = List[Float](0.0)\n        for (i <- numbers.size) {\n         \
    \   result = result.updated(i, numbers[i] * scale - min * scale)\n        }\n\
    \        return result\n    }\n\n    // Given list of numbers (of at least two\
    \ elements), apply a linear transform to that list,\n    // such that the smallest\
    \ number will become 0 and the largest will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var min = numbers.head\n        var\
    \ max = numbers.head\n        for (i <- numbers.size - 1) {\n            if (numbers[i]\
    \ < min) min = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n\
    \        }\n        var scale = 1.0 / (max - min)\n        var result = List[Float](0.0)\n\
    \        for (i <- numbers.size) {\n            result = result.updated(i, numbers[i]\
    \ * scale - min * scale)\n        }\n        return result\n    }\n\n    // Given\
    \ list of numbers (of at least two elements), apply a linear transform to that\
    \ list,\n    // such that the smallest number will become 0 and the largest will\
    \ become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4", "        val min = numbers.min()\n        val max = numbers.max()\n\
    \        val scale = 1.0 / (max - min)\n        val result = numbers.map(x =>\
    \ (x - min) * scale)\n        return result\n    }\n\n    // Given a list of numbers,\
    \ find the sum of the squares of those numbers\n    // >>> squareSum(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 30.0f\n   \
    \ def squareSum(numbers : List[Float]) : Float = {\n        val result = numbers.map(x\
    \ => x * x).sum()\n        return result\n    }\n\n    // Given a list of numbers,\
    \ find the sum of the products of those numbers\n    // >>> productSum(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 120.0f\n  \
    \  def productSum(numbers : List[Float]) : Float = {\n        val result = numbers.map(x\
    \ => x * x).sum()\n        return result\n    }\n\n    // Given a list of numbers,\
    \ find the sum of the products of the squares of those numbers\n    // >>> squareProductSum(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 300.0f\n  \
    \  def squareProductSum(numbers : List[Float]) : Float = {\n        val result\
    \ = numbers.map(x => x * x).map(x => x * x).sum()\n        return result\n   \
    \ }\n\n    // Given a list of numbers, find the sum of the products of the squares\
    \ of those numbers\n    // >>> squareSum(List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 30.0f\n    def squareSum(numbers\
    \ : List[Float", "        var min = numbers.min()\n        var max = numbers.max()\n\
    \        var scale = 1.0 / (max - min)\n        return numbers.map(x => (x - min)\
    \ * scale)", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min\
    \ = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        var result = List[Float](0.0)\n\
    \        for (i <- numbers.size) {\n            result = result.updated(i, numbers[i]\
    \ * scale - min * scale)\n        }\n        return result", "        var min\
    \ = numbers.head\n        var max = numbers.head\n        for (i <- numbers.size\
    \ - 1) {\n            min = min.min(numbers.apply(i))\n            max = max.max(numbers.apply(i))\n\
    \        }\n        var scale = 1.0 / (max - min)\n        var offset = -min *\
    \ scale\n        return numbers.map(x => (x - offset) * scale)", "        var\
    \ min = numbers.head\n        var max = numbers.head\n        for (i <- numbers.size\
    \ - 1) {\n            if (numbers[i] < min) min = numbers[i]\n            if (numbers[i]\
    \ > max) max = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n\
    \        var result = List[Float](0.0)\n        for (i <- numbers.size) {\n  \
    \          result = result.updated(i, numbers[i] * scale - min)\n        }\n \
    \       return result", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            if (numbers[i] < min) {\n\
    \                min = numbers[i]\n            }\n            if (numbers[i] >\
    \ max) {\n                max = numbers[i]\n            }\n        }\n       \
    \ var scale = 1.0 / (max - min)\n        var result = List[Float](0.0)\n     \
    \   for (i <- numbers.size) {\n            result = result.updated(i, (numbers[i]\
    \ - min) * scale)\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n       \
    \ for (i <- numbers.size) {\n            numbers[i] = numbers[i] - min\n     \
    \       numbers[i] = numbers[i] * scale\n        }\n        return numbers", " \
    \       var min = numbers.head\n        var max = numbers.head\n        for (i\
    \ <- numbers.size - 1) {\n            if (numbers[i] < min) {\n              \
    \  min = numbers[i]\n            }\n            if (numbers[i] > max) {\n    \
    \            max = numbers[i]\n            }\n        }\n        var scale = 1.0\
    \ / (max - min)\n        var result = List[Float](0.0)\n        for (i <- numbers.size)\
    \ {\n            result = result.append(numbers[i] - min * scale)\n        }\n\
    \        return result", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min\
    \ = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        var result = List[Float]()\n \
    \       for (i <- numbers.size) {\n            result = result.append(numbers[i]\
    \ - min) * scale\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) {\n                min = numbers[i]\n          \
    \  }\n            if (numbers[i] > max) {\n                max = numbers[i]\n\
    \            }\n        }\n        var scale = 1.0 / (max - min)\n        var\
    \ result = List[Float]()\n        for (i <- numbers.size) {\n            result\
    \ = result.append(numbers[i] - min * scale)\n        }\n        return result",
  "        var min = numbers.min()\n        var max = numbers.max()\n        var scale\
    \ = 1.0 / (max - min)\n        return numbers.map(x => (x - min) * scale)", " \
    \       var min = numbers.head\n        var max = numbers.head\n        for (i\
    \ <- numbers.size - 1) {\n            if (numbers[i] < min) min = numbers[i]\n\
    \            if (numbers[i] > max) max = numbers[i]\n        }\n        var scale\
    \ = 1.0 / (max - min)\n        var result = List[Float](0.0)\n        for (i <-\
    \ numbers.size) {\n            result = result.updated(i, numbers[i] - min * scale)\n\
    \        }\n        return result", "        var min = numbers.head\n        var\
    \ max = numbers.head\n        for (i <- numbers.size - 1) {\n            if (numbers[i]\
    \ < min) {\n                min = numbers[i]\n            }\n            if (numbers[i]\
    \ > max) {\n                max = numbers[i]\n            }\n        }\n     \
    \   var scale = 1.0 / (max - min)\n        var result = mutable.List[Float]()\n\
    \        for (i <- numbers.size) {\n            result.append(numbers[i] - min)\
    \ * scale\n        }\n        return result", "        var min = numbers.min()\n\
    \        var max = numbers.max()\n        var scale = 1.0 / (max - min)\n    \
    \    return numbers.map(x => (x - min) * scale)\n    }\n\n    // Given list of\
    \ numbers (of at least two elements), apply a linear transform to that list,\n\
    \    // such that the smallest number will become 0 and the largest will become\
    \ 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat,\
    \ 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat, 0.25f.toFloat,\
    \ 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers :\
    \ List[Float]) : List[Float] = {\n        var min = numbers.min()\n        var\
    \ max = numbers.max()\n        var scale = 1.0 / (max - min)\n        return numbers.map(x\
    \ => (x - min) * scale)\n    }\n\n    // Given list of numbers (of at least two\
    \ elements), apply a linear transform to that list,\n    // such that the smallest\
    \ number will become 0 and the largest will become 1\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat,\
    \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers\
    \ : List[Float]) : List[Float] = {\n        var min = numbers.min()\n        var\
    \ max = numbers.max()\n        var scale = 1.0 / (max - min)\n        return numbers.map(x\
    \ => (x - min) * scale)\n    }\n\n    // Given list of numbers (of at least two\
    \ elements), apply a linear transform to that list,\n    // such that the smallest\
    \ number will become 0", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min\
    \ = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        var result = List[Float](0.0)\n\
    \        for (i <- numbers.size) {\n            result = result.append(numbers[i]\
    \ - min) * scale\n        }\n        return result\n    }\n\n    // Given a list\
    \ of numbers, return a list of the same length with the numbers\n    // in sorted\
    \ order.\n    // >>> sort(List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat,\
    \ 4.0f.toFloat, 5.0f.toFloat))\n    // (List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    def sort(numbers : List[Float])\
    \ : List[Float] = {\n        var result = List[Float](0)\n        for (i <- numbers.size)\
    \ {\n            result = result.append(numbers[i])\n        }\n        return\
    \ result.sort()\n    }\n\n    // Given a list of numbers, return a list of the\
    \ same length with the numbers\n    // in sorted order.\n    // >>> sort(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // (List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    def sortBy(numbers\
    \ : List[Float], f : Function[Float] = Function(0)) : List[Float] = {\n      \
    \  var result = List[Float](0)\n        for (i <- numbers.size) {\n          \
    \  result = result.append(f(n", "        var min = numbers.head\n        var max\
    \ = numbers.head\n        for (i <- numbers.size - 1) {\n            if (numbers[i]\
    \ > max) max = numbers[i]\n            if (numbers[i] < min) min = numbers[i]\n\
    \        }\n        var scale = 1.0 / (max - min)\n        var result = List[Float](0.0)\n\
    \        for (i <- numbers.size) {\n            result = result.updated(i, numbers[i]\
    \ * scale - min * scale)\n        }\n        return result\n    }\n\n    // Given\
    \ a list of numbers, compute the sum of the squares of those numbers\n    // >>>\
    \ squareSum(List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat,\
    \ 5.0f.toFloat))\n    // 30.0\n    def squareSum(numbers : List[Float]) : Float\
    \ = {\n        var result = 0.0\n        for (i <- numbers.size) {\n         \
    \   result = result + numbers[i] * numbers[i]\n        }\n        return result\n\
    \    }\n\n    // Given a list of numbers, compute the sum of the products of those\
    \ numbers\n    // >>> productSum(List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat,\
    \ 4.0f.toFloat, 5.0f.toFloat))\n    // 120.0\n    def productSum(numbers : List[Float])\
    \ : Float = {\n        var result = 0.0\n        for (i <- numbers.size) {\n \
    \           result = result + numbers[i] * numbers[i]\n        }\n        return\
    \ result\n    }\n\n    // Given a list of numbers, compute the sum of the squares\
    \ of those numbers\n    // >>> squareSum(List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 30.0\n    def squareSum(numbers\
    \ : List[Float]) : Float = {\n        var result = 0.0\n        for (", "    \
    \    var min = numbers.min()\n        var max = numbers.max()\n        var scale\
    \ = 1.0 / (max - min)\n        return numbers.map(x => (x - min) * scale)\n  \
    \  }\n\n    // Given a list of numbers, find the sum of the squares of those numbers\n\
    \    // >>> squareSum(List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat,\
    \ 5.0f.toFloat))\n    // 30.0\n    def squareSum(numbers : List[Float]) : Float\
    \ = {\n        var sum = 0.0\n        for (var x : numbers) {\n            sum\
    \ += x * x\n        }\n        return sum\n    }\n\n    // Given a list of numbers,\
    \ find the sum of the products of those numbers\n    // >>> productSum(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 120.0\n   \
    \ def productSum(numbers : List[Float]) : Float = {\n        var sum = 0.0\n \
    \       for (var x : numbers) {\n            sum += x * x\n        }\n       \
    \ return sum\n    }\n\n    // Given a list of numbers, find the sum of the products\
    \ of the squares of those numbers\n    // >>> squareProductSum(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 300.0\n   \
    \ def squareProductSum(numbers : List[Float]) : Float = {\n        var sum = 0.0\n\
    \        for (var x : numbers) {\n            sum += x * x * x\n        }\n  \
    \      return sum\n    }\n\n    // Given a list of numbers, find the sum of the\
    \ cubes of those numbers\n    // >>> cubeSum(List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 125", "        val min =\
    \ numbers.min()\n        val max = numbers.max()\n        val scale = 1.0 / (max\
    \ - min)\n        val result = mutable.List[Float]()\n        for (i <- numbers.size)\
    \ {\n            result.append(numbers.apply(i) - min) * scale\n        }\n  \
    \      return result", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min\
    \ = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        var result = List[Float](0.0)\n\
    \        for (i <- numbers.size) {\n            result = result.updated(i, (numbers[i]\
    \ - min) * scale)\n        }\n        return result", "        var min = numbers.min()\n\
    \        var max = numbers.max()\n        var scale = 1.0 / (max - min)\n    \
    \    return numbers.map(x => (x - min) * scale)", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0f / (max - min)\n      \
    \  var result = List[Float](0.0f)\n        for (i <- numbers.size) {\n       \
    \     result = result.append(numbers[i] - min) * scale\n        }\n        return\
    \ result", "        var min = numbers.min()\n        var max = numbers.max()\n\
    \        var scale = 1.0f / (max - min)\n        return numbers.map(x => (x -\
    \ min) * scale)", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min\
    \ = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0f / (max - min)\n        var result = List[Float](0.0f)\n\
    \        for (i <- numbers.size) {\n            result = result.append(numbers[i]\
    \ - min * scale)\n        }\n        return result", "        val min = numbers.min()\n\
    \        val max = numbers.max()\n        val scale = 1.0 / (max - min)\n    \
    \    val result = mutable.List[Float]()\n        for (i <- numbers.size) {\n \
    \           result.append(min + (i * scale))\n        }\n        return result",
  "        val min = numbers.min()\n        val max = numbers.max()\n        val scale\
    \ = 1.0 / (max - min)\n        val result = numbers.map(x => (x - min) * scale)\n\
    \        return result\n    }\n\n    // Given a list of numbers, return a list\
    \ of the squares of those numbers\n    // >>> square(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // (List[Float](1.0f.toFloat,\
    \ 4.0f.toFloat, 9.0f.toFloat, 16.0f.toFloat, 25.0f.toFloat))\n    def square(numbers\
    \ : List[Float]) : List[Float] = {\n        val result = numbers.map(x => x *\
    \ x)\n        return result\n    }\n\n    // Given a list of numbers, return a\
    \ list of the cubes of those numbers\n    // >>> cube(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // (List[Float](1.0f.toFloat,\
    \ 8.0f.toFloat, 27.0f.toFloat, 64.0f.toFloat, 125.0f.toFloat))\n    def cube(numbers\
    \ : List[Float]) : List[Float] = {\n        val result = numbers.map(x => x *\
    \ x * x)\n        return result\n    }\n\n    // Given a list of numbers, return\
    \ a list of the fourth powers of those numbers\n    // >>> fourthPower(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // (List[Float](1.0f.toFloat,\
    \ 16.0f.toFloat, 81.0f.toFloat, 256.0f.toFloat, 625.0f.toFloat))\n    def fourthPower(numbers\
    \ : List[Float]) : List[Float] = {\n", "        var min = numbers.head\n     \
    \   var max = numbers.head\n        for (i <- numbers.size - 1) {\n          \
    \  if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max) max\
    \ = numbers[i]\n        }\n        var scale = 1.0f / (max - min)\n        for\
    \ (i <- numbers.size) {\n            numbers[i] = numbers[i] - min\n         \
    \   numbers[i] = numbers[i] * scale\n        }\n        return numbers", "   \
    \     var min = numbers.head\n        var max = numbers.head\n        for (i <-\
    \ numbers.size - 1) {\n            if (numbers[i] < min) {\n                min\
    \ = numbers[i]\n            }\n            if (numbers[i] > max) {\n         \
    \       max = numbers[i]\n            }\n        }\n        var scale = 1.0 /\
    \ (max - min)\n        var result = List[Float](0.0f.toFloat)\n        for (i\
    \ <- numbers.size) {\n            result = result.updated(i, (numbers[i] - min)\
    \ * scale)\n        }\n        return result", "        var min = numbers.min()\n\
    \        var max = numbers.max()\n        var scale = 1.0f / (max - min)\n   \
    \     return numbers.map(x => (x - min) * scale)", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0f / (max - min)\n      \
    \  var result = List[Float]()\n        for (i <- numbers.size) {\n           \
    \ result = result.append(numbers[i] - min)\n        }\n        for (i <- result.size\
    \ - 1) {\n            result[i] = result[i] * scale\n        }\n        return\
    \ result", "        var min = numbers.head\n        var max = numbers.head\n \
    \       for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min =\
    \ numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        var result = List[Float]()\n \
    \       for (i <- numbers.size) {\n            result = result.append(numbers[i]\
    \ - min) * scale\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) {\n                min = numbers[i]\n          \
    \  }\n            if (numbers[i] > max) {\n                max = numbers[i]\n\
    \            }\n        }\n        var scale = 1.0 / (max - min)\n        var\
    \ result = List[Float]()\n        for (i <- numbers.size) {\n            result\
    \ = result.append(numbers[i] - min)\n        }\n        for (i <- result.size\
    \ - 1) {\n            result[i] = result[i] * scale\n        }\n        return\
    \ result", "        var min = numbers.head\n        var max = numbers.head\n \
    \       for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min =\
    \ numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        var result = List[Float](0.0)\n\
    \        for (i <- numbers.size) {\n            result = result.updated(i, numbers[i]\
    \ * scale - min * scale)\n        }\n        return result", "        var min\
    \ = numbers.min()\n        var max = numbers.max()\n        var scale = 1.0 /\
    \ (max - min)\n        return numbers.map(x => (x - min) * scale)", "        var\
    \ min = numbers.head\n        var max = numbers.head\n        for (i <- numbers.size\
    \ - 1) {\n            if (numbers[i] < min) min = numbers[i]\n            if (numbers[i]\
    \ > max) max = numbers[i]\n        }\n        var scale = 1.0f / (max - min)\n\
    \        for (i <- numbers.size) {\n            numbers[i] = (numbers[i] - min)\
    \ * scale\n        }\n        return numbers", "        var min = numbers.min()\n\
    \        var max = numbers.max()\n        var scale = 1.0 / (max - min)\n    \
    \    return numbers.map(x => (x - min) * scale)", "        var min = numbers.min()\n\
    \        var max = numbers.max()\n        var scale = 1.0 / (max - min)\n    \
    \    return numbers.map(x => (x - min) * scale).toList\n    }\n\n    // Given\
    \ a list of numbers, find the sum of the squares of those numbers\n    // >>>\
    \ squareSum(List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat,\
    \ 5.0f.toFloat))\n    // 30.0\n    def squareSum(numbers : List[Float]) : Float\
    \ = {\n        return numbers.map(x => x * x).sum\n    }\n\n    // Given a list\
    \ of numbers, find the sum of the products of those numbers\n    // >>> productSum(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 120.0\n   \
    \ def productSum(numbers : List[Float]) : Float = {\n        return numbers.map(x\
    \ => x * x).sum\n    }\n\n    // Given a list of numbers, find the sum of the\
    \ products of those numbers\n    // >>> productSum(List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 120.0\n    def productSum2(numbers\
    \ : List[Float]) : Float = {\n        return numbers.foldLeft(0.0, (x, y) => x\
    \ + y)\n    }\n\n    // Given a list of numbers, find the sum of the products\
    \ of those numbers\n    // >>> productSum(List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 120.0\n    def productSum3(numbers\
    \ : List[Float]) : Float = {\n        return numbers.foldLeft(0.0, (x, y) => x\
    \ + y)\n    }\n\n    // Given a", "        var min = numbers.head\n        var\
    \ max = numbers.head\n        for (i <- numbers.size - 1) {\n            if (numbers[i]\
    \ < min) {\n                min = numbers[i]\n            }\n            if (numbers[i]\
    \ > max) {\n                max = numbers[i]\n            }\n        }\n     \
    \   var scale = 1.0 / (max - min)\n        var result = List[Float](0.0)\n   \
    \     for (i <- numbers.size) {\n            result = result.updated(i, numbers[i]\
    \ * scale)\n        }\n        return result\n    }\n\n    // Given a list of\
    \ numbers, return a list of their squares\n    // >>> squareList((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](1.0f.toFloat,\
    \ 4.0f.toFloat, 9.0f.toFloat, 16.0f.toFloat, 25.0f.toFloat))\n    def squareList(numbers\
    \ : List[Float]) : List[Float] = {\n        var result = List[Float](0.0)\n  \
    \      for (i <- numbers.size) {\n            result = result.updated(i, numbers[i]\
    \ * numbers[i])\n        }\n        return result\n    }\n\n    // Given a list\
    \ of numbers, return a list of their cubes\n    // >>> cubeList((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](1.0f.toFloat,\
    \ 8.0f.toFloat, 27.0f.toFloat, 64.0f.toFloat, 125.0f.toFloat))\n    def cubeList(numbers\
    \ : List[Float]) : List[Float] = {\n        var result = List[Float](0.0)\n  \
    \      for (i <- numbers.size) {\n            result = result.updated(i, numbers[i]\
    \ * numbers[i] * numbers[i", "        var min = numbers.head\n        var max\
    \ = numbers.head\n        for (i <- numbers.size - 1) {\n            if (numbers[i]\
    \ < min) min = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n\
    \        }\n        var scale = 1.0f / (max - min)\n        var result = List[Float](0.0f)\n\
    \        for (i <- numbers.size) {\n            result = result.append(numbers[i]\
    \ - min) * scale\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n       \
    \ var result = List[Float]()\n        for (i <- numbers.size) {\n            result\
    \ = result.append(numbers[i] - min) * scale\n        }\n        return result",
  "        var min = numbers.head\n        var max = numbers.head\n        for (i\
    \ <- numbers.size - 1) {\n            if (numbers[i] < min) {\n              \
    \  min = numbers[i]\n            }\n            if (numbers[i] > max) {\n    \
    \            max = numbers[i]\n            }\n        }\n        var scale = 1.0\
    \ / (max - min)\n        var result = List[Float](0.0)\n        for (i <- numbers.size)\
    \ {\n            result = result.updated(i, (numbers[i] - min) * scale)\n    \
    \    }\n        return result", "        var min = numbers.min()\n        var\
    \ max = numbers.max()\n        var scale = 1.0f / (max - min)\n        return\
    \ numbers.map(x => (x - min) * scale)\n    }\n\n    // Given a list of numbers,\
    \ find the sum of the squares of the numbers\n    // >>> squareSum(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 30.0f\n   \
    \ def squareSum(numbers : List[Float]) : Float = {\n        var sum = 0.0f\n \
    \       for (var i = 0; i < numbers.size(); i++) {\n            sum += numbers[i]\
    \ * numbers[i]\n        }\n        return sum\n    }\n\n    // Given a list of\
    \ numbers, find the sum of the products of the numbers\n    // >>> productSum(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 120.0f\n  \
    \  def productSum(numbers : List[Float]) : Float = {\n        var sum = 0.0f\n\
    \        for (var i = 0; i < numbers.size(); i++) {\n            sum += numbers[i]\
    \ * numbers[i]\n        }\n        return sum\n    }\n\n    // Given a list of\
    \ numbers, find the sum of the numbers\n    // >>> sum(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 15.0f\n   \
    \ def sum(numbers : List[Float]) : Float = {\n        var sum = 0.0f\n       \
    \ for (var i = 0; i < numbers.size(); i++) {\n            sum += numbers[i]\n\
    \        }\n        return sum\n    }\n\n    // Given a list of numbers, find\
    \ the product of the numbers\n    // >>> product(List[Float](1.0f.toFloat, 2.0f.toFloat,",
  "        var min = numbers.head\n        var max = numbers.head\n        for (i\
    \ <- numbers.size - 1) {\n            if (numbers[i] < min) {\n              \
    \  min = numbers[i]\n            }\n            if (numbers[i] > max) {\n    \
    \            max = numbers[i]\n            }\n        }\n        var scale = 1.0\
    \ / (max - min)\n        var result = List[Float](0.0)\n        for (i <- numbers.size)\
    \ {\n            result = result.updated(i, numbers[i] * scale - min * scale)\n\
    \        }\n        return result", "        var min = numbers.head\n        var\
    \ max = numbers.head\n        for (i <- numbers.size - 1) {\n            if (numbers[i]\
    \ > max) max = numbers[i]\n            if (numbers[i] < min) min = numbers[i]\n\
    \        }\n        var scale = 1.0 / (max - min)\n        var result = List[Float](0.0)\n\
    \        for (i <- numbers.size) {\n            result = result.updated(i, numbers[i]\
    \ - min * scale)\n        }\n        return result", "        var min = numbers.min()\n\
    \        var max = numbers.max()\n        var scale = 1.0 / (max - min)\n    \
    \    var result = List[Float]().setAll(min)\n        for (var i = 0; i < numbers.size();\
    \ i++) {\n            result = result.updated(i, (numbers.apply(i) - min) * scale)\n\
    \        }\n        return result\n    }\n\n    // Given a list of numbers, return\
    \ a list of the same length, where each number is the\n    // average of the numbers\
    \ in the original list that are less than or equal to it.\n    // >>> averageList(List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // (List[Float](2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    def averageList(numbers : List[Float])\
    \ : List[Float] = {\n        var result = List[Float]().setAll(0.0)\n        for\
    \ (var i = 0; i < numbers.size(); i++) {\n            result = result.updated(i,\
    \ numbers.apply(i))\n        }\n        return result\n    }\n\n    // Given a\
    \ list of numbers, return a list of the same length, where each number is the\n\
    \    // sum of the numbers in the original list that are less than or equal to\
    \ it.\n    // >>> sumList(List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat,\
    \ 4.0f.toFloat, 5.0f.toFloat))\n    // (List[Float](1.0f.toFloat, 3.0f.toFloat,\
    \ 6.0f.toFloat, 10.0f.toFloat, 15.0f.toFloat))\n    def sumList(numbers : List[Float])\
    \ : List[Float] = {\n        var result = List[Float]().setAll(0.0)\n        for\
    \ (var i = 0; i < numbers.size(); i++) {\n            result =", "        var\
    \ min = numbers.min()\n        var max = numbers.max()\n        var scale = 1.0f\
    \ / (max - min)\n        var result = List[Float]().setAll(min)\n        for (i\
    \ <- numbers.size) {\n            result = result.updated(i, (numbers[i] - min)\
    \ * scale)\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       min = min.min(numbers.apply(i))\n            max = max.max(numbers.apply(i))\n\
    \        }\n        var scale = 1.0 / (max - min)\n        var offset = -min *\
    \ scale\n        return numbers.map(x => (x - min) * scale + offset)", "     \
    \   var min = numbers.head\n        var max = numbers.head\n        for (i <-\
    \ numbers.size - 1) {\n            if (numbers[i] < min) min = numbers[i]\n  \
    \          if (numbers[i] > max) max = numbers[i]\n        }\n        var scale\
    \ = 1.0f / (max - min)\n        var result = List[Float]()\n        for (i <-\
    \ numbers.size) {\n            result = result.append(numbers[i] - min) * scale\n\
    \        }\n        return result", "        var min = numbers.head\n        var\
    \ max = numbers.head\n        for (i <- numbers.size - 1) {\n            if (numbers[i]\
    \ < min) min = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n\
    \        }\n        var scale = 1.0f / (max - min)\n        var result = List[Float](0.0f)\n\
    \        for (i <- numbers.size) {\n            result = result.updated(i, (numbers[i]\
    \ - min) * scale)\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n       \
    \ for (i <- numbers.size) {\n            numbers[i] = numbers[i] - min\n     \
    \       numbers[i] = numbers[i] * scale\n        }\n        return numbers", " \
    \       var min = numbers.min()\n        var max = numbers.max()\n        var\
    \ scale = 1.0 / (max - min)\n        return numbers.map(x => (x - min) * scale)",
  "        var min = numbers.head\n        var max = numbers.head\n        for (i\
    \ <- numbers.size - 1) {\n            if (numbers[i] < min) min = numbers[i]\n\
    \            if (numbers[i] > max) max = numbers[i]\n        }\n        var scale\
    \ = 1.0f / (max - min)\n        var result = List[Float](0.0f)\n        for (i\
    \ <- numbers.size) {\n            result = result.updated(i, numbers[i] * scale)\n\
    \        }\n        return result", "        var min = numbers.head\n        var\
    \ max = numbers.head\n        for (i <- numbers.size - 1) {\n            if (numbers[i]\
    \ < min) min = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n\
    \        }\n        var scale = 1.0 / (max - min)\n        var result = List[Float]()\n\
    \        for (i <- numbers.size) {\n            result = result.append(numbers[i]\
    \ - min) * scale\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.tail) {\n         \
    \   if (i < min) min = i\n            if (i > max) max = i\n        }\n      \
    \  var scale = 1.0 / (max - min)\n        var result = List[Float](0.0)\n    \
    \    for (i <- numbers) {\n            result = result.append(i.toFloat - min.toFloat\
    \ * scale)\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) {\n                min = numbers[i]\n          \
    \  }\n            if (numbers[i] > max) {\n                max = numbers[i]\n\
    \            }\n        }\n        var scale = 1.0f / (max - min)\n        var\
    \ result = mutable.List[Float]()\n        for (i <- numbers.size) {\n        \
    \    result.append(numbers[i] - min) * scale\n        }\n        return result\n\
    \    }\n\n    // Given a list of numbers, return a list of the same size where\
    \ the first element is the\n    // smallest and the last element is the largest\n\
    \    // >>> rescaleToUnit((List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat,\
    \ 4.0f.toFloat, 5.0f.toFloat)))\n    // (List[Float](0.0f.toFloat, 0.25f.toFloat,\
    \ 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))\n    def rescaleToUnit(numbers :\
    \ List[Float]) : List[Float] = {\n        var min = numbers.head\n        var\
    \ max = numbers.head\n        for (i <- numbers.size - 1) {\n            if (numbers[i]\
    \ < min) {\n                min = numbers[i]\n            }\n            if (numbers[i]\
    \ > max) {\n                max = numbers[i]\n            }\n        }\n     \
    \   var scale = 1.0f / (max - min)\n        var result = mutable.List[Float]()\n\
    \        for (i <- numbers.size) {\n            result.append(numbers[i] - min)\
    \ * scale\n        }\n        return result\n    }\n\n    // Given a list of numbers,\
    \ return a list of the same size where the first element is the\n    // smallest\
    \ and the last element is the largest\n    // >>> rescaleToUnit((List[Float](1.0f.toFloat,\
    \ 2.0f.toFloat, 3.0f.", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min\
    \ = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0f / (max - min)\n        var result = List[Float]()\n\
    \        for (i <- numbers.size) {\n            result = result.append(numbers[i]\
    \ - min * scale)\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0f / (max - min)\n      \
    \  var result = List[Float]()\n        for (i <- numbers.size) {\n           \
    \ result += numbers[i] * scale\n        }\n        return result", "        var\
    \ min = numbers.head\n        var max = numbers.head\n        for (i <- numbers.size\
    \ - 1) {\n            if (numbers[i] < min) {\n                min = numbers[i]\n\
    \            }\n            if (numbers[i] > max) {\n                max = numbers[i]\n\
    \            }\n        }\n        var scale = 1.0f / (max - min)\n        var\
    \ result = List[Float](0.0f)\n        for (i <- numbers.size) {\n            result\
    \ = result.updated(i, numbers[i] * scale - min * scale)\n        }\n        return\
    \ result", "        var min = numbers.head\n        var max = numbers.head\n \
    \       for (i <- numbers.size - 1) {\n            if (numbers[i] > max) max =\
    \ numbers[i]\n            if (numbers[i] < min) min = numbers[i]\n        }\n\
    \        var scale = 1.0f / (max - min)\n        var result = List[Float](0.0f)\n\
    \        for (i <- numbers.size) {\n            result = result.updated(i, numbers[i]\
    \ * scale - min)\n        }\n        return result", "        var min = numbers.head\n\
    \        var max = numbers.head\n        for (i <- numbers.size - 1) {\n     \
    \       if (numbers[i] < min) min = numbers[i]\n            if (numbers[i] > max)\
    \ max = numbers[i]\n        }\n        var scale = 1.0 / (max - min)\n       \
    \ var result = List[Float](0.0)\n        for (i <- numbers.size) {\n         \
    \   result = result.append(numbers[i] - min) * scale\n        }\n        return\
    \ result", "        var min = numbers.min()\n        var max = numbers.max()\n\
    \        var scale = 1.0 / (max - min)\n        return numbers.map(x => (x - min)\
    \ * scale)", "        var min = numbers.head\n        var max = numbers.head\n\
    \        for (i <- numbers.size - 1) {\n            if (numbers[i] < min) min\
    \ = numbers[i]\n            if (numbers[i] > max) max = numbers[i]\n        }\n\
    \        var scale = 1.0 / (max - min)\n        var result = List[Float](0.0)\n\
    \        for (i <- numbers.size) {\n            result = result.updated(i, numbers[i]\
    \ * scale - min * scale)\n        }\n        return result\n    }\n\n    // Given\
    \ a list of numbers, compute the sum of the squares of the numbers\n    // >>>\
    \ squareSum(List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat,\
    \ 5.0f.toFloat))\n    // 30.0\n    def squareSum(numbers : List[Float]) : Float\
    \ = {\n        var result = 0.0\n        for (i <- numbers.size) {\n         \
    \   result = result + numbers[i] * numbers[i]\n        }\n        return result\n\
    \    }\n\n    // Given a list of numbers, compute the sum of the products of the\
    \ numbers\n    // >>> productSum(List[Float](1.0f.toFloat, 2.0f.toFloat, 3.0f.toFloat,\
    \ 4.0f.toFloat, 5.0f.toFloat))\n    // 120.0\n    def productSum(numbers : List[Float])\
    \ : Float = {\n        var result = 0.0\n        for (i <- numbers.size) {\n \
    \           result = result + numbers[i] * numbers[i]\n        }\n        return\
    \ result\n    }\n\n    // Given a list of numbers, compute the sum of the products\
    \ of the numbers\n    // >>> productSum(List[Float](1.0f.toFloat, 2.0f.toFloat,\
    \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))\n    // 120.0\n    def productSum2(numbers\
    \ : List[Float]) : Float = {\n        var result = 0.0\n        for", "      \
    \  var min = numbers.min()\n        var max = numbers.max()\n        var scale\
    \ = 1.0 / (max - min)\n        return numbers.map(x => (x - min) * scale)", " \
    \       var min = numbers.head\n        var max = numbers.head\n        for (i\
    \ <- numbers.size - 1) {\n            if (numbers[i] < min) min = numbers[i]\n\
    \            if (numbers[i] > max) max = numbers[i]\n        }\n        var scale\
    \ = 1.0 / (max - min)\n        var result = List[Float](0.0)\n        for (i <-\
    \ numbers.size) {\n            result = result.append(numbers[i] - min * scale)\n\
    \        }\n        return result"]
stop_tokens:
- "\n    }\n"
