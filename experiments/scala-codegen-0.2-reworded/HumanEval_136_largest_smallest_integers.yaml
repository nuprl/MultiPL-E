name: HumanEval_136_largest_smallest_integers
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Create a function that returns a tuple (a, b), where 'a' is\n    // the\
  \ largest of negative integers, and 'b' is the smallest\n    // of positive integers\
  \ in a list.\n    // If there is no negative or positive integers, return them as\
  \ None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
  \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
  \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n   \
  \ // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
  \ : Tuple2[Option[Long], Option[Long]] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n\
  \    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
  \ 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None), Some(1l))));\n\
  \    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
  \ 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n    assert(largestSmallestIntegers((List[Long](4l.toLong,\
  \ 5l.toLong, 3l.toLong, 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l,\
  \ 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong, 3l.toLong, 8l.toLong,\
  \ 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l, 2l)));\n\
  \    assert(largestSmallestIntegers((List[Long]())).equals((Some(None), Some(None))));\n\
  \    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
  \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
  \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
  \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
  \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
  \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
  \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l, 1l)));\n\
  \    }\n\n}\n"
completions: ["        var maxNeg = None\n        var minPos = None\n        for (i\
    \ <- lst) {\n            if (i < 0) {\n                maxNeg = Some(i)\n    \
    \        } else if (i > 0) {\n                minPos = Some(i)\n            }\n\
    \        }\n        return (maxNeg, minPos)", "        var maxNeg = None\n   \
    \     var minPos = None\n        for (i <- lst.iterator()) {\n            if (i.isNegative())\
    \ {\n                maxNeg = Some(i.toLong())\n            } else if (i.isPositive())\
    \ {\n                minPos = Some(i.toLong())\n            }\n        }\n   \
    \     return (maxNeg, minPos)", "        var max = None\n        var min = None\n\
    \        for (i <- lst.iterator()) {\n            if (i.isNegative()) {\n    \
    \            max = Some(i.toLong())\n            } else if (i.isPositive()) {\n\
    \                min = Some(i.toLong())\n            }\n        }\n        return\
    \ (max, min)", "        var max = None\n        var min = None\n        for (i\
    \ <- lst) {\n            if (i < 0) {\n                max = Some(i)\n       \
    \     } else if (i > 0) {\n                min = Some(i)\n            }\n    \
    \    }\n        return (max, min)", "        var max = None\n        var min =\
    \ None\n        for (i <- lst) {\n            if (i < 0) {\n                max\
    \ = Some(i)\n            } else if (i > 0) {\n                min = Some(i)\n\
    \            }\n        }\n        return (max, min)\n    }\n\n    // Create a\
    \ function that returns the largest of positive integers\n    // in a list.\n\
    \    // If there is no positive integers, return them as None.\n    // Examples:\n\
    \    // >>> largestPositiveIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong)))\n    // Some(7l)\n    // >>> largestPositiveIntegers((List[Long]()))\n\
    \    // None\n    // >>> largestPositiveIntegers((List[Long](0l.toLong)))\n  \
    \  // None\n    def largestPositiveIntegers(lst : List[Long]) : Option[Long] =\
    \ {\n        var max = None\n        for (i <- lst) {\n            if (i > 0)\
    \ {\n                max = i\n            }\n        }\n        return max\n \
    \   }\n\n    // Create a function that returns the smallest of positive integers\n\
    \    // in a list.\n    // If there is no positive integers, return them as None.\n\
    \    // Examples:\n    // >>> smallestPositiveIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // Some(1l)\n\
    \    // >>> smallestPositiveIntegers((List[Long]()))\n    // None\n    // >>>\
    \ smallestPositiveIntegers((List[Long](0l.toLong)))\n    // None\n    def smallestPositiveIntegers(lst\
    \ : List[Long]) : Option[Long] = {\n        var min = None\n        for (i <-\
    \ lst) {\n            if (i > 0) {\n                min = i\n            }\n \
    \       }\n        return min\n    }\n\n    // Create a function that returns\
    \ the largest of negative integers\n    // in a list.\n    ", "        var a =\
    \ None\n        var b = None\n        for (var i = 0; i < lst.length; i++) {\n\
    \            var x = lst[i]\n            if (x < 0) {\n                a = Some(x)\n\
    \            } else if (x > 0) {\n                b = Some(x)\n            }\n\
    \        }\n        return (a, b)", "        if (lst.isEmpty()) {\n          \
    \  return (Option.empty(), Option.empty())\n        } else {\n            var\
    \ max = lst.head\n            var min = lst.head\n            for (i <- lst.tail)\
    \ {\n                if (i > max) {\n                    max = i\n           \
    \     }\n                if (i < min) {\n                    min = i\n       \
    \         }\n            }\n            return (Option.apply(max), Option.apply(min))\n\
    \        }", "        var max = None\n        var min = None\n        for (i <-\
    \ lst.iterator()) {\n            if (i.isNegative()) {\n                max =\
    \ Some(i.toLong())\n            } else if (i.isPositive()) {\n               \
    \ min = Some(i.toLong())\n            }\n        }\n        return (max, min)",
  "        if (lst.isEmpty()) {\n            return (Some(None), Some(None))\n   \
    \     } else {\n            var max = lst.head\n            var min = lst.head\n\
    \            for (i <- lst.tail) {\n                if (i > max) {\n         \
    \           max = i\n                }\n                if (i < min) {\n     \
    \               min = i\n                }\n            }\n            return\
    \ (Some(max), Some(min))\n        }", "        if (lst.isEmpty()) {\n        \
    \    return Tuple2(Option.empty(), Option.empty())\n        } else {\n       \
    \     var neg = lst.filter(x -> x < 0).toSeq().minBy(Long::compareTo).get()\n\
    \            var pos = lst.filter(x -> x > 0).toSeq().minBy(Long::compareTo).get()\n\
    \            return Tuple2(Option.apply(neg), Option.apply(pos))\n        }",
  "        var a = None\n        var b = None\n        for (i <- lst.iterator()) {\n\
    \            if (i.isNegative()) {\n                a = Some(i.toLong())\n   \
    \         } else if (i.isPositive()) {\n                b = Some(i.toLong())\n\
    \            }\n        }\n        return (a, b)", "        if (lst.isEmpty())\
    \ {\n            return (Option.empty(), Option.empty())\n        } else {\n \
    \           var max = lst.head\n            var min = lst.head\n            for\
    \ (i <- lst.tail) {\n                if (i > max) {\n                    max =\
    \ i\n                }\n                if (i < min) {\n                    min\
    \ = i\n                }\n            }\n            return (Option.of(max), Option.of(min))\n\
    \        }", "        var a = None\n        var b = None\n        for (i <- lst.iterator())\
    \ {\n            if (i.isNegative()) {\n                a = Some(i.toLong())\n\
    \            } else if (i.isPositive()) {\n                b = Some(i.toLong())\n\
    \            }\n        }\n        return (a, b)", "        if (lst.isEmpty())\
    \ {\n            return Tuple2(Option.empty(), Option.empty())\n        }\n  \
    \      var max = lst.head\n        var min = lst.head\n        for (i <- lst.tail)\
    \ {\n            if (i > max) {\n                max = i\n            }\n    \
    \        if (i < min) {\n                min = i\n            }\n        }\n \
    \       return Tuple2(Option.apply(max), Option.apply(min))", "        if (lst.isEmpty())\
    \ {\n            return (Option.empty(), Option.empty())\n        }\n        var\
    \ maxNeg = lst.head\n        var minPos = lst.head\n        var neg = lst.tail.filter(x\
    \ -> x < 0l).head\n        var pos = lst.tail.filter(x -> x > 0l).head\n     \
    \   if (neg.isDefined()) {\n            maxNeg = max(maxNeg, neg.get())\n    \
    \    }\n        if (pos.isDefined()) {\n            minPos = min(minPos, pos.get())\n\
    \        }\n        return (Some(maxNeg), Some(minPos))", "        var max = Option[Long]()\n\
    \        var min = Option[Long]()\n        for (i <- lst.iterator()) {\n     \
    \       if (i.isNegative()) {\n                max = max.getOrElse(i.toLong)\n\
    \            } else if (i.isPositive()) {\n                min = min.getOrElse(i.toLong)\n\
    \            }\n        }\n        max", "        if (lst.isEmpty()) {\n     \
    \       return (Option.empty(), Option.empty())\n        } else {\n          \
    \  var neg = lst.filter(x -> x < 0).toSeq().min()\n            var pos = lst.filter(x\
    \ -> x > 0).toSeq().max()\n            return (Option.apply(neg), Option.apply(pos))\n\
    \        }\n    }\n\n    // Create a function that returns the largest of positive\
    \ integers\n    // in a list. If there is no positive integers, return them as\
    \ None.\n    // Examples:\n    // >>> largestPositiveIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // Some(7l)\n\
    \    // >>> largestPositiveIntegers((List[Long]()))\n    // None\n    // >>> largestPositiveIntegers((List[Long](0l.toLong)))\n\
    \    // None\n    def largestPositiveIntegers(lst : List[Long]) : Option[Long]\
    \ = {\n        if (lst.isEmpty()) {\n            return Option.empty()\n     \
    \   } else {\n            var pos = lst.filter(x -> x > 0).toSeq().max()\n   \
    \         return Option.apply(pos)\n        }\n    }\n\n    // Create a function\
    \ that returns the smallest of negative integers\n    // in a list. If there is\
    \ no negative integers, return them as None.\n    // Examples:\n    // >>> smallestNegativeIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // Some(-1l)\n\
    \    // >>> smallestNegativeIntegers((List[Long]()))\n    // None\n    // >>>\
    \ smallestNegativeIntegers((List[Long](0l.toLong)))\n    // None\n    def smallestNegativeIntegers(lst\
    \ : List[Long]) : Option[Long] = {\n        if (lst.isEmpty()) {\n           \
    \ return Option.empty()\n        } else {\n            var neg = lst.filter(x\
    \ ->", "        var neg = List[Long]().toLong\n        var pos = List[Long]().toLong\n\
    \        for (i <- lst.iterator()) {\n            if (i.toLong < 0) {\n      \
    \          neg = neg.updated(i.toLong)\n            } else {\n               \
    \ pos = pos.updated(i.toLong)\n            }\n        }\n        if (neg.isEmpty()\
    \ && pos.isEmpty()) {\n            return (None, None)\n        } else if (neg.isEmpty())\
    \ {\n            return (Some(None), Some(pos.head()))\n        } else if (pos.isEmpty())\
    \ {\n            return (Some(neg.head()), Some(None))\n        } else {\n   \
    \         return (Some(Math.max(neg.head(), pos.head())), Some(Math.min(neg.head(),\
    \ pos.head())))\n        }", "        var max = None\n        var min = None\n\
    \        for (i <- lst.iterator()) {\n            if (i.isEmpty()) {\n       \
    \         continue\n            }\n            var n = i.head()\n            if\
    \ (n < 0) {\n                max = Some(n)\n            } else if (n > 0) {\n\
    \                min = Some(n)\n            }\n        }\n        return (max,\
    \ min)", "        if (lst.isEmpty()) {\n            return Tuple2(Option(None),\
    \ Option(None))\n        } else {\n            var neg = lst.filter(x -> x < 0).head()\n\
    \            var pos = lst.filter(x -> x > 0).head()\n            return Tuple2(Option(neg),\
    \ Option(pos))\n        }", "        var neg = None\n        var pos = None\n\
    \        for (i <- lst.iterator()) {\n            if (i.isNegative()) {\n    \
    \            neg = Some(i.getAsLong())\n            } else if (i.isPositive())\
    \ {\n                pos = Some(i.getAsLong())\n            }\n        }\n   \
    \     return (neg, pos)", "        if (lst.isEmpty()) {\n            return (Some(None),\
    \ Some(None))\n        } else {\n            var max = lst.head\n            var\
    \ min = lst.head\n            for (i <- lst.tail) {\n                if (i > max)\
    \ {\n                    max = i\n                }\n                if (i < min)\
    \ {\n                    min = i\n                }\n            }\n         \
    \   return (Some(max), Some(min))\n        }", "        var neg = List[Long]().toLong\n\
    \        var pos = List[Long]().toLong\n        for (i <- lst.iterator()) {\n\
    \            if (i.toLong < 0) {\n                neg = neg.updated(i.toLong)\n\
    \            } else {\n                pos = pos.updated(i.toLong)\n         \
    \   }\n        }\n        if (neg.isEmpty() && pos.isEmpty()) {\n            return\
    \ (Some(None), Some(None))\n        } else if (neg.isEmpty()) {\n            return\
    \ (Some(None), Some(pos.head()))\n        } else if (pos.isEmpty()) {\n      \
    \      return (Some(neg.head()), Some(None))\n        } else {\n            return\
    \ (Some(neg.head()), Some(pos.head()))\n        }", "        var max = None\n\
    \        var min = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                max = Some(i)\n            } else if (i > 0) {\n            \
    \    min = Some(i)\n            }\n        }\n        return (max, min)", "  \
    \      var max = None\n        var min = None\n        for (i <- lst) {\n    \
    \        if (i < 0) {\n                max = Some(i)\n            } else if (i\
    \ > 0) {\n                min = Some(i)\n            }\n        }\n        return\
    \ (max, min)", "        if (lst.isEmpty()) {\n            return (Option.empty(),\
    \ Option.empty())\n        } else {\n            var neg = lst.filter(x -> x <\
    \ 0).toSeq().min()\n            var pos = lst.filter(x -> x > 0).toSeq().max()\n\
    \            return (Option.of(neg), Option.of(pos))\n        }", "        var\
    \ a = None\n        var b = None\n        for (i <- lst.iterator()) {\n      \
    \      if (i.isNegative()) {\n                a = Some(i.toLong())\n         \
    \   } else if (i.isPositive()) {\n                b = Some(i.toLong())\n     \
    \       }\n        }\n        return (a, b)", "        var maxNeg = None\n   \
    \     var minPos = None\n        for (i <- lst.iterator()) {\n            var\
    \ n = i.next()\n            if (n < 0) {\n                maxNeg = Some(n)\n \
    \           } else if (n > 0) {\n                minPos = Some(n)\n          \
    \  }\n        }\n        return (maxNeg, minPos)", "        if (lst.isEmpty())\
    \ {\n            return (Option.empty(), Option.empty())\n        } else {\n \
    \           var neg = lst.filter(x -> x < 0).map(x -> -x).max(Long::compareTo)\n\
    \            var pos = lst.filter(x -> x > 0).min(Long::compareTo)\n         \
    \   return (Option.apply(-neg), Option.apply(pos))\n        }", "        var a\
    \ = None\n        var b = None\n        for (i <- lst.iterator()) {\n        \
    \    var x = i.next()\n            if (x < 0) {\n                a = Some(x)\n\
    \            } else if (x > 0) {\n                b = Some(x)\n            }\n\
    \        }\n        return (a, b)", "        if (lst.isEmpty()) {\n          \
    \  return (Option.empty(), Option.empty())\n        }\n        var max = lst.head\n\
    \        var min = lst.head\n        for (i <- lst.tail) {\n            if (i\
    \ > max) {\n                max = i\n            }\n            if (i < min) {\n\
    \                min = i\n            }\n        }\n        return (Option.of(max),\
    \ Option.of(min))", "        var neg = Option[Long]()\n        var pos = Option[Long]()\n\
    \        for (i <- lst.iterator()) {\n            if (i.isNegative()) {\n    \
    \            neg = Option.Some(i.toLong())\n            } else if (i.isPositive())\
    \ {\n                pos = Option.Some(i.toLong())\n            }\n        }\n\
    \        return (neg, pos)\n    }\n\n    // Create a function that returns the\
    \ largest of positive integers\n    // in a list.\n    // If there is no positive\
    \ integers, return them as None.\n    // Examples:\n    // >>> largestPositiveIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // Some(7l)\n\
    \    // >>> largestPositiveIntegers((List[Long]()))\n    // None\n    // >>> largestPositiveIntegers((List[Long](0l.toLong)))\n\
    \    // None\n    def largestPositiveIntegers(lst : List[Long]) : Option[Long]\
    \ = {\n        var pos = Option[Long]()\n        for (i <- lst.iterator()) {\n\
    \            if (i.isPositive()) {\n                pos = Option.Some(i.toLong())\n\
    \            }\n        }\n        return pos\n    }\n\n    // Create a function\
    \ that returns the smallest of positive integers\n    // in a list.\n    // If\
    \ there is no positive integers, return them as None.\n    // Examples:\n    //\
    \ >>> smallestPositiveIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 3l.toLong,\
    \ 5l.toLong, 7l.toLong)))\n    // Some(1l)\n    // >>> smallestPositiveIntegers((List[Long]()))\n\
    \    // None\n    // >>> smallestPositiveIntegers((List[Long](0l.toLong)))\n \
    \   // None\n    def smallestPositiveIntegers(lst : List[Long]) : Option[Long]\
    \ = {\n        var pos = Option[Long]()\n        for (i <- lst.iterator()) {\n\
    \            if", "        if (lst.isEmpty()) {\n            return (Option.empty(),\
    \ Option.empty())\n        } else {\n            var neg = lst.filter(x -> x <\
    \ 0).toSeq().minBy(x -> x)\n            var pos = lst.filter(x -> x > 0).toSeq().minBy(x\
    \ -> x)\n            return (Option.apply(neg), Option.apply(pos))\n        }",
  "        if (lst.isEmpty()) {\n            return (Some(None), Some(None))\n   \
    \     } else {\n            var neg = None\n            var pos = None\n     \
    \       for (i <- lst.iterator()) {\n                if (i.toLong < 0) {\n   \
    \                 neg = Some(i.toLong)\n                } else if (i.toLong >\
    \ 0) {\n                    pos = Some(i.toLong)\n                }\n        \
    \    }\n            return (Some(neg), Some(pos))\n        }", "        var max\
    \ = None\n        var min = None\n        for (i <- lst) {\n            if (i\
    \ < 0) {\n                max = Some(i)\n            } else if (i > 0) {\n   \
    \             min = Some(i)\n            }\n        }\n        return (max, min)\n\
    \    }\n\n    // Create a function that returns a tuple (a, b), where 'a' is\n\
    \    // the largest of positive integers, and 'b' is the smallest\n    // of negative\
    \ integers in a list.\n    // If there is no positive or negative integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(7l),\
    \ Some(-1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers2(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        var max = None\n        var\
    \ min = None\n        for (i <- lst) {\n            if (i > 0) {\n           \
    \     max = Some(i)\n            } else if (i < 0) {\n                min = Some(i)\n\
    \            }\n        }\n        return (max, min)\n    }\n\n    // Create a\
    \ function that returns a tuple (a, b), where 'a' is\n    // the largest of positive\
    \ integers, and 'b' is the smallest\n    // of positive integers in a list.\n\
    \    // If there is no positive integers, return them as None.\n    // Examples:\n\
    \    // >>> largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(7l), Some(5l))\n    // >>>\
    \ largestSmallestIntegers", "        var neg = List[Long]().toLong\n        var\
    \ pos = List[Long]().toLong\n        for (i <- lst.iterator()) {\n           \
    \ if (i.toLong < 0) {\n                neg = neg.updated(i.toLong)\n         \
    \   } else {\n                pos = pos.updated(i.toLong)\n            }\n   \
    \     }\n        if (neg.isEmpty && pos.isEmpty) {\n            return (Some(None),\
    \ Some(None))\n        } else if (neg.isEmpty) {\n            return (Some(None),\
    \ Some(pos.head))\n        } else if (pos.isEmpty) {\n            return (Some(neg.head),\
    \ Some(None))\n        } else {\n            return (Some(neg.head), Some(pos.head))\n\
    \        }", "        if (lst.isEmpty()) {\n            return (Option.empty(),\
    \ Option.empty())\n        } else {\n            var max = lst.head\n        \
    \    var min = lst.head\n            for (i <- lst.tail) {\n                if\
    \ (i > max) {\n                    max = i\n                }\n              \
    \  if (i < min) {\n                    min = i\n                }\n          \
    \  }\n            return (Option.apply(max), Option.apply(min))\n        }", " \
    \       if (lst.isEmpty()) {\n            return (Option.empty(), Option.empty())\n\
    \        } else {\n            var neg = lst.filter(x -> x < 0).map(x -> -x).maxBy(x\
    \ -> x)\n            var pos = lst.filter(x -> x > 0).minBy(x -> x)\n        \
    \    return (Option.of(neg), Option.of(pos))\n        }", "        if (lst.isEmpty())\
    \ {\n            return (Option.empty(), Option.empty())\n        }\n        var\
    \ max = lst.head\n        var min = lst.head\n        for (i <- lst.tail) {\n\
    \            if (i > max) {\n                max = i\n            }\n        \
    \    if (i < min) {\n                min = i\n            }\n        }\n     \
    \   return (Option.of(max), Option.of(min))", "        var neg = lst.filter(x\
    \ -> x < 0).toSeq().toList().sort(Comparator.comparingLong(x -> x)).head()\n \
    \       var pos = lst.filter(x -> x > 0).toSeq().toList().sort(Comparator.comparingLong(x\
    \ -> x)).head()\n        if (neg.isEmpty() && pos.isEmpty()) return (Option.empty(),\
    \ Option.empty())\n        if (neg.isEmpty()) return (Option.empty(), Some(pos.head()))\n\
    \        if (pos.isEmpty()) return (Some(neg.head()), Option.empty())\n      \
    \  return (Some(neg.head()), Some(pos.head()))", "        var neg = lst.filter(x\
    \ -> x < 0).toSeq().map(x -> -x).max()\n        var pos = lst.filter(x -> x >\
    \ 0).toSeq().min()\n        if (neg.isDefined && pos.isDefined) {\n          \
    \  return (Some(neg), Some(pos))\n        } else if (neg.isDefined) {\n      \
    \      return (Some(neg), None)\n        } else if (pos.isDefined) {\n       \
    \     return (None, Some(pos))\n        } else {\n            return (None, None)\n\
    \        }", "        var a = None\n        var b = None\n        for (i <- lst.iterator())\
    \ {\n            if (i.isNegative()) {\n                a = Some(i.toLong())\n\
    \            } else if (i.isPositive()) {\n                b = Some(i.toLong())\n\
    \            }\n        }\n        return (a, b)", "        var maxNeg = None\n\
    \        var minPos = None\n        for (i <- lst.iterator()) {\n            if\
    \ (i.isNegative()) {\n                maxNeg = Some(i.toLong())\n            }\
    \ else if (i.isPositive()) {\n                minPos = Some(i.toLong())\n    \
    \        }\n        }\n        return (maxNeg, minPos)", "        var max = None\n\
    \        var min = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                max = Some(i)\n            } else if (i > 0) {\n            \
    \    min = Some(i)\n            }\n        }\n        return (max, min)\n    }\n\
    \n    // Create a function that returns the largest of positive integers\n   \
    \ // in a list.\n    // If there is no positive integers, return them as None.\n\
    \    // Examples:\n    // >>> largestPositiveIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // Some(7l)\n    // >>> largestPositiveIntegers((List[Long]()))\n\
    \    // None\n    // >>> largestPositiveIntegers((List[Long](0l.toLong)))\n  \
    \  // None\n    def largestPositiveIntegers(lst : List[Long]) : Option[Long] =\
    \ {\n        var max = None\n        for (i <- lst) {\n            if (i > 0)\
    \ {\n                max = i\n            }\n        }\n        return max\n \
    \   }\n\n    // Create a function that returns the smallest of negative integers\n\
    \    // in a list.\n    // If there is no negative integers, return them as None.\n\
    \    // Examples:\n    // >>> smallestNegativeIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // Some(-1l)\n\
    \    // >>> smallestNegativeIntegers((List[Long]()))\n    // None\n    // >>>\
    \ smallestNegativeIntegers((List[Long](0l.toLong)))\n    // None\n    def smallestNegativeIntegers(lst\
    \ : List[Long]) : Option[Long] = {\n        var min = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                min = i\n            }\n \
    \       }\n        return min\n    }\n\n    // Create a function that returns\
    \ the smallest of positive integers\n    // in a list.\n    ", "        var largest\
    \ = None\n        var smallest = None\n        for (i <- lst) {\n            if\
    \ (i < 0) {\n                largest = Some(i)\n            } else if (i > 0)\
    \ {\n                smallest = Some(i)\n            }\n        }\n        (largest,\
    \ smallest)", "        if (lst.isEmpty()) {\n            return (Option.empty(),\
    \ Option.empty())\n        } else {\n            var max = lst.head\n        \
    \    var min = lst.head\n            for (i <- lst.tail) {\n                if\
    \ (i > max) {\n                    max = i\n                }\n              \
    \  if (i < min) {\n                    min = i\n                }\n          \
    \  }\n            return (Option.apply(max), Option.apply(min))\n        }", " \
    \       if (lst.isEmpty()) {\n            return (Option.empty(), Option.empty())\n\
    \        } else {\n            var max = lst.head\n            var min = lst.head\n\
    \            for (i <- lst.tail) {\n                if (i > max) {\n         \
    \           max = i\n                }\n                if (i < min) {\n     \
    \               min = i\n                }\n            }\n            return\
    \ (Option.apply(max), Option.apply(min))\n        }", "        var max = None\n\
    \        var min = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                max = Some(i)\n            } else if (i > 0) {\n            \
    \    min = Some(i)\n            }\n        }\n        max", "        if (lst.isEmpty())\
    \ {\n            return (Option.empty(), Option.empty())\n        } else {\n \
    \           var max = lst.head\n            var min = lst.head\n            for\
    \ (i <- lst.tail) {\n                if (i > max) {\n                    max =\
    \ i\n                }\n                if (i < min) {\n                    min\
    \ = i\n                }\n            }\n            return (Option.apply(max),\
    \ Option.apply(min))\n        }", "        var neg = None\n        var pos = None\n\
    \        for (i <- lst.iterator()) {\n            if (i.toLong < 0) {\n      \
    \          neg = Some(i.toLong)\n            } else if (i.toLong > 0) {\n    \
    \            pos = Some(i.toLong)\n            }\n        }\n        return (neg,\
    \ pos)", "        var a = None\n        var b = None\n        for (i <- lst.iterator())\
    \ {\n            if (i.isNegative()) {\n                a = Some(i.toLong())\n\
    \            } else if (i.isPositive()) {\n                b = Some(i.toLong())\n\
    \            }\n        }\n        return (a, b)", "        var neg = List[Long]().toLong\n\
    \        var pos = List[Long]().toLong\n        for (i <- lst.iterator()) {\n\
    \            if (i.toLong < 0) {\n                neg = neg.updated(i.toLong)\n\
    \            } else if (i.toLong > 0) {\n                pos = pos.updated(i.toLong)\n\
    \            }\n        }\n        if (neg.isEmpty() && pos.isEmpty()) {\n   \
    \         return (Some(None), Some(None))\n        } else if (neg.isEmpty()) {\n\
    \            return (Some(None), Some(pos.head))\n        } else if (pos.isEmpty())\
    \ {\n            return (Some(neg.head), Some(None))\n        } else {\n     \
    \       return (Some(max(neg.head, pos.head)), Some(min(neg.head, pos.head)))\n\
    \        }", "        var max = Option[Long](None)\n        var min = Option[Long](None)\n\
    \        for (i <- lst.iterator()) {\n            if (i.isNegative()) {\n    \
    \            max = Option.Some(i.toLong())\n            } else if (i.isPositive())\
    \ {\n                min = Option.Some(i.toLong())\n            }\n        }\n\
    \        return (max, min)", "        if (lst.isEmpty()) {\n            return\
    \ (Option.empty(), Option.empty())\n        } else {\n            var max = lst.head\n\
    \            var min = lst.head\n            for (i <- lst.tail) {\n         \
    \       if (i > max) {\n                    max = i\n                }\n     \
    \           if (i < min) {\n                    min = i\n                }\n \
    \           }\n            return (Option.apply(max), Option.apply(min))\n   \
    \     }", "        if (lst.isEmpty()) {\n            return (Some(None), Some(None))\n\
    \        } else {\n            var neg = lst.filter(x -> x < 0).head()\n     \
    \       var pos = lst.filter(x -> x > 0).head()\n            var neg_opt = Some(neg)\n\
    \            var pos_opt = Some(pos)\n            return (neg_opt, pos_opt)\n\
    \        }", "        if (lst.isEmpty()) {\n            return (Option.empty(),\
    \ Option.empty())\n        } else {\n            var neg = lst.filter(x -> x <\
    \ 0).toSeq().max()\n            var pos = lst.filter(x -> x > 0).toSeq().min()\n\
    \            return (Option.apply(neg), Option.apply(pos))\n        }", "    \
    \    var a = None\n        var b = None\n        for (i <- lst.iterator()) {\n\
    \            if (i.isNegative()) {\n                a = Some(i.toLong())\n   \
    \         } else if (i.isPositive()) {\n                b = Some(i.toLong())\n\
    \            }\n        }\n        return (a, b)", "        if (lst.isEmpty())\
    \ {\n            return (Some(None), Some(None))\n        } else {\n         \
    \   var max = lst.head\n            var min = lst.head\n            for (i <-\
    \ lst.tail) {\n                if (i > max) {\n                    max = i\n \
    \               }\n                if (i < min) {\n                    min = i\n\
    \                }\n            }\n            return (Some(max), Some(min))\n\
    \        }", "        var largestNegative = None\n        var smallestPositive\
    \ = None\n        for (i <- lst.iterator()) {\n            if (i.isNegative())\
    \ {\n                largestNegative = i\n            } else if (i.isPositive())\
    \ {\n                smallestPositive = i\n            }\n        }\n        if\
    \ (largestNegative != None && smallestPositive != None) {\n            return\
    \ (Some(largestNegative), Some(smallestPositive))\n        } else if (largestNegative\
    \ != None) {\n            return (Some(largestNegative), None)\n        } else\
    \ if (smallestPositive != None) {\n            return (None, Some(smallestPositive))\n\
    \        } else {\n            return (None, None)\n        }", "        if (lst.isEmpty())\
    \ {\n            return Tuple2(Some(None), Some(None))\n        } else {\n   \
    \         var max = lst.head\n            var min = lst.head\n            for\
    \ (i <- lst.tail) {\n                if (i > max) {\n                    max =\
    \ i\n                }\n                if (i < min) {\n                    min\
    \ = i\n                }\n            }\n            return Tuple2(Some(max),\
    \ Some(min))\n        }", "        var neg = None\n        var pos = None\n  \
    \      for (i <- lst.iterator()) {\n            if (i.toLong < 0) {\n        \
    \        neg = Some(i.toLong)\n            } else if (i.toLong > 0) {\n      \
    \          pos = Some(i.toLong)\n            }\n        }\n        if (neg !=\
    \ None && pos != None) {\n            return (Some(neg), Some(pos))\n        }\
    \ else if (neg != None) {\n            return (Some(neg), None)\n        } else\
    \ if (pos != None) {\n            return (None, Some(pos))\n        } else {\n\
    \            return (None, None)\n        }", "        if (lst.isEmpty()) {\n\
    \            return (Option.apply(None), Option.apply(None))\n        } else {\n\
    \            var max = lst.head\n            var min = lst.head\n            for\
    \ (i <- lst.tail) {\n                if (i > max) {\n                    max =\
    \ i\n                }\n                if (i < min) {\n                    min\
    \ = i\n                }\n            }\n            return (Option.apply(max),\
    \ Option.apply(min))\n        }", "        if (lst.isEmpty()) {\n            return\
    \ (Some(None), Some(None))\n        } else {\n            var neg = lst.filter(x\
    \ -> x < 0).toSeq().max()\n            var pos = lst.filter(x -> x > 0).toSeq().min()\n\
    \            return (Some(neg), Some(pos))\n        }", "        var max = None\n\
    \        var min = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                max = Some(i)\n            } else if (i > 0) {\n            \
    \    min = Some(i)\n            }\n        }\n        return (max, min)", "  \
    \      if (lst.isEmpty()) {\n            return Tuple2(Some(None), Some(None))\n\
    \        } else {\n            var max = lst.head\n            var min = lst.head\n\
    \            for (i <- lst.tail) {\n                if (i > max) {\n         \
    \           max = i\n                }\n                if (i < min) {\n     \
    \               min = i\n                }\n            }\n            return\
    \ Tuple2(Some(max), Some(min))\n        }", "        var max = None\n        var\
    \ min = None\n        for (i <- lst) {\n            if (i < 0) {\n           \
    \     max = Some(i)\n            } else if (i > 0) {\n                min = Some(i)\n\
    \            }\n        }\n        return (max, min)\n    }\n\n    // Create a\
    \ function that returns a tuple (a, b), where 'a' is\n    // the largest of positive\
    \ integers, and 'b' is the smallest\n    // of negative integers in a list.\n\
    \    // If there is no positive or negative integers, return them as None.\n \
    \   // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(7l), Some(-1l))\n\
    \    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None), Some(None))\n\
    \    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n    // (Some(None),\
    \ Some(None))\n    def largestSmallestIntegers2(lst : List[Long]) : Tuple2[Option[Long],\
    \ Option[Long]] = {\n        var max = None\n        var min = None\n        for\
    \ (i <- lst) {\n            if (i > 0) {\n                max = Some(i)\n    \
    \        } else if (i < 0) {\n                min = Some(i)\n            }\n \
    \       }\n        return (max, min)\n    }\n\n    // Create a function that returns\
    \ a tuple (a, b), where 'a' is\n    // the largest of positive integers, and 'b'\
    \ is the smallest\n    // of positive integers in a list.\n    // If there is\
    \ no positive integers, return them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(7l),\
    \ Some(1l))\n    // >>> largestSmallestIntegers", "        var neg = None\n  \
    \      var pos = None\n        for (i <- lst.iterator()) {\n            if (i.isNegative())\
    \ {\n                neg = Some(i.toLong())\n            } else if (i.isPositive())\
    \ {\n                pos = Some(i.toLong())\n            }\n        }\n      \
    \  return (neg, pos)", "        var neg = List[Long]().toLong\n        var pos\
    \ = List[Long]().toLong\n        for (i <- lst.iterator()) {\n            if (i.toLong\
    \ < 0) {\n                neg = neg.updated(i.toLong)\n            } else {\n\
    \                pos = pos.updated(i.toLong)\n            }\n        }\n     \
    \   if (neg.isEmpty() && pos.isEmpty()) {\n            return (Some(None), Some(None))\n\
    \        } else if (neg.isEmpty()) {\n            return (Some(None), Some(pos.head))\n\
    \        } else if (pos.isEmpty()) {\n            return (Some(neg.head), Some(None))\n\
    \        } else {\n            return (Some(neg.head), Some(pos.head))\n     \
    \   }", "        var neg = List[Long]().toLong\n        var pos = List[Long]().toLong\n\
    \        for (i <- lst.iterator()) {\n            if (i.toLong < 0) {\n      \
    \          neg = neg.updated(i.toLong)\n            } else {\n               \
    \ pos = pos.updated(i.toLong)\n            }\n        }\n        if (neg.isEmpty()\
    \ && pos.isEmpty()) {\n            return (Some(None), Some(None))\n        }\
    \ else if (neg.isEmpty()) {\n            return (Some(None), Some(pos.head))\n\
    \        } else if (pos.isEmpty()) {\n            return (Some(neg.head), Some(None))\n\
    \        } else {\n            return (Some(neg.head), Some(pos.head))\n     \
    \   }", "        var maxNeg = None\n        var minPos = None\n        for (i\
    \ <- 0 until lst.length) {\n            var n = lst[i]\n            if (n < 0)\
    \ {\n                if (maxNeg == None) {\n                    maxNeg = Some(n)\n\
    \                } else {\n                    maxNeg = max(maxNeg, Some(n))\n\
    \                }\n            } else if (n > 0) {\n                if (minPos\
    \ == None) {\n                    minPos = Some(n)\n                } else {\n\
    \                    minPos = min(minPos, Some(n))\n                }\n      \
    \      }\n        }\n        return (maxNeg, minPos)", "        if (lst.isEmpty())\
    \ {\n            return (Option.empty(), Option.empty())\n        }\n        var\
    \ max = lst.head\n        var min = lst.head\n        for (i <- lst.tail) {\n\
    \            if (i > max) {\n                max = i\n            }\n        \
    \    if (i < min) {\n                min = i\n            }\n        }\n     \
    \   return (Option.of(max), Option.of(min))", "        var max = None\n      \
    \  var min = None\n        for (i <- lst.iterator()) {\n            if (i.isNegative())\
    \ {\n                max = Some(i.toLong())\n            } else if (i.isPositive())\
    \ {\n                min = Some(i.toLong())\n            }\n        }\n      \
    \  return (max, min)", "        var neg = List[Long]().toLong\n        var pos\
    \ = List[Long]().toLong\n        for (i <- lst.iterator()) {\n            if (i.toLong\
    \ < 0) {\n                neg = neg.updated(i.toLong)\n            } else {\n\
    \                pos = pos.updated(i.toLong)\n            }\n        }\n     \
    \   if (neg.isEmpty() && pos.isEmpty()) {\n            return (Some(None), Some(None))\n\
    \        } else if (neg.isEmpty()) {\n            return (Some(None), Some(pos.head()))\n\
    \        } else if (pos.isEmpty()) {\n            return (Some(neg.head()), Some(None))\n\
    \        } else {\n            return (Some(neg.head()), Some(pos.head()))\n \
    \       }", "        if (lst.isEmpty()) {\n            return (Option.empty(),\
    \ Option.empty())\n        }\n        var maxNeg = lst.minBy(x -> -x)._1\n   \
    \     var minPos = lst.maxBy(x -> x)._1\n        if (maxNeg.isEmpty() && minPos.isEmpty())\
    \ {\n            return (Option.empty(), Option.empty())\n        }\n        return\
    \ (Option.of(maxNeg), Option.of(minPos))", "        var a = None\n        var\
    \ b = None\n        for (i <- lst.iterator()) {\n            if (i.isNegative())\
    \ {\n                a = Some(i.toLong())\n            } else if (i.isPositive())\
    \ {\n                b = Some(i.toLong())\n            }\n        }\n        return\
    \ (a, b)", "        var max = Option[Long](None)\n        var min = Option[Long](None)\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                max = Option.apply(i)\n\
    \            } else if (i > 0) {\n                min = Option.apply(i)\n    \
    \        }\n        }\n        return (max, min)", "        if (lst.isEmpty())\
    \ {\n            return (Option.empty(), Option.empty())\n        } else {\n \
    \           var max = lst.head\n            var min = lst.head\n            for\
    \ (i <- lst.tail) {\n                if (i > max) {\n                    max =\
    \ i\n                }\n                if (i < min) {\n                    min\
    \ = i\n                }\n            }\n            return (Option.apply(max),\
    \ Option.apply(min))\n        }", "        if (lst.isEmpty()) {\n            return\
    \ Tuple2(Some(None), Some(None))\n        } else {\n            var max = lst.head\n\
    \            var min = lst.head\n            for (i <- lst.tail) {\n         \
    \       if (i > max) {\n                    max = i\n                }\n     \
    \           if (i < min) {\n                    min = i\n                }\n \
    \           }\n            return Tuple2(Some(max), Some(min))\n        }", " \
    \       var max = None\n        var min = None\n        for (i <- lst.iterator())\
    \ {\n            var x = i.next()\n            if (x < 0) {\n                max\
    \ = Some(x)\n            } else if (x > 0) {\n                min = Some(x)\n\
    \            }\n        }\n        return (max, min)", "        var max = None\n\
    \        var min = None\n        for (i <- lst.iterator()) {\n            if (i.isNegative())\
    \ {\n                max = Some(i.toLong())\n            } else if (i.isPositive())\
    \ {\n                min = Some(i.toLong())\n            }\n        }\n      \
    \  return (max, min)", "        var a = None\n        var b = None\n        for\
    \ (i <- lst.iterator()) {\n            if (i.isNegative()) {\n               \
    \ a = Some(i.toLong())\n            } else if (i.isPositive()) {\n           \
    \     b = Some(i.toLong())\n            }\n        }\n        return (a, b)",
  "        var max = None\n        var min = None\n        for (i <- lst.iterator())\
    \ {\n            var x = i.next()\n            if (x < 0) {\n                max\
    \ = Some(x)\n            } else if (x > 0) {\n                min = Some(x)\n\
    \            }\n        }\n        return (max, min)", "        var a = None\n\
    \        var b = None\n        for (i <- lst.iterator()) {\n            if (i.isNegative())\
    \ {\n                a = Some(i.toLong())\n            } else if (i.isPositive())\
    \ {\n                b = Some(i.toLong())\n            }\n        }\n        return\
    \ (a, b)", "        var max = None\n        var min = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                max = Some(i)\n          \
    \  } else if (i > 0) {\n                min = Some(i)\n            }\n       \
    \ }\n        return (max, min)", "        var maxNeg = None\n        var minPos\
    \ = None\n        for (i <- lst.iterator()) {\n            if (i.isNegative())\
    \ {\n                maxNeg = Some(i.toLong())\n            } else if (i.isPositive())\
    \ {\n                minPos = Some(i.toLong())\n            }\n        }\n   \
    \     return (maxNeg, minPos)", "        var a = None\n        var b = None\n\
    \        for (i <- 0 until lst.length) {\n            if (lst[i] < 0) {\n    \
    \            a = Some(lst[i])\n            } else if (lst[i] > 0) {\n        \
    \        b = Some(lst[i])\n            }\n        }\n        return (a, b)", " \
    \       var max = None\n        var min = None\n        for (i <- lst.iterator())\
    \ {\n            if (i.isEmpty()) {\n                continue\n            }\n\
    \            if (i.head.isNegative()) {\n                max = Some(i.head)\n\
    \            } else if (i.head.isPositive()) {\n                min = Some(i.head)\n\
    \            }\n        }\n        return (max, min)", "        var maxNeg = None\n\
    \        var minPos = None\n        for (i <- lst.iterator()) {\n            if\
    \ (i.isNegative()) {\n                maxNeg = i\n            } else if (i.isPositive())\
    \ {\n                minPos = i\n            }\n        }\n        if (maxNeg\
    \ != None && minPos != None) {\n            return (Some(maxNeg), Some(minPos))\n\
    \        } else if (maxNeg != None) {\n            return (Some(maxNeg), None)\n\
    \        } else if (minPos != None) {\n            return (None, Some(minPos))\n\
    \        } else {\n            return (None, None)\n        }", "        var neg\
    \ = List[Long]().toLong\n        var pos = List[Long]().toLong\n        for (i\
    \ <- lst.iterator()) {\n            if (i.toLong < 0) {\n                neg =\
    \ neg.updated(i.toLong)\n            } else {\n                pos = pos.updated(i.toLong)\n\
    \            }\n        }\n        if (neg.isEmpty() && pos.isEmpty()) {\n   \
    \         return (Some(None), Some(None))\n        } else if (neg.isEmpty()) {\n\
    \            return (Some(None), Some(pos.head))\n        } else if (pos.isEmpty())\
    \ {\n            return (Some(neg.head), Some(None))\n        } else {\n     \
    \       return (Some(Math.max(neg.head, pos.head)), Some(Math.min(neg.head, pos.head)))\n\
    \        }", "        var a = None\n        var b = None\n        for (i <- lst.iterator())\
    \ {\n            if (i.isNegative()) {\n                a = Some(i.toLong())\n\
    \            } else if (i.isPositive()) {\n                b = Some(i.toLong())\n\
    \            }\n        }\n        return (a, b)", "        var neg = None\n \
    \       var pos = None\n        for (i <- lst.iterator()) {\n            if (i.isNegative())\
    \ {\n                neg = Some(i.toLong())\n            } else if (i.isPositive())\
    \ {\n                pos = Some(i.toLong())\n            }\n        }\n      \
    \  return (neg, pos)", "        if (lst.isEmpty()) {\n            return (Option.empty(),\
    \ Option.empty())\n        } else {\n            var neg = lst.filter(x -> x <\
    \ 0).toList().sort(Comparator.comparingLong(x -> x)).head()\n            var pos\
    \ = lst.filter(x -> x > 0).toList().sort(Comparator.comparingLong(x -> x)).head()\n\
    \            return (Some(neg), Some(pos))\n        }", "        if (lst.isEmpty())\
    \ {\n            return (Option.empty(), Option.empty())\n        } else {\n \
    \           var max = lst.head\n            var min = lst.head\n            for\
    \ (i <- lst.tail) {\n                if (i > max) {\n                    max =\
    \ i\n                }\n                if (i < min) {\n                    min\
    \ = i\n                }\n            }\n            return (Option.apply(max),\
    \ Option.apply(min))\n        }", "        var max = Option[Long](None)\n    \
    \    var min = Option[Long](None)\n        for (i <- lst) {\n            if (i\
    \ < 0) {\n                max = Option.apply(i)\n            } else if (i > 0)\
    \ {\n                min = Option.apply(i)\n            }\n        }\n       \
    \ return (max, min)\n    }\n\n    // Create a function that returns the largest\
    \ of positive integers\n    // in a list.\n    // If there is no positive integers,\
    \ return them as None.\n    // Examples:\n    // >>> largestPositiveIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // Some(7l)\n\
    \    // >>> largestPositiveIntegers((List[Long]()))\n    // None\n    // >>> largestPositiveIntegers((List[Long](0l.toLong)))\n\
    \    // None\n    def largestPositiveIntegers(lst : List[Long]) : Option[Long]\
    \ = {\n        var max = Option[Long](None)\n        for (i <- lst) {\n      \
    \      if (i > 0) {\n                max = Option.apply(i)\n            }\n  \
    \      }\n        return max\n    }\n\n    // Create a function that returns the\
    \ smallest of negative integers\n    // in a list.\n    // If there is no negative\
    \ integers, return them as None.\n    // Examples:\n    // >>> smallestNegativeIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // Some(-1l)\n\
    \    // >>> smallestNegativeIntegers((List[Long]()))\n    // None\n    // >>>\
    \ smallestNegativeIntegers((List[Long](0l.toLong)))\n    // None\n    def smallestNegativeIntegers(lst\
    \ : List[Long]) : Option[Long] = {\n        var min = Option[Long](None)\n   \
    \     for (i <- lst) {\n            if (i < 0) {\n                min = Option.apply(i)\n",
  "        var neg = List[Long]().toLong\n        var pos = List[Long]().toLong\n\
    \        for (i <- lst.iterator()) {\n            if (i.toLong < 0) {\n      \
    \          neg = neg.updated(i.toLong)\n            } else {\n               \
    \ pos = pos.updated(i.toLong)\n            }\n        }\n        if (neg.isEmpty()\
    \ && pos.isEmpty()) {\n            return (Some(None), Some(None))\n        }\
    \ else if (neg.isEmpty()) {\n            return (Some(None), Some(pos.head()))\n\
    \        } else if (pos.isEmpty()) {\n            return (Some(neg.head()), Some(None))\n\
    \        } else {\n            return (Some(max(neg.head(), pos.head())), Some(min(neg.head(),\
    \ pos.head())))\n        }", "        var max = None\n        var min = None\n\
    \        for (i <- lst.iterator()) {\n            var x = i.next()\n         \
    \   if (x < 0) {\n                max = Some(x)\n            } else if (x > 0)\
    \ {\n                min = Some(x)\n            }\n        }\n        return (max,\
    \ min)", "        if (lst.isEmpty()) {\n            return (Some(None), Some(None))\n\
    \        } else {\n            var max = lst.head\n            var min = lst.head\n\
    \            for (i <- lst.tail) {\n                if (i > max) {\n         \
    \           max = i\n                }\n                if (i < min) {\n     \
    \               min = i\n                }\n            }\n            return\
    \ (Some(max), Some(min))\n        }", "        var neg = None\n        var pos\
    \ = None\n        for (var i = 0; i < lst.length; i++) {\n            var x =\
    \ lst[i]\n            if (x < 0) {\n                if (neg == None) {\n     \
    \               neg = Some(x)\n                } else {\n                    if\
    \ (x > neg.get()) {\n                        neg = Some(x)\n                 \
    \   }\n                }\n            } else if (x > 0) {\n                if\
    \ (pos == None) {\n                    pos = Some(x)\n                } else {\n\
    \                    if (x < pos.get()) {\n                        pos = Some(x)\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ (neg, pos)", "        if (lst.isEmpty()) {\n            return (Some(None),\
    \ Some(None))\n        } else {\n            var neg = lst.filter(x -> x < 0).head()\n\
    \            var pos = lst.filter(x -> x > 0).head()\n            if (neg.isDefined()\
    \ && pos.isDefined()) {\n                return (Some(neg), Some(pos))\n     \
    \       } else if (neg.isDefined()) {\n                return (Some(neg), None)\n\
    \            } else if (pos.isDefined()) {\n                return (None, Some(pos))\n\
    \            } else {\n                return (None, None)\n            }\n  \
    \      }\n    }\n\n    // Create a function that returns the largest of positive\
    \ integers\n    // in a list. If there is no positive integers, return them as\
    \ None.\n    // Examples:\n    // >>> largestPositiveIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // Some(7l)\n\
    \    // >>> largestPositiveIntegers((List[Long]()))\n    // None\n    // >>> largestPositiveIntegers((List[Long](0l.toLong)))\n\
    \    // None\n    def largestPositiveIntegers(lst : List[Long]) : Option[Long]\
    \ = {\n        if (lst.isEmpty()) {\n            return None\n        } else {\n\
    \            var pos = lst.filter(x -> x > 0).head()\n            if (pos.isDefined())\
    \ {\n                return pos\n            } else {\n                return\
    \ None\n            }\n        }\n    }\n\n    // Create a function that returns\
    \ the smallest of positive integers\n    // in a list. If there is no positive\
    \ integers, return them as None.\n    // Examples:\n    // >>> smallestPositiveIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // Some(1l)\n\
    \    // >>> smallestPositiveIntegers((List[Long]()))\n    // None\n    //", " \
    \       var neg = None\n        var pos = None\n        for (i <- lst.iterator())\
    \ {\n            if (i.toLong < 0) {\n                neg = Some(i.toLong)\n \
    \           } else if (i.toLong > 0) {\n                pos = Some(i.toLong)\n\
    \            }\n        }\n        if (neg != None && pos != None) {\n       \
    \     return (Some(neg), Some(pos))\n        } else if (neg != None) {\n     \
    \       return (Some(neg), None)\n        } else if (pos != None) {\n        \
    \    return (None, Some(pos))\n        } else {\n            return (None, None)\n\
    \        }", "        var a = None\n        var b = None\n        for (i <- lst.iterator())\
    \ {\n            var x = i.next()\n            if (x < 0) {\n                a\
    \ = Some(x)\n            } else if (x > 0) {\n                b = Some(x)\n  \
    \          }\n        }\n        return (a, b)", "        var max = None\n   \
    \     var min = None\n        for (i <- lst) {\n            if (i < 0) {\n   \
    \             max = Some(i)\n            } else if (i > 0) {\n               \
    \ min = Some(i)\n            }\n        }\n        return (max, min)", "     \
    \   if (lst.isEmpty()) {\n            return (Some(None), Some(None))\n      \
    \  } else {\n            var max = lst.head\n            var min = lst.head\n\
    \            var i = 1\n            while (i < lst.size) {\n                if\
    \ (lst.apply(i).toLong > max.toLong) {\n                    max = lst.apply(i)\n\
    \                }\n                if (lst.apply(i).toLong < min.toLong) {\n\
    \                    min = lst.apply(i)\n                }\n                i\
    \ = i + 1\n            }\n            return (Some(max), Some(min))\n        }",
  "        var max = Option[Long](null)\n        var min = Option[Long](null)\n  \
    \      for (i <- lst.iterator()) {\n            if (i.isNegative()) {\n      \
    \          max = Option.Some(i.toLong())\n            } else if (i.isPositive())\
    \ {\n                min = Option.Some(i.toLong())\n            }\n        }\n\
    \        return (max, min)", "        var max = None\n        var min = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                max = Some(i)\n\
    \            } else if (i > 0) {\n                min = Some(i)\n            }\n\
    \        }\n        return (max, min)", "        var neg = None\n        var pos\
    \ = None\n        for (i <- lst.iterator()) {\n            if (i.toLong < 0) {\n\
    \                neg = Some(i.toLong)\n            } else if (i.toLong > 0) {\n\
    \                pos = Some(i.toLong)\n            }\n        }\n        return\
    \ (neg, pos)", "        if (lst.isEmpty()) {\n            return (Option.empty(),\
    \ Option.empty())\n        } else {\n            var neg = lst.filter(x -> x <\
    \ 0).toList().sort(Comparator.comparingLong(x -> x)).head()\n            var pos\
    \ = lst.filter(x -> x > 0).toList().sort(Comparator.comparingLong(x -> x)).head()\n\
    \            return (Option.of(neg), Option.of(pos))\n        }", "        if\
    \ (lst.isEmpty()) {\n            return Tuple2(Option.empty(), Option.empty())\n\
    \        } else {\n            var max = lst.head\n            var min = lst.head\n\
    \            for (i <- lst.tail) {\n                if (i > max) {\n         \
    \           max = i\n                }\n                if (i < min) {\n     \
    \               min = i\n                }\n            }\n            return\
    \ Tuple2(Option.apply(max), Option.apply(min))\n        }", "        var neg =\
    \ List[Long]().toLong\n        var pos = List[Long]().toLong\n        for (i <-\
    \ lst.iterator()) {\n            if (i.toLong < 0) {\n                neg = neg.updated(i.toLong)\n\
    \            } else {\n                pos = pos.updated(i.toLong)\n         \
    \   }\n        }\n        if (neg.isEmpty() && pos.isEmpty()) {\n            return\
    \ (None, None)\n        } else {\n            return (Some(neg.max()), Some(pos.min()))\n\
    \        }", "        var neg = lst.filter(x -> x < 0).toList().map(x -> -x).toJavaList().sort(Comparator.comparingLong(x\
    \ -> x)).head()\n        var pos = lst.filter(x -> x > 0).toList().map(x -> x).toJavaList().sort(Comparator.comparingLong(x\
    \ -> x)).head()\n        if (neg == None && pos == None) {\n            return\
    \ (None, None)\n        } else if (neg == None) {\n            return (Some(pos),\
    \ None)\n        } else if (pos == None) {\n            return (None, Some(neg))\n\
    \        } else {\n            return (Some(Math.max(neg, pos)), Some(Math.min(neg,\
    \ pos)))\n        }", "        if (lst.isEmpty()) {\n            return (Option.empty(),\
    \ Option.empty())\n        } else {\n            var max = lst.head\n        \
    \    var min = lst.head\n            for (i <- lst.tail) {\n                if\
    \ (i > max) {\n                    max = i\n                }\n              \
    \  if (i < min) {\n                    min = i\n                }\n          \
    \  }\n            return (Option.apply(max), Option.apply(min))\n        }", " \
    \       var max = None\n        var min = None\n        for (i <- lst.iterator())\
    \ {\n            var x = i.next()\n            if (x < 0) {\n                max\
    \ = Some(x)\n            } else if (x > 0) {\n                min = Some(x)\n\
    \            }\n        }\n        return (max, min)", "        var neg = None\n\
    \        var pos = None\n        for (i <- lst.iterator()) {\n            if (i.isNegative())\
    \ {\n                neg = i\n            } else if (i.isPositive()) {\n     \
    \           pos = i\n            }\n        }\n        if (neg != None && pos\
    \ != None) {\n            return (Some(neg), Some(pos))\n        } else if (neg\
    \ != None) {\n            return (Some(neg), None)\n        } else if (pos !=\
    \ None) {\n            return (None, Some(pos))\n        } else {\n          \
    \  return (None, None)\n        }", "        var max = None\n        var min =\
    \ None\n        for (i <- lst) {\n            if (i < 0) {\n                max\
    \ = Some(i)\n            } else if (i > 0) {\n                min = Some(i)\n\
    \            }\n        }\n        return (max, min)", "        if (lst.isEmpty())\
    \ {\n            return (Option.empty(), Option.empty())\n        } else {\n \
    \           var max = lst.head\n            var min = lst.head\n            for\
    \ (i <- lst.tail) {\n                if (i > max) {\n                    max =\
    \ i\n                }\n                if (i < min) {\n                    min\
    \ = i\n                }\n            }\n            return (Option.apply(max),\
    \ Option.apply(min))\n        }", "        if (lst.isEmpty()) {\n            return\
    \ (Option.empty(), Option.empty())\n        }\n        var max = lst.head\n  \
    \      var min = lst.head\n        for (i <- lst.tail) {\n            if (i >\
    \ max) {\n                max = i\n            }\n            if (i < min) {\n\
    \                min = i\n            }\n        }\n        return (Option.apply(max),\
    \ Option.apply(min))", "        var max = Option[Long](None)\n        var min\
    \ = Option[Long](None)\n        for (i <- lst.iterator()) {\n            if (i.isNegative())\
    \ {\n                max = Option.Some(i.toLong())\n            } else if (i.isPositive())\
    \ {\n                min = Option.Some(i.toLong())\n            }\n        }\n\
    \        return (max, min)", "        var a = None\n        var b = None\n   \
    \     for (i <- lst.iterator()) {\n            if (i.isNegative()) {\n       \
    \         a = Some(i.toLong())\n            } else if (i.isPositive()) {\n   \
    \             b = Some(i.toLong())\n            }\n        }\n        return (a,\
    \ b)", "        var neg = None\n        var pos = None\n        for (var i = 0;\
    \ i < lst.length; i++) {\n            if (lst[i] < 0) {\n                neg =\
    \ Some(lst[i])\n            } else if (lst[i] > 0) {\n                pos = Some(lst[i])\n\
    \            }\n        }\n        return (neg, pos)", "        var neg = None\n\
    \        var pos = None\n        for (i <- lst.iterator()) {\n            if (i.toLong\
    \ < 0) {\n                neg = Some(i.toLong)\n            } else if (i.toLong\
    \ > 0) {\n                pos = Some(i.toLong)\n            }\n        }\n   \
    \     return (neg, pos)", "        var neg = List[Long]().toLong\n        var\
    \ pos = List[Long]().toLong\n        for (i <- lst.iterator()) {\n           \
    \ if (i.toLong < 0) {\n                neg = neg.updated(i.toLong)\n         \
    \   } else {\n                pos = pos.updated(i.toLong)\n            }\n   \
    \     }\n        if (neg.isEmpty() && pos.isEmpty()) {\n            return (Some(None),\
    \ Some(None))\n        } else if (neg.isEmpty()) {\n            return (Some(None),\
    \ Some(pos.head()))\n        } else if (pos.isEmpty()) {\n            return (Some(neg.head()),\
    \ Some(None))\n        } else {\n            return (Some(neg.head()), Some(pos.head()))\n\
    \        }", "        var neg = lst.filter(x -> x < 0).map(x -> -x).minBy(Long::compareTo).getOrElse(None)\n\
    \        var pos = lst.filter(x -> x > 0).minBy(Long::compareTo).getOrElse(None)\n\
    \        var negOrPos = neg.isDefined() ? Some(neg) : Some(pos)\n        return\
    \ Tuple2(negOrPos, pos)", "        var maxNeg = None\n        var minPos = None\n\
    \        for (i <- lst.iterator()) {\n            if (i.isNegative()) {\n    \
    \            maxNeg = i\n            } else if (i.isPositive()) {\n          \
    \      minPos = i\n            }\n        }\n        if (maxNeg != None && minPos\
    \ != None) {\n            return (Some(maxNeg), Some(minPos))\n        } else\
    \ if (maxNeg != None) {\n            return (Some(maxNeg), None)\n        } else\
    \ if (minPos != None) {\n            return (None, Some(minPos))\n        } else\
    \ {\n            return (None, None)\n        }", "        var maxNeg = None\n\
    \        var minPos = None\n        for (i <- lst.iterator()) {\n            if\
    \ (i.isNegative()) {\n                maxNeg = Some(i.toLong())\n            }\
    \ else if (i.isPositive()) {\n                minPos = Some(i.toLong())\n    \
    \        }\n        }\n        return (maxNeg, minPos)", "        var neg = lst.filter(x\
    \ -> x < 0).toSeq().map(x -> -x).max()\n        var pos = lst.filter(x -> x >\
    \ 0).toSeq().min()\n        if (neg.isDefined && pos.isDefined) {\n          \
    \  return (Some(neg), Some(pos))\n        } else if (neg.isDefined) {\n      \
    \      return (Some(neg), None)\n        } else if (pos.isDefined) {\n       \
    \     return (None, Some(pos))\n        } else {\n            return (None, None)\n\
    \        }", "        if (lst.isEmpty()) {\n            return (Option.empty(),\
    \ Option.empty())\n        } else {\n            var min = lst.head\n        \
    \    var max = lst.head\n            var minFound = true\n            var maxFound\
    \ = true\n            for (i <- lst.tail) {\n                if (i < min) {\n\
    \                    min = i\n                    minFound = true\n          \
    \      } else if (i > max) {\n                    max = i\n                  \
    \  maxFound = true\n                }\n            }\n            if (minFound)\
    \ {\n                if (maxFound) {\n                    return (Option.empty(),\
    \ Option.empty())\n                } else {\n                    return (Option.empty(),\
    \ Option.of(max))\n                }\n            } else {\n                if\
    \ (maxFound) {\n                    return (Option.of(min), Option.empty())\n\
    \                } else {\n                    return (Option.of(min), Option.of(max))\n\
    \                }\n            }\n        }", "        var max = Option[Long](null)\n\
    \        var min = Option[Long](null)\n        for (i <- lst.iterator()) {\n \
    \           if (i.isNegative()) {\n                max = Option.Some(i.toLong)\n\
    \            } else if (i.isPositive()) {\n                min = Option.Some(i.toLong)\n\
    \            }\n        }\n        return (max, min)", "        var max = Option[Long]()\n\
    \        var min = Option[Long]()\n        for (i <- lst.iterator()) {\n     \
    \       if (i.isEmpty()) {\n                max = None\n                min =\
    \ None\n            } else {\n                if (i.head < 0) {\n            \
    \        max = Some(i.head)\n                } else {\n                    min\
    \ = Some(i.head)\n                }\n            }\n        }\n        return\
    \ (max, min)\n    }\n\n    // Create a function that returns the largest of positive\
    \ integers\n    // in a list. If there is no positive integers, return them as\
    \ None.\n    // Examples:\n    // >>> largestPositiveIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // Some(7l)\n\
    \    // >>> largestPositiveIntegers((List[Long]()))\n    // None\n    // >>> largestPositiveIntegers((List[Long](0l.toLong)))\n\
    \    // None\n    def largestPositiveIntegers(lst : List[Long]) : Option[Long]\
    \ = {\n        var max = None\n        for (i <- lst.iterator()) {\n         \
    \   if (i > 0) {\n                max = i\n            }\n        }\n        return\
    \ max\n    }\n\n    // Create a function that returns the smallest of positive\
    \ integers\n    // in a list. If there is no positive integers, return them as\
    \ None.\n    // Examples:\n    // >>> smallestPositiveIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // Some(1l)\n\
    \    // >>> smallestPositiveIntegers((List[Long]()))\n    // None\n    // >>>\
    \ smallestPositiveIntegers((List[Long](0l.toLong)))\n    // None\n    def smallestPositiveIntegers(lst\
    \ : List[Long]) : Option[Long] = {\n        var min = None\n        for (i <-\
    \ lst.iterator()) {\n            if (i > 0) {\n                min =", "     \
    \   if (lst.isEmpty()) {\n            return Tuple2(Option(None), Option(None))\n\
    \        } else {\n            var max = lst.head\n            var min = lst.head\n\
    \            for (i <- lst.tail) {\n                if (i > max) {\n         \
    \           max = i\n                }\n                if (i < min) {\n     \
    \               min = i\n                }\n            }\n            return\
    \ Tuple2(Option(max), Option(min))\n        }", "        var neg = List[Long]().toLong\n\
    \        var pos = List[Long]().toLong\n        for (i <- lst.iterator()) {\n\
    \            if (i.toLong < 0) {\n                neg = neg.updated(i.toLong)\n\
    \            } else {\n                pos = pos.updated(i.toLong)\n         \
    \   }\n        }\n        var negOpt = Option[Long]().toLong\n        var posOpt\
    \ = Option[Long]().toLong\n        if (neg.isEmpty()) {\n            negOpt =\
    \ None\n        } else {\n            negOpt = Some(neg.min())\n        }\n  \
    \      if (pos.isEmpty()) {\n            posOpt = None\n        } else {\n   \
    \         posOpt = Some(pos.max())\n        }\n        return (negOpt, posOpt)",
  "        var neg = lst.filter(x -> x < 0).toSeq().map(x -> -x).minBy(Long::compareTo).getOrElse(None)\n\
    \        var pos = lst.filter(x -> x > 0).toSeq().minBy(Long::compareTo).getOrElse(None)\n\
    \        if (neg != None && pos != None) {\n            return (Some(neg), Some(pos))\n\
    \        } else if (neg != None) {\n            return (Some(neg), None)\n   \
    \     } else if (pos != None) {\n            return (None, Some(pos))\n      \
    \  } else {\n            return (None, None)\n        }", "        var neg = List[Long]().toLong\n\
    \        var pos = List[Long]().toLong\n        for (i <- lst.iterator()) {\n\
    \            if (i.toLong < 0) {\n                neg = neg.updated(i.toLong)\n\
    \            } else {\n                pos = pos.updated(i.toLong)\n         \
    \   }\n        }\n        if (neg.isEmpty() && pos.isEmpty()) {\n            return\
    \ (Some(None), Some(None))\n        } else if (neg.isEmpty()) {\n            return\
    \ (Some(None), Some(pos.head))\n        } else if (pos.isEmpty()) {\n        \
    \    return (Some(neg.head), Some(None))\n        } else {\n            return\
    \ (Some(neg.head), Some(pos.head))\n        }", "        var neg = None\n    \
    \    var pos = None\n        for (var i = 0; i < lst.length; i++) {\n        \
    \    if (lst[i] < 0) {\n                neg = Some(lst[i])\n            } else\
    \ if (lst[i] > 0) {\n                pos = Some(lst[i])\n            }\n     \
    \   }\n        return (neg, pos)", "        if (lst.isEmpty()) {\n           \
    \ return (Option.empty(), Option.empty())\n        } else {\n            var min\
    \ = lst.head\n            var max = lst.head\n            for (i <- lst.tail)\
    \ {\n                if (i < min) {\n                    min = i\n           \
    \     } else if (i > max) {\n                    max = i\n                }\n\
    \            }\n            return (Option.apply(max), Option.apply(min))\n  \
    \      }", "        var max = None\n        var min = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                max = Some(i)\n          \
    \  } else if (i > 0) {\n                min = Some(i)\n            }\n       \
    \ }\n        return (max, min)\n    }\n\n    // Create a function that returns\
    \ the largest of positive integers\n    // in a list.\n    // If there is no positive\
    \ integers, return them as None.\n    // Examples:\n    // >>> largestPositiveIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // Some(7l)\n\
    \    // >>> largestPositiveIntegers((List[Long]()))\n    // None\n    // >>> largestPositiveIntegers((List[Long](0l.toLong)))\n\
    \    // None\n    def largestPositiveIntegers(lst : List[Long]) : Option[Long]\
    \ = {\n        var max = None\n        for (i <- lst) {\n            if (i > 0)\
    \ {\n                max = i\n            }\n        }\n        return max\n \
    \   }\n\n    // Create a function that returns the smallest of negative integers\n\
    \    // in a list.\n    // If there is no negative integers, return them as None.\n\
    \    // Examples:\n    // >>> smallestNegativeIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // Some(-1l)\n\
    \    // >>> smallestNegativeIntegers((List[Long]()))\n    // None\n    // >>>\
    \ smallestNegativeIntegers((List[Long](0l.toLong)))\n    // None\n    def smallestNegativeIntegers(lst\
    \ : List[Long]) : Option[Long] = {\n        var min = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                min = i\n            }\n \
    \       }\n        return min\n    }\n\n    // Create a function that returns\
    \ the smallest of positive integers\n    // in a list.\n    ", "        var maxNeg\
    \ = None\n        var minPos = None\n        for (i <- lst) {\n            if\
    \ (i < 0) {\n                maxNeg = Some(i)\n            } else if (i > 0) {\n\
    \                minPos = Some(i)\n            }\n        }\n        return (maxNeg,\
    \ minPos)", "        var maxNeg = None\n        var minPos = None\n        for\
    \ (i <- lst.iterator()) {\n            var n = i.next()\n            if (n < 0)\
    \ {\n                maxNeg = Some(n)\n            } else if (n > 0) {\n     \
    \           minPos = Some(n)\n            }\n        }\n        return (maxNeg,\
    \ minPos)", "        if (lst.isEmpty()) {\n            return Tuple2(Option.empty(),\
    \ Option.empty())\n        } else {\n            var neg = lst.filter(x -> x <\
    \ 0).toSeq().max()\n            var pos = lst.filter(x -> x > 0).toSeq().min()\n\
    \            return Tuple2(Option.apply(neg), Option.apply(pos))\n        }",
  "        var a = None\n        var b = None\n        for (i <- 0 until lst.length)\
    \ {\n            if (lst[i] < 0) {\n                a = Some(lst[i])\n       \
    \     } else if (lst[i] > 0) {\n                b = Some(lst[i])\n           \
    \ }\n        }\n        return (a, b)", "        var max = None\n        var min\
    \ = None\n        for (i <- lst.iterator()) {\n            if (i.isNegative())\
    \ {\n                max = Some(i.toLong())\n            } else if (i.isPositive())\
    \ {\n                min = Some(i.toLong())\n            }\n        }\n      \
    \  return (max, min)", "        var neg = List[Long]().toLong\n        var pos\
    \ = List[Long]().toLong\n        for (i <- lst.iterator()) {\n            if (i.toLong\
    \ < 0) {\n                neg = neg.updated(i.toLong)\n            } else {\n\
    \                pos = pos.updated(i.toLong)\n            }\n        }\n     \
    \   var negOpt = Option[Long]().toLong\n        var posOpt = Option[Long]().toLong\n\
    \        if (neg.isEmpty() && pos.isEmpty()) {\n            negOpt = None\n  \
    \          posOpt = None\n        } else if (neg.isEmpty()) {\n            negOpt\
    \ = pos.head\n            posOpt = pos.tail.head\n        } else if (pos.isEmpty())\
    \ {\n            negOpt = neg.head\n            posOpt = neg.tail.head\n     \
    \   } else {\n            negOpt = pos.head\n            posOpt = pos.tail.head\n\
    \        }\n        return (Some(negOpt), Some(posOpt))", "        var max = None\n\
    \        var min = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                max = Some(i)\n            } else if (i > 0) {\n            \
    \    min = Some(i)\n            }\n        }\n        return (max, min)\n    }\n\
    \n    // Create a function that returns a tuple (a, b), where 'a' is\n    // the\
    \ largest of positive integers, and 'b' is the smallest\n    // of negative integers\
    \ in a list.\n    // If there is no positive or negative integers, return them\
    \ as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(7l),\
    \ Some(-1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers2(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        var max = None\n        var\
    \ min = None\n        for (i <- lst) {\n            if (i > 0) {\n           \
    \     max = Some(i)\n            } else if (i < 0) {\n                min = Some(i)\n\
    \            }\n        }\n        return (max, min)\n    }\n\n    // Create a\
    \ function that returns a tuple (a, b), where 'a' is\n    // the largest of positive\
    \ integers, and 'b' is the smallest\n    // of positive integers in a list.\n\
    \    // If there is no positive integers, return them as None.\n    // Examples:\n\
    \    // >>> largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(7l), Some(1l))\n    // >>>\
    \ largestSmallestIntegers", "        var a = None\n        var b = None\n    \
    \    for (i <- lst.iterator()) {\n            if (i.isNegative()) {\n        \
    \        a = Some(i.toLong())\n            } else if (i.isPositive()) {\n    \
    \            b = Some(i.toLong())\n            }\n        }\n        return (a,\
    \ b)", "        if (lst.isEmpty()) {\n            return (Option.empty(), Option.empty())\n\
    \        } else {\n            var max = lst.head\n            var min = lst.head\n\
    \            for (i <- lst.tail) {\n                if (i > max) {\n         \
    \           max = i\n                }\n                if (i < min) {\n     \
    \               min = i\n                }\n            }\n            return\
    \ (Option.apply(max), Option.apply(min))\n        }", "        if (lst.isEmpty())\
    \ {\n            return (Some(None), Some(None))\n        } else {\n         \
    \   var max = lst.head\n            var min = lst.head\n            for (i <-\
    \ lst.tail) {\n                if (i > max) {\n                    max = i\n \
    \               }\n                if (i < min) {\n                    min = i\n\
    \                }\n            }\n            return (Some(max), Some(min))\n\
    \        }", "        var maxNeg = None\n        var minPos = None\n        for\
    \ (i <- lst.iterator()) {\n            if (i.isNegative()) {\n               \
    \ maxNeg = Some(i.toLong())\n            } else if (i.isPositive()) {\n      \
    \          minPos = Some(i.toLong())\n            }\n        }\n        return\
    \ (maxNeg, minPos)", "        var maxNeg = None\n        var minPos = None\n \
    \       for (i <- lst.iterator()) {\n            if (i.isNegative()) {\n     \
    \           maxNeg = i\n            } else if (i.isPositive()) {\n           \
    \     minPos = i\n            }\n        }\n        if (maxNeg != None && minPos\
    \ != None) {\n            return (Some(maxNeg), Some(minPos))\n        } else\
    \ if (maxNeg != None) {\n            return (Some(maxNeg), None)\n        } else\
    \ if (minPos != None) {\n            return (None, Some(minPos))\n        } else\
    \ {\n            return (None, None)\n        }", "        var maxNeg = None\n\
    \        var minPos = None\n        for (i <- lst.iterator()) {\n            if\
    \ (i.isNegative()) {\n                maxNeg = i\n            } else if (i.isPositive())\
    \ {\n                minPos = i\n            }\n        }\n        if (maxNeg\
    \ != None && minPos != None) {\n            return (Some(maxNeg), Some(minPos))\n\
    \        } else if (maxNeg != None) {\n            return (Some(maxNeg), None)\n\
    \        } else if (minPos != None) {\n            return (None, Some(minPos))\n\
    \        } else {\n            return (None, None)\n        }", "        if (lst.isEmpty())\
    \ {\n            return (Some(None), Some(None))\n        } else {\n         \
    \   var max = lst.head\n            var min = lst.head\n            for (i <-\
    \ lst.tail) {\n                if (i > max) {\n                    max = i\n \
    \               }\n                if (i < min) {\n                    min = i\n\
    \                }\n            }\n            return (Some(max), Some(min))\n\
    \        }", "        var a = None\n        var b = None\n        for (i <- lst.iterator())\
    \ {\n            if (i.isNegative()) {\n                a = Some(i.toLong())\n\
    \            } else if (i.isPositive()) {\n                b = Some(i.toLong())\n\
    \            }\n        }\n        return (a, b)", "        if (lst.isEmpty())\
    \ {\n            return (Some(None), Some(None))\n        } else {\n         \
    \   var neg = lst.filter(x -> x < 0).head()\n            var pos = lst.filter(x\
    \ -> x > 0).head()\n            if (neg != None && pos != None) {\n          \
    \      return (Some(neg), Some(pos))\n            } else if (neg != None) {\n\
    \                return (Some(neg), None)\n            } else {\n            \
    \    return (Some(None), Some(pos))\n            }\n        }", "        var max\
    \ = None\n        var min = None\n        for (var i = 0; i < lst.length; i++)\
    \ {\n            var num = lst[i]\n            if (num < 0) {\n              \
    \  max = Some(num)\n            } else if (num > 0) {\n                min = Some(num)\n\
    \            }\n        }\n        return (max, min)", "        var neg = lst.filter(x\
    \ -> x < 0).map(x -> -x).minBy(x -> x)\n        var pos = lst.filter(x -> x >\
    \ 0).minBy(x -> x)\n        if (neg.isDefined && pos.isDefined) {\n          \
    \  return (Some(neg), Some(pos))\n        } else if (neg.isDefined) {\n      \
    \      return (Some(neg), None)\n        } else if (pos.isDefined) {\n       \
    \     return (None, Some(pos))\n        } else {\n            return (None, None)\n\
    \        }", "        var neg = List[Long]().toLong\n        var pos = List[Long]().toLong\n\
    \        for (i <- lst.iterator()) {\n            if (i.toLong < 0) {\n      \
    \          neg = neg.updated(i.toLong)\n            } else {\n               \
    \ pos = pos.updated(i.toLong)\n            }\n        }\n        if (neg.isEmpty()\
    \ && pos.isEmpty()) {\n            return (Some(None), Some(None))\n        }\
    \ else if (neg.isEmpty()) {\n            return (Some(None), Some(pos.head))\n\
    \        } else if (pos.isEmpty()) {\n            return (Some(neg.head), Some(None))\n\
    \        } else {\n            return (Some(neg.head), Some(pos.head))\n     \
    \   }", "        if (lst.isEmpty()) {\n            return Tuple2(Option.empty(),\
    \ Option.empty())\n        } else {\n            var max = lst.head\n        \
    \    var min = lst.head\n            for (i <- lst.tail) {\n                if\
    \ (i > max) {\n                    max = i\n                }\n              \
    \  if (i < min) {\n                    min = i\n                }\n          \
    \  }\n            return Tuple2(Option.apply(max), Option.apply(min))\n      \
    \  }", "        var max = None\n        var min = None\n        for (i <- lst)\
    \ {\n            if (i < 0) {\n                max = Some(i)\n            } else\
    \ if (i > 0) {\n                min = Some(i)\n            }\n        }\n    \
    \    return (max, min)", "        var a = None\n        var b = None\n       \
    \ for (i <- lst.iterator()) {\n            if (i.isNegative()) {\n           \
    \     a = Some(i.toLong())\n            } else if (i.isPositive()) {\n       \
    \         b = Some(i.toLong())\n            }\n        }\n        return (a, b)",
  "        var neg = None\n        var pos = None\n        for (i <- lst.iterator())\
    \ {\n            if (i.toLong < 0) {\n                neg = Some(i.toLong)\n \
    \           } else if (i.toLong > 0) {\n                pos = Some(i.toLong)\n\
    \            }\n        }\n        return (neg, pos)", "        var max = None\n\
    \        var min = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                max = Some(i)\n            } else if (i > 0) {\n            \
    \    min = Some(i)\n            }\n        }\n        return (max, min)", "  \
    \      if (lst.isEmpty()) {\n            return (Option.empty(), Option.empty())\n\
    \        }\n        var max = lst.head\n        var min = lst.head\n        for\
    \ (i <- lst.tail) {\n            if (i > max) {\n                max = i\n   \
    \         }\n            if (i < min) {\n                min = i\n           \
    \ }\n        }\n        return (Option.apply(max), Option.apply(min))", "    \
    \    var largestNegative = None\n        var smallestPositive = None\n       \
    \ for (i <- lst.iterator()) {\n            if (i.isNegative()) {\n           \
    \     largestNegative = Some(i.toLong())\n            } else if (i.isPositive())\
    \ {\n                smallestPositive = Some(i.toLong())\n            }\n    \
    \    }\n        return (largestNegative, smallestPositive)", "        if (lst.isEmpty())\
    \ {\n            return (Some(None), Some(None))\n        } else {\n         \
    \   var max = lst.head\n            var min = lst.head\n            for (i <-\
    \ lst.tail) {\n                if (i > max) {\n                    max = i\n \
    \               }\n                if (i < min) {\n                    min = i\n\
    \                }\n            }\n            return (Some(max), Some(min))\n\
    \        }", "        var max = None\n        var min = None\n        for (i <-\
    \ lst.iterator()) {\n            if (i.isNegative()) {\n                max =\
    \ Some(i.toLong())\n            } else if (i.isPositive()) {\n               \
    \ min = Some(i.toLong())\n            }\n        }\n        return (max, min)",
  "        var neg = List[Long]().toLong\n        var pos = List[Long]().toLong\n\
    \        for (i <- lst.iterator()) {\n            if (i.toLong < 0) {\n      \
    \          neg = neg.updated(i.toLong)\n            } else {\n               \
    \ pos = pos.updated(i.toLong)\n            }\n        }\n        if (neg.isEmpty()\
    \ && pos.isEmpty()) {\n            return (Some(None), Some(None))\n        }\
    \ else if (neg.isEmpty()) {\n            return (Some(None), Some(pos.head))\n\
    \        } else if (pos.isEmpty()) {\n            return (Some(neg.head), Some(None))\n\
    \        } else {\n            return (Some(neg.head), Some(pos.head))\n     \
    \   }", "        if (lst.isEmpty()) {\n            return (Option.empty(), Option.empty())\n\
    \        } else {\n            var max = lst.head\n            var min = lst.head\n\
    \            for (i <- lst.tail) {\n                if (i > max) {\n         \
    \           max = i\n                }\n                if (i < min) {\n     \
    \               min = i\n                }\n            }\n            return\
    \ (Option.apply(max), Option.apply(min))\n        }", "        var neg = None\n\
    \        var pos = None\n        for (i <- lst.iterator()) {\n            if (i.toLong\
    \ < 0) {\n                neg = Some(i.toLong)\n            } else if (i.toLong\
    \ > 0) {\n                pos = Some(i.toLong)\n            }\n        }\n   \
    \     if (neg != None && pos != None) {\n            return (Some(neg), Some(pos))\n\
    \        } else if (neg != None) {\n            return (Some(neg), None)\n   \
    \     } else if (pos != None) {\n            return (None, Some(pos))\n      \
    \  } else {\n            return (None, None)\n        }", "        var max = -1l\n\
    \        var min = 1l\n        for (i <- lst) {\n            if (i < 0) {\n  \
    \              max = max.max(i)\n            } else {\n                min = min.min(i)\n\
    \            }\n        }\n        if (max == -1l) {\n            return (Some(None),\
    \ Some(None))\n        } else {\n            return (Some(max), Some(min))\n \
    \       }", "        var neg = None\n        var pos = None\n        for (i <-\
    \ lst.iterator()) {\n            if (i.isNegative()) {\n                neg =\
    \ i\n            } else if (i.isPositive()) {\n                pos = i\n     \
    \       }\n        }\n        if (neg != None && pos != None) {\n            return\
    \ (Some(neg), Some(pos))\n        } else if (neg != None) {\n            return\
    \ (Some(neg), None)\n        } else if (pos != None) {\n            return (None,\
    \ Some(pos))\n        } else {\n            return (None, None)\n        }", " \
    \       if (lst.isEmpty()) {\n            return (Option.empty(), Option.empty())\n\
    \        }\n        var maxNeg = lst.head.toLong\n        var minPos = lst.head.toLong\n\
    \        for (i <- lst.tail.iterator()) {\n            if (i.toLong > maxNeg)\
    \ {\n                maxNeg = i.toLong\n            }\n            if (i.toLong\
    \ < minPos) {\n                minPos = i.toLong\n            }\n        }\n \
    \       return (Option.apply(maxNeg), Option.apply(minPos))", "        var max\
    \ = None\n        var min = None\n        for (i <- lst) {\n            if (i\
    \ < 0) {\n                max = Some(i)\n            } else if (i > 0) {\n   \
    \             min = Some(i)\n            }\n        }\n        return (max, min)",
  "        if (lst.isEmpty()) {\n            return (None, None)\n        } else {\n\
    \            var min = lst.head\n            var max = lst.head\n            var\
    \ minFound = true\n            var maxFound = true\n            for (i <- lst.tail)\
    \ {\n                if (i < min) {\n                    min = i\n           \
    \         minFound = true\n                } else if (i > max) {\n           \
    \         max = i\n                    maxFound = true\n                }\n  \
    \          }\n            if (minFound) {\n                return (Some(min),\
    \ Some(max))\n            } else {\n                return (None, None)\n    \
    \        }\n        }", "        if (lst.isEmpty()) {\n            return (Option.empty(),\
    \ Option.empty())\n        }\n        var max = lst.head\n        var min = lst.head\n\
    \        var lst2 = lst.tail\n        for (var i <- lst2.size - 1) {\n       \
    \     var curr = lst2.apply(i)\n            if (curr > max) {\n              \
    \  max = curr\n            }\n            if (curr < min) {\n                min\
    \ = curr\n            }\n        }\n        return (Option.apply(max), Option.apply(min))",
  "        var max = None\n        var min = None\n        for (i <- lst) {\n    \
    \        if (i < 0) {\n                max = Some(i)\n            } else if (i\
    \ > 0) {\n                min = Some(i)\n            }\n        }\n        return\
    \ (max, min)", "        if (lst.isEmpty()) {\n            return (Option.empty(),\
    \ Option.empty())\n        } else {\n            var max = lst.head\n        \
    \    var min = lst.head\n            for (i <- lst.tail) {\n                if\
    \ (i > max) {\n                    max = i\n                }\n              \
    \  if (i < min) {\n                    min = i\n                }\n          \
    \  }\n            return (Option.apply(max), Option.apply(min))\n        }", " \
    \       var neg = List[Long]().toLong\n        var pos = List[Long]().toLong\n\
    \        for (i <- lst.iterator()) {\n            if (i.toLong < 0) {\n      \
    \          neg = neg.updated(i.toLong)\n            } else {\n               \
    \ pos = pos.updated(i.toLong)\n            }\n        }\n        if (neg.isEmpty()\
    \ && pos.isEmpty()) {\n            return (Some(None), Some(None))\n        }\
    \ else if (neg.isEmpty()) {\n            return (Some(None), Some(pos.head()))\n\
    \        } else if (pos.isEmpty()) {\n            return (Some(neg.head()), Some(None))\n\
    \        } else {\n            return (Some(neg.head()), Some(pos.head()))\n \
    \       }", "        var max = None\n        var min = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                max = Some(i)\n          \
    \  } else if (i > 0) {\n                min = Some(i)\n            }\n       \
    \ }\n        return (max, min)", "        if (lst.isEmpty()) {\n            return\
    \ (Option.apply(None), Option.apply(None))\n        } else {\n            var\
    \ neg = lst.filter(x -> x < 0).toSeq().max()\n            var pos = lst.filter(x\
    \ -> x > 0).toSeq().min()\n            return (Option.apply(neg), Option.apply(pos))\n\
    \        }", "        var a = None\n        var b = None\n        for (i <- lst.iterator())\
    \ {\n            if (i.isNegative()) {\n                a = Some(i.toLong())\n\
    \            } else if (i.isPositive()) {\n                b = Some(i.toLong())\n\
    \            }\n        }\n        return (a, b)", "        var a = None\n   \
    \     var b = None\n        for (i <- lst.iterator()) {\n            if (i.isNegative())\
    \ {\n                a = Some(i.toLong())\n            } else if (i.isPositive())\
    \ {\n                b = Some(i.toLong())\n            }\n        }\n        return\
    \ (a, b)", "        if (lst.isEmpty()) {\n            return (Option.apply(None),\
    \ Option.apply(None))\n        } else {\n            var max = lst.head\n    \
    \        var min = lst.head\n            for (i <- lst.tail) {\n             \
    \   if (i > max) {\n                    max = i\n                }\n         \
    \       if (i < min) {\n                    min = i\n                }\n     \
    \       }\n            return (Option.apply(max), Option.apply(min))\n       \
    \ }\n    }\n\n    // Create a function that returns a tuple (a, b), where 'a'\
    \ is\n    // the largest of positive integers, and 'b' is the smallest\n    //\
    \ of negative integers in a list.\n    // If there is no positive or negative\
    \ integers, return them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(7l),\
    \ Some(-1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers2(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        if (lst.isEmpty()) {\n   \
    \         return (Option.apply(None), Option.apply(None))\n        } else {\n\
    \            var max = lst.head\n            var min = lst.head\n            for\
    \ (i <- lst.tail) {\n                if (i > max) {\n                    max =\
    \ i\n                }\n                if (i < min) {\n                    min\
    \ = i\n                }\n            }\n            return (Option.apply(max),\
    \ Option.apply(min))\n        }\n    }\n\n    // Create a function that returns\
    \ a tuple (a, b), where 'a' is\n    // the largest of positive integers, and 'b'\
    \ is the smallest\n    // of positive integers in a list.\n", "        if (lst.isEmpty())\
    \ {\n            return (Option.apply(None), Option.apply(None))\n        } else\
    \ {\n            var max = lst.head\n            var min = lst.head\n        \
    \    for (i <- lst.tail) {\n                if (i > max) {\n                 \
    \   max = i\n                }\n                if (i < min) {\n             \
    \       min = i\n                }\n            }\n            return (Option.apply(max),\
    \ Option.apply(min))\n        }", "        var max = None\n        var min = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                max = Some(i)\n\
    \            } else if (i > 0) {\n                min = Some(i)\n            }\n\
    \        }\n        return (max, min)", "        var a = None\n        var b =\
    \ None\n        for (i <- lst.iterator()) {\n            var x = i.next()\n  \
    \          if (x < 0) {\n                a = Some(x)\n            } else if (x\
    \ > 0) {\n                b = Some(x)\n            }\n        }\n        return\
    \ (a, b)", "        if (lst.isEmpty()) {\n            return (Option.empty(),\
    \ Option.empty())\n        } else {\n            var neg = lst.filter(x -> x <\
    \ 0).head()\n            var pos = lst.filter(x -> x > 0).head()\n           \
    \ if (neg.isDefined() && pos.isDefined()) {\n                return (Option.of(neg),\
    \ Option.of(pos))\n            } else if (neg.isDefined()) {\n               \
    \ return (Option.of(neg), Option.empty())\n            } else if (pos.isDefined())\
    \ {\n                return (Option.empty(), Option.of(pos))\n            } else\
    \ {\n                return (Option.empty(), Option.empty())\n            }\n\
    \        }", "        var neg = None\n        var pos = None\n        for (i <-\
    \ lst.iterator()) {\n            if (i.toLong < 0) {\n                neg = Some(i.toLong)\n\
    \            } else if (i.toLong > 0) {\n                pos = Some(i.toLong)\n\
    \            }\n        }\n        if (neg == None && pos == None) {\n       \
    \     return (None, None)\n        } else if (neg == None) {\n            return\
    \ (Some(pos), None)\n        } else if (pos == None) {\n            return (None,\
    \ Some(neg))\n        } else {\n            return (Some(min(neg.get(), pos.get())),\
    \ Some(max(neg.get(), pos.get())))\n        }", "        var max = None\n    \
    \    var min = None\n        for (i <- lst.iterator()) {\n            var n =\
    \ i.next()\n            if (n < 0) {\n                max = Some(n)\n        \
    \    } else if (n > 0) {\n                min = Some(n)\n            }\n     \
    \   }\n        return (max, min)", "        var max = None\n        var min =\
    \ None\n        for (i <- lst) {\n            if (i < 0) {\n                max\
    \ = Some(i)\n            } else if (i > 0) {\n                min = Some(i)\n\
    \            }\n        }\n        return (max, min)", "        if (lst.isEmpty())\
    \ {\n            return (Option.empty(), Option.empty())\n        } else {\n \
    \           var max = lst.head\n            var min = lst.head\n            for\
    \ (i <- lst.tail) {\n                if (i < max) {\n                    max =\
    \ i\n                }\n                if (i > min) {\n                    min\
    \ = i\n                }\n            }\n            return (Option.apply(max),\
    \ Option.apply(min))\n        }", "        var max = None\n        var min = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                max = Some(i)\n\
    \            } else if (i > 0) {\n                min = Some(i)\n            }\n\
    \        }\n        return (max, min)", "        var maxNeg = None\n        var\
    \ minPos = None\n        for (i <- lst.iterator()) {\n            if (i.isNegative())\
    \ {\n                maxNeg = i\n            } else if (i.isPositive()) {\n  \
    \              minPos = i\n            }\n        }\n        if (maxNeg != None\
    \ && minPos != None) {\n            return (Some(maxNeg), Some(minPos))\n    \
    \    } else if (maxNeg != None) {\n            return (Some(maxNeg), None)\n \
    \       } else if (minPos != None) {\n            return (None, Some(minPos))\n\
    \        } else {\n            return (None, None)\n        }", "        if (lst.isEmpty())\
    \ {\n            return (Some(None), Some(None))\n        } else {\n         \
    \   var max = lst.head\n            var min = lst.head\n            for (i <-\
    \ lst.tail) {\n                if (i > max) {\n                    max = i\n \
    \               }\n                if (i < min) {\n                    min = i\n\
    \                }\n            }\n            return (Some(max), Some(min))\n\
    \        }", "        var max = None\n        var min = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                max = Some(i)\n          \
    \  } else if (i > 0) {\n                min = Some(i)\n            }\n       \
    \ }\n        return (max, min)", "        if (lst.isEmpty()) {\n            return\
    \ Tuple2(Option.apply(None), Option.apply(None))\n        } else {\n         \
    \   var max = lst.head\n            var min = lst.head\n            for (i <-\
    \ lst.tail) {\n                if (i > max) {\n                    max = i\n \
    \               }\n                if (i < min) {\n                    min = i\n\
    \                }\n            }\n            return Tuple2(Option.apply(max),\
    \ Option.apply(min))\n        }", "        var maxNeg = None\n        var minPos\
    \ = None\n        for (i <- lst.iterator()) {\n            if (i.isNegative())\
    \ {\n                maxNeg = Some(i.toLong())\n            } else if (i.isPositive())\
    \ {\n                minPos = Some(i.toLong())\n            }\n        }\n   \
    \     return (maxNeg, minPos)", "        var neg = List[Long]().toLong\n     \
    \   var pos = List[Long]().toLong\n        for (i <- lst.iterator()) {\n     \
    \       if (i.toLong < 0) {\n                neg = neg.updated(i.toLong)\n   \
    \         } else {\n                pos = pos.updated(i.toLong)\n            }\n\
    \        }\n        if (neg.isEmpty() && pos.isEmpty()) {\n            return\
    \ (Some(None), Some(None))\n        } else if (neg.isEmpty()) {\n            return\
    \ (Some(None), Some(pos.head))\n        } else if (pos.isEmpty()) {\n        \
    \    return (Some(neg.head), Some(None))\n        } else {\n            return\
    \ (Some(Math.max(neg.head, pos.head)), Some(Math.min(neg.head, pos.head)))\n \
    \       }", "        var neg = lst.filter(x -> x < 0).toSeq().max()\n        var\
    \ pos = lst.filter(x -> x > 0).toSeq().min()\n        if (neg.isDefined && pos.isDefined)\
    \ {\n            return (Some(neg), Some(pos))\n        } else if (neg.isDefined)\
    \ {\n            return (Some(neg), None)\n        } else if (pos.isDefined) {\n\
    \            return (None, Some(pos))\n        } else {\n            return (None,\
    \ None)\n        }", "        var max = -1l\n        var min = 1l\n        for\
    \ (i <- lst) {\n            if (i < 0l) {\n                max = max.max(i)\n\
    \            } else if (i > 0l) {\n                min = min.min(i)\n        \
    \    }\n        }\n        if (max == -1l) {\n            return (Some(None),\
    \ Some(None))\n        } else {\n            return (Some(max), Some(min))\n \
    \       }", "        if (lst.isEmpty()) {\n            return Tuple2(Some(None),\
    \ Some(None))\n        } else {\n            var neg = lst.filter(x -> x < 0).head()\n\
    \            var pos = lst.filter(x -> x > 0).head()\n            if (neg != None\
    \ && pos != None) {\n                return Tuple2(Some(neg), Some(pos))\n   \
    \         } else if (neg != None) {\n                return Tuple2(Some(neg),\
    \ None)\n            } else {\n                return Tuple2(None, Some(pos))\n\
    \            }\n        }", "        var max = Option[Long]()\n        var min\
    \ = Option[Long]()\n        for (i <- lst.iterator()) {\n            if (i.isNegative())\
    \ {\n                max = max.getOrElse(i.toLong)\n            } else {\n   \
    \             min = min.getOrElse(i.toLong)\n            }\n        }\n      \
    \  max", "        var a = None\n        var b = None\n        for (var i = 0;\
    \ i < lst.length; i++) {\n            var x = lst[i]\n            if (x < 0) {\n\
    \                if (a == None) {\n                    a = Some(x)\n         \
    \       } else {\n                    if (x > a.get()) {\n                   \
    \     a = Some(x)\n                    }\n                }\n            } else\
    \ if (x > 0) {\n                if (b == None) {\n                    b = Some(x)\n\
    \                } else {\n                    if (x < b.get()) {\n          \
    \              b = Some(x)\n                    }\n                }\n       \
    \     }\n        }\n        return (a, b)"]
stop_tokens:
- "\n    }\n"
