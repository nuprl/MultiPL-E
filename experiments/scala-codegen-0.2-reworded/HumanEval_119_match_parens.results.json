{
  "name": "HumanEval_119_match_parens",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "results": [
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        } else {\n            var s = lst.head\n            var result = \"No\"\n            var stack = List[String]()\n            for (i <- 1 to lst.size) {\n                if (s.equals(\"(\")) {\n                    stack = stack.append(s)\n                } else if (s.equals(\")\")) {\n                    if (stack.isEmpty()) {\n                        result = \"No\"\n                        break\n                    } else {\n                        stack = stack.tail\n                    }\n                }\n                s = lst.apply(i)\n            }\n            if (stack.isEmpty()) {\n                result = \"Yes\"\n            }\n            return result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293015,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpikhgtsr1.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpikhgtsr1.scala:26:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                    stack = stack.append(s)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[String] - did you mean List[String].appended?\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpikhgtsr1.scala:28:30 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                    \u001b[33mif\u001b[0m (stack.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpikhgtsr1.scala:30:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                        break\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpikhgtsr1.scala:37:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mif\u001b[0m (stack.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"No\"\n        }\n        if (lst.length == 1) {\n            return \"Yes\"\n        }\n        if (lst.length == 2) {\n            return \"Yes\"\n        }\n        if (lst.length == 3) {\n            return \"Yes\"\n        }\n        if (lst.length == 4) {\n            return \"Yes\"\n        }\n        if (lst.length == 5) {\n            return \"Yes\"\n        }\n        if (lst.length == 6) {\n            return \"Yes\"\n        }\n        if (lst.length == 7) {\n            return \"Yes\"\n        }\n        if (lst.length == 8) {\n            return \"Yes\"\n        }\n        if (lst.length == 9) {\n            return \"Yes\"\n        }\n        if (lst.length == 10) {\n            return \"Yes\"\n        }\n        if (lst.length == 11) {\n            return \"Yes\"\n        }\n        if (lst.length == 12) {\n            return \"Yes\"\n        }\n        if (lst.length == 13) {\n            return \"Yes\"\n        }\n        if (lst.length == 14) {\n            return \"Yes\"\n        }\n        if (lst.length == 15) {\n            return \"Yes\"\n        }\n        if (lst.length == 16) {\n            return \"Yes\"\n        }\n        if (lst.length == 17) {\n            return \"Yes\"\n        }\n        if (lst.length == 18) {\n            return \"Yes\"\n        }\n        if (lst.length == 19) {\n            return \"Yes\"\n        }\n        if (lst.length == 20) {\n            return \"Yes\"\n        }\n        if (lst.length == 21) {\n            return \"Yes\"\n        }\n        if (lst.length == 22) {\n            return \"Yes\"\n        }\n        if (lst.length == 23) {\n            return \"Yes\"\n        }\n        if (lst.length ==\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293009,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpgs7ibexl.scala:90:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m90 |\u001b[0m        \u001b[33mif\u001b[0m (lst.length ==\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var i = 0\n        var j = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293015,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpg24d7v3r.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mi\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mi is already defined as \u001b[33mvariable\u001b[0m \u001b[35mi\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpg24d7v3r.scala:43:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mj\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mj is already defined as \u001b[33mvariable\u001b[0m \u001b[35mj\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpg24d7v3r.scala:49:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mp\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mp is already defined as \u001b[33mvariable\u001b[0m \u001b[35mp\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpg24d7v3r.scala:50:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mq\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mq is already defined as \u001b[33mvariable\u001b[0m \u001b[35mq\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpg24d7v3r.scala:51:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mr\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mr is already defined as \u001b[33mvariable\u001b[0m \u001b[35mr\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpg24d7v3r.scala:52:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36ms\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var i = 1\n        while (i < lst.size) {\n            if (s.charAt(0) == '(') {\n                if (s.charAt(s.length - 1) == ')') {\n                    s = s.substring(1, s.length - 1)\n                } else {\n                    s = s.substring(1)\n                }\n            } else {\n                if (s.charAt(s.length - 1) == '(') {\n                    s = s.substring(0, s.length - 1)\n                } else {\n                    s = s.substring(0)\n                }\n            }\n            i = i + 1\n        }\n        if (s.charAt(0) == '(') {\n            return \"No\"\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293008,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpkbvmgbex.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) return \"No\"\n        var left = lst.head\n        var right = lst.tail.head\n        var left_count = 0\n        var right_count = 0\n        for (i <- lst.tail.tail.iterator()) {\n            if (i.head == \"(\") left_count += 1\n            if (i.head == \")\") right_count += 1\n        }\n        if (left_count != right_count) return \"No\"\n        if (left_count == 0) return \"Yes\"\n        if (left_count == 1) {\n            if (left == \")\") return \"Yes\"\n            else return \"No\"\n        }\n        if (left_count == 2) {\n            if (left == \")\") {\n                if (right == \")\") return \"Yes\"\n                else return \"No\"\n            }\n            else return \"No\"\n        }\n        if (left_count == 3) {\n            if (left == \")\") {\n                if (right == \")\") return \"Yes\"\n                else return \"No\"\n            }\n            else return \"No\"\n        }\n        if (left_count == 4) {\n            if (left == \")\") {\n                if (right == \")\") return \"Yes\"\n                else return \"No\"\n            }\n            else return \"No\"\n        }\n        if (left_count == 5) {\n            if (left == \")\") {\n                if (right == \")\") return \"Yes\"\n                else return \"No\"\n            }\n            else return \"No\"\n        }\n        if (left_count == 6) {\n            if (left == \")\") {\n                if (right == \")\") return \"Yes\"\n                else return \"No\"\n            }\n            else return \"No\"\n        }\n        if (left_count == 7) {\n            if (left == \")\") {\n                if (right == \")\") return \"Yes\"\n                else return \"No\"\n            }\n            else return \"No\"\n        }\n        if (left_count == 8) {\n            if (left == \")\") {\n                if\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293009,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp452skvux.scala:77:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m77 |\u001b[0m                \u001b[33mif\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp452skvux.scala:95:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m95 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp452skvux.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) \u001b[33mreturn\u001b[0m \u001b[31m\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp452skvux.scala:23:32 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- lst.tail.tail.iterator()) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m\u001b[33mmethod\u001b[0m \u001b[35miterator\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mStrictOptimizedLinearSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmp452skvux.scala:79:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m79 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"No\"\n        }\n        if (lst.length == 1) {\n            return \"Yes\"\n        }\n        if (lst.length == 2) {\n            if (lst[0] == \")\") {\n                return \"No\"\n            }\n            if (lst[1] == \")\") {\n                return \"Yes\"\n            }\n        }\n        if (lst.length == 3) {\n            if (lst[0] == \")\") {\n                if (lst[1] == \")\") {\n                    return \"No\"\n                }\n            }\n            if (lst[1] == \")\") {\n                if (lst[2] == \")\") {\n                    return \"Yes\"\n                }\n            }\n        }\n        if (lst.length == 4) {\n            if (lst[0] == \")\") {\n                if (lst[1] == \")\") {\n                    if (lst[2] == \")\") {\n                        return \"No\"\n                    }\n                }\n            }\n            if (lst[1] == \")\") {\n                if (lst[2] == \")\") {\n                    if (lst[3] == \")\") {\n                        return \"Yes\"\n                    }\n                }\n            }\n        }\n        if (lst.length == 5) {\n            if (lst[0] == \")\") {\n                if (lst[1] == \")\") {\n                    if (lst[2] == \")\") {\n                        if (lst[3] == \")\") {\n                            return \"No\"\n                        }\n                    }\n                }\n            }\n            if (lst[1] == \")\") {\n                if (lst[2] == \")\") {\n                    if (lst[3] == \")\") {\n                        if (lst[4] == \")\") {\n                            return \"Yes\"\n                        }\n                    }\n                }\n            }\n        }\n        if (lst.length == 6) {\n            if (lst[0] == \"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293017,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmprhwggb28.scala:81:26 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m            \u001b[33mif\u001b[0m (lst[\u001b[31m0\u001b[0m] == \"\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          unclosed string literal\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmprhwggb28.scala:99:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m99 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- Error: /tmp/tmprhwggb28.scala:25:19 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (lst[\u001b[31m0\u001b[0m] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m does not take type parameters\n\u001b[31m\u001b[31m-- Error: /tmp/tmprhwggb28.scala:28:19 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mif\u001b[0m (lst[\u001b[31m1\u001b[0m] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m does not take type parameters\n\u001b[31m\u001b[31m-- Error: /tmp/tmprhwggb28.scala:33:19 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            \u001b[33mif\u001b[0m (lst[\u001b[31m0\u001b[0m] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m does not take type parameters\n\u001b[31m\u001b[31m-- Error: /tmp/tmprhwggb28.scala:34:23 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                \u001b[33mif\u001b[0m (lst[\u001b[31m1\u001b[0m] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m does not take type parameters\n\u001b[31m\u001b[31m-- Error: /tmp/tmprhwggb28.scala:38:19 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            \u001b[33mif\u001b[0m (lst[\u001b[31m1\u001b[0m] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m     ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        var leftParensStack = List[String]()\n        var rightParensStack = List[String]()\n        var leftParensStackSize = 0\n        var rightParensStackSize = 0\n        var leftParensStackSizeStack = List[Int]()\n        var rightParensStackSizeStack = List[Int]()\n        var leftParensStackSizeStackSize = 0\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParen\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293014,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpdb1oc4pk.scala:56:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdb1oc4pk.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParensStackSizeStackSize\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParensStackSizeStackSize is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParensStackSizeStackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdb1oc4pk.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParensStackSizeStackSizeStack\u001b[0m = List[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParensStackSizeStackSizeStack is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftParensStackSizeStackSizeStack\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdb1oc4pk.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParensStackSizeStackSize\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParensStackSizeStackSize is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParensStackSizeStackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdb1oc4pk.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParensStackSizeStackSizeStack\u001b[0m = List[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParensStackSizeStackSizeStack is already def",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"Yes\"\n        } else {\n            var left = lst.head\n            var right = lst.tail.head\n            var leftParens = 0\n            var rightParens = 0\n            for (i <- 0 until left.length) {\n                if (left[i] == '(') {\n                    leftParens += 1\n                } else {\n                    leftParens -= 1\n                }\n            }\n            for (i <- 0 until right.length) {\n                if (right[i] == '(') {\n                    rightParens += 1\n                } else {\n                    rightParens -= 1\n                }\n            }\n            if (leftParens == rightParens) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293008,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3xb0gzfw.scala:26:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mif\u001b[0m (left[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3xb0gzfw.scala:33:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                \u001b[33mif\u001b[0m (right[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var parens = 0\n        var result = \"\"\n        for (i <- 0 until lst.size) {\n            if (lst[i] == \"(\") {\n                parens += 1\n            } else if (lst[i] == \")\") {\n                parens -= 1\n            }\n            if (parens == 0) {\n                result += lst[i]\n            }\n        }\n        if (parens == 0) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293014,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxyb0co6h.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mif\u001b[0m (lst[\u001b[35mi\u001b[0m] == \u001b[31m\"(\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxyb0co6h.scala:23:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (lst[i] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxyb0co6h.scala:27:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result += lst[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxyb0co6h.scala:27:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result += lst[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        if (lst.size() == 1) {\n            return \"No\"\n        }\n        var s = lst.head\n        var s2 = lst.tail.head\n        var s3 = lst.tail.tail.head\n        var s4 = lst.tail.tail.tail.head\n        var s5 = lst.tail.tail.tail.tail.head\n        var s6 = lst.tail.tail.tail.tail.tail.head\n        var s7 = lst.tail.tail.tail.tail.tail.tail.head\n        var s8 = lst.tail.tail.tail.tail.tail.tail.tail.head\n        var s9 = lst.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s10 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s11 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s12 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s13 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s14 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s15 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s16 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s17 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s18 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293014,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpulpmm8ol.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpulpmm8ol.scala:21:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpulpmm8ol.scala:42:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"No\"\n        }\n        if (lst.size() == 1) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var s2 = lst.tail.head\n        var s3 = lst.tail.tail.head\n        var s4 = lst.tail.tail.tail.head\n        var s5 = lst.tail.tail.tail.tail.head\n        var s6 = lst.tail.tail.tail.tail.tail.head\n        var s7 = lst.tail.tail.tail.tail.tail.tail.head\n        var s8 = lst.tail.tail.tail.tail.tail.tail.tail.head\n        var s9 = lst.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s10 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s11 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s12 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s13 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s14 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s15 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s16 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s17 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s18 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293014,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpt8uw0ylb.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpt8uw0ylb.scala:21:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt8uw0ylb.scala:42:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var result = \"No\"\n        var stack = List.empty[String]\n        for (s in lst) {\n            if (s == \"(\") stack = stack.append(s)\n            else if (s == \")\") {\n                if (stack.isEmpty()) {\n                    result = \"No\"\n                    break\n                } else {\n                    stack = stack.tail\n                }\n            }\n        }\n        if (stack.isEmpty()) result = \"Yes\"\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293017,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpds8sp1tm.scala:20:23 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mfor\u001b[0m (s in lst) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       '<-' expected, but '{' found\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpds8sp1tm.scala:31:36 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mif\u001b[0m (stack.isEmpty()) result = \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    expression expected but \u001b[31m=\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpds8sp1tm.scala:30:9 -------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m         ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator asScala\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.set asScala\n\u001b[31m   |\u001b[0m\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        if (left.isEmpty() || right.isEmpty()) {\n            return \"No\"\n        }\n        if (left.head == \"(\" && right.head == \")\") {\n            return matchParens(lst.tail.tail).equals(\"Yes\")\n        }\n        if (left.head == \")\" && right.head == \")\") {\n            return matchParens(lst.tail.tail).equals(\"No\")\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpof6f86iv.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpof6f86iv.scala:26:12 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mif\u001b[0m (left.head == \u001b[31m\"(\"\u001b[0m && right.head == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpof6f86iv.scala:26:32 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mif\u001b[0m (left.head == \u001b[31m\"(\"\u001b[0m && right.head == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpof6f86iv.scala:27:52 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mreturn\u001b[0m matchParens(lst.tail.tail).equals(\u001b[31m\"Yes\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    Boolean\n\u001b[31m   |\u001b[0m                   Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpof6f86iv.scala:29:12 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mif\u001b[0m (left.head == \u001b[31m\")\"\u001b[0m && right.head == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpof6f86iv.scala:29:32 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mif\u001b[0m (left.head == \u001b[31m\")\"\u001b[0m && right.head == \u001b[31m\"",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var parens = 0\n        var openParens = 0\n        var closeParens = 0\n        var last = lst.head\n        var result = \"No\"\n        for (var i = 1; i < lst.size(); i++) {\n            var cur = lst.get(i)\n            if (cur == \"(\") {\n                openParens += 1\n                if (openParens > closeParens) {\n                    result = \"No\"\n                    break\n                }\n            } else if (cur == \")\") {\n                closeParens += 1\n                if (openParens > closeParens) {\n                    result = \"No\"\n                    break\n                }\n            }\n            if (openParens > closeParens) {\n                result = \"No\"\n                break\n            }\n            if (openParens == closeParens) {\n                if (openParens == 0) {\n                    result = \"Yes\"\n                    break\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293017,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpcrzvbpak.scala:26:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m1\u001b[0m; i < lst.size(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpcrzvbpak.scala:26:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m1\u001b[0m; i < lst.size(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpcrzvbpak.scala:26:43 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m1\u001b[0m; i < lst.size(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpcrzvbpak.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcrzvbpak.scala:26:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m1\u001b[0m; i < lst.size(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"No\"\n        }\n        if (lst.length == 1) {\n            return \"Yes\"\n        }\n        var left = lst[0]\n        var right = lst[1]\n        var leftParens = 0\n        var rightParens = 0\n        var leftParensStack = List[String]()\n        var rightParensStack = List[String]()\n        for (i <- 0 until left.length) {\n            if (left[i] == '(') {\n                leftParens += 1\n                leftParensStack = leftParensStack.append(left[i])\n            } else {\n                leftParens -= 1\n                leftParensStack = leftParensStack.append(left[i])\n            }\n        }\n        for (i <- 0 until right.length) {\n            if (right[i] == '(') {\n                rightParens += 1\n                rightParensStack = rightParensStack.append(right[i])\n            } else {\n                rightParens -= 1\n                rightParensStack = rightParensStack.append(right[i])\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        for (i <- 0 until leftParensStack.length) {\n            if (leftParensStack[i] != '(') {\n                return \"No\"\n            }\n        }\n        for (i <- 0 until rightParensStack.length) {\n            if (rightParensStack[i] != ')') {\n                return \"No\"\n            }\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293017,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpfpbpmfyu.scala:24:22 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleft\u001b[0m = lst[\u001b[31m0\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m does not take type parameters\n\u001b[31m\u001b[31m-- Error: /tmp/tmpfpbpmfyu.scala:25:23 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mright\u001b[0m = lst[\u001b[31m1\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m does not take type parameters\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfpbpmfyu.scala:31:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mif\u001b[0m (left[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfpbpmfyu.scala:33:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                leftParensStack = leftParensStack.append(left[\u001b[35mi\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[String] - did you mean List[String].appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfpbpmfyu.scala:33:62 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                leftParensStack = leftParensStack.append(left[\u001b[35mi\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfpbpmfyu.scala:36:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                leftParensStack = leftParensStack.append(left[\u001b[35mi\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"No\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        var leftParensStack = List.empty()\n        var rightParensStack = List.empty()\n        for (i <- 0 until left.length) {\n            if (left[i] == '(') {\n                leftParens += 1\n                leftParensStack = leftParensStack.append(i)\n            } else if (left[i] == ')') {\n                leftParens -= 1\n                leftParensStack = leftParensStack.remove(leftParensStack.last)\n            }\n        }\n        for (i <- 0 until right.length) {\n            if (right[i] == '(') {\n                rightParens += 1\n                rightParensStack = rightParensStack.append(i)\n            } else if (right[i] == ')') {\n                rightParens -= 1\n                rightParensStack = rightParensStack.remove(rightParensStack.last)\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        var leftParensStackCopy = leftParensStack.copy\n        var rightParensStackCopy = rightParensStack.copy\n        var leftParensStackCopyStack = List.empty()\n        var rightParensStackCopyStack = List.empty()\n        for (i <- 0 until leftParensStack.length) {\n            leftParensStackCopyStack = leftParensStackCopyStack.append(leftParensStack[i])\n        }\n        for (i <- 0 until rightParensStack.length) {\n            rightParensStackCopyStack = rightParensStackCopyStack.append(rightParensStack[i])\n        }\n        if (leftParensStackCopyStack.length != rightParensStackCopyStack.length) {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpucvfp87b.scala:25:40 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParensStack\u001b[0m = List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): A\n\u001b[31m\u001b[31m-- Error: /tmp/tmpucvfp87b.scala:26:41 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParensStack\u001b[0m = List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): A\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpucvfp87b.scala:28:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mif\u001b[0m (left[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpucvfp87b.scala:31:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (left[i] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpucvfp87b.scala:37:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mif\u001b[0m (right[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpucvfp87b.scala:40:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (right[i] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"Yes\"\n        }\n        if (lst.length == 1) {\n            return \"No\"\n        }\n        var parens = 0\n        var left = lst[0]\n        var right = lst[1]\n        var leftParens = 0\n        var rightParens = 0\n        for (i <- 0 until left.length) {\n            if (left[i] == '(') {\n                leftParens += 1\n            } else {\n                leftParens -= 1\n            }\n        }\n        for (i <- 0 until right.length) {\n            if (right[i] == '(') {\n                rightParens += 1\n            } else {\n                rightParens -= 1\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        if (leftParens == 0) {\n            return \"Yes\"\n        }\n        var leftParens = 0\n        var rightParens = 0\n        for (i <- 0 until left.length) {\n            if (left[i] == '(') {\n                leftParens += 1\n            } else {\n                leftParens -= 1\n            }\n        }\n        for (i <- 0 until right.length) {\n            if (right[i] == '(') {\n                rightParens += 1\n            } else {\n                rightParens -= 1\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        if (leftParens == 0) {\n            return \"Yes\"\n        }\n        var leftParens = 0\n        var rightParens = 0\n        for (i <- 0 until left.length) {\n            if (left[i] == '(') {\n                leftParens += 1\n            } else {\n                leftParens -= 1\n            }\n        }\n        for (i <- 0 until right.length) {\n            if (right[i] == '(') {\n                rightParens += 1\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293011,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvedv_4hh.scala:100:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m100 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvedv_4hh.scala:49:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftParens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvedv_4hh.scala:50:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvedv_4hh.scala:71:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftParens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvedv_4hh.scala:72:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- Error: /tmp/tmpvedv_4hh.scala:25:22 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleft\u001b[0m = lst[\u001b[31m0\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m        ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        }\n        var s = lst.head\n        var r = lst.tail\n        var p = 0\n        var b = 0\n        var i = 0\n        while (i < s.length) {\n            if (s[i] == '(') {\n                p += 1\n            } else {\n                if (s[i] == ')') {\n                    b += 1\n                }\n            }\n            i += 1\n        }\n        if (p == b) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293010,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpefoqzao_.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpefoqzao_.scala:27:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpefoqzao_.scala:30:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var s = \"\"\n        for (i <- 0 until lst.length) {\n            if (lst[i] == \"(\" || lst[i] == \")\") {\n                s += lst[i]\n            } else {\n                if (s.length > 0) {\n                    s += lst[i]\n                } else {\n                    return \"No\"\n                }\n            }\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293016,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt5362lpt.scala:20:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mif\u001b[0m (lst[\u001b[35mi\u001b[0m] == \u001b[31m\"(\"\u001b[0m || lst[\u001b[35mi\u001b[0m] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt5362lpt.scala:21:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                s += lst[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt5362lpt.scala:21:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                s += lst[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt5362lpt.scala:24:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                    s += lst[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt5362lpt.scala:24:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                    s += lst[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) return \"No\"\n        var s = lst.head\n        var p = lst.tail\n        var i = 0\n        var j = 0\n        var c = 0\n        var parens = 0\n        while (i < s.length) {\n            if (s[i] == '(') {\n                parens += 1\n            } else if (s[i] == ')') {\n                parens -= 1\n            }\n            i += 1\n        }\n        if (parens == 0) return \"Yes\"\n        while (j < p.length) {\n            if (p[j] == '(') {\n                parens += 1\n            } else if (p[j] == ')') {\n                parens -= 1\n            }\n            j += 1\n        }\n        if (parens == 0) return \"Yes\"\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293010,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpd298rvaw.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) \u001b[33mreturn\u001b[0m \u001b[31m\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd298rvaw.scala:26:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd298rvaw.scala:28:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (s[i] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd298rvaw.scala:35:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            \u001b[33mif\u001b[0m (p[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd298rvaw.scala:37:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (p[j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"No\"\n        }\n        if (lst.size() == 1) {\n            return \"Yes\"\n        }\n        if (lst.size() == 2) {\n            if (lst.get(0).equals(\"()\") && lst.get(1).equals(\"()\")) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.size() == 3) {\n            if (lst.get(0).equals(\"()\") && lst.get(1).equals(\"()\") && lst.get(2).equals(\"()\")) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.size() == 4) {\n            if (lst.get(0).equals(\"()\") && lst.get(1).equals(\"()\") && lst.get(2).equals(\"()\") && lst.get(3).equals(\"()\")) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.size() == 5) {\n            if (lst.get(0).equals(\"()\") && lst.get(1).equals(\"()\") && lst.get(2).equals(\"()\") && lst.get(3).equals(\"()\") && lst.get(4).equals(\"()\")) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.size() == 6) {\n            if (lst.get(0).equals(\"()\") && lst.get(1).equals(\"()\") && lst.get(2).equals(\"()\") && lst.get(3).equals(\"()\") && lst.get(4).equals(\"()\") && lst.get(5).equals(\"()\")) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.size()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293018,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpq3n_2ur2.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpq3n_2ur2.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpq3n_2ur2.scala:21:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpq3n_2ur2.scala:24:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m2\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpq3n_2ur2.scala:25:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (lst.get(\u001b[31m0\u001b[0m).equals(\u001b[31m\"()\"\u001b[0m) && lst.get(\u001b[31m1\u001b[0m).equals(\u001b[31m\"()\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of List[String] - did you mean lst.seq?\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpq3n_2ur2.scala:31:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m3\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        } else {\n            var s = lst.head\n            var result = \"Yes\"\n            var stack = List.empty()\n            for (i <- lst.tail) {\n                if (i.equals(\"(\")) {\n                    stack = stack.prepend(i)\n                } else if (i.equals(\")\")) {\n                    if (stack.isEmpty()) {\n                        result = \"No\"\n                        break\n                    } else {\n                        stack = stack.tail\n                    }\n                }\n            }\n            return result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293010,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjomjedhv.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpjomjedhv.scala:23:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mstack\u001b[0m = List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): A\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjomjedhv.scala:30:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                        break\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        } else {\n            var s = lst.head\n            var l = lst.tail\n            var b = s.count(\"(\")\n            var e = s.count(\")\")\n            if (b == e) {\n                return \"Yes\"\n            } else {\n                if (b > e) {\n                    return \"No\"\n                } else {\n                    return matchParens(l)\n                }\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293016,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmppp7uzild.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppp7uzild.scala:23:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mb\u001b[0m = s.count(\u001b[31m\"(\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (\u001b[32m\"(\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                            Required: Char => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppp7uzild.scala:24:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36me\u001b[0m = s.count(\u001b[31m\")\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (\u001b[32m\")\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                            Required: Char => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        } else {\n            var left = lst.head\n            var right = lst.tail.head\n            if (left.isEmpty() || right.isEmpty()) {\n                return \"No\"\n            } else {\n                return matchParens(lst.tail.tail).equals(\"Yes\") && matchParens(lst.tail).equals(\"Yes\") ? \"Yes\" : \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293029,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp_89dhtd6.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_89dhtd6.scala:26:103 -----------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mreturn\u001b[0m matchParens(lst.tail.tail).equals(\u001b[31m\"Yes\"\u001b[0m) && matchParens(lst.tail).equals(\u001b[31m\"Yes\"\u001b[0m) ? \u001b[31m\"Yes\"\u001b[0m : \u001b[31m\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      value ? is not a member of Boolean\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"No\"\n        }\n        if (lst.length == 1) {\n            return \"Yes\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        var leftOpen = 0\n        var rightOpen = 0\n        var leftOpenStack = List[String]()\n        var rightOpenStack = List[String]()\n        var leftOpenStackIndex = 0\n        var rightOpenStackIndex = 0\n        var leftOpenStackSize = 0\n        var rightOpenStackSize = 0\n        var leftOpenStackSizeStack = List[Integer]()\n        var rightOpenStackSizeStack = List[Integer]()\n        var leftOpenStackSizeStackIndex = 0\n        var rightOpenStackSizeStackIndex = 0\n        var leftOpenStackSizeStackSize = 0\n        var rightOpenStackSizeStackSize = 0\n        var leftOpenStackSizeStackSizeStack = List[Integer]()\n        var rightOpenStackSizeStackSizeStack = List[Integer]()\n        var leftOpenStackSizeStackSizeStackIndex = 0\n        var rightOpenStackSizeStackSizeStackIndex = 0\n        var leftOpenStackSizeStackSizeStackSize = 0\n        var rightOpenStackSizeStackSizeStackSize = 0\n        var leftOpenStackSizeStackSizeStackSizeStack = List[Integer]()\n        var rightOpenStackSizeStackSizeStackSizeStack = List[Integer]()\n        var leftOpenStackSizeStackSizeStackSizeStackIndex = 0\n        var rightOpenStackSizeStackSizeStackSizeStackIndex = 0\n        var leftOpenStackSizeStackSizeStackSizeStackSize = 0\n        var rightOpenStackSizeStackSizeStackSizeStackSize = 0\n        var leftOpenStackSizeStackSizeStackSizeStackSizeStack = List[Integer]()\n        var rightOpenStackSizeStackSizeStackSizeStackSizeStack = List[Integer]()\n        var leftOpenStackSizeStackSizeStackSizeStackSizeStackIndex = 0\n        var rightOpenStackSizeStackSizeStackSizeStackSizeStackIndex = 0\n        var leftOpenStackSizeStackSizeStackSizeStackSizeStackSize = 0\n        var rightOpenStackSizeStackSizeStackSizeStackSizeStackSize =\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293030,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpel_kyf2h.scala:59:68 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightOpenStackSizeStackSizeStackSizeStackSizeStackSize\u001b[0m =\n\u001b[31m\u001b[31m   |\u001b[0m                                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpel_kyf2h.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        if (lst.size() == 1) {\n            return \"No\"\n        }\n        var s = lst.head\n        var t = lst.tail\n        var p = s.indexOf('(')\n        var c = s.indexOf(')')\n        if (p == -1 || c == -1) {\n            return \"No\"\n        }\n        var left = p\n        var right = c\n        var count = 0\n        for (var i = 0; i < lst.size(); i++) {\n            if (lst.get(i).equals(\"(\")) {\n                count += 1\n            } else if (lst.get(i).equals(\")\")) {\n                count -= 1\n            }\n            if (count < 0) {\n                return \"No\"\n            }\n        }\n        if (count != 0) {\n            return \"No\"\n        }\n        if (left > right) {\n            return \"No\"\n        }\n        if (left == right) {\n            return \"Yes\"\n        }\n        var s1 = s.substring(0, left)\n        var s2 = s.substring(left + 1, right)\n        var s3 = s.substring(right + 1, lst.size())\n        var s4 = t.head\n        var t1 = t.tail\n        var t2 = t.tail.tail\n        var t3 = t.tail.tail.tail\n        var t4 = t.tail.tail.tail.tail\n        if (s1.equals(s2) && s3.equals(t1) && s4.equals(t2) && t3.equals(t4)) {\n            return \"Yes\"\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293035,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpith2tbcx.scala:34:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.size(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpith2tbcx.scala:34:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.size(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpith2tbcx.scala:34:43 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.size(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpith2tbcx.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpith2tbcx.scala:21:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpith2tbcx.scala:34:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        } else {\n            var left = lst.head\n            var right = lst.tail.head\n            var leftParens = 0\n            var rightParens = 0\n            var leftParensStack = List[String]()\n            var rightParensStack = List[String]()\n            var leftParensStackSize = 0\n            var rightParensStackSize = 0\n            var leftParensStackSizeStack = List[Int]()\n            var rightParensStackSizeStack = List[Int]()\n            var leftParensStackSizeStackSize = 0\n            var rightParensStackSizeStackSize = 0\n            var leftParensStackSizeStackSizeStack = List[Int]()\n            var rightParensStackSizeStackSize = 0\n            var leftParensStackSizeStackSizeStack = List[Int]()\n            var rightParensStackSizeStackSize = 0\n            var leftParensStackSizeStackSizeStack = List[Int]()\n            var rightParensStackSizeStackSize = 0\n            var leftParensStackSizeStackSizeStack = List[Int]()\n            var rightParensStackSizeStackSize = 0\n            var leftParensStackSizeStackSizeStack = List[Int]()\n            var rightParensStackSizeStackSize = 0\n            var leftParensStackSizeStackSizeStack = List[Int]()\n            var rightParensStackSizeStackSize = 0\n            var leftParensStackSizeStackSizeStack = List[Int]()\n            var rightParensStackSizeStackSize = 0\n            var leftParensStackSizeStackSizeStack = List[Int]()\n            var rightParensStackSizeStackSize = 0\n            var leftParensStackSizeStackSizeStack = List[Int]()\n            var rightParensStackSizeStackSize = 0\n            var leftParensStackSizeStackSizeStack = List[Int]()\n            var rightParensStackSizeStackSize = 0\n            var leftParensStackSizeStackSizeStack = List[Int]()\n            var rightParensStackSizeStackSize = 0\n            var left\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293032,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4gxd43og.scala:56:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4gxd43og.scala:73:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp4gxd43og.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4gxd43og.scala:34:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mrightParensStackSizeStackSize\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParensStackSizeStackSize is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParensStackSizeStackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4gxd43og.scala:35:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mleftParensStackSizeStackSizeStack\u001b[0m = List[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParensStackSizeStackSizeStack is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftParensStackSizeStackSizeStack\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4gxd43og.scala:36:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mrightParensStackSizeStackSize\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        var leftParensStack = List.empty()\n        var rightParensStack = List.empty()\n        var leftParensStackSize = 0\n        var rightParensStackSize = 0\n        var leftParensStackSizeStack = List.empty()\n        var rightParensStackSizeStack = List.empty()\n        var leftParensStackSizeStackSize = 0\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List.empty()\n        var right\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293035,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpscflm2ge.scala:57:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpscflm2ge.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParensStackSizeStackSize\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParensStackSizeStackSize is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParensStackSizeStackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpscflm2ge.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParensStackSizeStackSizeStack\u001b[0m = List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParensStackSizeStackSizeStack is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftParensStackSizeStackSizeStack\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpscflm2ge.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParensStackSizeStackSize\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParensStackSizeStackSize is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParensStackSizeStackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpscflm2ge.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParensStackSizeStackSizeStack\u001b[0m = List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParensStackSizeStackSizeStack is already defined as \u001b[33mv",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        } else {\n            var left = lst.head\n            var right = lst.tail.head\n            var leftParens = 0\n            var rightParens = 0\n            for (i <- 0 until left.length) {\n                if (left[i] == \"(\") {\n                    leftParens += 1\n                } else {\n                    leftParens -= 1\n                }\n            }\n            for (i <- 0 until right.length) {\n                if (right[i] == \")\") {\n                    rightParens += 1\n                } else {\n                    rightParens -= 1\n                }\n            }\n            if (leftParens == rightParens) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293026,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpxvsgdti3.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxvsgdti3.scala:26:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mif\u001b[0m (left[\u001b[35mi\u001b[0m] == \u001b[31m\"(\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxvsgdti3.scala:33:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                \u001b[33mif\u001b[0m (right[\u001b[35mi\u001b[0m] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var res = \"No\"\n        var count = 0\n        for (var i = 1; i < lst.length; i++) {\n            if (s.charAt(0) == '(' && lst.get(i).charAt(0) == ')') {\n                count += 1\n                s = lst.get(i)\n            } else if (s.charAt(0) == '(' && lst.get(i).charAt(0) == '(') {\n                count += 1\n                s = lst.get(i)\n            } else if (s.charAt(0) == ')' && lst.get(i).charAt(0) == ')') {\n                count -= 1\n                s = lst.get(i)\n            } else if (s.charAt(0) == ')' && lst.get(i).charAt(0) == '(') {\n                count -= 1\n                s = lst.get(i)\n            } else {\n                s = lst.get(i)\n            }\n            if (count == 0) {\n                res = \"Yes\"\n                break\n            }\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293035,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpvb5c6fd8.scala:24:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m1\u001b[0m; i < lst.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvb5c6fd8.scala:24:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m1\u001b[0m; i < lst.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpvb5c6fd8.scala:24:43 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m1\u001b[0m; i < lst.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvb5c6fd8.scala:24:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m1\u001b[0m; i < lst.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.conve",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"No\"\n        }\n        var s = lst.head\n        var res = \"Yes\"\n        for (i <- lst.tail.size - 1) {\n            if (s.charAt(0) == '(') {\n                if (s.charAt(s.length - 1) == ')') {\n                    s = s.substring(1, s.length - 1)\n                } else {\n                    res = \"No\"\n                    break\n                }\n            } else {\n                if (s.charAt(s.length - 1) == ')') {\n                    s = s.substring(0, s.length - 1)\n                } else {\n                    res = \"No\"\n                    break\n                }\n            }\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293033,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjt2qmamg.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjt2qmamg.scala:23:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- lst.tail.size - \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        } else {\n            var left = lst.head\n            var right = lst.tail.head\n            var leftParens = 0\n            var rightParens = 0\n            for (i <- 0 until left.length) {\n                if (left[i] == '(') {\n                    leftParens += 1\n                } else {\n                    leftParens -= 1\n                }\n            }\n            for (i <- 0 until right.length) {\n                if (right[i] == '(') {\n                    rightParens += 1\n                } else {\n                    rightParens -= 1\n                }\n            }\n            if (leftParens == rightParens) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293028,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpf_cj_pnx.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf_cj_pnx.scala:26:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mif\u001b[0m (left[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf_cj_pnx.scala:33:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                \u001b[33mif\u001b[0m (right[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var p = lst.tail\n        var i = 0\n        var j = 0\n        var res = \"\"\n        while (i < s.length) {\n            if (s[i] == '(') {\n                j = 0\n                while (j < p.length) {\n                    if (p[j] == '(') {\n                        j += 1\n                    } else if (p[j] == ')') {\n                        j += 1\n                    } else {\n                        break\n                    }\n                }\n                if (j == p.length) {\n                    res += \"Yes\"\n                    i += 1\n                } else {\n                    res += \"No\"\n                    break\n                }\n            } else {\n                i += 1\n            }\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293031,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpy5kf4rem.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy5kf4rem.scala:27:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy5kf4rem.scala:30:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                    \u001b[33mif\u001b[0m (p[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy5kf4rem.scala:32:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (p[j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy5kf4rem.scala:35:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                        break\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy5kf4rem.scala:43:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        for (i <- lst.tail.tail.size) {\n            if (left == \"(\" && right == \")\") {\n                leftParens += 1\n            } else if (left == \")\" && right == \"(\" && leftParens > 0) {\n                leftParens -= 1\n            } else if (left == \"(\" && right == \")\") {\n                rightParens += 1\n            } else if (left == \")\" && right == \"(\" && rightParens > 0) {\n                rightParens -= 1\n            } else {\n                return \"No\"\n            }\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293034,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp_b4ce12t.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_b4ce12t.scala:25:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- lst.tail.tail.size) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        var leftParensStack = List.empty()\n        var rightParensStack = List.empty()\n        for (var i = 0; i < left.length(); i++) {\n            if (left[i] == '(') {\n                leftParens += 1\n                leftParensStack = leftParensStack.append(left[i])\n            } else if (left[i] == ')') {\n                leftParens -= 1\n                leftParensStack = leftParensStack.prepend(left[i])\n            }\n        }\n        for (var i = 0; i < right.length(); i++) {\n            if (right[i] == '(') {\n                rightParens += 1\n                rightParensStack = rightParensStack.append(right[i])\n            } else if (right[i] == ')') {\n                rightParens -= 1\n                rightParensStack = rightParensStack.prepend(right[i])\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        var leftStack = List.empty()\n        var rightStack = List.empty()\n        for (var i = 0; i < left.length(); i++) {\n            if (left[i] == '(') {\n                leftStack = leftStack.append(left[i])\n            } else if (left[i] == ')') {\n                leftStack = leftStack.prepend(left[i])\n            }\n        }\n        for (var i = 0; i < right.length(); i++) {\n            if (right[i] == '(') {\n                rightStack = rightStack.append(right[i])\n            } else if (right[i] == ')') {\n                rightStack = rightStack.prepend(right[i])\n            }\n        }\n        if (left\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293043,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp2_1m8ver.scala:27:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < left.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp2_1m8ver.scala:27:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < left.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp2_1m8ver.scala:27:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < left.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp2_1m8ver.scala:36:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < right.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp2_1m8ver.scala:36:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < right.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp2_1m8ver.scala:36:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < right.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                     ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"No\"\n        }\n        if (lst.length == 1) {\n            return \"Yes\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        for (i <- lst.tail.tail.length) {\n            if (lst.tail.tail[i] == \"(\" && leftParens == 0) {\n                leftParens = 1\n            }\n            if (lst.tail.tail[i] == \")\" && leftParens == 1) {\n                leftParens = 0\n            }\n            if (lst.tail.tail[i] == \"(\" && rightParens == 0) {\n                rightParens = 1\n            }\n            if (lst.tail.tail[i] == \")\" && rightParens == 1) {\n                rightParens = 0\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        if (leftParens == 0) {\n            return \"Yes\"\n        }\n        var leftParens = 0\n        var rightParens = 0\n        for (i <- lst.length) {\n            if (lst[i] == \"(\" && leftParens == 0) {\n                leftParens = 1\n            }\n            if (lst[i] == \")\" && leftParens == 1) {\n                leftParens = 0\n            }\n            if (lst[i] == \"(\" && rightParens == 0) {\n                rightParens = 1\n            }\n            if (lst[i] == \")\" && rightParens == 1) {\n                rightParens = 0\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        if (leftParens == 0) {\n            return \"Yes\"\n        }\n        var leftParens = 0\n        var rightParens = 0\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293036,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwq8gifw_.scala:48:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftParens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwq8gifw_.scala:49:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwq8gifw_.scala:70:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m70 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftParens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwq8gifw_.scala:71:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwq8gifw_.scala:28:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- lst.tail.tail.length) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwq8gifw_.scala:50:18 --------------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        }\n        var s = lst.head\n        var i = 0\n        var j = 0\n        var res = \"\"\n        while (i < s.length) {\n            if (s[i] == '(') {\n                i = i + 1\n            } else {\n                i = i + 1\n                if (s[i] == '(') {\n                    res = res + \"No\"\n                    return res\n                }\n                if (s[i] == ')') {\n                    j = j + 1\n                } else {\n                    j = j + 1\n                    res = res + \"No\"\n                    return res\n                }\n            }\n        }\n        if (j == 0) {\n            res = res + \"Yes\"\n            return res\n        }\n        res = res + \"No\"\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293030,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpofs3kx_x.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpofs3kx_x.scala:26:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpofs3kx_x.scala:30:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpofs3kx_x.scala:34:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var s = \"\"\n        for(var i = 0; i < lst.size(); i++) {\n            if(lst.get(i).equals(\"(\")) {\n                s += \"(\"\n            } else if(lst.get(i).equals(\")\")) {\n                s += \")\"\n            } else {\n                s += lst.get(i)\n            }\n        }\n        if(s.equals(\"\")) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmph632yxt5.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mfor\u001b[0m(\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.size(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^\u001b[0m\n\u001b[31m   |\u001b[0m            pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmph632yxt5.scala:19:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mfor\u001b[0m(\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.size(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmph632yxt5.scala:19:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mfor\u001b[0m(\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.size(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmph632yxt5.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mfor\u001b[0m(\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.size(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.Implicit",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var result = \"No\"\n        var i = 0\n        while (i < lst.size) {\n            if (s.charAt(0) == '(') {\n                i += 1\n                s = s.substring(1)\n            } else {\n                i += 1\n                s = s.substring(1)\n                if (s.charAt(0) == '(') {\n                    result = \"No\"\n                    break\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293031,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmphqd4za_p.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphqd4za_p.scala:33:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        }\n        var s = lst.head\n        var i = 0\n        var j = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293036,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvu3phuxx.scala:103:4 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m103 |\u001b[0m    }\n\u001b[31m\u001b[31m    |\u001b[0m    ^\u001b[0m\n\u001b[31m    |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvu3phuxx.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mi\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mi is already defined as \u001b[33mvariable\u001b[0m \u001b[35mi\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvu3phuxx.scala:43:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mj\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mj is already defined as \u001b[33mvariable\u001b[0m \u001b[35mj\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvu3phuxx.scala:49:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mp\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mp is already defined as \u001b[33mvariable\u001b[0m \u001b[35mp\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvu3phuxx.scala:50:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mq\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mq is already defined as \u001b[33mvariable\u001b[0m \u001b[35mq\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvu3phuxx.scala:51:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mr\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mr is already defined as \u001b[33mvariable\u001b[0m \u001b[35mr\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var lst2 = lst.tail\n        var res = \"\"\n        var open = 0\n        var close = 0\n        var i = 0\n        while (i < s.length) {\n            if (s[i] == '(') {\n                open += 1\n            } else {\n                close += 1\n            }\n            i += 1\n        }\n        if (open == close) {\n            return \"Yes\"\n        }\n        if (open > close) {\n            return \"No\"\n        }\n        var res = \"\"\n        var i = 0\n        while (i < lst2.length) {\n            if (lst2[i] == '(') {\n                open += 1\n            } else {\n                close += 1\n            }\n            i += 1\n        }\n        if (open == close) {\n            return \"Yes\"\n        }\n        if (open > close) {\n            return \"No\"\n        }\n        var res = \"\"\n        var i = 0\n        while (i < lst2.length) {\n            if (lst2[i] == '(') {\n                open += 1\n            } else {\n                close += 1\n            }\n            i += 1\n        }\n        if (open == close) {\n            return \"Yes\"\n        }\n        if (open > close) {\n            return \"No\"\n        }\n        var res = \"\"\n        var i = 0\n        while (i < lst2.length) {\n            if (lst2[i] == '(') {\n                open += 1\n            } else {\n                close += 1\n            }\n            i += 1\n        }\n        if (open == close) {\n            return \"Yes\"\n        }\n        if (open > close) {\n            return \"No\"\n        }\n        var res = \"\"\n        var i = 0\n        while (i < lst2.length) {\n            if (lst2[i] == '(') {\n                open += 1\n            } else {\n                close += 1\n            \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293033,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpmviyhuni.scala:114:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m114 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmviyhuni.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mres\u001b[0m = \u001b[31m\"\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mres is already defined as \u001b[33mvariable\u001b[0m \u001b[35mres\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmviyhuni.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mi\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mi is already defined as \u001b[33mvariable\u001b[0m \u001b[35mi\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmviyhuni.scala:57:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mres\u001b[0m = \u001b[31m\"\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mres is already defined as \u001b[33mvariable\u001b[0m \u001b[35mres\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmviyhuni.scala:58:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mi\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mi is already defined as \u001b[33mvariable\u001b[0m \u001b[35mi\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmviyhuni.scala:73:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mres\u001b[0m = \u001b[31m\"\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mres is already defined as \u001b[33mvariable\u001b[0m \u001b[35mres\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded me",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        for (i <- lst.tail.tail.length - 1) {\n            if (lst.tail.tail[i] == \")\") {\n                rightParens += 1\n            } else {\n                leftParens += 1\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        var leftParens = 0\n        var rightParens = 0\n        for (i <- lst.length - 1) {\n            if (lst[i] == \")\") {\n                rightParens += 1\n            } else {\n                leftParens += 1\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        var leftParens = 0\n        var rightParens = 0\n        for (i <- lst.length - 1) {\n            if (lst[i] == \")\") {\n                rightParens += 1\n            } else {\n                leftParens += 1\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        var leftParens = 0\n        var rightParens = 0\n        for (i <- lst.length - 1) {\n            if (lst[i] == \")\") {\n                rightParens += 1\n            } else {\n                leftParens += 1\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293039,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5rn8puqv.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftParens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5rn8puqv.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5rn8puqv.scala:47:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftParens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5rn8puqv.scala:48:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5rn8puqv.scala:59:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftParens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defin",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        }\n        var s = \"\"\n        for (i <- 0 until lst.size()) {\n            if (lst.get(i).equals(\"(\")) {\n                s += \"(\"\n            } else {\n                s += \")\"\n            }\n        }\n        return matchParens(lst.tail())\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293039,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpud9lf5_q.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpud9lf5_q.scala:22:30 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until lst.size()) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpud9lf5_q.scala:23:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m (lst.get(i).equals(\u001b[31m\"(\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of List[String] - did you mean lst.seq?\n\u001b[31m\u001b[31m-- Error: /tmp/tmpud9lf5_q.scala:29:35 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mreturn\u001b[0m matchParens(lst.tail())\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): String @uncheckedVariance\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) return \"No\"\n        if (lst.head.equals(\"()\")) return \"Yes\"\n        if (lst.head.equals(\"()()\")) {\n            return matchParens(lst.tail.tail).equals(\"Yes\") ? \"Yes\" : \"No\"\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293038,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmplb6cu6wl.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) \u001b[33mreturn\u001b[0m \u001b[31m\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplb6cu6wl.scala:21:60 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mreturn\u001b[0m matchParens(lst.tail.tail).equals(\u001b[31m\"Yes\"\u001b[0m) ? \u001b[31m\"Yes\"\u001b[0m : \u001b[31m\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value ? is not a member of Boolean\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"No\"\n        } else {\n            var s = lst.head\n            var i = 0\n            while (i < lst.size()) {\n                if (s.charAt(0) == '(') {\n                    s = s.substring(1)\n                    i = i + 1\n                } else {\n                    s = s.substring(1)\n                    i = i + 1\n                }\n            }\n            if (s.charAt(0) == '(') {\n                return \"No\"\n            } else {\n                return \"Yes\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293034,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpi8ggrv5u.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpi8ggrv5u.scala:23:27 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mwhile\u001b[0m (i < lst.size()) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        } else {\n            var s = lst.head\n            var i = 0\n            while (i < s.length) {\n                if (s[i] == '(') {\n                    i += 1\n                } else {\n                    i += 1\n                    if (i >= s.length) {\n                        return \"No\"\n                    } else {\n                        if (s[i] == ')') {\n                            i += 1\n                        } else {\n                            return \"No\"\n                        }\n                    }\n                }\n            }\n            return \"Yes\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293035,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp8elcufjw.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8elcufjw.scala:24:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8elcufjw.scala:31:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                        \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        }\n        if (lst.size() == 1) {\n            return \"Yes\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        for (i <- 0 until left.length) {\n            if (left[i] == '(') {\n                leftParens += 1\n            } else {\n                leftParens -= 1\n            }\n        }\n        for (i <- 0 until right.length) {\n            if (right[i] == '(') {\n                rightParens += 1\n            } else {\n                rightParens -= 1\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        var leftParens = 0\n        var rightParens = 0\n        for (i <- 0 until left.length) {\n            if (left[i] == '(') {\n                leftParens += 1\n            } else {\n                leftParens -= 1\n            }\n        }\n        for (i <- 0 until right.length) {\n            if (right[i] == '(') {\n                rightParens += 1\n            } else {\n                rightParens -= 1\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        var leftParens = 0\n        var rightParens = 0\n        for (i <- 0 until left.length) {\n            if (left[i] == '(') {\n                leftParens += 1\n            } else {\n                leftParens -= 1\n            }\n        }\n        for (i <- 0 until right.length) {\n            if (right[i] == '(') {\n                rightParens += 1\n            } else {\n                rightParens -= 1\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        var leftParens\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293049,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp2t0npbuh.scala:84:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2t0npbuh.scala:45:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftParens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2t0npbuh.scala:46:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2t0npbuh.scala:64:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftParens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2t0npbuh.scala:65:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m65 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp2t0npbuh.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var i = 0\n        while (i < lst.size) {\n            if (s.charAt(0) == '(') {\n                if (s.charAt(s.length - 1) == ')') {\n                    s = s.substring(1, s.length - 1)\n                } else {\n                    i += 1\n                }\n            } else {\n                if (s.charAt(s.length - 1) == '(') {\n                    s = s.substring(0, s.length - 1)\n                } else {\n                    i += 1\n                }\n            }\n        }\n        if (s.length == 0) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293045,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmphbpvbxuf.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"No\"\n        }\n        var s = lst.head\n        var r = lst.tail\n        var c = 0\n        var p = 0\n        var i = 0\n        while (i < s.length) {\n            if (s[i] == '(') {\n                c += 1\n            } else {\n                c -= 1\n            }\n            if (c < 0) {\n                return \"No\"\n            }\n            i += 1\n        }\n        while (i < s.length) {\n            if (s[i] == '(') {\n                p += 1\n            } else {\n                p -= 1\n            }\n            if (p < 0) {\n                return \"No\"\n            }\n            i += 1\n        }\n        while (r.nonEmpty()) {\n            if (r.head[0] == '(') {\n                c += 1\n            } else {\n                c -= 1\n            }\n            if (c < 0) {\n                return \"No\"\n            }\n            r = r.tail\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293045,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3yxwlf62.scala:27:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3yxwlf62.scala:38:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp3yxwlf62.scala:48:17 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m        \u001b[33mwhile\u001b[0m (r.nonEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       \u001b[33mmethod\u001b[0m \u001b[35mnonEmpty\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOnceOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp3yxwlf62.scala:49:22 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m            \u001b[33mif\u001b[0m (r.head[\u001b[31m0\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mStringOps\u001b[0m does not take type parameters\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        } else {\n            var s = lst.head\n            var left = lst.tail\n            var right = lst.tail.tail\n            var leftParens = 0\n            var rightParens = 0\n            var leftParensStack = List.empty()\n            var rightParensStack = List.empty()\n            while (true) {\n                if (s.equals(\"(\")) {\n                    leftParensStack = leftParensStack.append(leftParens)\n                    leftParens = leftParens + 1\n                } else if (s.equals(\")\")) {\n                    rightParensStack = rightParensStack.append(rightParens)\n                    rightParens = rightParens + 1\n                } else {\n                    if (leftParens == rightParens) {\n                        leftParens = leftParensStack.head\n                        rightParens = rightParensStack.head\n                        leftParensStack = leftParensStack.tail\n                        rightParensStack = rightParensStack.tail\n                    } else {\n                        return \"No\"\n                    }\n                }\n                if (leftParens == 0 && rightParens == 0) {\n                    break\n                }\n                s = left.head\n                left = left.tail\n                right = right.tail\n            }\n            return \"Yes\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293046,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpu7pqr6mh.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpu7pqr6mh.scala:26:44 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mleftParensStack\u001b[0m = List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): A\n\u001b[31m\u001b[31m-- Error: /tmp/tmpu7pqr6mh.scala:27:45 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mrightParensStack\u001b[0m = List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): A\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpu7pqr6mh.scala:46:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var result = \"No\"\n        var stack = List[String]()\n        for (i <- 0 to lst.length - 1) {\n            if (lst[i] == \"(\" && !stack.isEmpty()) {\n                stack = stack.tail\n            } else if (lst[i] == \")\" && stack.isEmpty()) {\n                result = \"Yes\"\n                break\n            } else {\n                stack = stack.append(lst[i])\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293050,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8pt9a7oy.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mif\u001b[0m (lst[\u001b[35mi\u001b[0m] == \u001b[31m\"(\"\u001b[0m && !stack.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8pt9a7oy.scala:23:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (lst[i] == \u001b[31m\")\"\u001b[0m && stack.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8pt9a7oy.scala:25:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8pt9a7oy.scala:27:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                stack = stack.append(lst[\u001b[35mi\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[String] - did you mean List[String].appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8pt9a7oy.scala:27:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                stack = stack.append(lst[\u001b[35mi\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        var leftParensStack = List.empty()\n        var rightParensStack = List.empty()\n        for (var i = 0; i < left.length(); i++) {\n            if (left[i] == '(') {\n                leftParensStack = leftParensStack.append(i)\n                leftParens += 1\n            } else {\n                leftParens -= 1\n                if (leftParens == 0) {\n                    leftParensStack = leftParensStack.tail\n                }\n            }\n        }\n        for (var i = 0; i < right.length(); i++) {\n            if (right[i] == '(') {\n                rightParensStack = rightParensStack.append(i)\n                rightParens += 1\n            } else {\n                rightParens -= 1\n                if (rightParens == 0) {\n                    rightParensStack = rightParensStack.tail\n                }\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        var leftParensStackCopy = leftParensStack.copy()\n        var rightParensStackCopy = rightParensStack.copy()\n        while (!leftParensStack.isEmpty() && !rightParensStack.isEmpty()) {\n            var leftParensIndex = leftParensStack.head\n            var rightParensIndex = rightParensStack.head\n            if (leftParensIndex > rightParensIndex) {\n                leftParensStack = leftParensStack.tail\n                rightParensStack = rightParensStack.tail\n            } else if (leftParensIndex < rightParensIndex) {\n                rightParensStack = rightParensStack.tail\n            } else {\n                leftParensStack = leftParensStack.\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293057,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp3h7j9ege.scala:27:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < left.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3h7j9ege.scala:27:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < left.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp3h7j9ege.scala:27:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < left.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp3h7j9ege.scala:38:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < right.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3h7j9ege.scala:38:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < right.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp3h7j9ege.scala:38:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < right.length(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                     ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        }\n        if (lst.size() == 1) {\n            return \"No\"\n        }\n        if (lst.size() == 2) {\n            if (lst.get(0).equals(\"()\") && lst.get(1).equals(\"()\")) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.size() == 3) {\n            if (lst.get(0).equals(\"()\") && lst.get(1).equals(\"()\") && lst.get(2).equals(\"()\")) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.size() == 4) {\n            if (lst.get(0).equals(\"()\") && lst.get(1).equals(\"()\") && lst.get(2).equals(\"()\") && lst.get(3).equals(\"()\")) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.size() == 5) {\n            if (lst.get(0).equals(\"()\") && lst.get(1).equals(\"()\") && lst.get(2).equals(\"()\") && lst.get(3).equals(\"()\") && lst.get(4).equals(\"()\")) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.size() == 6) {\n            if (lst.get(0).equals(\"()\") && lst.get(1).equals(\"()\") && lst.get(2).equals(\"()\") && lst.get(3).equals(\"()\") && lst.get(4).equals(\"()\") && lst.get(5).equals(\"()\")) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.size()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293056,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8akh_9mf.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp8akh_9mf.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp8akh_9mf.scala:21:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp8akh_9mf.scala:24:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m2\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8akh_9mf.scala:25:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (lst.get(\u001b[31m0\u001b[0m).equals(\u001b[31m\"()\"\u001b[0m) && lst.get(\u001b[31m1\u001b[0m).equals(\u001b[31m\"()\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of List[String] - did you mean lst.seq?\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp8akh_9mf.scala:31:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m3\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"Yes\"\n        }\n        if (lst.length == 1) {\n            return \"No\"\n        }\n        if (lst.length == 2) {\n            if (lst.get(0) == \"(\" && lst.get(1) == \")\") {\n                return \"Yes\"\n            }\n            if (lst.get(0) == \")\" && lst.get(1) == \")\") {\n                return \"No\"\n            }\n        }\n        if (lst.length > 2) {\n            if (lst.get(0) == \"(\" && lst.get(1) == \"(\" && lst.get(2) == \")\") {\n                return \"Yes\"\n            }\n            if (lst.get(0) == \"(\" && lst.get(1) == \"(\" && lst.get(2) == \")\") {\n                return \"No\"\n            }\n            if (lst.get(0) == \"(\" && lst.get(1) == \"(\" && lst.get(2) == \")\") {\n                return \"No\"\n            }\n            if (lst.get(0) == \"(\" && lst.get(1) == \"(\" && lst.get(2) == \")\") {\n                return \"No\"\n            }\n            if (lst.get(0) == \"(\" && lst.get(1) == \"(\" && lst.get(2) == \")\") {\n                return \"No\"\n            }\n            if (lst.get(0) == \"(\" && lst.get(1) == \"(\" && lst.get(2) == \")\") {\n                return \"No\"\n            }\n            if (lst.get(0) == \"(\" && lst.get(1) == \"(\" && lst.get(2) == \")\") {\n                return \"No\"\n            }\n            if (lst.get(0) == \"(\" && lst.get(1) == \"(\" && lst.get(2) == \")\") {\n                return \"No\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293056,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpfn0l1xs2.scala:55:23 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m                \u001b[33mreturn\u001b[0m \"No\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       unclosed string literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmpfn0l1xs2.scala:57:34 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 end of statement expected but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfn0l1xs2.scala:73:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfn0l1xs2.scala:25:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (lst.get(\u001b[31m0\u001b[0m) == \u001b[31m\"(\"\u001b[0m && lst.get(\u001b[31m1\u001b[0m) == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of List[String] - did you mean lst.seq?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfn0l1xs2.scala:28:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mif\u001b[0m (lst.get(\u001b[31m0\u001b[0m) == \u001b[31m\")\"\u001b[0m && lst.get(\u001b[31m1\u001b[0m) == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue get is not a member of List[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfn0l1xs2.scala:33:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            \u001b[33mif\u001b[0m (lst.get(\u001b[31m0\u001b[0m) == \u001b[31m\"(\"\u001b[0m && lst.get(\u001b[31m1\u001b[0m) == \u001b[31m\"(\"\u001b[0m && lst.get(\u001b[31m2\u001b[0m) == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        }\n        var s = \"\"\n        var p = 0\n        var c = 0\n        for (i <- lst.size()) {\n            if (lst[i] == \"(\") {\n                p += 1\n            } else if (lst[i] == \")\") {\n                p -= 1\n            } else {\n                s += lst[i]\n            }\n            if (p == 0) {\n                c += 1\n            }\n        }\n        if (c == 0) {\n            return \"Yes\"\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293048,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpycauggho.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpycauggho.scala:24:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- lst.size()) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        var leftOpen = 0\n        var rightOpen = 0\n        var leftClose = 0\n        var rightClose = 0\n        var leftOpenParens = 0\n        var rightOpenParens = 0\n        var leftCloseParens = 0\n        var rightCloseParens = 0\n        var leftOpenParensStack = List.empty()\n        var rightOpenParensStack = List.empty()\n        var leftCloseParensStack = List.empty()\n        var rightCloseParensStack = List.empty()\n        var leftOpenParensStackStack = List.empty()\n        var rightOpenParensStackStack = List.empty()\n        var leftCloseParensStackStack = List.empty()\n        var rightCloseParensStackStack = List.empty()\n        var leftOpenParensStackStackStack = List.empty()\n        var rightOpenParensStackStackStack = List.empty()\n        var leftCloseParensStackStackStack = List.empty()\n        var rightCloseParensStackStackStack = List.empty()\n        var leftOpenParensStackStackStackStack = List.empty()\n        var rightOpenParensStackStackStackStack = List.empty()\n        var leftCloseParensStackStackStackStack = List.empty()\n        var rightCloseParensStackStackStackStack = List.empty()\n        var leftOpenParensStackStackStackStackStack = List.empty()\n        var rightOpenParensStackStackStackStackStack = List.empty()\n        var leftCloseParensStackStackStackStackStack = List.empty()\n        var rightCloseParensStackStackStackStackStack = List.empty()\n        var leftOpenParensStackStackStackStackStackStack = List.empty()\n        var rightOpenParensStackStackStackStackStackStack = List.empty()\n        var leftCloseParensStackStackStackStackStackStack = List.empty()\n        var rightCloseParensStackStack\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293059,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp6hj5sln_.scala:57:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp6hj5sln_.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp6hj5sln_.scala:33:44 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftOpenParensStack\u001b[0m = List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): A\n\u001b[31m\u001b[31m-- Error: /tmp/tmp6hj5sln_.scala:34:45 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightOpenParensStack\u001b[0m = List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): A\n\u001b[31m\u001b[31m-- Error: /tmp/tmp6hj5sln_.scala:35:45 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftCloseParensStack\u001b[0m = List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): A\n\u001b[31m\u001b[31m-- Error: /tmp/tmp6hj5sln_.scala:36:46 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightCloseParensStack\u001b[0m = List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"No\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        var leftParensStack = List[String]()\n        var rightParensStack = List[String]()\n        var result = \"\"\n        while (leftParensStack.size() > 0 || rightParensStack.size() > 0) {\n            if (leftParensStack.size() > 0) {\n                leftParens = leftParensStack.head\n                leftParensStack = leftParensStack.tail\n            }\n            if (rightParensStack.size() > 0) {\n                rightParens = rightParensStack.head\n                rightParensStack = rightParensStack.tail\n            }\n            if (leftParens == rightParens) {\n                result = result + left\n                leftParens = leftParens + 1\n                rightParens = rightParens - 1\n            } else if (leftParens > rightParens) {\n                rightParensStack = rightParensStack.append(right)\n                right = right + \")\"\n                rightParens = rightParens + 1\n            } else {\n                leftParensStack = leftParensStack.append(left)\n                left = left + \"(\"\n                leftParens = leftParens - 1\n            }\n        }\n        return \"Yes\" if result == \"\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293059,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpzxfpvhxv.scala:51:21 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m        \u001b[33mreturn\u001b[0m \u001b[31m\"Yes\"\u001b[0m \u001b[33mif\u001b[0m result == \u001b[31m\"\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^\u001b[0m\n\u001b[31m   |\u001b[0m                     end of statement expected but 'if' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpzxfpvhxv.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpzxfpvhxv.scala:28:31 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mwhile\u001b[0m (leftParensStack.size() > \u001b[31m0\u001b[0m || rightParensStack.size() > \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpzxfpvhxv.scala:29:32 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mif\u001b[0m (leftParensStack.size() > \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzxfpvhxv.scala:30:45 --------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                leftParens = leftParensStack.head\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    String\n\u001b[31m   |\u001b[0m                             Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer expla",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        } else {\n            var left = lst.head\n            var right = lst.tail.head\n            var leftParens = 0\n            var rightParens = 0\n            for (i <- lst.tail.tail.size) {\n                if (left == \"(\" && right == \")\") {\n                    leftParens += 1\n                } else if (left == \")\" && right == \"(\" && leftParens > rightParens) {\n                    rightParens += 1\n                } else if (left == \"(\" && right == \")\") {\n                    leftParens -= 1\n                } else if (left == \"(\" && right == \")\") {\n                    rightParens -= 1\n                }\n            }\n            if (leftParens == rightParens) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293055,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpnqi53ofx.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnqi53ofx.scala:25:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- lst.tail.tail.size) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value foreach is not a member of Int\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        if (left.isEmpty() || right.isEmpty()) {\n            return \"No\"\n        }\n        if (left.head == \"(\" && right.head == \")\") {\n            return matchParens(lst.tail.tail).equals(\"Yes\") ? \"Yes\" : \"No\"\n        }\n        if (left.head == \")\" && right.head == \")\") {\n            return matchParens(lst.tail.tail).equals(\"Yes\") ? \"Yes\" : \"No\"\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293058,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfkqud_8w.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpfkqud_8w.scala:26:12 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mif\u001b[0m (left.head == \u001b[31m\"(\"\u001b[0m && right.head == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpfkqud_8w.scala:26:32 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mif\u001b[0m (left.head == \u001b[31m\"(\"\u001b[0m && right.head == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfkqud_8w.scala:27:60 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mreturn\u001b[0m matchParens(lst.tail.tail).equals(\u001b[31m\"Yes\"\u001b[0m) ? \u001b[31m\"Yes\"\u001b[0m : \u001b[31m\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value ? is not a member of Boolean\n\u001b[31m\u001b[31m-- Error: /tmp/tmpfkqud_8w.scala:29:12 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mif\u001b[0m (left.head == \u001b[31m\")\"\u001b[0m && right.head == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpfkqud_8w.scala:29:32 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mif\u001b[0m (left.head == \u001b[31m\")\"\u001b[0m && right.head == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        for (i <- 0 until left.length) {\n            if (left[i] == '(') {\n                leftParens += 1\n            } else {\n                leftParens -= 1\n            }\n        }\n        for (i <- 0 until right.length) {\n            if (right[i] == '(') {\n                rightParens += 1\n            } else {\n                rightParens -= 1\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        return matchParens(lst.tail)\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293050,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmplmve_qhi.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplmve_qhi.scala:26:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (left[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplmve_qhi.scala:33:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            \u001b[33mif\u001b[0m (right[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        } else {\n            var left = lst.head\n            var right = lst.tail.head\n            if (left.equals(\"(\")) {\n                return matchParens(lst.tail.tail)\n            } else if (right.equals(\")\")) {\n                return matchParens(lst.tail.tail)\n            } else {\n                return \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293050,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpy0cw5xdz.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        }\n        var s = lst.head\n        var i = 0\n        var j = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p1 = 0\n        var p2 = 0\n        var p3 = 0\n        var p4 = 0\n        var p5 = 0\n        var p6 = 0\n        var p7 = 0\n        var p8 = 0\n        var p9 = 0\n        var p10 = 0\n        var p11 = 0\n        var p12 = 0\n        var p13 = 0\n        var p14 = 0\n        var p15 = 0\n        var p16 = 0\n        var p17 = 0\n        var p18 = 0\n        var p19 = 0\n        var p20 = 0\n        var p21 = 0\n        var p22 = 0\n        var p23 = 0\n        var p24 = 0\n        var p25 = 0\n        var p26 = 0\n        var p27 = 0\n        var p28 = 0\n        var p29 = 0\n        var p30 = 0\n        var p31 = 0\n        var p32 = 0\n        var p33 = 0\n        var p34 = 0\n        var p35 = 0\n        var p36 = 0\n        var p37 = 0\n        var p38 = 0\n        var p39 = 0\n        var p40 = 0\n        var p41 = 0\n        var p42 = 0\n        var p43 = 0\n        var p44 = 0\n        var p45 = 0\n        var p46 = 0\n        var p47 = 0\n        var p48 = 0\n        var p49 = 0\n        var p50 = 0\n        var p51 = 0\n        var p52 = 0\n        var p53 = 0\n        var p54 = 0\n        var p55 = 0\n        var p56 = 0\n        var p57 = 0\n        var p58 = 0\n        var p59 = 0\n        var p60 = 0\n        var p61 = 0\n        var p62 = 0\n        \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293056,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpm4iap64v.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpm4iap64v.scala:93:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m93 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        }\n        var s = lst.head\n        var i = 0\n        var j = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293036,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvu3phuxx.scala:103:4 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m103 |\u001b[0m    }\n\u001b[31m\u001b[31m    |\u001b[0m    ^\u001b[0m\n\u001b[31m    |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvu3phuxx.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mi\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mi is already defined as \u001b[33mvariable\u001b[0m \u001b[35mi\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvu3phuxx.scala:43:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mj\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mj is already defined as \u001b[33mvariable\u001b[0m \u001b[35mj\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvu3phuxx.scala:49:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mp\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mp is already defined as \u001b[33mvariable\u001b[0m \u001b[35mp\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvu3phuxx.scala:50:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mq\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mq is already defined as \u001b[33mvariable\u001b[0m \u001b[35mq\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvu3phuxx.scala:51:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mr\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mr is already defined as \u001b[33mvariable\u001b[0m \u001b[35mr\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        } else {\n            var left = lst.head\n            var right = lst.tail.head\n            if (left.equals(right)) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293052,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfbhpspru.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        }\n        if (lst.size() == 1) {\n            return \"No\"\n        }\n        if (lst.size() == 2) {\n            if (lst.get(0).equals(\"()\") && lst.get(1).equals(\"()\")) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.size() == 3) {\n            if (lst.get(0).equals(\"()\") && lst.get(1).equals(\"()\") && lst.get(2).equals(\"()\")) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.size() == 4) {\n            if (lst.get(0).equals(\"()\") && lst.get(1).equals(\"()\") && lst.get(2).equals(\"()\") && lst.get(3).equals(\"()\")) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.size() == 5) {\n            if (lst.get(0).equals(\"()\") && lst.get(1).equals(\"()\") && lst.get(2).equals(\"()\") && lst.get(3).equals(\"()\") && lst.get(4).equals(\"()\")) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.size() == 6) {\n            if (lst.get(0).equals(\"()\") && lst.get(1).equals(\"()\") && lst.get(2).equals(\"()\") && lst.get(3).equals(\"()\") && lst.get(4).equals(\"()\") && lst.get(5).equals(\"()\")) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.size()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293056,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8akh_9mf.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp8akh_9mf.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp8akh_9mf.scala:21:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp8akh_9mf.scala:24:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m2\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8akh_9mf.scala:25:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (lst.get(\u001b[31m0\u001b[0m).equals(\u001b[31m\"()\"\u001b[0m) && lst.get(\u001b[31m1\u001b[0m).equals(\u001b[31m\"()\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of List[String] - did you mean lst.seq?\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp8akh_9mf.scala:31:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m3\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        } else {\n            var s = lst.head\n            var lst2 = lst.tail\n            var result = \"No\"\n            var i = 0\n            while (i < s.length) {\n                if (s[i] == '(') {\n                    i = i + 1\n                    if (i >= s.length) {\n                        return result\n                    }\n                    var j = i\n                    while (j < s.length && s[j] != ')') {\n                        j = j + 1\n                    }\n                    if (j >= s.length) {\n                        return result\n                    }\n                    var k = j + 1\n                    while (k < s.length && s[k] != '(') {\n                        k = k + 1\n                    }\n                    if (k >= s.length) {\n                        return result\n                    }\n                    var parens = k - i\n                    if (parens % 2 != 0) {\n                        return result\n                    }\n                    i = k + 1\n                } else {\n                    i = i + 1\n                }\n            }\n            return result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293053,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpic4o2i87.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpic4o2i87.scala:26:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpic4o2i87.scala:32:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    \u001b[33mwhile\u001b[0m (j < s.length && s[\u001b[35mj\u001b[0m] != \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpic4o2i87.scala:39:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                    \u001b[33mwhile\u001b[0m (k < s.length && s[\u001b[35mk\u001b[0m] != \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             Not found: type k\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var p = lst.tail\n        var res = \"No\"\n        var parens = 0\n        var open = 0\n        for (i <- 0 until s.length) {\n            if (s[i] == '(') {\n                open += 1\n            } else if (s[i] == ')') {\n                open -= 1\n            }\n            if (open == 0) {\n                if (open == parens) {\n                    res = \"Yes\"\n                    break\n                }\n                parens = open\n            }\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293054,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyzopzyib.scala:27:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyzopzyib.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (s[i] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyzopzyib.scala:35:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        }\n        var s = \"\"\n        var p = \"\"\n        var c = \"\"\n        var i = 0\n        var j = 0\n        var k = 0\n        while (i < lst.size()) {\n            if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                c = \"(\"\n                k = i\n                i = i + 1\n                j = j + 1\n            } else if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                c = \"(\"\n                k = i\n                i = i + 1\n                j = j + 1\n            } else if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                c = \"(\"\n                k = i\n                i = i + 1\n                j = j + 1\n            } else if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                c = \"(\"\n                k = i\n                i = i + 1\n                j = j + 1\n            } else if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                c = \"(\"\n                k = i\n                i = i + 1\n                j = j + 1\n            } else if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                c = \"(\"\n                k = i\n                i = i + 1\n                j = j + 1\n            } else if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                c = \"(\"\n                k = i\n                i = i + 1\n                j = j + 1\n            } else if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                c = \"(\"\n                k = i\n                i = i + 1\n                j = j + 1\n            } else if (lst.get(i) == \"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293067,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpcii2smt_.scala:68:37 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (lst.get(i) == \"\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     unclosed string literal\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpcii2smt_.scala:86:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m86 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpcii2smt_.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpcii2smt_.scala:27:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mwhile\u001b[0m (i < lst.size()) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcii2smt_.scala:28:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mif\u001b[0m (lst.get(i) == \u001b[31m\"(\"\u001b[0m && lst.get(j) == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of List[String] - did you mean lst.seq?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcii2smt_.scala:33:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (lst.get(i) == \u001b[31m\"(\"\u001b[0m && lst.get(j) == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue get is not a member of List[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var result = \"No\"\n        var left = 0\n        var right = 0\n        for (s in lst) {\n            if (s == \"(\") {\n                left += 1\n            } else {\n                right += 1\n            }\n            if (left == right) {\n                result = \"Yes\"\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293062,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmphusxnw3v.scala:21:23 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (s in lst) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       '<-' expected, but '{' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphusxnw3v.scala:31:9 -------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m         ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator asScala\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.set asScala\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        } else {\n            var s = lst.head\n            var i = 0\n            var j = 0\n            var p = 0\n            while (i < s.length) {\n                if (s[i] == '(') {\n                    p += 1\n                } else if (s[i] == ')') {\n                    p -= 1\n                }\n                i += 1\n            }\n            if (p == 0) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293056,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpskcrh6vg.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpskcrh6vg.scala:26:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpskcrh6vg.scala:28:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (s[i] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        } else {\n            var s = lst.head\n            var p = lst.tail\n            var parens = 0\n            var open = 0\n            var close = 0\n            var i = 0\n            while (i < s.length) {\n                if (s[i] == '(') {\n                    open += 1\n                } else if (s[i] == ')') {\n                    close += 1\n                }\n                i += 1\n            }\n            if (open == close) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293060,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpp7k1xsgh.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp7k1xsgh.scala:28:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpp7k1xsgh.scala:30:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (s[i] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"No\"\n        }\n        if (lst.size() == 1) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var i = 1\n        while (i < lst.size()) {\n            if (lst.get(i).equals(\"(\")) {\n                s = s + lst.get(i)\n            } else if (lst.get(i).equals(\")\")) {\n                s = s + lst.get(i)\n            } else {\n                return \"No\"\n            }\n            i = i + 1\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293072,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp96z7ol2s.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp96z7ol2s.scala:21:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp96z7ol2s.scala:26:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mwhile\u001b[0m (i < lst.size()) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp96z7ol2s.scala:27:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m (lst.get(i).equals(\u001b[31m\"(\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of List[String] - did you mean lst.seq?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp96z7ol2s.scala:28:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                s = s + lst.get(i)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue get is not a member of List[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        }\n        if (lst.size() == 1) {\n            return \"No\"\n        }\n        var s1 = lst.head\n        var s2 = lst.tail.head\n        var s3 = lst.tail.tail.head\n        var s4 = lst.tail.tail.tail.head\n        var s5 = lst.tail.tail.tail.tail.head\n        var s6 = lst.tail.tail.tail.tail.tail.head\n        var s7 = lst.tail.tail.tail.tail.tail.tail.head\n        var s8 = lst.tail.tail.tail.tail.tail.tail.tail.head\n        var s9 = lst.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s10 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s11 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s12 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s13 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s14 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s15 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s16 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s17 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s18 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293068,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5pkx_q8v.scala:42:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp5pkx_q8v.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp5pkx_q8v.scala:21:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5pkx_q8v.scala:42:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"Yes\"\n        }\n        if (lst.length == 1) {\n            return \"No\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        var leftParensStack = List[String]()\n        var rightParensStack = List[String]()\n        var leftParensStackIndex = 0\n        var rightParensStackIndex = 0\n        var leftParensStackSize = 0\n        var rightParensStackSize = 0\n        var leftParensStackSizeStack = List[Int]()\n        var rightParensStackSizeStack = List[Int]()\n        var leftParensStackSizeStackIndex = 0\n        var rightParensStackSizeStackIndex = 0\n        var leftParensStackSizeStackSize = 0\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSizeStack = List[Int]()\n        var leftParensStackSizeStackSizeStackIndex = 0\n        var rightParensStackSizeStackSizeStackIndex = 0\n        var leftParensStackSizeStackSizeStackSize = 0\n        var rightParensStackSizeStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSizeStackSizeStack = List[Int]()\n        var leftParensStackSizeStackSizeStackSizeStackIndex = 0\n        var rightParensStackSizeStackSizeStackSizeStackIndex = 0\n        var leftParensStackSizeStackSizeStackSizeStackSize = 0\n        var rightParensStackSizeStackSizeStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSizeStackSizeStackSizeStack = List[Int]()\n        var leftParensStackSizeStackSizeStackSizeStackSizeStackIndex = 0\n        var rightParensStackSizeStack\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293068,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpn31yb5gs.scala:56:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn31yb5gs.scala:56:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var parens = 0\n        var open = 0\n        var close = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var s = \"\"\n        var result = \"No\"\n        while (i < lst.size()) {\n            if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                parens += 1\n                i += 1\n                j += 1\n            } else if (lst.get(i) == \"(\" && lst.get(j) != \")\") {\n                open += 1\n                i += 1\n            } else if (lst.get(i) != \"(\" && lst.get(j) == \")\") {\n                close += 1\n                j += 1\n            } else {\n                s += lst.get(i)\n                i += 1\n            }\n            if (open == close) {\n                if (parens == 0) {\n                    result = \"Yes\"\n                    break\n                } else {\n                    open = 0\n                    close = 0\n                    parens = 0\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293075,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpyjylecf8.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpyjylecf8.scala:29:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mwhile\u001b[0m (i < lst.size()) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyjylecf8.scala:30:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            \u001b[33mif\u001b[0m (lst.get(i) == \u001b[31m\"(\"\u001b[0m && lst.get(j) == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of List[String] - did you mean lst.seq?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyjylecf8.scala:34:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (lst.get(i) == \u001b[31m\"(\"\u001b[0m && lst.get(j) != \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue get is not a member of List[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyjylecf8.scala:37:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (lst.get(i) != \u001b[31m\"(\"\u001b[0m && lst.get(j) == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        }\n        var s = lst.head\n        var result = \"Yes\"\n        var stack = List[String]()\n        for (i <- lst.tail) {\n            if (i.equals(\"(\")) {\n                stack = stack.append(i)\n            } else if (i.equals(\")\")) {\n                stack = stack.tail\n                if (stack.isEmpty()) {\n                    result = \"No\"\n                    break\n                } else {\n                    stack = stack.head\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293073,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpqlrm7zlv.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqlrm7zlv.scala:26:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                stack = stack.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[String] - did you mean List[String].appended?\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpqlrm7zlv.scala:29:26 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                \u001b[33mif\u001b[0m (stack.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqlrm7zlv.scala:31:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqlrm7zlv.scala:33:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                    stack = stack.head\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    String\n\u001b[31m   |\u001b[0m                            Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mString\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"No\"\n        }\n        if (lst.length == 1) {\n            return \"Yes\"\n        }\n        if (lst.length == 2) {\n            if (lst.get(0) == \"(\" && lst.get(1) == \")\") {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.length == 3) {\n            if (lst.get(0) == \"(\" && lst.get(1) == \"(\" && lst.get(2) == \")\") {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.length == 4) {\n            if (lst.get(0) == \"(\" && lst.get(1) == \"(\" && lst.get(2) == \"(\" && lst.get(3) == \")\") {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.length == 5) {\n            if (lst.get(0) == \"(\" && lst.get(1) == \"(\" && lst.get(2) == \"(\" && lst.get(3) == \"(\" && lst.get(4) == \")\") {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.length == 6) {\n            if (lst.get(0) == \"(\" && lst.get(1) == \"(\" && lst.get(2) == \"(\" && lst.get(3) == \"(\" && lst.get(4) == \"(\" && lst.get(5) == \")\") {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.length == 7) {\n            if (lst.get(0) == \"(\" && lst.get(1) == \"(\" && lst.get(2) == \"(\" && lst\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293078,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpe54rz855.scala:61:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpe54rz855.scala:78:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe54rz855.scala:25:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (lst.get(\u001b[31m0\u001b[0m) == \u001b[31m\"(\"\u001b[0m && lst.get(\u001b[31m1\u001b[0m) == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of List[String] - did you mean lst.seq?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe54rz855.scala:32:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mif\u001b[0m (lst.get(\u001b[31m0\u001b[0m) == \u001b[31m\"(\"\u001b[0m && lst.get(\u001b[31m1\u001b[0m) == \u001b[31m\"(\"\u001b[0m && lst.get(\u001b[31m2\u001b[0m) == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue get is not a member of List[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe54rz855.scala:39:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            \u001b[33mif\u001b[0m (lst.get(\u001b[31m0\u001b[0m) == \u001b[31m\"(\"\u001b[0m && lst.get(\u001b[31m1\u001b[0m) == \u001b[31m\"(\"\u001b[0m && lst.get(\u001b[31m2\u001b[0m) == \u001b[31m\"(\"\u001b[0m && lst.get(\u001b[31m3\u001b[0m) == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue get is not a member of List[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.Im",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var i = 0\n        var j = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293073,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9z5tj0cs.scala:103:4 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m103 |\u001b[0m    }\n\u001b[31m\u001b[31m    |\u001b[0m    ^\u001b[0m\n\u001b[31m    |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9z5tj0cs.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mi\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mi is already defined as \u001b[33mvariable\u001b[0m \u001b[35mi\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9z5tj0cs.scala:43:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mj\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mj is already defined as \u001b[33mvariable\u001b[0m \u001b[35mj\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9z5tj0cs.scala:49:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mp\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mp is already defined as \u001b[33mvariable\u001b[0m \u001b[35mp\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9z5tj0cs.scala:50:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mq\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mq is already defined as \u001b[33mvariable\u001b[0m \u001b[35mq\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9z5tj0cs.scala:51:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mr\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mr is already defined as \u001b[33mvariable\u001b[0m \u001b[35mr\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        }\n        var s = \"\"\n        var i = 0\n        var j = 0\n        while (i < lst.size()) {\n            if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                s += \"(\"\n                i += 1\n                j += 1\n            } else if (lst.get(i) == \")\" && lst.get(j) == \"(\" && i > 0 && j > 0 && lst.get(i - 1) == \"(\" && lst.get(j - 1) == \")\") {\n                s += \")\"\n                i += 1\n                j += 1\n            } else if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                s += \"(\"\n                i += 1\n                j += 1\n            } else if (lst.get(i) == \")\" && lst.get(j) == \"(\" && i > 0 && j > 0 && lst.get(i - 1) == \"(\" && lst.get(j - 1) == \")\") {\n                s += \")\"\n                i += 1\n                j += 1\n            } else {\n                s += lst.get(i)\n                i += 1\n            }\n        }\n        if (s.equals(\"\")) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293078,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpb1fd0n1u.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpb1fd0n1u.scala:24:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mwhile\u001b[0m (i < lst.size()) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpb1fd0n1u.scala:25:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (lst.get(i) == \u001b[31m\"(\"\u001b[0m && lst.get(j) == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of List[String] - did you mean lst.seq?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpb1fd0n1u.scala:29:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (lst.get(i) == \u001b[31m\")\"\u001b[0m && lst.get(j) == \u001b[31m\"(\"\u001b[0m && i > \u001b[31m0\u001b[0m && j > \u001b[31m0\u001b[0m && lst.get(i - \u001b[31m1\u001b[0m) == \u001b[31m\"(\"\u001b[0m && lst.get(j - \u001b[31m1\u001b[0m) == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue get is not a member of List[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpb1fd0n1u.scala:33:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        } else {\n            var left = lst.head\n            var right = lst.tail.head\n            var leftParens = 0\n            var rightParens = 0\n            var leftParensStack = List[String]()\n            var rightParensStack = List[String]()\n            for (i <- 0 until left.length) {\n                if (left[i] == '(') {\n                    leftParens += 1\n                } else {\n                    leftParens -= 1\n                }\n                if (leftParens == 0) {\n                    leftParensStack = leftParensStack.append(left[i])\n                }\n            }\n            for (i <- 0 until right.length) {\n                if (right[i] == '(') {\n                    rightParens += 1\n                } else {\n                    rightParens -= 1\n                }\n                if (rightParens == 0) {\n                    rightParensStack = rightParensStack.append(right[i])\n                }\n            }\n            if (leftParensStack.isEmpty() && rightParensStack.isEmpty()) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293076,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpx8it0qm5.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpx8it0qm5.scala:28:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                \u001b[33mif\u001b[0m (left[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx8it0qm5.scala:34:54 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                    leftParensStack = leftParensStack.append(left[\u001b[35mi\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[String] - did you mean List[String].appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpx8it0qm5.scala:34:66 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                    leftParensStack = leftParensStack.append(left[\u001b[35mi\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpx8it0qm5.scala:38:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                \u001b[33mif\u001b[0m (right[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx8it0qm5.scala:44:56 ---------------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        }\n        if (lst.size() == 1) {\n            return \"No\"\n        }\n        if (lst.size() == 2) {\n            if (lst.get(0).equals(\"()\") && lst.get(1).equals(\"()\")) {\n                return \"Yes\"\n            }\n            return \"No\"\n        }\n        if (lst.size() == 3) {\n            if (lst.get(0).equals(\"()\") && lst.get(1).equals(\"()\") && lst.get(2).equals(\"()\")) {\n                return \"Yes\"\n            }\n            return \"No\"\n        }\n        if (lst.size() == 4) {\n            if (lst.get(0).equals(\"()\") && lst.get(1).equals(\"()\") && lst.get(2).equals(\"()\") && lst.get(3).equals(\"()\")) {\n                return \"Yes\"\n            }\n            return \"No\"\n        }\n        if (lst.size() == 5) {\n            if (lst.get(0).equals(\"()\") && lst.get(1).equals(\"()\") && lst.get(2).equals(\"()\") && lst.get(3).equals(\"()\") && lst.get(4).equals(\"()\")) {\n                return \"Yes\"\n            }\n            return \"No\"\n        }\n        if (lst.size() == 6) {\n            if (lst.get(0).equals(\"()\") && lst.get(1).equals(\"()\") && lst.get(2).equals(\"()\") && lst.get(3).equals(\"()\") && lst.get(4).equals(\"()\") && lst.get(5).equals(\"()\")) {\n                return \"Yes\"\n            }\n            return \"No\"\n        }\n        if (lst.size() == 7) {\n            if (lst.get(0).equals(\"()\") && lst.get\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293080,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmponrvxwb_.scala:56:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmponrvxwb_.scala:73:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmponrvxwb_.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmponrvxwb_.scala:21:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmponrvxwb_.scala:24:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m2\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmponrvxwb_.scala:25:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (lst.get(\u001b[31m0\u001b[0m).equals(\u001b[31m\"()\"\u001b[0m) && lst.get(\u001b[31m1\u001b[0m).equals(\u001b[31m\"()\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of List[String] - did you mean lst.seq?\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmponrvxwb_.scala:30:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        }\n        var s = lst.head\n        var lst2 = lst.tail\n        var s2 = lst2.head\n        var lst3 = lst2.tail\n        var s3 = lst3.head\n        var lst4 = lst3.tail\n        var s4 = lst4.head\n        var lst5 = lst4.tail\n        var s5 = lst5.head\n        var lst6 = lst5.tail\n        var s6 = lst6.head\n        var lst7 = lst6.tail\n        var s7 = lst7.head\n        var lst8 = lst7.tail\n        var s8 = lst8.head\n        var lst9 = lst8.tail\n        var s9 = lst9.head\n        var lst10 = lst9.tail\n        var s10 = lst10.head\n        var lst11 = lst10.tail\n        var s11 = lst11.head\n        var lst12 = lst11.tail\n        var s12 = lst12.head\n        var lst13 = lst12.tail\n        var s13 = lst13.head\n        var lst14 = lst13.tail\n        var s14 = lst14.head\n        var lst15 = lst14.tail\n        var s15 = lst15.head\n        var lst16 = lst15.tail\n        var s16 = lst16.head\n        var lst17 = lst16.tail\n        var s17 = lst17.head\n        var lst18 = lst17.tail\n        var s18 = lst18.head\n        var lst19 = lst18.tail\n        var s19 = lst19.head\n        var lst20 = lst19.tail\n        var s20 = lst20.head\n        var lst21 = lst20.tail\n        var s21 = lst21.head\n        var lst22 = lst21.tail\n        var s22 = lst22.head\n        \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293078,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpmrwyz8i8.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmrwyz8i8.scala:65:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m65 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) return \"No\"\n        var s = lst.head\n        lst = lst.tail\n        var res = \"\"\n        var count = 0\n        while (count < s.length()) {\n            if (s.charAt(count) == '(') {\n                count += 1\n            } else {\n                count -= 1\n            }\n        }\n        if (count == 0) {\n            res += \"Yes\"\n        } else {\n            res += \"No\"\n        }\n        return matchParens(lst).concat(res)\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293072,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmplvld06qp.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) \u001b[33mreturn\u001b[0m \u001b[31m\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmplvld06qp.scala:20:12 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        lst = lst.tail\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Reassignment to val lst\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        var leftParensStack = List[String]()\n        var rightParensStack = List[String]()\n        for (i <- 0 until left.length) {\n            if (left[i] == '(') {\n                leftParens += 1\n                leftParensStack = leftParensStack.append(left[i])\n            } else {\n                leftParens -= 1\n                leftParensStack = leftParensStack.prepend(left[i])\n            }\n        }\n        for (i <- 0 until right.length) {\n            if (right[i] == '(') {\n                rightParens += 1\n                rightParensStack = rightParensStack.append(right[i])\n            } else {\n                rightParens -= 1\n                rightParensStack = rightParensStack.prepend(right[i])\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        var leftParensStackCopy = leftParensStack\n        var rightParensStackCopy = rightParensStack\n        var leftParensStackCopyStack = List[String]()\n        var rightParensStackCopyStack = List[String]()\n        for (i <- 0 until leftParensStack.length) {\n            if (leftParensStack[i] == '(') {\n                leftParensStackCopyStack = leftParensStackCopyStack.append(leftParensStack[i])\n            } else {\n                leftParensStackCopyStack = leftParensStackCopyStack.prepend(leftParensStack[i])\n            }\n        }\n        for (i <- 0 until rightParensStack.length) {\n            if (rightParensStack[i] == '(') {\n                rightParensStackCopyStack = rightParensStackCopyStack\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293082,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpl0ztu2cs.scala:79:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpl0ztu2cs.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl0ztu2cs.scala:28:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mif\u001b[0m (left[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl0ztu2cs.scala:30:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                leftParensStack = leftParensStack.append(left[\u001b[35mi\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[String] - did you mean List[String].appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl0ztu2cs.scala:30:62 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                leftParensStack = leftParensStack.append(left[\u001b[35mi\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl0ztu2cs.scala:33:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                leftParensStack = leftParensStack.prepend(left[\u001b[35mi\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue prepend is not a ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var s = \"\"\n        for(i <- 0 until lst.length) {\n            if(lst[i] == \"(\") {\n                s += \"(\"\n            } else if(lst[i] == \")\") {\n                s += \")\"\n            } else {\n                s += lst[i]\n            }\n        }\n        if(s.count(\"(\") == s.count(\")\")) {\n            \"Yes\"\n        } else {\n            \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293081,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp12z419jw.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mif\u001b[0m(lst[\u001b[35mi\u001b[0m] == \u001b[31m\"(\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp12z419jw.scala:22:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m(lst[i] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp12z419jw.scala:25:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                s += lst[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp12z419jw.scala:25:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                s += lst[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp12z419jw.scala:28:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mif\u001b[0m(s.count(\u001b[31m\"(\"\u001b[0m) == s.count(\u001b[31m\")\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (\u001b[32m\"(\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                   Required: Char => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp12z419jw.scala:28:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mif\u001b[0m(s.count(\u001b[31m\"(\"\u001b[0m) == s.count(\u001b[31m\")\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"No\"\n        }\n        var s = lst.head\n        var p = lst.tail\n        var i = 0\n        var j = 0\n        var parens = 0\n        var open = 0\n        var close = 0\n        while (i < s.length) {\n            if (s[i] == '(') {\n                open += 1\n            } else if (s[i] == ')') {\n                close += 1\n            }\n            i += 1\n        }\n        if (open == close) {\n            return \"Yes\"\n        }\n        while (j < p.size()) {\n            if (p[j] == '(') {\n                open += 1\n            } else if (p[j] == ')') {\n                close += 1\n            }\n            j += 1\n        }\n        if (open == close) {\n            return \"Yes\"\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293074,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp3vuqllcq.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3vuqllcq.scala:29:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3vuqllcq.scala:31:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (s[i] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp3vuqllcq.scala:39:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mwhile\u001b[0m (j < p.size()) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3vuqllcq.scala:40:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m            \u001b[33mif\u001b[0m (p[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3vuqllcq.scala:42:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (p[j] == \u001b[31",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        } else {\n            var left = lst.head\n            var right = lst.tail.head\n            var leftParens = 0\n            var rightParens = 0\n            var leftOpen = 0\n            var rightOpen = 0\n            var leftOpenStack = List.empty[String]\n            var rightOpenStack = List.empty[String]\n            var leftOpenStack2 = List.empty[String]\n            var rightOpenStack2 = List.empty[String]\n            var leftOpenStack3 = List.empty[String]\n            var rightOpenStack3 = List.empty[String]\n            var leftOpenStack4 = List.empty[String]\n            var rightOpenStack4 = List.empty[String]\n            var leftOpenStack5 = List.empty[String]\n            var rightOpenStack5 = List.empty[String]\n            var leftOpenStack6 = List.empty[String]\n            var rightOpenStack6 = List.empty[String]\n            var leftOpenStack7 = List.empty[String]\n            var rightOpenStack7 = List.empty[String]\n            var leftOpenStack8 = List.empty[String]\n            var rightOpenStack8 = List.empty[String]\n            var leftOpenStack9 = List.empty[String]\n            var rightOpenStack9 = List.empty[String]\n            var leftOpenStack10 = List.empty[String]\n            var rightOpenStack10 = List.empty[String]\n            var leftOpenStack11 = List.empty[String]\n            var rightOpenStack11 = List.empty[String]\n            var leftOpenStack12 = List.empty[String]\n            var rightOpenStack12 = List.empty[String]\n            var leftOpenStack13 = List.empty[String]\n            var rightOpenStack13 = List.empty[String]\n            var leftOpenStack14 = List.empty[String]\n            var rightOpenStack14 = List.empty[String]\n            var leftOpenStack15 = List.empty[String]\n            var rightOpenStack15 = List.empty[String]\n            var leftOpenStack16 = List.empty[String]\n            var rightOpenStack16\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293080,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpmazog2s8.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpmazog2s8.scala:76:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpmazog2s8.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmazog2s8.scala:75:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpmazog2s8.scala:60:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m60 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        }\n        var s = \"\"\n        var i = 0\n        while (i < lst.size()) {\n            if (lst.get(i).equals(\"(\")) {\n                s += \"(\"\n                i += 1\n            } else if (lst.get(i).equals(\")\")) {\n                s += \")\"\n                i += 1\n            } else {\n                s += lst.get(i)\n                i += 1\n            }\n        }\n        if (s.equals(\"\")) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293083,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmplog6onas.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmplog6onas.scala:23:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mwhile\u001b[0m (i < lst.size()) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplog6onas.scala:24:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m (lst.get(i).equals(\u001b[31m\"(\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of List[String] - did you mean lst.seq?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplog6onas.scala:27:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (lst.get(i).equals(\u001b[31m\")\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue get is not a member of List[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplog6onas.scala:31:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                s += lst.get(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"No\"\n        }\n        if (lst.length == 1) {\n            return \"Yes\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        var leftParensStack = List[String]()\n        var rightParensStack = List[String]()\n        for (i <- lst) {\n            if (i == left) {\n                leftParens += 1\n                leftParensStack = leftParensStack.append(i)\n            } else if (i == right) {\n                rightParens += 1\n                rightParensStack = rightParensStack.append(i)\n            } else {\n                if (leftParens == rightParens) {\n                    leftParensStack = leftParensStack.append(i)\n                } else if (leftParens < rightParens) {\n                    leftParensStack = leftParensStack.append(i)\n                } else {\n                    rightParensStack = rightParensStack.append(i)\n                }\n            }\n        }\n        if (leftParens == rightParens) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293083,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdhxvafse.scala:33:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                leftParensStack = leftParensStack.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[String] - did you mean List[String].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdhxvafse.scala:36:52 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                rightParensStack = rightParensStack.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[String] - did you mean List[String].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdhxvafse.scala:39:54 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                    leftParensStack = leftParensStack.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[String] - did you mean List[String].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdhxvafse.scala:41:54 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m                    leftParensStack = leftParensStack.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[String] - did you mean List[String].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdhxvafse.scala:43:56 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m                    rightParensStack = rightParensStack.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[String] - did you mean List[String].appended?\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        }\n        if (lst.size() == 1) {\n            return \"No\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        var leftParensStack = List[String]()\n        var rightParensStack = List[String]()\n        var leftParensStackSize = 0\n        var rightParensStackSize = 0\n        var leftParensStackSizeStack = List[Int]()\n        var rightParensStackSizeStack = List[Int]()\n        var leftParensStackSizeStackSize = 0\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack =\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293082,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpiox2tqmp.scala:56:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParensStackSizeStackSizeStack\u001b[0m =\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpiox2tqmp.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParensStackSizeStackSize\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParensStackSizeStackSize is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParensStackSizeStackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpiox2tqmp.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParensStackSizeStackSizeStack\u001b[0m = List[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParensStackSizeStackSizeStack is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftParensStackSizeStackSizeStack\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpiox2tqmp.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParensStackSizeStackSize\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParensStackSizeStackSize is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParensStackSizeStackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpiox2tqmp.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var l = lst.tail\n        var i = 0\n        var j = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293083,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpam3c7umr.scala:43:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mi\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mi is already defined as \u001b[33mvariable\u001b[0m \u001b[35mi\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpam3c7umr.scala:44:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mj\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mj is already defined as \u001b[33mvariable\u001b[0m \u001b[35mj\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpam3c7umr.scala:46:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36ml\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0ml is already defined as \u001b[33mvariable\u001b[0m \u001b[35ml\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpam3c7umr.scala:50:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mp\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mp is already defined as \u001b[33mvariable\u001b[0m \u001b[35mp\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpam3c7umr.scala:51:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mq\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mq is already defined as \u001b[33mvariable\u001b[0m \u001b[35mq\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpam3c7umr.scala:52:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mr\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = \"\"\n        var i = 0\n        while (i < lst.size()) {\n            if (lst.get(i) == \"(\" && lst.get(i + 1) == \")\") {\n                s += \"(\"\n                i += 2\n            } else if (lst.get(i) == \")\" && lst.get(i + 1) == \")\") {\n                s += \")\"\n                i += 2\n            } else {\n                s += lst.get(i)\n                i += 1\n            }\n        }\n        if (s.count(\"(\") == s.count(\")\")) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293087,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp1k6iflsi.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp1k6iflsi.scala:23:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mwhile\u001b[0m (i < lst.size()) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1k6iflsi.scala:24:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m (lst.get(i) == \u001b[31m\"(\"\u001b[0m && lst.get(i + \u001b[31m1\u001b[0m) == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of List[String] - did you mean lst.seq?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1k6iflsi.scala:27:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (lst.get(i) == \u001b[31m\")\"\u001b[0m && lst.get(i + \u001b[31m1\u001b[0m) == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue get is not a member of List[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1k6iflsi.scala:31:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                s += lst.get(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of St",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        }\n        var s = \"\"\n        var i = 0\n        while (i < lst.size()) {\n            if (lst[i] == \")\") {\n                s += \"(\"\n            } else {\n                s += lst[i]\n            }\n            i += 1\n        }\n        return matchParens(lst.tail.map(_.toString()).toList + s)\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293088,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpmpbx1tw4.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpmpbx1tw4.scala:23:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mwhile\u001b[0m (i < lst.size()) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmpbx1tw4.scala:24:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m (lst[\u001b[35mi\u001b[0m] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmpbx1tw4.scala:27:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                s += lst[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmpbx1tw4.scala:27:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                s += lst[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmpbx1tw4.scala:31:61 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mreturn\u001b[0m matchParens(lst.tail.map(_.toString()).toList + s)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^^^^^^^^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var p = lst.tail\n        var i = 0\n        var j = 0\n        var parens = 0\n        var open = 0\n        var close = 0\n        while (i < s.length) {\n            if (s[i] == '(') {\n                open += 1\n            } else if (s[i] == ')') {\n                close += 1\n            }\n            i += 1\n        }\n        if (open != close) {\n            return \"No\"\n        }\n        while (j < p.length) {\n            if (p[j] == '(') {\n                open += 1\n            } else if (p[j] == ')') {\n                close += 1\n            }\n            j += 1\n        }\n        if (open != close) {\n            return \"No\"\n        }\n        var res = \"\"\n        var sb = new StringBuilder()\n        var pb = new StringBuilder()\n        var parens = 0\n        var open = 0\n        var close = 0\n        while (i < s.length) {\n            if (s[i] == '(') {\n                open += 1\n            } else if (s[i] == ')') {\n                close += 1\n            }\n            if (open == close) {\n                if (open > 0) {\n                    sb.append(s[i])\n                    open -= 1\n                } else {\n                    pb.append(s[i])\n                    close -= 1\n                }\n            } else {\n                if (open > 0) {\n                    sb.append(s[i])\n                    open -= 1\n                } else {\n                    pb.append(s[i])\n                    close -= 1\n                }\n            }\n            i += 1\n        }\n        if (open > 0) {\n            return \"No\"\n        }\n        if (open == close) {\n            res = sb.toString()\n        } else {\n            res = pb.toString()\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293086,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjeidy9ay.scala:53:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mparens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mparens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mparens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjeidy9ay.scala:54:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mopen\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mopen is already defined as \u001b[33mvariable\u001b[0m \u001b[35mopen\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjeidy9ay.scala:55:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mclose\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mclose is already defined as \u001b[33mvariable\u001b[0m \u001b[35mclose\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjeidy9ay.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjeidy9ay.scala:29:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjeidy9ay.scala:31:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        } else {\n            var s = lst.head\n            var res = matchParens(lst.tail)\n            if (s.charAt(0) == '(') {\n                if (s.charAt(s.length - 1) == ')') {\n                    if (res == \"Yes\") {\n                        return \"Yes\"\n                    } else {\n                        return \"No\"\n                    }\n                } else {\n                    return \"No\"\n                }\n            } else {\n                if (s.charAt(s.length - 1) == ')') {\n                    if (res == \"Yes\") {\n                        return \"Yes\"\n                    } else {\n                        return \"No\"\n                    }\n                } else {\n                    return \"No\"\n                }\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293086,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp2g10l8x8.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"No\"\n        }\n        if (lst.size() == 1) {\n            return \"Yes\"\n        }\n        var s = \"\"\n        var parens = 0\n        for (i <- 0 until lst.size()) {\n            if (lst[i] == \"(\") {\n                parens += 1\n            } else if (lst[i] == \")\") {\n                parens -= 1\n            }\n            if (parens == 0) {\n                s += lst[i]\n            }\n        }\n        if (parens == 0) {\n            return \"Yes\"\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293091,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfrwd_qm0.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfrwd_qm0.scala:21:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfrwd_qm0.scala:26:30 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until lst.size()) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfrwd_qm0.scala:27:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m (lst[\u001b[35mi\u001b[0m] == \u001b[31m\"(\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfrwd_qm0.scala:29:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (lst[i] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfrwd_qm0.scala:33:18 --",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var result = \"No\"\n        var stack = List[String]()\n        for (s in lst) {\n            if (s == \"(\" || s == \")\") {\n                if (stack.isEmpty()) {\n                    stack = List[String](s)\n                } else {\n                    if (s == \")\") {\n                        stack = stack.tail\n                    } else {\n                        stack = stack.prepend(s)\n                    }\n                }\n            } else {\n                result = \"Yes\"\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293096,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp53_9tv5w.scala:20:23 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mfor\u001b[0m (s in lst) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       '<-' expected, but '{' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp53_9tv5w.scala:35:9 -------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m         ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator asScala\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.set asScala\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"No\"\n        }\n        var s = lst.head\n        var i = 1\n        while (i < lst.length) {\n            if (s.charAt(0) == '(') {\n                if (s.charAt(s.length - 1) == ')') {\n                    s = s.substring(1, s.length - 1)\n                } else {\n                    return \"No\"\n                }\n            } else {\n                if (s.charAt(s.length - 1) == '(') {\n                    return \"No\"\n                } else {\n                    s = s.substring(1, s.length - 1)\n                }\n            }\n            i = i + 1\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293098,
      "stdout": "",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp1k9xyux4.scala:42)\n\tat Problem.main(tmp1k9xyux4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "exit_code": 0,
      "status": "Exception"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var p = lst.tail\n        var i = 0\n        var j = 0\n        var parens = 0\n        while (i < s.length) {\n            if (s[i] == '(') {\n                parens += 1\n            } else if (s[i] == ')') {\n                parens -= 1\n            }\n            i += 1\n        }\n        if (parens == 0) {\n            return \"Yes\"\n        }\n        while (j < p.size) {\n            if (p[j] == '(') {\n                parens += 1\n            } else if (p[j] == ')') {\n                parens -= 1\n            }\n            j += 1\n        }\n        if (parens == 0) {\n            return \"Yes\"\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293091,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpvzhh7h7q.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvzhh7h7q.scala:27:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvzhh7h7q.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (s[i] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvzhh7h7q.scala:38:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            \u001b[33mif\u001b[0m (p[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvzhh7h7q.scala:40:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (p[j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        var leftParensStack = List[String]()\n        var rightParensStack = List[String]()\n        var leftParensStackSize = 0\n        var rightParensStackSize = 0\n        var leftParensStackSizeStack = List[Int]()\n        var rightParensStackSizeStack = List[Int]()\n        var leftParensStackSizeStackSize = 0\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParen\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293014,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpdb1oc4pk.scala:56:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdb1oc4pk.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParensStackSizeStackSize\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParensStackSizeStackSize is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParensStackSizeStackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdb1oc4pk.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParensStackSizeStackSizeStack\u001b[0m = List[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParensStackSizeStackSizeStack is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftParensStackSizeStackSizeStack\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdb1oc4pk.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParensStackSizeStackSize\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParensStackSizeStackSize is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParensStackSizeStackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdb1oc4pk.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParensStackSizeStackSizeStack\u001b[0m = List[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParensStackSizeStackSizeStack is already def",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        }\n        if (lst.size() == 1) {\n            return \"No\"\n        }\n        var s1 = lst.head\n        var s2 = lst.tail.head\n        var s3 = lst.tail.tail.head\n        var s4 = lst.tail.tail.tail.head\n        var s5 = lst.tail.tail.tail.tail.head\n        var s6 = lst.tail.tail.tail.tail.tail.head\n        var s7 = lst.tail.tail.tail.tail.tail.tail.head\n        var s8 = lst.tail.tail.tail.tail.tail.tail.tail.head\n        var s9 = lst.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s10 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s11 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s12 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s13 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s14 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s15 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s16 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s17 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var s18 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293068,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5pkx_q8v.scala:42:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp5pkx_q8v.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp5pkx_q8v.scala:21:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5pkx_q8v.scala:42:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        } else {\n            var s = lst.head\n            var i = 0\n            var j = 0\n            var p = 0\n            var q = 0\n            var r = 0\n            var s1 = \"\"\n            var s2 = \"\"\n            var s3 = \"\"\n            var s4 = \"\"\n            var s5 = \"\"\n            var s6 = \"\"\n            var s7 = \"\"\n            var s8 = \"\"\n            var s9 = \"\"\n            var s10 = \"\"\n            var s11 = \"\"\n            var s12 = \"\"\n            var s13 = \"\"\n            var s14 = \"\"\n            var s15 = \"\"\n            var s16 = \"\"\n            var s17 = \"\"\n            var s18 = \"\"\n            var s19 = \"\"\n            var s20 = \"\"\n            var s21 = \"\"\n            var s22 = \"\"\n            var s23 = \"\"\n            var s24 = \"\"\n            var s25 = \"\"\n            var s26 = \"\"\n            var s27 = \"\"\n            var s28 = \"\"\n            var s29 = \"\"\n            var s30 = \"\"\n            var s31 = \"\"\n            var s32 = \"\"\n            var s33 = \"\"\n            var s34 = \"\"\n            var s35 = \"\"\n            var s36 = \"\"\n            var s37 = \"\"\n            var s38 = \"\"\n            var s39 = \"\"\n            var s40 = \"\"\n            var s41 = \"\"\n            var s42 = \"\"\n            var s43 = \"\"\n            var s44 = \"\"\n            var s45 = \"\"\n            var s46 = \"\"\n            var s47 = \"\"\n            var s48 = \"\"\n            var s49 = \"\"\n            var s50 = \"\"\n            var s51 = \"\"\n            var s52 = \"\"\n            var s53 = \"\"\n            var s54 = \"\"\n            var s55 = \"\"\n            var s56 = \"\"\n            var s57 = \"\"\n            var s58 = \"\"\n            var s59 = \"\"\n            var s60 = \"\"\n            var s61 = \"\"\n            var s62 = \"\"\n            var s63 = \"\"\n            var s64 = \"\"\n            \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293097,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpxgsvk5ot.scala:109:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m109 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpxgsvk5ot.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxgsvk5ot.scala:108:1 --------------------\u001b[0m\u001b[0m\n\u001b[31m108 |\u001b[0m}\n\u001b[31m\u001b[31m    |\u001b[0m ^\u001b[0m\n\u001b[31m    |\u001b[0m Found:    Unit\n\u001b[31m    |\u001b[0m Required: String\n\u001b[31m    |\u001b[0m\n\u001b[31m    |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpxgsvk5ot.scala:93:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m93 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var i = 0\n        while (i < lst.size) {\n            if (s.charAt(0) == '(') {\n                i += 1\n                s = s.substring(1)\n            } else {\n                i += 1\n                s = s.substring(1)\n            }\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293090,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpl8p1x_um.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        if (lst.head.equals(\"()\")) {\n            return \"No\"\n        }\n        if (lst.tail.isEmpty()) {\n            return \"Yes\"\n        }\n        if (lst.tail.head.equals(\"()\")) {\n            return \"No\"\n        }\n        return matchParens(lst.tail).equals(\"Yes\") ? \"Yes\" : \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293096,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpi1_4jlst.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpi1_4jlst.scala:24:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mif\u001b[0m (lst.tail.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi1_4jlst.scala:30:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mreturn\u001b[0m matchParens(lst.tail).equals(\u001b[31m\"Yes\"\u001b[0m) ? \u001b[31m\"Yes\"\u001b[0m : \u001b[31m\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               value ? is not a member of Boolean\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"No\"\n        }\n        var s = lst.head\n        var p = lst.tail.head\n        var q = lst.tail.tail.head\n        var r = lst.tail.tail.tail.head\n        var l = lst.tail.tail.tail.tail.head\n        var m = lst.tail.tail.tail.tail.tail.head\n        var n = lst.tail.tail.tail.tail.tail.tail.head\n        var o = lst.tail.tail.tail.tail.tail.tail.tail.head\n        var p1 = lst.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var p2 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var p3 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var p4 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var p5 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var p6 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var p7 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var p8 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var p9 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var p10 = lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n        var p11 = lst.tail.tail.tail\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293098,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6ikuku2n.scala:40:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"No\"\n        } else {\n            var left = lst.head\n            var right = lst.tail.head\n            var leftParens = 0\n            var rightParens = 0\n            var leftParensStack = List.empty()\n            var rightParensStack = List.empty()\n            for (i <- lst.range(1, lst.length)) {\n                if (leftParensStack.isEmpty() && rightParensStack.isEmpty()) {\n                    leftParensStack = leftParensStack.append(left)\n                    rightParensStack = rightParensStack.append(right)\n                } else if (leftParensStack.isEmpty()) {\n                    leftParensStack = leftParensStack.append(left)\n                } else if (rightParensStack.isEmpty()) {\n                    rightParensStack = rightParensStack.append(right)\n                } else {\n                    if (left == \"(\" && right == \")\") {\n                        leftParensStack = leftParensStack.append(left)\n                        rightParensStack = rightParensStack.append(right)\n                    } else if (left == \"(\" && right != \")\") {\n                        leftParensStack = leftParensStack.append(left)\n                    } else if (left != \"(\" && right == \")\") {\n                        rightParensStack = rightParensStack.append(right)\n                    } else {\n                        return \"No\"\n                    }\n                }\n            }\n            if (leftParensStack.isEmpty() && rightParensStack.isEmpty()) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293101,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpyhotz150.scala:25:44 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mleftParensStack\u001b[0m = List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): A\n\u001b[31m\u001b[31m-- Error: /tmp/tmpyhotz150.scala:26:45 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mrightParensStack\u001b[0m = List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): A\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyhotz150.scala:27:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- lst.range(\u001b[31m1\u001b[0m, lst.length)) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value range is not a member of List[String] - did you mean lst.take?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var s = \"\"\n        var i = 0\n        while (i < lst.length) {\n            if (lst[i] == \"(\" || lst[i] == \")\") {\n                s += lst[i]\n                i += 1\n            } else {\n                break\n            }\n        }\n        if (i == lst.length) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293098,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpid7nold7.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mif\u001b[0m (lst[\u001b[35mi\u001b[0m] == \u001b[31m\"(\"\u001b[0m || lst[\u001b[35mi\u001b[0m] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpid7nold7.scala:22:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                s += lst[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpid7nold7.scala:22:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                s += lst[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpid7nold7.scala:25:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var i = 0\n        var j = 0\n        var p = 0\n        var q = 0\n        while (i < s.length) {\n            if (s[i] == '(') {\n                p += 1\n            } else {\n                if (p == 0) {\n                    return \"No\"\n                }\n                p -= 1\n            }\n            i += 1\n        }\n        while (j < lst.tail.length) {\n            if (lst.tail[j] == '(') {\n                q += 1\n            } else {\n                if (q == 0) {\n                    return \"No\"\n                }\n                q -= 1\n            }\n            j += 1\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293095,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfo_koiwp.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfo_koiwp.scala:27:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfo_koiwp.scala:38:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            \u001b[33mif\u001b[0m (lst.tail[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        } else {\n            var left = lst.head\n            var right = lst.tail.head\n            var leftParens = 0\n            var rightParens = 0\n            var leftParensStack = List.empty()\n            var rightParensStack = List.empty()\n            while (leftParensStack.size() > 0 || rightParensStack.size() > 0) {\n                if (leftParensStack.size() > 0) {\n                    leftParens = leftParensStack.head\n                    leftParensStack = leftParensStack.tail\n                }\n                if (rightParensStack.size() > 0) {\n                    rightParens = rightParensStack.head\n                    rightParensStack = rightParensStack.tail\n                }\n                if (leftParens == rightParens) {\n                    leftParensStack = leftParensStack.append(left)\n                    rightParensStack = rightParensStack.append(right)\n                } else if (leftParens > rightParens) {\n                    leftParensStack = leftParensStack.append(left)\n                } else {\n                    rightParensStack = rightParensStack.append(right)\n                }\n            }\n            return \"Yes\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293098,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmptkghnwll.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmptkghnwll.scala:25:44 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mleftParensStack\u001b[0m = List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): A\n\u001b[31m\u001b[31m-- Error: /tmp/tmptkghnwll.scala:26:45 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mrightParensStack\u001b[0m = List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): A\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        }\n        var s = \"\"\n        for (var i = 0; i < lst.size(); i++) {\n            if (lst.get(i).equals(\"(\")) {\n                s += \"(\"\n            } else if (lst.get(i).equals(\")\")) {\n                s += \")\"\n            } else {\n                return \"No\"\n            }\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293104,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpo3h19ops.scala:22:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.size(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpo3h19ops.scala:22:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.size(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpo3h19ops.scala:22:43 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.size(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpo3h19ops.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo3h19ops.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.size(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var result = \"No\"\n        var stack = List.empty[String]\n        for (s in lst) {\n            if (s == \"(\" || s == \")\") {\n                if (stack.isEmpty()) {\n                    stack = stack.append(s)\n                } else {\n                    if (s == \")\") {\n                        stack = stack.pop()\n                    } else {\n                        stack = stack.append(s)\n                    }\n                }\n            } else {\n                result = \"No\"\n                break\n            }\n        }\n        if (stack.isEmpty()) {\n            result = \"Yes\"\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293104,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp6bhuj5wg.scala:20:23 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mfor\u001b[0m (s in lst) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       '<-' expected, but '{' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp6bhuj5wg.scala:38:9 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m         ^\u001b[0m\n\u001b[31m   |\u001b[0m         pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6bhuj5wg.scala:35:9 -------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m         ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator asScala\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.set asScala\n\u001b[31m   |\u001b[0m\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        } else {\n            var left = lst.head\n            var right = lst.tail.head\n            if (left.equals(\"(\")) {\n                return matchParens(lst.tail.tail)\n            } else if (right.equals(\")\")) {\n                return matchParens(lst.tail.tail)\n            } else {\n                return \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293050,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpy0cw5xdz.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        }\n        var s = lst.head\n        var p = lst.tail\n        var i = 0\n        var j = 0\n        var parens = 0\n        while (i < s.length) {\n            if (s[i] == '(') {\n                parens += 1\n            } else if (s[i] == ')') {\n                parens -= 1\n            }\n            i += 1\n        }\n        if (parens == 0) {\n            return \"Yes\"\n        }\n        while (j < p.length) {\n            if (p[j] == '(') {\n                parens += 1\n            } else if (p[j] == ')') {\n                parens -= 1\n            }\n            j += 1\n        }\n        if (parens == 0) {\n            return \"Yes\"\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293098,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmplnvugifu.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplnvugifu.scala:27:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplnvugifu.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (s[i] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplnvugifu.scala:38:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            \u001b[33mif\u001b[0m (p[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplnvugifu.scala:40:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (p[j] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = \"\"\n        var p = 0\n        for (i <- lst.size()) {\n            if (lst[i].equals(\"(\")) {\n                p += 1\n            } else if (lst[i].equals(\")\")) {\n                p -= 1\n            }\n            if (p == 0) {\n                s += lst[i]\n            }\n        }\n        if (p == 0) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293098,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpwy3zg3pn.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpwy3zg3pn.scala:23:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- lst.size()) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var r = lst.tail\n        var i = 0\n        var j = 0\n        var p = 0\n        var q = 0\n        var m = 0\n        var n = 0\n        var parens = 0\n        var balance = 0\n        while (i < s.length) {\n            if (s[i] == '(') {\n                parens += 1\n            } else if (s[i] == ')') {\n                parens -= 1\n            }\n            if (parens == 0) {\n                balance += 1\n            } else if (parens == 1) {\n                balance -= 1\n            }\n            if (balance == 0) {\n                if (j < r.size()) {\n                    if (r[j] == '(') {\n                        balance += 1\n                    } else if (r[j] == ')') {\n                        balance -= 1\n                    }\n                }\n                if (balance == 0) {\n                    m = i\n                    n = j\n                    p = parens\n                    q = balance\n                    break\n                }\n            }\n            i += 1\n        }\n        if (balance != 0) {\n            return \"No\"\n        }\n        var s1 = s.substring(m, n + 1)\n        var s2 = r.substring(n, r.size())\n        var s3 = s1 + s2\n        if (s3.equals(s)) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293103,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpidobk6vu.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpidobk6vu.scala:32:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpidobk6vu.scala:34:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (s[i] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpidobk6vu.scala:43:26 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m                \u001b[33mif\u001b[0m (j < r.size()) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpidobk6vu.scala:44:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m                    \u001b[33mif\u001b[0m (r[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpidobk6vu.scala:46:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m                  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        }\n        if (lst.size() == 1) {\n            return \"No\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        var leftParensStack = List[String]()\n        var rightParensStack = List[String]()\n        for (i <- 0 until left.size()) {\n            if (left[i] == \"(\" && leftParensStack.isEmpty()) {\n                leftParensStack += left[i]\n                leftParens += 1\n            } else if (left[i] == \")\" && leftParensStack.isEmpty()) {\n                leftParensStack += left[i]\n                leftParens -= 1\n            } else if (left[i] == \"(\" && leftParensStack.isEmpty()) {\n                leftParensStack += left[i]\n                leftParens += 1\n            } else if (left[i] == \")\" && leftParensStack.isEmpty()) {\n                leftParensStack += left[i]\n                leftParens -= 1\n            } else if (left[i] == \"(\" && leftParensStack.isEmpty()) {\n                leftParensStack += left[i]\n                leftParens += 1\n            } else if (left[i] == \")\" && leftParensStack.isEmpty()) {\n                leftParensStack += left[i]\n                leftParens -= 1\n            } else if (left[i] == \"(\" && leftParensStack.isEmpty()) {\n                leftParensStack += left[i]\n                leftParens += 1\n            } else if (left[i] == \")\" && leftParensStack.isEmpty()) {\n                leftParensStack += left[i]\n                leftParens -= 1\n            } else if (left[i] == \"(\" && leftParensStack.isEmpty()) {\n                leftParensStack += left[i]\n                leftP\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293111,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp2sr12ts2.scala:75:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp2sr12ts2.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp2sr12ts2.scala:21:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp2sr12ts2.scala:30:31 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until left.size()) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mStringOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2sr12ts2.scala:31:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            \u001b[33mif\u001b[0m (left[\u001b[35mi\u001b[0m] == \u001b[31m\"(\"\u001b[0m && leftParensStack.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2sr12ts2.scala:32:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                leftParensStack += left[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        } else {\n            var s = lst.head\n            var i = 1\n            var j = 1\n            while (i < lst.size()) {\n                if (lst.get(i) == \")\") {\n                    if (s.charAt(j - 1) == '(') {\n                        s = s.substring(0, j - 1) + lst.get(i)\n                        j = j - 1\n                    } else {\n                        return \"No\"\n                    }\n                } else {\n                    if (s.charAt(j - 1) == '(') {\n                        s = s.substring(0, j - 1) + lst.get(i)\n                        j = j - 1\n                    } else {\n                        s = s + lst.get(i)\n                    }\n                }\n                i = i + 1\n            }\n            return \"Yes\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293107,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpvyr2svzh.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpvyr2svzh.scala:24:27 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mwhile\u001b[0m (i < lst.size()) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvyr2svzh.scala:25:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                \u001b[33mif\u001b[0m (lst.get(i) == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of List[String] - did you mean lst.seq?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvyr2svzh.scala:27:56 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                        s = s.substring(\u001b[31m0\u001b[0m, j - \u001b[31m1\u001b[0m) + lst.get(i)\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue get is not a member of List[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvyr2svzh.scala:34:56 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                        s = s.substring(\u001b[31m0\u001b[0m, j - \u001b[31m1\u001b[0m) + lst.get(i)\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        }\n        if (lst.size() == 1) {\n            return \"No\"\n        }\n        var s = \"\"\n        var i = 0\n        var j = 0\n        var k = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p1 = 0\n        var p2 = 0\n        var p3 = 0\n        var p4 = 0\n        var p5 = 0\n        var p6 = 0\n        var p7 = 0\n        var p8 = 0\n        var p9 = 0\n        var p10 = 0\n        var p11 = 0\n        var p12 = 0\n        var p13 = 0\n        var p14 = 0\n        var p15 = 0\n        var p16 = 0\n        var p17 = 0\n        var p18 = 0\n        var p19 = 0\n        var p20 = 0\n        var p21 = 0\n        var p22 = 0\n        var p23 = 0\n        var p24 = 0\n        var p25 = 0\n        var p26 = 0\n        var p27 = 0\n        var p28 = 0\n        var p29 = 0\n        var p30 = 0\n        var p31 = 0\n        var p32 = 0\n        var p33 = 0\n        var p34 = 0\n        var p35 = 0\n        var p36 = 0\n        var p37 = 0\n        var p38 = 0\n        var p39 = 0\n        var p40 = 0\n        var p41 = 0\n        var p42 = 0\n        var p43 = 0\n        var p44 = 0\n        var p45 = 0\n        var p46 = 0\n        var p47 = 0\n        var p48 = 0\n        var p49 = 0\n        var p50 = 0\n        var p51 = 0\n        var p52 = 0\n        var p53 = 0\n        var p54 = 0\n        var p55 = 0\n        var p56 = 0\n        var p57 = 0\n        var p\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293107,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpes67sdsy.scala:93:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m93 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpes67sdsy.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpes67sdsy.scala:21:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpes67sdsy.scala:93:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m93 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        } else {\n            var left = lst.head\n            var right = lst.tail.head\n            var leftParens = 0\n            var rightParens = 0\n            var leftParensStack = List.empty()\n            var rightParensStack = List.empty()\n            var leftParensStackSize = 0\n            var rightParensStackSize = 0\n            var leftParensStackSizeStack = List.empty()\n            var rightParensStackSizeStack = List.empty()\n            var leftParensStackSizeStackSize = 0\n            var rightParensStackSizeStackSize = 0\n            var leftParensStackSizeStackSizeStack = List.empty()\n            var rightParensStackSizeStackSize = 0\n            var leftParensStackSizeStackSizeStack = List.empty()\n            var rightParensStackSizeStackSizeStack = List.empty()\n            var leftParensStackSizeStackSizeStackSize = 0\n            var rightParensStackSizeStackSizeStackSize = 0\n            var leftParensStackSizeStackSizeStackSizeStack = List.empty()\n            var rightParensStackSizeStackSizeStackSize = 0\n            var leftParensStackSizeStackSizeStackSizeStack = List.empty()\n            var rightParensStackSizeStackSizeStackSize = 0\n            var leftParensStackSizeStackSizeStackSizeStack = List.empty()\n            var rightParensStackSizeStackSizeStackSize = 0\n            var leftParensStackSizeStackSizeStackSizeStack = List.empty()\n            var rightParensStackSizeStackSizeStackSize = 0\n            var leftParensStackSizeStackSizeStackSizeStack = List.empty()\n            var rightParensStackSizeStackSizeStackSize = 0\n            var leftParensStackSizeStackSizeStackSizeStack = List.empty()\n            var rightParensStackSizeStackSizeStackSize = 0\n            var leftParensStackSizeStackSizeStackSizeStack = List.empty()\n            var rightParensStackSizeStackSizeStackSize = 0\n            var leftParensStackSizeStackSizeStackSizeStack = List.\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293111,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpizs8n4wi.scala:54:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpizs8n4wi.scala:71:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpizs8n4wi.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpizs8n4wi.scala:34:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mrightParensStackSizeStackSize\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParensStackSizeStackSize is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParensStackSizeStackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpizs8n4wi.scala:35:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mleftParensStackSizeStackSizeStack\u001b[0m = List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParensStackSizeStackSizeStack is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftParensStackSizeStackSizeStack\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpizs8n4wi.scala:40:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mrightParensStackSizeStackSizeStackSize\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"No\"\n        } else {\n            var s = lst.head\n            var p = lst.tail\n            var b = 0\n            var i = 0\n            while (i < s.length) {\n                if (s[i] == '(') {\n                    b += 1\n                } else {\n                    b -= 1\n                }\n                if (b < 0) {\n                    return \"No\"\n                }\n                i += 1\n            }\n            if (b == 0) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293104,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp1ka5r05y.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1ka5r05y.scala:26:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        var leftOpen = 0\n        var rightOpen = 0\n        var leftClose = 0\n        var rightClose = 0\n        for (i <- lst) {\n            if (i == \"(\") {\n                leftParens += 1\n                leftOpen += 1\n            } else if (i == \")\") {\n                rightParens += 1\n                rightOpen += 1\n            } else if (i == \")\") {\n                rightClose += 1\n            } else {\n                leftOpen -= 1\n                rightOpen -= 1\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        if (leftOpen != rightOpen) {\n            return \"No\"\n        }\n        if (leftOpen != 0) {\n            return \"No\"\n        }\n        if (rightOpen != 0) {\n            return \"No\"\n        }\n        if (leftClose != rightClose) {\n            return \"No\"\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293105,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpu89g755v.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var s = \"\"\n        for(var i = 0; i < lst.length; i++) {\n            if(lst[i] == \")\") {\n                s += \")\"\n            } else {\n                s += \"(\"\n            }\n        }\n        if(s.count(\"(\") == s.count(\")\")) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293116,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpwcy896ck.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mfor\u001b[0m(\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^\u001b[0m\n\u001b[31m   |\u001b[0m            pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwcy896ck.scala:19:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mfor\u001b[0m(\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpwcy896ck.scala:19:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mfor\u001b[0m(\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwcy896ck.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mfor\u001b[0m(\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.Implicit",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var i = 0\n        while (i < lst.size) {\n            if (s.charAt(0) == '(') {\n                i += 1\n                s = lst.get(i)\n            } else {\n                if (s.charAt(0) == ')') {\n                    i += 1\n                    s = lst.get(i)\n                } else {\n                    return \"No\"\n                }\n            }\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293114,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp9fa7ne6k.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9fa7ne6k.scala:26:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                s = lst.get(i)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of List[String] - did you mean lst.seq?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9fa7ne6k.scala:30:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                    s = lst.get(i)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue get is not a member of List[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"No\"\n        }\n        if (lst.length == 1) {\n            return \"Yes\"\n        }\n        if (lst.length == 2) {\n            if (lst.get(0) == \"(\" && lst.get(1) == \")\") {\n                return \"Yes\"\n            }\n            if (lst.get(0) == \")\" && lst.get(1) == \")\") {\n                return \"No\"\n            }\n        }\n        var s = \"\"\n        var i = 0\n        var j = 0\n        var p = 0\n        while (i < lst.length) {\n            if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                p++\n                i++\n                j++\n            } else if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                p--\n                i++\n                j++\n            } else if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                p--\n                i++\n                j++\n            } else if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                p++\n                i++\n                j++\n            } else if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                p--\n                i++\n                j++\n            } else if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                p--\n                i++\n                j++\n            } else if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                p++\n                i++\n                j++\n            } else if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                p--\n                i++\n                j++\n            } else if (lst.get(i) == \"(\" && lst.get(\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293119,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpmb9hoi13.scala:40:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                j++\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpmb9hoi13.scala:44:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m                j++\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpmb9hoi13.scala:48:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m                j++\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpmb9hoi13.scala:52:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m                j++\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpmb9hoi13.scala:56:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m                j++\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpmb9hoi13.scala:60:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m                j++\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        } else {\n            var s = lst.head\n            var l = lst.tail\n            var r = matchParens(l)\n            if (r == \"Yes\") {\n                return \"Yes\"\n            } else {\n                if (s.charAt(0) == '(') {\n                    return \"No\"\n                } else {\n                    return \"Yes\"\n                }\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293110,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp3o4zywhb.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var p = lst.tail\n        var b = s.count(\"(\");\n        var e = s.count(\")\");\n        if (b == e) {\n            return \"Yes\"\n        }\n        if (b > e) {\n            return \"No\"\n        }\n        if (b < e) {\n            return \"No\"\n        }\n        var i = 0\n        while (i < p.length) {\n            if (p[i].count(\"(\") != p[i].count(\")\")) {\n                return \"No\"\n            }\n            i = i + 1\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293118,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp6f5vcc0w.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6f5vcc0w.scala:23:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mb\u001b[0m = s.count(\u001b[31m\"(\"\u001b[0m);\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    (\u001b[32m\"(\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                        Required: Char => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6f5vcc0w.scala:24:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36me\u001b[0m = s.count(\u001b[31m\")\"\u001b[0m);\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    (\u001b[32m\")\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                        Required: Char => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6f5vcc0w.scala:36:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            \u001b[33mif\u001b[0m (p[\u001b[35mi\u001b[0m].count(\u001b[31m\"(\"\u001b[0m) != p[\u001b[35mi\u001b[0m].count(\u001b[31m\")\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        } else {\n            var left = lst.head\n            var right = lst.tail.head\n            var leftParens = 0\n            var rightParens = 0\n            for (i <- lst.tail.tail.size - 1) {\n                if (leftParens == rightParens) {\n                    leftParens = leftParens + 1\n                    rightParens = rightParens + 1\n                } else if (leftParens > rightParens) {\n                    rightParens = rightParens + 1\n                } else {\n                    leftParens = leftParens + 1\n                }\n            }\n            if (leftParens == rightParens) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293117,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp_im7w2ch.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_im7w2ch.scala:25:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- lst.tail.tail.size - \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value foreach is not a member of Int\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        }\n        if (lst.size() == 1) {\n            return \"No\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        for (i <- 0 until left.size) {\n            if (left.get(i) == '(') {\n                leftParens += 1\n            } else {\n                leftParens -= 1\n            }\n        }\n        for (i <- 0 until right.size) {\n            if (right.get(i) == '(') {\n                rightParens += 1\n            } else {\n                rightParens -= 1\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        var leftParens = 0\n        var rightParens = 0\n        for (i <- 0 until left.size) {\n            if (left.get(i) == '(') {\n                leftParens += 1\n            } else {\n                leftParens -= 1\n            }\n        }\n        for (i <- 0 until right.size) {\n            if (right.get(i) == '(') {\n                rightParens += 1\n            } else {\n                rightParens -= 1\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        var leftParens = 0\n        var rightParens = 0\n        for (i <- 0 until left.size) {\n            if (left.get(i) == '(') {\n                leftParens += 1\n            } else {\n                leftParens -= 1\n            }\n        }\n        for (i <- 0 until right.size) {\n            if (right.get(i) == '(') {\n                rightParens += 1\n            } else {\n                rightParens -= 1\n            }\n        }\n        if (leftParens != rightParens) {\n            \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293122,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpejg6qzpg.scala:99:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m99 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpejg6qzpg.scala:45:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftParens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpejg6qzpg.scala:46:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpejg6qzpg.scala:64:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftParens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpejg6qzpg.scala:65:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m65 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpejg6qzpg.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"No\"\n        }\n        if (lst.size() == 1) {\n            return \"Yes\"\n        }\n        if (lst.size() == 2) {\n            if (lst.get(0) == \"(\" && lst.get(1) == \")\") {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.size() == 3) {\n            if (lst.get(0) == \"(\" && lst.get(1) == \"(\" && lst.get(2) == \")\") {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.size() == 4) {\n            if (lst.get(0) == \"(\" && lst.get(1) == \"(\" && lst.get(2) == \"(\" && lst.get(3) == \")\") {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.size() == 5) {\n            if (lst.get(0) == \"(\" && lst.get(1) == \"(\" && lst.get(2) == \"(\" && lst.get(3) == \"(\" && lst.get(4) == \")\") {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.size() == 6) {\n            if (lst.get(0) == \"(\" && lst.get(1) == \"(\" && lst.get(2) == \"(\" && lst.get(3) == \"(\" && lst.get(4) == \"(\" && lst.get(5) == \")\") {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.size() == 7) {\n            if (lst.get(0) == \"(\" && lst.get(1) == \"(\" && lst.get(\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293125,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp45b6xja7.scala:60:66 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m            \u001b[33mif\u001b[0m (lst.get(\u001b[31m0\u001b[0m) == \u001b[31m\"(\"\u001b[0m && lst.get(\u001b[31m1\u001b[0m) == \u001b[31m\"(\"\u001b[0m && lst.get(\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp45b6xja7.scala:78:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp45b6xja7.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp45b6xja7.scala:21:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp45b6xja7.scala:24:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m2\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp45b6xja7.scala:25:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (lst.get(\u001b[31m0\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var result = \"No\"\n        var leftParens = 0\n        var rightParens = 0\n        var leftOpen = 0\n        var rightOpen = 0\n        var leftOpenStack = List.empty[String]\n        var rightOpenStack = List.empty[String]\n        while (leftParens != leftOpen) {\n            leftOpenStack = leftOpenStack.append(left)\n            leftParens = leftParens + 1\n            leftOpen = leftOpen + 1\n        }\n        while (rightParens != rightOpen) {\n            rightOpenStack = rightOpenStack.append(right)\n            rightParens = rightParens + 1\n            rightOpen = rightOpen + 1\n        }\n        for (var i = 0; i < leftOpenStack.length; i++) {\n            if (leftOpenStack.apply(i) == \"(\" && rightOpenStack.apply(i) == \")\") {\n                leftParens = leftParens - 1\n                rightParens = rightParens - 1\n                leftOpen = leftOpen - 1\n                rightOpen = rightOpen - 1\n            } else {\n                result = \"No\"\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293124,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp1zwihlfg.scala:40:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < leftOpenStack.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp1zwihlfg.scala:40:48 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < leftOpenStack.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp1zwihlfg.scala:40:53 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < leftOpenStack.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                     pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp1zwihlfg.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1zwihlfg.scala:31:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            leftOpenStack = leftOpenStack.append(left)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[String] - did you mean List[String].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1zwihlfg.scala:36:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            rightOpenStack = rightOpenS",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        }\n        var s = lst.head\n        var i = 1\n        var j = 1\n        var p = 0\n        while (i < lst.size) {\n            if (s.charAt(p) == '(') {\n                p += 1\n            } else {\n                p -= 1\n            }\n            if (p == -1) {\n                return \"No\"\n            }\n            if (s.charAt(p) == ')') {\n                p += 1\n            } else {\n                p -= 1\n            }\n            if (p == -1) {\n                return \"No\"\n            }\n            if (s.charAt(p) == '(') {\n                i += 1\n            } else {\n                i -= 1\n            }\n            if (i == lst.size) {\n                return \"No\"\n            }\n            if (s.charAt(p) == ')') {\n                j += 1\n            } else {\n                j -= 1\n            }\n            if (j == lst.size) {\n                return \"No\"\n            }\n            if (s.charAt(p) == '(') {\n                i += 1\n            } else {\n                i -= 1\n            }\n            if (i == lst.size) {\n                return \"No\"\n            }\n            if (s.charAt(p) == '(') {\n                j += 1\n            } else {\n                j -= 1\n            }\n            if (j == lst.size) {\n                return \"No\"\n            }\n            if (s.charAt(p) == '(') {\n                i += 1\n            } else {\n                i -= 1\n            }\n            if (i == lst.size) {\n                return \"No\"\n            }\n            if (s.charAt(p) == '(') {\n                j += 1\n            } else {\n                j -= 1\n            }\n            if (j == lst.size) {\n                return \"No\"\n            }\n            if (s.charAt(p) == '(') {\n                \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293122,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmphqjtvlel.scala:109:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m109 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmphqjtvlel.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphqjtvlel.scala:25:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m 25 |\u001b[0m        \u001b[33mwhile\u001b[0m (i < lst.size) {\n\u001b[31m\u001b[31m    |\u001b[0m        ^\u001b[0m\n\u001b[31m    |\u001b[0m        Found:    Unit\n\u001b[31m    |\u001b[0m        Required: String\n\u001b[31m 26 |\u001b[0m            \u001b[33mif\u001b[0m (s.charAt(p) == \u001b[31m'('\u001b[0m) {\n\u001b[31m 27 |\u001b[0m                p += \u001b[31m1\u001b[0m\n\u001b[31m 28 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m 29 |\u001b[0m                p -= \u001b[31m1\u001b[0m\n\u001b[31m 30 |\u001b[0m            }\n\u001b[31m 31 |\u001b[0m            \u001b[33mif\u001b[0m (p == -\u001b[31m1\u001b[0m) {\n\u001b[31m 32 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31m\"No\"\u001b[0m\n\u001b[31m 33 |\u001b[0m            }\n\u001b[31m 34 |\u001b[0m            \u001b[33mif\u001b[0m (s.charAt(p) == \u001b[31m')'\u001b[0m) {\n\u001b[31m 35 |\u001b[0m                p += \u001b[31m1\u001b[0m\n\u001b[31m 36 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m 37 |\u001b[0m                p -= \u001b[31m1\u001b[0m\n\u001b[31m 38 |\u001b[0m            }\n\u001b[31m 39 |\u001b[0m            \u001b[33mif\u001b[0m (p == -\u001b[31m1\u001b[0m) {\n\u001b[31m 40 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31m\"No\"\u001b[0m\n\u001b[31m 41 |\u001b[0m            }\n\u001b[31m 42 |\u001b[0m            \u001b[33mif\u001b[0m (s.charAt(p) == \u001b[31m'('\u001b[0m) {\n\u001b[31m 43 |\u001b[0m                i += \u001b[31m1\u001b[0m\n\u001b[31m 44 |\u001b[0m            } \u001b[33melse\u001b[0m {\n\u001b[31m 45 |\u001b[0m                i -= \u001b[31m1\u001b[0m\n\u001b[31m 46 |\u001b[0m            }\n\u001b[31m 47 |\u001b[0m            \u001b[33mif\u001b[0m (i == lst.size) {\n\u001b[31m 48 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[31m\"No\"\u001b[0m\n\u001b[31m 49 |\u001b[0m            }\n\u001b[31m 50 |\u001b[0m            \u001b[33mif\u001b[0m (s.charAt(p) == \u001b[31m')'\u001b[0m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var lst2 = lst.tail\n        var res = \"No\"\n        var parens = 0\n        var open = 0\n        var close = 0\n        var i = 0\n        while (i < s.length) {\n            if (s[i] == '(') {\n                open += 1\n            } else if (s[i] == ')') {\n                close += 1\n            }\n            i += 1\n        }\n        if (open == close) {\n            res = \"Yes\"\n        } else {\n            for (i = 0; i < lst2.length; i++) {\n                if (lst2[i] == '(') {\n                    open += 1\n                } else if (lst2[i] == ')') {\n                    close += 1\n                }\n                if (open == close) {\n                    res = \"Yes\"\n                    break\n                }\n            }\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293124,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp2sehi3x8.scala:39:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            \u001b[33mfor\u001b[0m (i = \u001b[31m0\u001b[0m; i < lst2.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp2sehi3x8.scala:39:39 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            \u001b[33mfor\u001b[0m (i = \u001b[31m0\u001b[0m; i < lst2.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp2sehi3x8.scala:39:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            \u001b[33mfor\u001b[0m (i = \u001b[31m0\u001b[0m; i < lst2.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp2sehi3x8.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2sehi3x8.scala:29:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2sehi3x8.scala:31:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (s[i] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        } else {\n            var s = lst.head\n            var l = lst.tail\n            var p = s.indexOf('(')\n            var c = s.indexOf(')')\n            if (p == -1 || c == -1) {\n                return \"No\"\n            } else {\n                if (p > c) {\n                    return \"No\"\n                } else {\n                    var r = matchParens(l)\n                    if (r == \"Yes\") {\n                        return \"Yes\"\n                    } else {\n                        return \"No\"\n                    }\n                }\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293114,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpsd1euw45.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        } else {\n            var s = lst.head\n            var lst2 = lst.tail\n            var res = \"No\"\n            var parens = 0\n            while (true) {\n                if (s.charAt(0) == '(') {\n                    parens += 1\n                } else if (s.charAt(0) == ')') {\n                    parens -= 1\n                }\n                if (parens == 0) {\n                    if (lst2.isEmpty()) {\n                        res = \"Yes\"\n                        break\n                    } else {\n                        s = lst2.head\n                        lst2 = lst2.tail\n                    }\n                } else {\n                    if (lst2.isEmpty()) {\n                        break\n                    } else {\n                        s = lst2.head\n                        lst2 = lst2.tail\n                    }\n                }\n            }\n            return res\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293116,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmppki2ej6p.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmppki2ej6p.scala:32:29 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    \u001b[33mif\u001b[0m (lst2.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppki2ej6p.scala:34:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                        break\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmppki2ej6p.scala:40:29 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                    \u001b[33mif\u001b[0m (lst2.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppki2ej6p.scala:41:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m                        break\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var s = \"\"\n        for(i <- 0 until lst.length) {\n            if(lst[i] == \"(\") {\n                s += \"(\"\n            } else if(lst[i] == \")\") {\n                s += \")\"\n            } else {\n                s += lst[i]\n            }\n        }\n        if(s.count(\"(\") == s.count(\")\")) {\n            \"Yes\"\n        } else {\n            \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293081,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp12z419jw.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mif\u001b[0m(lst[\u001b[35mi\u001b[0m] == \u001b[31m\"(\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp12z419jw.scala:22:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m(lst[i] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp12z419jw.scala:25:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                s += lst[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp12z419jw.scala:25:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                s += lst[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp12z419jw.scala:28:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mif\u001b[0m(s.count(\u001b[31m\"(\"\u001b[0m) == s.count(\u001b[31m\")\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Found:    (\u001b[32m\"(\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                   Required: Char => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp12z419jw.scala:28:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mif\u001b[0m(s.count(\u001b[31m\"(\"\u001b[0m) == s.count(\u001b[31m\")\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var l = lst.tail\n        var c = 0\n        var p = 0\n        var i = 0\n        while (i < s.length) {\n            if (s[i] == '(') {\n                c += 1\n            } else if (s[i] == ')') {\n                c -= 1\n            }\n            if (c < 0) {\n                return \"No\"\n            }\n            i += 1\n        }\n        while (l != List.empty) {\n            if (l.head[0] == '(') {\n                c += 1\n            } else if (l.head[0] == ')') {\n                c -= 1\n            }\n            if (c < 0) {\n                return \"No\"\n            }\n            l = l.tail\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293119,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpmwvq9rtk.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmwvq9rtk.scala:27:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmwvq9rtk.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (s[i] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpmwvq9rtk.scala:38:22 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            \u001b[33mif\u001b[0m (l.head[\u001b[31m0\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mStringOps\u001b[0m does not take type parameters\n\u001b[31m\u001b[31m-- Error: /tmp/tmpmwvq9rtk.scala:40:29 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (l.head[\u001b[31m0\u001b[0m] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mStringOps\u001b[0m does not take type parameters\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        if (lst.size() == 1) {\n            return \"No\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        var leftOpen = 0\n        var rightOpen = 0\n        var leftOpenParens = 0\n        var rightOpenParens = 0\n        var leftOpenParensStack = List.empty()\n        var rightOpenParensStack = List.empty()\n        var leftOpenParensStackIndex = 0\n        var rightOpenParensStackIndex = 0\n        var leftOpenParensStackSize = 0\n        var rightOpenParensStackSize = 0\n        var leftOpenParensStackSizeStack = List.empty()\n        var rightOpenParensStackSizeStack = List.empty()\n        var leftOpenParensStackSizeStackIndex = 0\n        var rightOpenParensStackSizeStackIndex = 0\n        var leftOpenParensStackSizeStackSize = 0\n        var rightOpenParensStackSizeStackSize = 0\n        var leftOpenParensStackSizeStackSizeStack = List.empty()\n        var rightOpenParensStackSizeStackSizeStack = List.empty()\n        var leftOpenParensStackSizeStackSizeStackIndex = 0\n        var rightOpenParensStackSizeStackSizeStackIndex = 0\n        var leftOpenParensStackSizeStackSizeStackSize = 0\n        var rightOpenParensStackSizeStackSizeStackSize = 0\n        var leftOpenParensStackSizeStackSizeStackSizeStack = List.empty()\n        var rightOpenParensStackSizeStackSizeStackSizeStack = List.empty()\n        var leftOpenParensStackSizeStackSizeStackSizeStackIndex = 0\n        var rightOpenParensStackSizeStackSizeStackSizeStackIndex = 0\n        var leftOpenParensStackSizeStackSizeStackSizeStackSize = 0\n        var rightOpenParensStackSizeStackSizeStackSizeStackSize = 0\n        var leftOpenParensStackSizeStackSizeStackSizeStackSizeStack = List.empty()\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293127,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpgk1lr3q4.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpgk1lr3q4.scala:21:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpgk1lr3q4.scala:32:44 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftOpenParensStack\u001b[0m = List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): A\n\u001b[31m\u001b[31m-- Error: /tmp/tmpgk1lr3q4.scala:33:45 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightOpenParensStack\u001b[0m = List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): A\n\u001b[31m\u001b[31m-- Error: /tmp/tmpgk1lr3q4.scala:38:53 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftOpenParensStackSizeStack\u001b[0m = List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): A\n\u001b[31m\u001b[31m-- Error: /tmp/tmpgk1lr3q4.scala:39:54 -------------------------------------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        } else {\n            var s = lst.head\n            var r = lst.tail\n            var b = s.count(\"(\")\n            var e = s.count(\")\")\n            if (b == e) {\n                return \"Yes\"\n            } else if (b > e) {\n                return \"No\"\n            } else {\n                return matchParens(r).equals(\"Yes\") ? \"Yes\" : \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293128,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpsay85_m9.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsay85_m9.scala:23:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mb\u001b[0m = s.count(\u001b[31m\"(\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (\u001b[32m\"(\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                            Required: Char => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsay85_m9.scala:24:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36me\u001b[0m = s.count(\u001b[31m\")\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (\u001b[32m\")\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                            Required: Char => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsay85_m9.scala:30:52 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                \u001b[33mreturn\u001b[0m matchParens(r).equals(\u001b[31m\"Yes\"\u001b[0m) ? \u001b[31m\"Yes\"\u001b[0m : \u001b[31m\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value ? is not a member of Boolean\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var l = lst.tail\n        var p = 0\n        var c = 0\n        while (p < s.length) {\n            if (s[p] == '(') {\n                c += 1\n            } else {\n                c -= 1\n            }\n            if (c < 0) {\n                return \"No\"\n            }\n            p += 1\n        }\n        while (l != List.empty) {\n            var s = l.head\n            var l = l.tail\n            var p = 0\n            var c = 0\n            while (p < s.length) {\n                if (s[p] == '(') {\n                    c += 1\n                } else {\n                    c -= 1\n                }\n                if (c < 0) {\n                    return \"No\"\n                }\n                p += 1\n            }\n            l = l.tail\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293121,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy4sm6rq0.scala:26:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (s[\u001b[35mp\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type p\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpy4sm6rq0.scala:38:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36ml\u001b[0m = l.tail\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Recursive \u001b[33mvariable\u001b[0m \u001b[35ml\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy4sm6rq0.scala:42:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m                \u001b[33mif\u001b[0m (s[\u001b[35mp\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: type p\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        } else {\n            var s = lst.head\n            var i = 0\n            var j = 0\n            var parens = 0\n            while (i < s.length) {\n                if (s[i] == '(') {\n                    parens += 1\n                } else if (s[i] == ')') {\n                    parens -= 1\n                }\n                i += 1\n            }\n            if (parens == 0) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293122,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp1zodzdv7.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1zodzdv7.scala:26:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1zodzdv7.scala:28:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (s[i] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        } else {\n            var s = lst.head\n            var i = 0\n            var j = 0\n            var p = 0\n            var q = 0\n            var r = 0\n            var t = 0\n            var u = 0\n            var v = 0\n            var w = 0\n            var x = 0\n            var y = 0\n            var z = 0\n            var a = 0\n            var b = 0\n            var c = 0\n            var d = 0\n            var e = 0\n            var f = 0\n            var g = 0\n            var h = 0\n            var i = 0\n            var j = 0\n            var k = 0\n            var l = 0\n            var m = 0\n            var n = 0\n            var o = 0\n            var p = 0\n            var q = 0\n            var r = 0\n            var s = 0\n            var t = 0\n            var u = 0\n            var v = 0\n            var w = 0\n            var x = 0\n            var y = 0\n            var z = 0\n            var a = 0\n            var b = 0\n            var c = 0\n            var d = 0\n            var e = 0\n            var f = 0\n            var g = 0\n            var h = 0\n            var i = 0\n            var j = 0\n            var k = 0\n            var l = 0\n            var m = 0\n            var n = 0\n            var o = 0\n            var p = 0\n            var q = 0\n            var r = 0\n            var s = 0\n            var t = 0\n            var u = 0\n            var v = 0\n            var w = 0\n            var x = 0\n            var y = 0\n            var z = 0\n            var a = 0\n            var b = 0\n            var c = 0\n            var d = 0\n            var e = 0\n            var f = 0\n            var g = 0\n            var h = 0\n            var i = 0\n            var j = 0\n            var k = 0\n            var l = 0\n            var m = 0\n            var n = 0\n            var o = 0\n            var p = 0\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293129,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpi0xusa17.scala:119:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m119 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpi0xusa17.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpi0xusa17.scala:42:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mi\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mi is already defined as \u001b[33mvariable\u001b[0m \u001b[35mi\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpi0xusa17.scala:43:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mj\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mj is already defined as \u001b[33mvariable\u001b[0m \u001b[35mj\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpi0xusa17.scala:49:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mp\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mp is already defined as \u001b[33mvariable\u001b[0m \u001b[35mp\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpi0xusa17.scala:50:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mq\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mq is already defined as \u001b[33mvariable\u001b[0m \u001b[35mq\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        }\n        var s = lst.head\n        var i = 0\n        while (i < lst.size) {\n            if (s.charAt(0) == '(') {\n                i += 1\n                s = s.substring(1)\n            } else {\n                i += 1\n                s = s.substring(1)\n            }\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293124,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp0u12y_9p.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var i = 0\n        var j = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s1 = \"\"\n        var s2 = \"\"\n        var s3 = \"\"\n        var s4 = \"\"\n        var s5 = \"\"\n        var s6 = \"\"\n        var s7 = \"\"\n        var s8 = \"\"\n        var s9 = \"\"\n        var s10 = \"\"\n        var s11 = \"\"\n        var s12 = \"\"\n        var s13 = \"\"\n        var s14 = \"\"\n        var s15 = \"\"\n        var s16 = \"\"\n        var s17 = \"\"\n        var s18 = \"\"\n        var s19 = \"\"\n        var s20 = \"\"\n        var s21 = \"\"\n        var s22 = \"\"\n        var s23 = \"\"\n        var s24 = \"\"\n        var s25 = \"\"\n        var s26 = \"\"\n        var s27 = \"\"\n        var s28 = \"\"\n        var s29 = \"\"\n        var s30 = \"\"\n        var s31 = \"\"\n        var s32 = \"\"\n        var s33 = \"\"\n        var s34 = \"\"\n        var s35 = \"\"\n        var s36 = \"\"\n        var s37 = \"\"\n        var s38 = \"\"\n        var s39 = \"\"\n        var s40 = \"\"\n        var s41 = \"\"\n        var s42 = \"\"\n        var s43 = \"\"\n        var s44 = \"\"\n        var s45 = \"\"\n        var s46 = \"\"\n        var s47 = \"\"\n        var s48 = \"\"\n        var s49 = \"\"\n        var s50 = \"\"\n        var s51 = \"\"\n        var s52 = \"\"\n        var s53 = \"\"\n        var s54 = \"\"\n        var s55 = \"\"\n        var s56 = \"\"\n        var s57 = \"\"\n        var s58 = \"\"\n        var s59 = \"\"\n        var s60 = \"\"\n        var s61 = \"\"\n        var s62 = \"\"\n        var s63 = \"\"\n        var s64 = \"\"\n        var s65 =\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293129,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp5q439nd0.scala:91:17 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m91 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36ms65\u001b[0m =\n\u001b[31m\u001b[31m   |\u001b[0m                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                 expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp5q439nd0.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5q439nd0.scala:92:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        }\n        var s = lst.head\n        var i = 0\n        while (i < lst.size) {\n            if (s.charAt(0) == '(') {\n                s = s.substring(1)\n            } else {\n                s = s.substring(1)\n                if (s.charAt(0) == ')') {\n                    s = s.substring(1)\n                } else {\n                    return \"No\"\n                }\n            }\n            i = i + 1\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293127,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpqyd5tleb.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"No\"\n        }\n        if (lst.length == 1) {\n            return \"Yes\"\n        }\n        if (lst.length == 2) {\n            if (lst.get(0) == \"(\" && lst.get(1) == \")\") {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.length == 3) {\n            if (lst.get(0) == \"(\" && lst.get(1) == \"(\" && lst.get(2) == \")\") {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.length == 4) {\n            if (lst.get(0) == \"(\" && lst.get(1) == \"(\" && lst.get(2) == \"(\" && lst.get(3) == \")\") {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.length == 5) {\n            if (lst.get(0) == \"(\" && lst.get(1) == \"(\" && lst.get(2) == \"(\" && lst.get(3) == \"(\" && lst.get(4) == \")\") {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.length == 6) {\n            if (lst.get(0) == \"(\" && lst.get(1) == \"(\" && lst.get(2) == \"(\" && lst.get(3) == \"(\" && lst.get(4) == \"(\" && lst.get(5) == \")\") {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.length == 7) {\n            if (lst.get(0) == \"(\" && lst.get(1) == \"(\" && lst.get(2) == \"(\" && lst\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293078,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpe54rz855.scala:61:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpe54rz855.scala:78:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe54rz855.scala:25:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (lst.get(\u001b[31m0\u001b[0m) == \u001b[31m\"(\"\u001b[0m && lst.get(\u001b[31m1\u001b[0m) == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of List[String] - did you mean lst.seq?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe54rz855.scala:32:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mif\u001b[0m (lst.get(\u001b[31m0\u001b[0m) == \u001b[31m\"(\"\u001b[0m && lst.get(\u001b[31m1\u001b[0m) == \u001b[31m\"(\"\u001b[0m && lst.get(\u001b[31m2\u001b[0m) == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue get is not a member of List[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe54rz855.scala:39:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            \u001b[33mif\u001b[0m (lst.get(\u001b[31m0\u001b[0m) == \u001b[31m\"(\"\u001b[0m && lst.get(\u001b[31m1\u001b[0m) == \u001b[31m\"(\"\u001b[0m && lst.get(\u001b[31m2\u001b[0m) == \u001b[31m\"(\"\u001b[0m && lst.get(\u001b[31m3\u001b[0m) == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue get is not a member of List[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.Im",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var left = 0\n        var right = 0\n        var result = \"\"\n        for (s in lst) {\n            if (s == \"(\") {\n                left += 1\n            } else {\n                right += 1\n            }\n            if (left == right) {\n                result += s\n            }\n        }\n        if (left == right) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293135,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpy0nsn3be.scala:21:23 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (s in lst) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       '<-' expected, but '{' found\n\u001b[31m\u001b[31m-- [E020] Syntax Error: /tmp/tmpy0nsn3be.scala:33:10 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m          ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          \u001b[33myield\u001b[0m or \u001b[33mdo\u001b[0m expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy0nsn3be.scala:30:9 -------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m         ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator asScala\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.set asScala\n\u001b[31m   |\u001b[0m\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var p = lst.tail\n        var i = 0\n        var j = 0\n        var n = 0\n        var m = 0\n        var b = false\n        while (i < s.length) {\n            if (s[i] == '(') {\n                n = n + 1\n            } else {\n                if (s[i] == ')') {\n                    m = m + 1\n                }\n            }\n            i = i + 1\n        }\n        if (n == m) {\n            return \"Yes\"\n        }\n        while (j < p.length) {\n            if (p[j] == '(') {\n                n = n - 1\n            } else {\n                if (p[j] == ')') {\n                    m = m - 1\n                }\n            }\n            j = j + 1\n        }\n        if (n == m) {\n            return \"Yes\"\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293129,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpi522efs_.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpi522efs_.scala:29:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpi522efs_.scala:32:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpi522efs_.scala:42:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m            \u001b[33mif\u001b[0m (p[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpi522efs_.scala:45:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m                \u001b[33mif\u001b[0m (p[\u001b[35mj\u001b[0m] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var s = \"\"\n        for (i <- 0 until lst.length) {\n            if (lst[i] == \"(\") {\n                s += \"(\"\n            } else if (lst[i] == \")\") {\n                s += \")\"\n            } else {\n                s += lst[i]\n            }\n        }\n        if (s.count(\"(\") == s.count(\")\")) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293137,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj918r1_n.scala:20:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mif\u001b[0m (lst[\u001b[35mi\u001b[0m] == \u001b[31m\"(\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj918r1_n.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (lst[i] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj918r1_n.scala:25:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                s += lst[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj918r1_n.scala:25:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                s += lst[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpj918r1_n.scala:28:20 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mif\u001b[0m (s.count(\u001b[31m\"(\"\u001b[0m) == s.count(\u001b[31m\")\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Found:    (\u001b[32m\"(\"\u001b[0m : String)\n\u001b[31m   |\u001b[0m                    Required: Char => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpj918r1_n.scala:28:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mif\u001b[0m (s.count(\u001b[31m\"(\"\u001b[0m) == s.count(\u001b[31m\")\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^\u001b[0m\n\u001b[31m   |",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        var leftParensStack = List.empty()\n        var rightParensStack = List.empty()\n        var leftParensStackSize = 0\n        var rightParensStackSize = 0\n        var leftParensStackSizeStack = List.empty()\n        var rightParensStackSizeStack = List.empty()\n        var leftParensStackSizeStackSize = 0\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSizeStack = List.empty()\n        var leftParensStackSizeStackSizeStackSize = 0\n        var rightParensStackSizeStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStackSizeStack = List.empty()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293138,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4xshm1wh.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParensStackSizeStackSize\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParensStackSizeStackSize is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParensStackSizeStackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4xshm1wh.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParensStackSizeStackSizeStack\u001b[0m = List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParensStackSizeStackSizeStack is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftParensStackSizeStackSizeStack\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4xshm1wh.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParensStackSizeStackSizeStackSize\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParensStackSizeStackSizeStackSize is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParensStackSizeStackSizeStackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4xshm1wh.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParensStackSizeStackSizeStackSizeStack\u001b[0m = List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParensStackSizeStackSizeStackSizeStack is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftParensStackSizeStackSizeStackSizeStack\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var parens = 0\n        var i = 0\n        while (i < lst.length) {\n            if (lst[i] == \"(\") {\n                parens += 1\n            } else if (lst[i] == \")\") {\n                parens -= 1\n            }\n            i += 1\n        }\n        if (parens == 0) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293131,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4rjr39gb.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mif\u001b[0m (lst[\u001b[35mi\u001b[0m] == \u001b[31m\"(\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4rjr39gb.scala:23:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (lst[i] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        }\n        if (lst.size() == 1) {\n            return \"No\"\n        }\n        if (lst.size() == 2) {\n            if (lst.get(0).equals(\"()\") && lst.get(1).equals(\"()\")) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.size() == 3) {\n            if (lst.get(0).equals(\"()\") && lst.get(1).equals(\"()\") && lst.get(2).equals(\"()\")) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.size() == 4) {\n            if (lst.get(0).equals(\"()\") && lst.get(1).equals(\"()\") && lst.get(2).equals(\"()\") && lst.get(3).equals(\"()\")) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.size() == 5) {\n            if (lst.get(0).equals(\"()\") && lst.get(1).equals(\"()\") && lst.get(2).equals(\"()\") && lst.get(3).equals(\"()\") && lst.get(4).equals(\"()\")) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.size() == 6) {\n            if (lst.get(0).equals(\"()\") && lst.get(1).equals(\"()\") && lst.get(2).equals(\"()\") && lst.get(3).equals(\"()\") && lst.get(4).equals(\"()\") && lst.get(5).equals(\"()\")) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n        if (lst.size()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293056,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8akh_9mf.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp8akh_9mf.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp8akh_9mf.scala:21:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp8akh_9mf.scala:24:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m2\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8akh_9mf.scala:25:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (lst.get(\u001b[31m0\u001b[0m).equals(\u001b[31m\"()\"\u001b[0m) && lst.get(\u001b[31m1\u001b[0m).equals(\u001b[31m\"()\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of List[String] - did you mean lst.seq?\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp8akh_9mf.scala:31:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m3\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        } else {\n            var left = lst.head\n            var right = lst.tail.head\n            var result = matchParens(lst.tail)\n            if (left == \"(\" && right == \")\") {\n                return \"Yes\"\n            } else if (left == \"(\" && right == \")\") {\n                return \"No\"\n            } else {\n                return \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293132,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpr_sjf9by.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        }\n        var s = lst.head\n        var p = lst.tail\n        var c = 0\n        var b = 0\n        for (i <- 0 until p.length) {\n            if (p[i] == \"(\" && c == 0) {\n                c += 1\n            } else if (p[i] == \")\" && c == 1) {\n                c -= 1\n            } else if (p[i] == \"(\" && c == 0) {\n                b += 1\n            } else if (p[i] == \")\" && c == 1) {\n                b -= 1\n            }\n            if (c == 0 && b == 0) {\n                return \"Yes\"\n            }\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293134,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmptzcdlj9_.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptzcdlj9_.scala:26:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (p[\u001b[35mi\u001b[0m] == \u001b[31m\"(\"\u001b[0m && c == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptzcdlj9_.scala:28:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (p[i] == \u001b[31m\")\"\u001b[0m && c == \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptzcdlj9_.scala:30:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (p[i] == \u001b[31m\"(\"\u001b[0m && c == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptzcdlj9_.scala:32:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (p[i] == \u001b[31m\")\"\u001b[0m && c == \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var parens = 0\n        var str = \"\"\n        for (i <- lst.size()) {\n            if (lst[i] == \"(\" || lst[i] == \")\") {\n                if (lst[i] == \"(\" && parens == 0) {\n                    str += lst[i]\n                } else if (lst[i] == \")\" && parens == 1) {\n                    str += lst[i]\n                } else if (lst[i] == \"(\" && parens == 1) {\n                    parens -= 1\n                } else if (lst[i] == \")\" && parens == 0) {\n                    parens += 1\n                }\n            } else {\n                str += lst[i]\n            }\n        }\n        if (parens == 0) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293134,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpqg2yqeuw.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpqg2yqeuw.scala:23:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- lst.size()) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        } else {\n            var s = lst.head\n            var l = lst.tail\n            var c = s.charAt(0)\n            var r = s.charAt(s.length - 1)\n            if (c == '(' && r == ')') {\n                return \"Yes\"\n            } else if (c == '(') {\n                return \"No\"\n            } else if (r == ')') {\n                return \"No\"\n            } else {\n                var lst2 = l.map(Problem::matchParens)\n                if (lst2.exists(x => x == \"Yes\")) {\n                    return \"Yes\"\n                } else {\n                    return \"No\"\n                }\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293139,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpqqr46lj7.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqqr46lj7.scala:32:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                \u001b[33mvar\u001b[0m \u001b[36mlst2\u001b[0m = l.map(Problem::matchParens)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value :: is not a member of List[String] => String\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var p = lst.tail\n        var b = 0\n        var c = 0\n        var i = 0\n        while (i < s.length) {\n            if (s[i] == '(') {\n                b += 1\n            } else {\n                c += 1\n            }\n            i += 1\n        }\n        if (b == c) {\n            return \"Yes\"\n        }\n        if (b > c) {\n            return \"No\"\n        }\n        var j = 0\n        while (j < p.length) {\n            if (p[j] == '(') {\n                b -= 1\n            } else {\n                c -= 1\n            }\n            j += 1\n        }\n        if (b == c) {\n            return \"Yes\"\n        }\n        if (b < c) {\n            return \"No\"\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293135,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjx_atxni.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjx_atxni.scala:27:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjx_atxni.scala:42:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m            \u001b[33mif\u001b[0m (p[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"No\"\n        }\n        var s = \"\"\n        var p = 0\n        var q = 0\n        for (i <- lst.length) {\n            if (lst[i] == \"(\" || lst[i] == \")\") {\n                if (lst[i] == \"(\" && p == 0) {\n                    p = i\n                } else if (lst[i] == \")\" && p != 0) {\n                    q = i\n                    s = s + lst[p] + lst[q]\n                    p = 0\n                    q = 0\n                }\n            }\n        }\n        if (p != 0 || q != 0) {\n            return \"No\"\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293142,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjad7b_87.scala:24:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- lst.length) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"No\"\n        }\n        var s = \"\"\n        var open = 0\n        for (var i = 0; i < lst.length; i++) {\n            if (lst[i] == \"(\" || lst[i] == \")\") {\n                if (lst[i] == \"(\" && open == 0) {\n                    open = 1\n                } else if (lst[i] == \")\" && open == 1) {\n                    open = 0\n                }\n            } else {\n                s += lst[i]\n            }\n        }\n        if (open == 0) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293145,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpmkdt6rud.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpmkdt6rud.scala:23:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpmkdt6rud.scala:23:43 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmkdt6rud.scala:23:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.conve",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var result = \"No\"\n        var left = 0\n        var right = 0\n        var stack = List[String]()\n        for (i <- 0 until lst.length) {\n            if (lst[i] == \"(\") {\n                left += 1\n            } else if (lst[i] == \")\") {\n                right += 1\n            } else {\n                stack = stack.append(lst[i])\n            }\n            if (left == right) {\n                result = \"Yes\"\n                break\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293143,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0s2kv1u8.scala:23:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m (lst[\u001b[35mi\u001b[0m] == \u001b[31m\"(\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0s2kv1u8.scala:25:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (lst[i] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0s2kv1u8.scala:28:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                stack = stack.append(lst[\u001b[35mi\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[String] - did you mean List[String].appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0s2kv1u8.scala:28:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                stack = stack.append(lst[\u001b[35mi\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0s2kv1u8.scala:32:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var l = lst.tail\n        var p = 0\n        var r = 0\n        var i = 0\n        while (i < s.length) {\n            if (s[i] == '(') {\n                p += 1\n            } else {\n                r += 1\n            }\n            i += 1\n        }\n        if (p == r) {\n            return \"Yes\"\n        }\n        if (p > r) {\n            return \"No\"\n        }\n        var m = 0\n        var j = 0\n        while (j < l.length) {\n            if (l[j] == '(') {\n                m += 1\n            } else {\n                p -= 1\n            }\n            j += 1\n        }\n        if (p == 0) {\n            return \"Yes\"\n        }\n        if (p < 0) {\n            return \"No\"\n        }\n        if (m == 0) {\n            return \"Yes\"\n        }\n        if (m > 0) {\n            return \"No\"\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293139,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpza8aobem.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpza8aobem.scala:27:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpza8aobem.scala:43:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m            \u001b[33mif\u001b[0m (l[\u001b[35mj\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        } else {\n            var left = lst.head\n            var right = lst.tail.head\n            var leftParens = 0\n            var rightParens = 0\n            var leftParensStack = List[String]()\n            var rightParensStack = List[String]()\n            var leftParensStackIndex = 0\n            var rightParensStackIndex = 0\n            var leftParensStackSize = 0\n            var rightParensStackSize = 0\n            var leftParensStackSizeStack = List[Int]()\n            var rightParensStackSizeStack = List[Int]()\n            var leftParensStackSizeStackIndex = 0\n            var rightParensStackSizeStackIndex = 0\n            var leftParensStackSizeStackSize = 0\n            var rightParensStackSizeStackSize = 0\n            var leftParensStackSizeStackSizeStack = List[Int]()\n            var rightParensStackSizeStackSizeStack = List[Int]()\n            var leftParensStackSizeStackSizeStackIndex = 0\n            var rightParensStackSizeStackSizeStackIndex = 0\n            var leftParensStackSizeStackSizeStackSize = 0\n            var rightParensStackSizeStackSizeStackSize = 0\n            var leftParensStackSizeStackSizeStackSizeStack = List[Int]()\n            var rightParensStackSizeStackSizeStackSizeStack = List[Int]()\n            var leftParensStackSizeStackSizeStackSizeStackIndex = 0\n            var rightParensStackSizeStackSizeStackSizeStackIndex = 0\n            var leftParensStackSizeStackSizeStackSizeStackSize = 0\n            var rightParensStackSizeStackSizeStackSizeStackSize = 0\n            var leftParensStackSizeStackSizeStackSizeStackSizeStack = List[Int]()\n            var rightParensStackSizeStackSizeStackSizeStackSizeStack = List[Int]()\n            var leftParensStackSizeStackSizeStackSizeStackSizeStackIndex = 0\n            var rightParensStackSizeStackSizeStackSizeStackSizeStackIndex = 0\n            var leftParensStackSizeStackSize\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293145,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvphr8wkm.scala:54:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvphr8wkm.scala:71:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m71 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpvphr8wkm.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvphr8wkm.scala:70:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m70 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpvphr8wkm.scala:55:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m55 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        var leftParensStack = List[String]()\n        var rightParensStack = List[String]()\n        var leftParensStackSize = 0\n        var rightParensStackSize = 0\n        var leftParensStackSizeStack = List[Int]()\n        var rightParensStackSizeStack = List[Int]()\n        var leftParensStackSizeStackSize = 0\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var left\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293144,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4yhm38rn.scala:56:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4yhm38rn.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParensStackSizeStackSize\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParensStackSizeStackSize is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParensStackSizeStackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4yhm38rn.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParensStackSizeStackSizeStack\u001b[0m = List[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParensStackSizeStackSizeStack is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftParensStackSizeStackSizeStack\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4yhm38rn.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParensStackSizeStackSize\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParensStackSizeStackSize is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParensStackSizeStackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4yhm38rn.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParensStackSizeStackSizeStack\u001b[0m = List[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParensStackSizeStackSizeStack is already def",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var s = \"\"\n        var i = 0\n        while (i < lst.length) {\n            if (lst[i] == \"(\" || lst[i] == \")\") {\n                s += lst[i]\n                i += 1\n            } else {\n                break\n            }\n        }\n        if (i == lst.length) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293098,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpid7nold7.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mif\u001b[0m (lst[\u001b[35mi\u001b[0m] == \u001b[31m\"(\"\u001b[0m || lst[\u001b[35mi\u001b[0m] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpid7nold7.scala:22:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                s += lst[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpid7nold7.scala:22:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                s += lst[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpid7nold7.scala:25:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) return \"No\"\n        if (lst.size() == 1) return \"Yes\"\n        if (lst.size() == 2) return \"Yes\"\n        if (lst.size() == 3) return \"Yes\"\n        if (lst.size() == 4) return \"Yes\"\n        if (lst.size() == 5) return \"Yes\"\n        if (lst.size() == 6) return \"Yes\"\n        if (lst.size() == 7) return \"Yes\"\n        if (lst.size() == 8) return \"Yes\"\n        if (lst.size() == 9) return \"Yes\"\n        if (lst.size() == 10) return \"Yes\"\n        if (lst.size() == 11) return \"Yes\"\n        if (lst.size() == 12) return \"Yes\"\n        if (lst.size() == 13) return \"Yes\"\n        if (lst.size() == 14) return \"Yes\"\n        if (lst.size() == 15) return \"Yes\"\n        if (lst.size() == 16) return \"Yes\"\n        if (lst.size() == 17) return \"Yes\"\n        if (lst.size() == 18) return \"Yes\"\n        if (lst.size() == 19) return \"Yes\"\n        if (lst.size() == 20) return \"Yes\"\n        if (lst.size() == 21) return \"Yes\"\n        if (lst.size() == 22) return \"Yes\"\n        if (lst.size() == 23) return \"Yes\"\n        if (lst.size() == 24) return \"Yes\"\n        if (lst.size() == 25) return \"Yes\"\n        if (lst.size() == 26) return \"Yes\"\n        if (lst.size() == 27) return \"Yes\"\n        if (lst.size() == 28) return \"Yes\"\n        if (lst.size() == 29) return \"Yes\"\n        if (lst.size() == 30) return \"Yes\"\n        if (lst.size() == 31) return \"Yes\"\n        if\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmptctmedzf.scala:50:10 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m        \u001b[33mif\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m          ^\u001b[0m\n\u001b[31m   |\u001b[0m          expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmptctmedzf.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) \u001b[33mreturn\u001b[0m \u001b[31m\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmptctmedzf.scala:19:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m1\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmptctmedzf.scala:20:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m2\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmptctmedzf.scala:21:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m3\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31m\"Yes\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-expla",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var lst2 = lst.tail\n        var s2 = lst2.head\n        var lst3 = lst2.tail\n        var s3 = lst3.head\n        var lst4 = lst3.tail\n        var s4 = lst4.head\n        var lst5 = lst4.tail\n        var s5 = lst5.head\n        var lst6 = lst5.tail\n        var s6 = lst6.head\n        var lst7 = lst6.tail\n        var s7 = lst7.head\n        var lst8 = lst7.tail\n        var s8 = lst8.head\n        var lst9 = lst8.tail\n        var s9 = lst9.head\n        var lst10 = lst9.tail\n        var s10 = lst10.head\n        var lst11 = lst10.tail\n        var s11 = lst11.head\n        var lst12 = lst11.tail\n        var s12 = lst12.head\n        var lst13 = lst12.tail\n        var s13 = lst13.head\n        var lst14 = lst13.tail\n        var s14 = lst14.head\n        var lst15 = lst14.tail\n        var s15 = lst15.head\n        var lst16 = lst15.tail\n        var s16 = lst16.head\n        var lst17 = lst16.tail\n        var s17 = lst17.head\n        var lst18 = lst17.tail\n        var s18 = lst18.head\n        var lst19 = lst18.tail\n        var s19 = lst19.head\n        var lst20 = lst19.tail\n        var s20 = lst20.head\n        var lst21 = lst20.tail\n        var s21 = lst21.head\n        var lst22 = lst21.tail\n        var s22 = lst22.head\n        \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293145,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpsie771gv.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsie771gv.scala:65:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m65 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        } else {\n            var s = lst.head\n            var p = lst.tail.head\n            var parens = 0\n            var open = 0\n            var close = 0\n            var i = 0\n            while (i < s.length) {\n                if (s[i] == '(') {\n                    open += 1\n                } else if (s[i] == ')') {\n                    close += 1\n                }\n                i += 1\n            }\n            if (open == close) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293143,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpyrk0gl14.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyrk0gl14.scala:28:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyrk0gl14.scala:30:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (s[i] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"No\"\n        }\n        if (lst.length == 1) {\n            return \"Yes\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        for (i <- 0 until left.length) {\n            if (left[i] == '(') {\n                leftParens += 1\n            } else {\n                leftParens -= 1\n            }\n        }\n        for (i <- 0 until right.length) {\n            if (right[i] == '(') {\n                rightParens += 1\n            } else {\n                rightParens -= 1\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        var leftParens = 0\n        var rightParens = 0\n        for (i <- 0 until left.length) {\n            if (left[i] == '(') {\n                leftParens += 1\n            } else {\n                leftParens -= 1\n            }\n        }\n        for (i <- 0 until right.length) {\n            if (right[i] == '(') {\n                rightParens += 1\n            } else {\n                rightParens -= 1\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        var leftParens = 0\n        var rightParens = 0\n        for (i <- 0 until left.length) {\n            if (left[i] == '(') {\n                leftParens += 1\n            } else {\n                leftParens -= 1\n            }\n        }\n        for (i <- 0 until right.length) {\n            if (right[i] == '(') {\n                rightParens += 1\n            } else {\n                rightParens -= 1\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        var leftParens\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293147,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpe2btxux7.scala:84:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m84 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpe2btxux7.scala:45:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftParens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpe2btxux7.scala:46:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpe2btxux7.scala:64:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftParens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpe2btxux7.scala:65:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m65 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParens\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParens is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParens\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe2btxux7.scala:29:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mif\u001b[0m (left[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var s = \"\"\n        for(var i = 0; i < lst.size(); i++) {\n            var c = lst.get(i)\n            if(c == \"(\") {\n                s += \"(\"\n            } else {\n                s += \")\"\n            }\n        }\n        if(s.count(\"(\") == s.count(\")\")) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293151,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp1rrkznua.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mfor\u001b[0m(\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.size(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^\u001b[0m\n\u001b[31m   |\u001b[0m            pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp1rrkznua.scala:19:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mfor\u001b[0m(\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.size(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp1rrkznua.scala:19:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mfor\u001b[0m(\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.size(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1rrkznua.scala:19:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mfor\u001b[0m(\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.size(); i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.Implicit",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var i = 0\n        while (i < lst.size) {\n            if (s.charAt(0) == '(') {\n                s = s.substring(1)\n                i = i + 1\n            } else {\n                s = s.substring(1)\n                i = i + 1\n            }\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293145,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp6381vt4f.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) return \"No\"\n        var s = lst.head\n        var p = lst.tail\n        var result = \"\"\n        var i = 0\n        while (i < s.length) {\n            if (s[i] == '(') {\n                if (p.isEmpty()) return \"No\"\n                var p1 = p.head\n                var p2 = p.tail\n                if (p1.isEmpty()) {\n                    p = p2\n                    i = i + 1\n                    continue\n                }\n                if (p2.isEmpty()) {\n                    p = p1\n                    i = i + 1\n                    continue\n                }\n                if (p1.head == '(' && p2.head == '(') {\n                    p = p1.tail\n                    i = i + 1\n                    continue\n                }\n                if (p1.head == '(' && p2.head == ')') {\n                    p = p1.tail\n                    i = i + 1\n                    continue\n                }\n                if (p1.head == ')' && p2.head == '(') {\n                    p = p1.tail\n                    i = i + 1\n                    continue\n                }\n                if (p1.head == ')' && p2.head == ')') {\n                    p = p1.tail\n                    i = i + 1\n                    continue\n                }\n                return \"No\"\n            }\n            if (s[i] == ')') {\n                return \"No\"\n            }\n            result = result + s[i]\n            i = i + 1\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293153,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpa_6ypoih.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) \u001b[33mreturn\u001b[0m \u001b[31m\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpa_6ypoih.scala:24:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpa_6ypoih.scala:25:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                \u001b[33mif\u001b[0m (p.isEmpty()) \u001b[33mreturn\u001b[0m \u001b[31m\"No\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpa_6ypoih.scala:31:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                    continue\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: continue\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpa_6ypoih.scala:33:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                \u001b[33mif\u001b[0m (p2.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpa_6ypoih.scala:34:24 ---",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        var leftParensStack = List[String]()\n        var rightParensStack = List[String]()\n        var leftParensStackSize = 0\n        var rightParensStackSize = 0\n        var leftParensStackSizeStack = List[Int]()\n        var rightParensStackSizeStack = List[Int]()\n        var leftParensStackSizeStackSize = 0\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List[Int]()\n        var rightParensStackSizeStackSize = 0\n        var left\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293144,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4yhm38rn.scala:56:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4yhm38rn.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParensStackSizeStackSize\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParensStackSizeStackSize is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParensStackSizeStackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4yhm38rn.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParensStackSizeStackSizeStack\u001b[0m = List[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParensStackSizeStackSizeStack is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftParensStackSizeStackSizeStack\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4yhm38rn.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParensStackSizeStackSize\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParensStackSizeStackSize is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParensStackSizeStackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4yhm38rn.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParensStackSizeStackSizeStack\u001b[0m = List[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParensStackSizeStackSizeStack is already def",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var left = 0\n        var right = 0\n        var result = \"\"\n        for (s in lst) {\n            if (s == \"(\") {\n                left += 1\n            } else {\n                right += 1\n            }\n            if (left == right) {\n                result += s\n            }\n        }\n        if (left == right) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293135,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpy0nsn3be.scala:21:23 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (s in lst) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       '<-' expected, but '{' found\n\u001b[31m\u001b[31m-- [E020] Syntax Error: /tmp/tmpy0nsn3be.scala:33:10 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        } \u001b[33melse\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m          ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          \u001b[33myield\u001b[0m or \u001b[33mdo\u001b[0m expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy0nsn3be.scala:30:9 -------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m         ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator asScala\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.set asScala\n\u001b[31m   |\u001b[0m\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        } else {\n            var s = lst.head\n            var p = lst.tail.head\n            var q = lst.tail.tail.head\n            var r = lst.tail.tail.tail.head\n            var parens = 0\n            var open = 0\n            var close = 0\n            var i = 0\n            while (i < s.length) {\n                if (s[i] == '(') {\n                    open += 1\n                } else if (s[i] == ')') {\n                    close += 1\n                }\n                i += 1\n            }\n            if (open == close) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293145,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpb6osf5h6.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb6osf5h6.scala:30:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb6osf5h6.scala:32:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (s[i] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var s = \"\"\n        for(i <- 0 until lst.length) {\n            if(lst[i] == \"(\") {\n                s += \"(\"\n            } else {\n                s += \")\"\n            }\n        }\n        if(s == \"\") {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293146,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkm58l5x3.scala:20:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mif\u001b[0m(lst[\u001b[35mi\u001b[0m] == \u001b[31m\"(\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        var leftParensStack = List[String]()\n        var rightParensStack = List[String]()\n        for (i <- 0 until left.length) {\n            if (left[i] == '(') {\n                leftParensStack = leftParensStack.append(left[i])\n                leftParens += 1\n            } else {\n                leftParens -= 1\n                if (leftParens == 0) {\n                    leftParensStack = leftParensStack.tail\n                }\n            }\n        }\n        for (i <- 0 until right.length) {\n            if (right[i] == '(') {\n                rightParensStack = rightParensStack.append(right[i])\n                rightParens += 1\n            } else {\n                rightParens -= 1\n                if (rightParens == 0) {\n                    rightParensStack = rightParensStack.tail\n                }\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        for (i <- 0 until leftParensStack.length) {\n            if (leftParensStack[i] == '(') {\n                leftParens += 1\n            } else {\n                leftParens -= 1\n            }\n        }\n        for (i <- 0 until rightParensStack.length) {\n            if (rightParensStack[i] == '(') {\n                rightParens += 1\n            } else {\n                rightParens -= 1\n            }\n        }\n        if (leftParens != 0 || rightParens != 0) {\n            return \"No\"\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293155,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpixfe0hfi.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpixfe0hfi.scala:28:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mif\u001b[0m (left[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpixfe0hfi.scala:29:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                leftParensStack = leftParensStack.append(left[\u001b[35mi\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[String] - did you mean List[String].appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpixfe0hfi.scala:29:62 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                leftParensStack = leftParensStack.append(left[\u001b[35mi\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpixfe0hfi.scala:39:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            \u001b[33mif\u001b[0m (right[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpixfe0hfi.scala:40:52 ------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m         ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        var leftParensStack = List[String]()\n        var rightParensStack = List[String]()\n        for (i <- 0 until left.length) {\n            if (left[i] == '(') {\n                leftParens += 1\n                leftParensStack += left[i]\n            } else if (left[i] == ')') {\n                leftParens -= 1\n                leftParensStack += left[i]\n            }\n        }\n        for (i <- 0 until right.length) {\n            if (right[i] == '(') {\n                rightParens += 1\n                rightParensStack += right[i]\n            } else if (right[i] == ')') {\n                rightParens -= 1\n                rightParensStack += right[i]\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        var leftParensStackCopy = leftParensStack\n        var rightParensStackCopy = rightParensStack\n        var leftParensStackCopyStack = List[String]()\n        var rightParensStackCopyStack = List[String]()\n        for (i <- 0 until leftParensStack.length) {\n            if (leftParensStack[i] == '(') {\n                leftParensStackCopyStack += leftParensStack[i]\n            } else if (leftParensStack[i] == ')') {\n                leftParensStackCopyStack += leftParensStack[i]\n            }\n        }\n        for (i <- 0 until rightParensStack.length) {\n            if (rightParensStack[i] == '(') {\n                rightParensStackCopyStack += rightParensStack[i]\n            } else if (rightParensStack[i] == ')') {\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4i2kn201.scala:81:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m81 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp4i2kn201.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4i2kn201.scala:28:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mif\u001b[0m (left[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4i2kn201.scala:30:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                leftParensStack += left[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue += is not a member of List[String] - did you mean List[String].!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4i2kn201.scala:30:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                leftParensStack += left[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4i2kn201.scala:31:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (left[i] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var parens = 0\n        var result = \"\"\n        for (s in lst) {\n            if (s == \"(\") {\n                parens += 1\n            } else if (s == \")\") {\n                parens -= 1\n            } else {\n                result += s\n            }\n            if (parens < 0) {\n                return \"No\"\n            }\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293157,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4gxesggo.scala:20:23 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mfor\u001b[0m (s in lst) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       '<-' expected, but '{' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4gxesggo.scala:31:9 -------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m         ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.iterator asScala\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.set asScala\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var i = 0\n        while (i < lst.size) {\n            if (s.charAt(0) == '(') {\n                i += 1\n                s = s.substring(1)\n            } else {\n                i += 1\n                s = s.substring(1)\n            }\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293090,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpl8p1x_um.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        } else {\n            var s = lst.head\n            var result = \"Yes\"\n            var i = 0\n            while (i < lst.size) {\n                if (s.charAt(0) == '(') {\n                    if (s.charAt(s.length - 1) == ')') {\n                        s = s.substring(1, s.length - 1)\n                    } else {\n                        result = \"No\"\n                        break\n                    }\n                } else {\n                    if (s.charAt(s.length - 1) == '(') {\n                        result = \"No\"\n                        break\n                    } else {\n                        s = s.substring(1, s.length - 1)\n                    }\n                }\n                i += 1\n            }\n            return result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293150,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfsdstssi.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfsdstssi.scala:30:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                        break\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfsdstssi.scala:35:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                        break\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"No\"\n        } else {\n            var left = lst.head\n            var right = lst.tail.head\n            if (left.equals(\"(\")) {\n                return matchParens(lst.tail.tail)\n            } else if (right.equals(\")\")) {\n                return matchParens(lst.tail.tail)\n            } else {\n                return \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293152,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpx1wwio0l.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        } else {\n            var left = lst.head\n            var right = lst.tail.head\n            var leftParens = 0\n            var rightParens = 0\n            var leftOpen = 0\n            var rightOpen = 0\n            for (i <- lst) {\n                if (i.equals(\"(\")) {\n                    leftParens += 1\n                } else if (i.equals(\")\")) {\n                    rightParens += 1\n                } else if (i.equals(\"(\")) {\n                    leftOpen += 1\n                } else if (i.equals(\")\")) {\n                    rightOpen += 1\n                }\n            }\n            if (leftParens == rightParens) {\n                if (leftOpen == rightOpen) {\n                    return \"Yes\"\n                } else {\n                    return \"No\"\n                }\n            } else {\n                return \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293153,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpndmlji6v.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        }\n        if (lst.size() == 1) {\n            return \"No\"\n        }\n        var s = \"\"\n        var i = 0\n        var j = 0\n        var p = 0\n        var q = 0\n        while (i < lst.size()) {\n            if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                p++\n                i++\n                j++\n            } else if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                p++\n                i++\n                j++\n            } else if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                p++\n                i++\n                j++\n            } else if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                p++\n                i++\n                j++\n            } else if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                p++\n                i++\n                j++\n            } else if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                p++\n                i++\n                j++\n            } else if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                p++\n                i++\n                j++\n            } else if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                p++\n                i++\n                j++\n            } else if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                p++\n                i++\n                j++\n            } else if (lst.get(i) == \"(\" && lst.get(j) == \")\") {\n                p++\n                i++\n                j++\n            } else if (lst.get(i) == \"(\" && lst\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293164,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmptprist0y.scala:33:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                j++\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmptprist0y.scala:37:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                j++\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmptprist0y.scala:41:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m                j++\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmptprist0y.scala:45:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m                j++\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmptprist0y.scala:49:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m                j++\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmptprist0y.scala:53:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m                j++\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var p = lst.tail\n        var parens = 0\n        var open = 0\n        var close = 0\n        for (i <- 0 until s.length) {\n            if (s[i] == '(') {\n                open += 1\n            } else if (s[i] == ')') {\n                close += 1\n            }\n            if (open == close) {\n                parens += 1\n            } else if (open > close) {\n                open -= 1\n            } else {\n                close -= 1\n            }\n        }\n        if (open == close && parens == 0) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293155,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp91lb7mca.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp91lb7mca.scala:27:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m (s[\u001b[35mi\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp91lb7mca.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (s[i] == \u001b[31m')'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var i = 0\n        var j = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293073,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9z5tj0cs.scala:103:4 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m103 |\u001b[0m    }\n\u001b[31m\u001b[31m    |\u001b[0m    ^\u001b[0m\n\u001b[31m    |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9z5tj0cs.scala:42:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mi\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mi is already defined as \u001b[33mvariable\u001b[0m \u001b[35mi\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9z5tj0cs.scala:43:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mj\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mj is already defined as \u001b[33mvariable\u001b[0m \u001b[35mj\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9z5tj0cs.scala:49:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mp\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mp is already defined as \u001b[33mvariable\u001b[0m \u001b[35mp\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9z5tj0cs.scala:50:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mq\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mq is already defined as \u001b[33mvariable\u001b[0m \u001b[35mq\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9z5tj0cs.scala:51:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mr\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mr is already defined as \u001b[33mvariable\u001b[0m \u001b[35mr\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"No\"\n        } else {\n            var s = \"\"\n            var i = 0\n            while (i < lst.length) {\n                if (lst[i].equals(\"(\")) {\n                    s += \"(\"\n                    i += 1\n                } else if (lst[i].equals(\")\")) {\n                    s += \")\"\n                    i += 1\n                } else {\n                    s += lst[i]\n                    i += 1\n                }\n            }\n            if (s.equals(\"\")) {\n                return \"Yes\"\n            } else {\n                return \"No\"\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxg4nq1re.scala:24:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                \u001b[33mif\u001b[0m (lst[\u001b[35mi\u001b[0m].equals(\u001b[31m\"(\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxg4nq1re.scala:27:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (lst[i].equals(\u001b[31m\")\"\u001b[0m)) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxg4nq1re.scala:31:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                    s += lst[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxg4nq1re.scala:31:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                    s += lst[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var result = \"No\"\n        var stack = List[String]()\n        for (i <- 0 until lst.size) {\n            if (lst.get(i) == \"(\") {\n                stack.append(lst.get(i))\n            } else if (lst.get(i) == \")\") {\n                if (stack.isEmpty()) {\n                    result = \"No\"\n                    break\n                } else {\n                    stack.pop()\n                }\n            }\n        }\n        if (stack.isEmpty()) {\n            result = \"Yes\"\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmmp01m7d.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33mif\u001b[0m (lst.get(i) == \u001b[31m\"(\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of List[String] - did you mean lst.seq?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmmp01m7d.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                stack.append(lst.get(i))\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[String] - did you mean List[String].appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmmp01m7d.scala:22:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                stack.append(lst.get(i))\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue get is not a member of List[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmmp01m7d.scala:23:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (lst.get(i) == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue get is not a member of List[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpmmp01m7d.scala:24:26 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                \u001b[33mif\u001b[0m (stack.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   \u001b[33mme",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"No\"\n        }\n        var s = \"\"\n        var i = 0\n        while (i < lst.length) {\n            if (lst[i] == \")\") {\n                s += \"(\"\n                i += 1\n                continue\n            }\n            if (lst[i] == \"(\") {\n                s += \")\"\n                i += 1\n                continue\n            }\n            s += lst[i]\n            i += 1\n        }\n        if (s.length == 0) {\n            return \"Yes\"\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8cxfl5h0.scala:24:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m (lst[\u001b[35mi\u001b[0m] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8cxfl5h0.scala:27:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                continue\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: continue\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8cxfl5h0.scala:29:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mif\u001b[0m (lst[\u001b[35mi\u001b[0m] == \u001b[31m\"(\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8cxfl5h0.scala:32:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                continue\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: continue\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8cxfl5h0.scala:34:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            s += lst[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8cxfl5h0.scala:34:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            s += lst[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n6 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var result = \"No\"\n        var stack = List.empty()\n        for (i <- lst.tail) {\n            if (s.equals(\"(\")) {\n                stack = stack.append(s)\n            } else if (s.equals(\")\")) {\n                if (stack.isEmpty()) {\n                    result = \"No\"\n                    break\n                } else {\n                    stack = stack.tail\n                }\n            }\n        }\n        if (stack.isEmpty()) {\n            result = \"Yes\"\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpiz_vixqy.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpiz_vixqy.scala:23:30 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mstack\u001b[0m = List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): A\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiz_vixqy.scala:30:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"Yes\"\n        }\n        var s = lst.head\n        var i = 0\n        while (i < lst.size) {\n            if (s.charAt(0) == '(') {\n                s = s.substring(1)\n                i = i + 1\n            } else {\n                s = s.substring(1)\n                i = i + 1\n            }\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293145,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp6381vt4f.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        }\n        var s = lst.head\n        var l = lst.tail\n        var p = 0\n        var c = 0\n        var b = 0\n        while (p < s.length) {\n            if (s[p] == '(') {\n                c += 1\n            } else {\n                c -= 1\n            }\n            if (c == 0) {\n                b += 1\n            } else {\n                b -= 1\n            }\n            if (b == 0) {\n                return \"Yes\"\n            }\n            p += 1\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpbpabwdsb.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbpabwdsb.scala:27:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mif\u001b[0m (s[\u001b[35mp\u001b[0m] == \u001b[31m'('\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: type p\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"Yes\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        for (i <- lst.tail.tail.length) {\n            if (leftParens == rightParens) {\n                leftParens = leftParens + 1\n                rightParens = rightParens + 1\n            } else if (leftParens > rightParens) {\n                rightParens = rightParens + 1\n            } else {\n                leftParens = leftParens + 1\n            }\n        }\n        if (leftParens == rightParens) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphxax2b_t.scala:25:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- lst.tail.tail.length) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        }\n        var s = lst.head\n        var i = 0\n        var j = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s1 = \"\"\n        var s2 = \"\"\n        var s3 = \"\"\n        var s4 = \"\"\n        var s5 = \"\"\n        var s6 = \"\"\n        var s7 = \"\"\n        var s8 = \"\"\n        var s9 = \"\"\n        var s10 = \"\"\n        var s11 = \"\"\n        var s12 = \"\"\n        var s13 = \"\"\n        var s14 = \"\"\n        var s15 = \"\"\n        var s16 = \"\"\n        var s17 = \"\"\n        var s18 = \"\"\n        var s19 = \"\"\n        var s20 = \"\"\n        var s21 = \"\"\n        var s22 = \"\"\n        var s23 = \"\"\n        var s24 = \"\"\n        var s25 = \"\"\n        var s26 = \"\"\n        var s27 = \"\"\n        var s28 = \"\"\n        var s29 = \"\"\n        var s30 = \"\"\n        var s31 = \"\"\n        var s32 = \"\"\n        var s33 = \"\"\n        var s34 = \"\"\n        var s35 = \"\"\n        var s36 = \"\"\n        var s37 = \"\"\n        var s38 = \"\"\n        var s39 = \"\"\n        var s40 = \"\"\n        var s41 = \"\"\n        var s42 = \"\"\n        var s43 = \"\"\n        var s44 = \"\"\n        var s45 = \"\"\n        var s46 = \"\"\n        var s47 = \"\"\n        var s48 = \"\"\n        var s49 = \"\"\n        var s50 = \"\"\n        var s51 = \"\"\n        var s52 = \"\"\n        var s53 = \"\"\n        var s54 = \"\"\n        var s55 = \"\"\n        var s56 = \"\"\n        var s57 = \"\"\n        var s58 = \"\"\n        var s59 = \"\"\n        var s60 = \"\"\n        var s61 = \"\"\n        var s62 = \"\"\n        var s63 = \"\"\n        var s64 = \"\"\n        var s65 =\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpqwq3f07a.scala:91:17 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m91 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36ms65\u001b[0m =\n\u001b[31m\u001b[31m   |\u001b[0m                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                 expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpqwq3f07a.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqwq3f07a.scala:92:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"No\"\n        }\n        var s = lst.head\n        var parens = 0\n        var open = 0\n        var close = 0\n        for (i <- lst.tail.size - 1) {\n            if (s.charAt(i) == '(') {\n                open += 1\n            } else {\n                close += 1\n            }\n            if (open == close) {\n                parens += 1\n            } else {\n                parens = 0\n            }\n            if (parens == 0) {\n                return \"Yes\"\n            }\n            s = s.substring(0, i) + s.substring(i + 1)\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpwyr7rtdu.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwyr7rtdu.scala:25:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- lst.tail.size - \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Int\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.isEmpty()) {\n            return \"No\"\n        }\n        var s = lst.head\n        var p = lst.tail\n        var parens = 0\n        var balance = 0\n        while (s.charAt(0) == '(') {\n            parens += 1\n            balance += 1\n            s = s.substring(1)\n        }\n        while (s.charAt(s.length - 1) == ')') {\n            balance -= 1\n            parens -= 1\n            s = s.substring(0, s.length - 1)\n        }\n        if (balance != 0) {\n            return \"No\"\n        }\n        if (parens != 0) {\n            return \"No\"\n        }\n        if (s.length != 0) {\n            return \"No\"\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp67adp4f_.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"Yes\"\n        }\n        if (lst.size() == 1) {\n            return \"No\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        var leftParensStack = List.empty()\n        var rightParensStack = List.empty()\n        var leftParensStackSize = 0\n        var rightParensStackSize = 0\n        var leftParensStackSizeStack = List.empty()\n        var rightParensStackSizeStack = List.empty()\n        var leftParensStackSizeStackSize = 0\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSizeStack = List.empty()\n        var leftParensStackSizeStackSizeStackSize = 0\n        var rightParensStackSizeStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStackSizeStackSize = 0\n        var leftParensStackSizeStackSizeStackSizeStack = List.empty()\n        var rightParensStackSizeStack\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293164,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpj4p33yff.scala:56:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpj4p33yff.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParensStackSizeStackSize\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParensStackSizeStackSize is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParensStackSizeStackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpj4p33yff.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParensStackSizeStackSizeStack\u001b[0m = List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftParensStackSizeStackSizeStack is already defined as \u001b[33mvariable\u001b[0m \u001b[35mleftParensStackSizeStackSizeStack\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpj4p33yff.scala:43:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrightParensStackSizeStackSizeStackSize\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mrightParensStackSizeStackSizeStackSize is already defined as \u001b[33mvariable\u001b[0m \u001b[35mrightParensStackSizeStackSizeStackSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpj4p33yff.scala:44:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mleftParensStackSizeStackSizeStackSizeStack\u001b[0m = List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mleftPare",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        var s = \"\"\n        for (i <- 0 until lst.length) {\n            if (lst[i] == \"(\") {\n                s += \"(\"\n            } else {\n                s += \")\"\n            }\n        }\n        if (s == \"\") {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293161,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo3oswj79.scala:20:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mif\u001b[0m (lst[\u001b[35mi\u001b[0m] == \u001b[31m\"(\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"No\"\n        }\n        var left = lst.head\n        var right = lst.tail.head\n        var leftParens = 0\n        var rightParens = 0\n        for (i <- 0 until left.size) {\n            if (left[i] == \"(\") {\n                leftParens += 1\n            } else if (left[i] == \")\") {\n                leftParens -= 1\n            }\n        }\n        for (i <- 0 until right.size) {\n            if (right[i] == \"(\") {\n                rightParens += 1\n            } else if (right[i] == \")\") {\n                rightParens -= 1\n            }\n        }\n        if (leftParens != rightParens) {\n            return \"No\"\n        }\n        var result = \"\"\n        for (i <- 0 until left.size) {\n            result += left[i]\n        }\n        for (i <- 0 until right.size) {\n            result += right[i]\n        }\n        return \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp5gkfsl8d.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5gkfsl8d.scala:26:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (left[\u001b[35mi\u001b[0m] == \u001b[31m\"(\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5gkfsl8d.scala:28:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (left[i] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5gkfsl8d.scala:33:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            \u001b[33mif\u001b[0m (right[\u001b[35mi\u001b[0m] == \u001b[31m\"(\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5gkfsl8d.scala:35:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (right[i] == \u001b[31m\")\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5gkfsl8d.scala:44:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m            result += left[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.length == 0) {\n            return \"Yes\"\n        }\n        var s = \"\"\n        var parens = 0\n        for (var i = 0; i < lst.length; i++) {\n            if (lst[i] == \"(\" || lst[i] == \")\") {\n                if (lst[i] == \"(\" && parens == 0) {\n                    s += lst[i]\n                } else if (lst[i] == \")\" && parens == 1) {\n                    s += lst[i]\n                } else if (lst[i] == \")\" && parens == 0) {\n                    parens += 1\n                }\n            }\n        }\n        if (parens == 0) {\n            return \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpxksqbhwx.scala:23:13 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpxksqbhwx.scala:23:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpxksqbhwx.scala:23:43 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxksqbhwx.scala:23:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mfor\u001b[0m (\u001b[33mvar\u001b[0m i = \u001b[31m0\u001b[0m; i < lst.length; i++) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.conve",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"No\"\n        }\n        var s = lst.head\n        var p = lst.tail\n        var i = 0\n        var j = 0\n        var k = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p1 = 0\n        var p2 = 0\n        var p3 = 0\n        var p4 = 0\n        var p5 = 0\n        var p6 = 0\n        var p7 = 0\n        var p8 = 0\n        var p9 = 0\n        var p10 = 0\n        var p11 = 0\n        var p12 = 0\n        var p13 = 0\n        var p14 = 0\n        var p15 = 0\n        var p16 = 0\n        var p17 = 0\n        var p18 = 0\n        var p19 = 0\n        var p20 = 0\n        var p21 = 0\n        var p22 = 0\n        var p23 = 0\n        var p24 = 0\n        var p25 = 0\n        var p26 = 0\n        var p27 = 0\n        var p28 = 0\n        var p29 = 0\n        var p30 = 0\n        var p31 = 0\n        var p32 = 0\n        var p33 = 0\n        var p34 = 0\n        var p35 = 0\n        var p36 = 0\n        var p37 = 0\n        var p38 = 0\n        var p39 = 0\n        var p40 = 0\n        var p41 = 0\n        var p42 = 0\n        var p43 = 0\n        var p44 = 0\n        var p45 = 0\n        var p46 = 0\n        var p47 = 0\n        var p48 = 0\n        var p49 = 0\n        var p50 = 0\n        var p51 = 0\n        var p52 = 0\n        var p53 = 0\n        var p54 = 0\n        var p55 = 0\n        var p56 = 0\n        var p57 = 0\n        var p58 = 0\n        var p59 = 0\n        var p60 = 0\n        var p61 = 0\n        var p62 = 0\n        var\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp6yn7k6mj.scala:91:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m91 |\u001b[0m        \u001b[33mvar\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp6yn7k6mj.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6yn7k6mj.scala:92:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // You are given a list of two strings, both strings consist of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your job is to check if it is possible to concatenate the two strings in\n    // some order, that the resulting string will be good.\n    // A string S is considered to be good if and only if all parentheses in S\n    // are balanced. For example: the string '(())()' is good, while the string\n    // '())' is not.\n    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n    // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    // (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        if (lst.size() == 0) {\n            return \"No\"\n        }\n        var s = lst.head\n        var i = 1\n        var j = 1\n        var p = 0\n        var q = 0\n        while (i < lst.size()) {\n            if (s.charAt(p) == '(') {\n                p += 1\n            } else {\n                p -= 1\n            }\n            if (s.charAt(q) == ')') {\n                q += 1\n            } else {\n                q -= 1\n            }\n            if (p == 0 && q == 0) {\n                return \"Yes\"\n            }\n            if (p == 0) {\n                i += 1\n            } else {\n                i -= 1\n            }\n            if (q == 0) {\n                j += 1\n            } else {\n                j -= 1\n            }\n            s = lst.get(i)\n        }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n    }\n\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp9paitkvu.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mif\u001b[0m (lst.size() == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp9paitkvu.scala:26:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mwhile\u001b[0m (i < lst.size()) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   \u001b[33mmethod\u001b[0m \u001b[35msize\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9paitkvu.scala:50:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m            s = lst.get(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of List[String] - did you mean lst.seq?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}