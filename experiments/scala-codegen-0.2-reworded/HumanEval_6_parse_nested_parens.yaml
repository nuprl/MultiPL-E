name: HumanEval_6_parse_nested_parens
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n    // For each of the group, output the deepest\
  \ level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of\
  \ nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((()))\
  \ () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n\
  \    def parseNestedParens(paren_string : String) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
  (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
  \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
  )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
completions: ["        var paren_list = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (i <- 0 until paren_list.length) {\n           \
    \ var paren_group = paren_list[i]\n            var paren_count = 0\n         \
    \   for (j <- 0 until paren_group.length) {\n                if (paren_group[j]\
    \ == '(') {\n                    paren_count += 1\n                } else if (paren_group[j]\
    \ == ')') {\n                    paren_count -= 1\n                }\n       \
    \     }\n            result = result.append(paren_count)\n        }\n        return\
    \ result", "        var result = List[Long]()\n        var paren_stack = List[String]()\n\
    \        var paren_count = 0\n        var paren_index = 0\n        var paren_char\
    \ = \"\"\n        var paren_level = 0\n        var paren_count_max = 0\n     \
    \   var paren_count_min = 0\n        var paren_count_diff = 0\n        var paren_count_diff_max\
    \ = 0\n        var paren_count_diff_min = 0\n        var paren_count_diff_diff\
    \ = 0\n        var paren_count_diff_diff_max = 0\n        var paren_count_diff_diff_min\
    \ = 0\n        var paren_count_diff_diff_diff = 0\n        var paren_count_diff_diff_diff_max\
    \ = 0\n        var paren_count_diff_diff_diff_min = 0\n        var paren_count_diff_diff_diff_diff\
    \ = 0\n        var paren_count_diff_diff_diff_diff_max = 0\n        var paren_count_diff_diff_diff_diff_min\
    \ = 0\n        var paren_count_diff_diff_diff_diff_diff = 0\n        var paren_count_diff_diff_diff_diff_diff_max\
    \ = 0\n        var paren_count_diff_diff_diff_diff_diff_min = 0\n        var paren_count_diff_diff_diff_diff_diff_diff\
    \ = 0\n        var paren_count_diff_diff_diff_diff_diff_diff_max = 0\n       \
    \ var paren_count_diff_diff_diff_diff_diff_diff_min = 0\n        var paren_count_diff_diff_diff_diff_diff_diff_diff\
    \ = 0\n        var paren_count_diff_diff_diff_diff_diff_diff_diff_max = 0\n  \
    \      var paren_count_diff_diff_diff_diff_diff_diff_diff_min = 0\n        var\
    \ paren_count_diff_diff_diff_diff_diff_diff_diff_diff = 0\n        var paren_count_diff_diff_diff_diff_diff_diff_diff_",
  "        var paren_list = paren_string.split(\" \")\n        var max_nesting = 0\n\
    \        var result = List[Long]()\n        for (i <- 0 until paren_list.length)\
    \ {\n            var paren_group = paren_list[i]\n            var paren_count\
    \ = 0\n            for (j <- 0 until paren_group.length) {\n                if\
    \ (paren_group[j] == '(') {\n                    paren_count += 1\n          \
    \      } else if (paren_group[j] == ')') {\n                    paren_count -=\
    \ 1\n                }\n            }\n            if (paren_count > max_nesting)\
    \ {\n                max_nesting = paren_count\n            }\n            if\
    \ (paren_count == 0) {\n                result = result.append(max_nesting)\n\
    \            }\n        }\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"\
    ))\n        val result_list = result.map(Long.parseLong).toList\n        result_list",
  "        val parens = paren_string.split(\" \")\n        val paren_list = parens.map(p\
    \ -> p.replaceAll(\"[()]\", \"\"))\n        val paren_counts = paren_list.map(p\
    \ -> p.length()).toSeq\n        val max_paren_count = paren_counts.max()\n   \
    \     val max_paren_count_index = paren_counts.indexOf(max_paren_count)\n    \
    \    val max_paren_count_parens = paren_list.take(max_paren_count_index)\n   \
    \     val max_paren_count_parens_count = max_paren_count_parens.length()\n   \
    \     val max_paren_count_parens_list = max_paren_count_parens.map(p -> p.length()).toSeq\n\
    \        val max_paren_count_parens_count_list = max_paren_count_parens_list.map(p\
    \ -> p.toLong).toSeq\n        val max_paren_count_parens_count_list_to_list =\
    \ max_paren_count_parens_count_list.toList\n        val max_paren_count_parens_count_list_to_list_to_list\
    \ = max_paren_count_parens_count_list_to_list.toList\n        val max_paren_count_parens_count_list_to_list_to_list_to_list\
    \ = max_paren_count_parens_count_list_to_list_to_list.toList\n        val max_paren_count_parens_count_list_to_list_to_list_to_list_to_list\
    \ = max_paren_count_parens_count_list_to_list_to_list_to_list.toList\n       \
    \ val max_paren_count_parens_count_list_to_list_to_list_to_list_to_list_to_list\
    \ = max_paren_count_parens_count_list_to_list_to_list_to_list_to_list.toList\n\
    \        val max_paren_count_parens_count_list_to_list_", "        var parens\
    \ = paren_string.split(\" \")\n        var max_nesting = 0\n        var max_nesting_index\
    \ = 0\n        for (i <- 0 until parens.length) {\n            var paren_count\
    \ = 0\n            for (j <- i until parens.length) {\n                if (parens[j]\
    \ == \"(\" || parens[j] == \")\") {\n                    paren_count += 1\n  \
    \              } else {\n                    paren_count -= 1\n              \
    \  }\n                if (paren_count > max_nesting) {\n                    max_nesting\
    \ = paren_count\n                    max_nesting_index = j\n                }\n\
    \            }\n        }\n        var result = List[Long]()\n        for (i <-\
    \ 0 until max_nesting_index) {\n            result = result.append(i)\n      \
    \  }\n        return result", "        val parens = paren_string.split(\" \")\n\
    \        val result = parens.map(s => {\n            val parens = s.split(\"(\"\
    )\n            val depth = parens.length - 1\n            val max_depth = depth.max()\n\
    \            return depth.toLong\n        })\n        return result", "      \
    \  val parens = paren_string.split(\" \")\n        val result = parens.map(_.toLong).toList\n\
    \        return result", "        val parens = paren_string.split(\" \")\n   \
    \     val result = parens.map(_.trim).map(Problem::parseNestedParens).reduce(_.maxBy(Comparator.naturalOrder()))\n\
    \        return result", "        var paren_list = paren_string.split(\" \")\n\
    \        var result = List[Long]()\n        for (i <- 0 until paren_list.length)\
    \ {\n            var level = 0\n            var paren_str = paren_list[i]\n  \
    \          for (j <- 0 until paren_str.length) {\n                if (paren_str[j]\
    \ == '(') {\n                    level += 1\n                } else if (paren_str[j]\
    \ == ')') {\n                    level -= 1\n                }\n             \
    \   if (level == 0) {\n                    result = result.append(j)\n       \
    \         }\n            }\n        }\n        return result", "        val parens\
    \ = paren_string.split(\" \")\n        val result = List[Long]()\n        for\
    \ (i <- 0 until parens.length) {\n            val paren = parens(i)\n        \
    \    val depth = depth(paren)\n            result = result.append(depth)\n   \
    \     }\n        return result\n    }\n\n    // Returns the depth of the deepest\
    \ level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n    // >>> depth(\"(()()) ((())) () ((())()())\"\
    ))\n    // 2\n    def depth(paren : String) : Long = {\n        val parens = paren.split(\"\
    \ \")\n        val result = 0L\n        for (i <- 0 until parens.length) {\n \
    \           val paren = parens(i)\n            val depth = depth(paren)\n    \
    \        if (depth > result) {\n                result = depth\n            }\n\
    \        }\n        return result", "        var paren_list = paren_string.split(\"\
    \ \")\n        var paren_list_len = paren_list.length\n        var result = List[Long]()\n\
    \        for (i <- 0 until paren_list_len) {\n            var paren_group = paren_list[i]\n\
    \            var paren_group_len = paren_group.length\n            var paren_group_count\
    \ = 0\n            for (j <- 0 until paren_group_len) {\n                if (paren_group[j]\
    \ == '(') {\n                    paren_group_count += 1\n                } else\
    \ if (paren_group[j] == ')') {\n                    paren_group_count -= 1\n \
    \               }\n            }\n            result = result.append(paren_group_count)\n\
    \        }\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(Problem.parseParen).toList\n        result.sort(Comparator.comparingLong(l\
    \ -> l))\n        return result\n    }\n\n    // Input to this function is a string\
    \ represented multiple groups for nested parentheses separated by spaces.\n  \
    \  // For each of the group, output the deepest level of nesting of parentheses.\n\
    \    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\
    \    // >>> parseNestedParens(\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseParen(paren : String) : Long\
    \ = {\n        val parens = paren.split(\"(\")\n        val result = parens.map(Problem.parseParen).toList\n\
    \        result.sort(Comparator.comparingLong(l -> l))\n        return result",
  "        var parens = paren_string.split(\" \")\n        var max_nesting = 0\n \
    \       var max_nesting_index = 0\n        for (i <- 0 until parens.length) {\n\
    \            var nesting = 0\n            for (j <- 0 until parens[i].length)\
    \ {\n                if (parens[i][j] == '(') {\n                    nesting +=\
    \ 1\n                } else if (parens[i][j] == ')') {\n                    nesting\
    \ -= 1\n                }\n                if (nesting > max_nesting) {\n    \
    \                max_nesting = nesting\n                    max_nesting_index\
    \ = i\n                }\n            }\n        }\n        var result = List[Long]()\n\
    \        for (i <- 0 until max_nesting_index) {\n            result = result.append(i)\n\
    \        }\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n\
    \        return result", "        val parens = paren_string.split(\" \")\n   \
    \     val result = parens.map(p -> {\n            val parens = p.split(\"(\")\n\
    \            val depth = parens.length - 1\n            return depth\n       \
    \ }).toList\n        return result", "        var parens = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (i <- 0 until parens.length)\
    \ {\n            var level = 0\n            for (j <- 0 until parens[i].length)\
    \ {\n                if (parens[i][j] == '(') {\n                    level +=\
    \ 1\n                } else if (parens[i][j] == ')') {\n                    level\
    \ -= 1\n                }\n                if (level < 0) {\n                \
    \    throw new RuntimeException(\"Invalid parentheses\")\n                }\n\
    \            }\n            result = result.append(level.toLong)\n        }\n\
    \        return result", "        val parens = paren_string.split(\" \")\n   \
    \     val result = parens.map(Problem.parseNestedParens).reduce(List[Long]())\n\
    \        return result", "        val parens = paren_string.split(\" \")\n   \
    \     val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n    \
    \    val result_list = result.map(Long.parseLong).toList\n        result_list",
  "        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n\
    \        result", "        var parens = paren_string.split(\" \")\n        var\
    \ max_depth = 0\n        var max_depth_index = 0\n        for (i <- 0 until parens.length)\
    \ {\n            var depth = 0\n            for (j <- 0 until parens.length) {\n\
    \                if (parens[j].equals(\"(\")) depth += 1\n                if (parens[j].equals(\"\
    )\")) depth -= 1\n                if (depth > max_depth) {\n                 \
    \   max_depth = depth\n                    max_depth_index = j\n             \
    \   }\n            }\n        }\n        var result = List[Long]()\n        for\
    \ (i <- 0 until max_depth_index) {\n            result = result.append(Long(parens[i].length()))\n\
    \        }\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(s => {\n            val parens = s.split(\"\
    (\")\n            val max_nesting = parens.map(s1 => {\n                val parens1\
    \ = s1.split(\")\")\n                return parens1.length - 1\n            }).max()\n\
    \            return max_nesting\n        }).toList\n        return result", " \
    \       var paren_list = paren_string.split(\" \")\n        var max_nesting =\
    \ 0\n        var result = List[Long]()\n        for (i <- 0 until paren_list.length)\
    \ {\n            var paren_group = paren_list[i]\n            var paren_count\
    \ = 0\n            for (j <- 0 until paren_group.length) {\n                if\
    \ (paren_group[j] == '(') {\n                    paren_count += 1\n          \
    \      } else if (paren_group[j] == ')') {\n                    paren_count -=\
    \ 1\n                }\n                if (paren_count > max_nesting) {\n   \
    \                 max_nesting = paren_count\n                }\n            }\n\
    \            result = result.append(max_nesting)\n        }\n        return result",
  "        var paren_list = paren_string.split(\" \")\n        var max_nesting = 0\n\
    \        var max_nesting_index = 0\n        for (i <- 0 until paren_list.length)\
    \ {\n            var nesting = 0\n            for (j <- i until paren_list.length)\
    \ {\n                if (paren_list[j] == \"(\" && paren_list[j - 1] == \")\"\
    ) {\n                    nesting += 1\n                } else if (paren_list[j]\
    \ == \")\" && paren_list[j - 1] == \")\") {\n                    nesting -= 1\n\
    \                }\n                if (nesting > max_nesting) {\n           \
    \         max_nesting = nesting\n                    max_nesting_index = j\n \
    \               }\n            }\n        }\n        var result = List[Long]()\n\
    \        for (i <- 0 until max_nesting_index) {\n            result = result.append(Long(paren_list[i].toLong))\n\
    \        }\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(s => {\n            val parens = s.split(\"\
    (\")\n            val paren_count = parens.length - 1\n            val max_paren_count\
    \ = paren_count\n            for (i <- 0 until paren_count) {\n              \
    \  val paren_count_i = parens[i].length - 1\n                if (paren_count_i\
    \ > max_paren_count) max_paren_count = paren_count_i\n            }\n        \
    \    return max_paren_count\n        })\n        return result", "        val\
    \ parens = paren_string.split(\" \")\n        val result = parens.map(_.toLong).toList\n\
    \        return result", "        val paren_list = paren_string.split(\" \")\n\
    \        val result = paren_list.map(s => {\n            val paren_list = s.split(\"\
    (\")\n            val paren_list_2 = paren_list.map(s2 => {\n                val\
    \ paren_list_3 = s2.split(\")\")\n                val paren_list_4 = paren_list_3.map(s3\
    \ => {\n                    val paren_list_5 = s3.split(\"(\")\n             \
    \       val paren_list_6 = paren_list_5.map(s4 => {\n                        val\
    \ paren_list_7 = s4.split(\")\")\n                        val paren_list_8 = paren_list_7.map(s5\
    \ => {\n                            val paren_list_9 = s5.split(\"(\")\n     \
    \                       val paren_list_10 = paren_list_9.map(s6 => {\n       \
    \                         val paren_list_11 = s6.split(\")\")\n              \
    \                  val paren_list_12 = paren_list_11.map(s7 => {\n           \
    \                         val paren_list_13 = s7.split(\"(\")\n              \
    \                      val paren_list_14 = paren_list_13.map(s8 => {\n       \
    \                                 val paren_list_15 = s8.split(\")\")\n      \
    \                                  val paren_list_16 = paren_list_15.map(s9 =>\
    \ {\n                                            val paren_list_17 = s9.split(\"\
    (\")\n                                            val paren_list_18 = paren_list_17.map(s10\
    \ => {\n                                                val paren_list_19 = s10.split(\"\
    )\")\n                                                val paren_list_20 = paren_list_19.map(s11\
    \ => {\n                                                    val paren_list_21\
    \ = s11.split(\"(\")\n                                                    val\
    \ paren_list_22 = paren_list_21.map(s12 => {\n                               \
    \                         val paren_list_23 = s12.", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"\
    ))\n        val result_list = result.map(_.split(\"(\")).map(_.map(_.trim).map(_.replaceAll(\"\
    [()]\", \"\"))\n        result_list.forEach(x -> {\n            val result_list_2\
    \ = x.map(_.split(\"(\")).map(_.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n\
    \            result_list_2.forEach(y -> {\n                val result_list_3 =\
    \ y.map(_.split(\"(\")).map(_.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n\
    \                result_list_3.forEach(z -> {\n                    val result_list_4\
    \ = z.map(_.split(\"(\")).map(_.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n\
    \                    result_list_4.forEach(w -> {\n                        val\
    \ result_list_5 = w.map(_.split(\"(\")).map(_.map(_.trim).map(_.replaceAll(\"\
    [()]\", \"\"))\n                        result_list_5.forEach(v -> {\n       \
    \                     val result_list_6 = v.map(_.split(\"(\")).map(_.map(_.trim).map(_.replaceAll(\"\
    [()]\", \"\"))\n                            result_list_6.forEach(u -> {\n   \
    \                             val result_list_7 = u.map(_.split(\"(\")).map(_.map(_.trim).map(_.replaceAll(\"\
    [()]\", \"\"))\n                                result_list_7.forEach(t -> {\n\
    \                                    val result_list_8 = t.map(_.split(\"(\")).map(_.map(_.trim).map(_.replaceAll(\"\
    [()]\", \"\"))\n                                    result_list_8.forEach(s ->\
    \ {\n                                        val result_list_9 = s.map(_.split(\"\
    (\")).map(_.map(_.trim).map(_.replaceAll(\"[()", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(Problem.parseNestedParens1).reduce(_.maxBy(Comparator.naturalOrder()))\n\
    \        return result\n    }\n\n    // Input to this function is a string represented\
    \ multiple groups for nested parentheses separated by spaces.\n    // For each\
    \ of the group, output the deepest level of nesting of parentheses.\n    // E.g.\
    \ (()()) has maximum two levels of nesting while ((())) has three.\n    // >>>\
    \ parseNestedParens1((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens1(paren_string :\
    \ String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n \
    \       val result = parens.map(Problem.parseNestedParens2).reduce(_.maxBy(Comparator.naturalOrder()))\n\
    \        return result\n    }\n\n    // Input to this function is a string represented\
    \ multiple groups for nested parentheses separated by spaces.\n    // For each\
    \ of the group, output the deepest level of nesting of parentheses.\n    // E.g.\
    \ (()()) has maximum two levels of nesting while ((())) has three.\n    // >>>\
    \ parseNestedParens2((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens2(paren_string :\
    \ String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n \
    \       val result = parens.map(Problem.parseNestedParens3).reduce(_.maxBy(Comparator.naturalOrder()))\n\
    \        return result\n    }\n\n    // Input to this function is a string represented\
    \ multiple groups for nested parentheses separated by spaces.\n    // For each\
    \ of the group, output the deepest level of nesting of parentheses.\n    // E.g.\
    \ (()()) has maximum two levels of", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(s => {\n            val parens = s.split(\"\
    (\")\n            val depth = parens.length - 1\n            val max_depth = depth.max()\n\
    \            return max_depth\n        }).toList\n        return result", "  \
    \      val parens = paren_string.split(\" \")\n        val result = parens.map(_.toLong).toList\n\
    \        result", "        val parens = paren_string.split(\" \")\n        val\
    \ result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n\
    \        result", "        val parens = paren_string.split(\" \")\n        val\
    \ result = parens.map(Problem::parseNestedParens_helper).reduce(List[Long]::concat)\n\
    \        return result\n    }\n\n    // Helper function for parseNestedParens.\n\
    \    // Returns the depth of the deepest level of nesting of parentheses.\n  \
    \  // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\
    \    // >>> parseNestedParens_helper(\"(()()) ((())) () ((())()())\")(0)\n   \
    \ // 2\n    def parseNestedParens_helper(parens : String, depth : Long) : Long\
    \ = {\n        if (parens.isEmpty()) {\n            return depth\n        } else\
    \ {\n            val curr_depth = depth + 1\n            val curr_parens = parens.substring(0,\
    \ 1)\n            val next_depth = parseNestedParens_helper(parens.substring(1),\
    \ curr_depth)\n            if (next_depth > curr_depth) {\n                return\
    \ next_depth\n            } else {\n                return curr_depth\n      \
    \      }\n        }", "        val parens = paren_string.split(\" \")\n      \
    \  val paren_list = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n   \
    \     val paren_counts = paren_list.map(parens => parens.length()).toSeq\n   \
    \     val max_paren_count = paren_counts.max()\n        val max_paren_count_index\
    \ = paren_counts.indexOf(max_paren_count)\n        val max_paren_count_list =\
    \ paren_list.take(max_paren_count_index)\n        val max_paren_count_list_length\
    \ = max_paren_count_list.length\n        val max_paren_count_list_as_longs = max_paren_count_list.map(Long).toSeq\n\
    \        val max_paren_count_as_long = max_paren_count_list_as_longs.head\n  \
    \      val max_paren_count_as_long_as_long = max_paren_count_as_long.toLong\n\
    \        val max_paren_count_as_long_as_long_as_long = max_paren_count_as_long_as_long.toLong\n\
    \        val max_paren_count_as_long_as_long_as_long_as_long = max_paren_count_as_long_as_long_as_long.toLong\n\
    \        val max_paren_count_as_long_as_long_as_long_as_long_as_long = max_paren_count_as_long_as_long_as_long_as_long.toLong\n\
    \        val max_paren_count_as_long_as_long_as_long_as_long_as_long_as_long =\
    \ max_paren_count_as_long_as_long_as_long_as_long_as_long.toLong\n        val\
    \ max_paren_count_as_long_as_long_as_long_as_long_as_long_as_long_as_long = max_paren_count_as_long_as_long_as_long_as_long_as_long_as",
  "        var parens = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (i <- 0 until parens.length) {\n            var level = 0\n     \
    \       for (j <- 0 until parens[i].length) {\n                if (parens[i][j]\
    \ == '(') {\n                    level += 1\n                } else if (parens[i][j]\
    \ == ')') {\n                    level -= 1\n                }\n             \
    \   if (level < 0) {\n                    throw new RuntimeException(\"Invalid\
    \ parentheses string\")\n                }\n            }\n            result\
    \ = result.append(level.toLong)\n        }\n        return result", "        val\
    \ parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens).reduce(List[Long]::concat)\n\
    \        result", "        var paren_list = paren_string.split(\" \")\n      \
    \  var result = List[Long]()\n        for (i <- 0 until paren_list.length) {\n\
    \            var paren_group = paren_list[i]\n            var paren_count = 0\n\
    \            for (j <- 0 until paren_group.length) {\n                if (paren_group[j]\
    \ == '(') {\n                    paren_count += 1\n                } else if (paren_group[j]\
    \ == ')') {\n                    paren_count -= 1\n                }\n       \
    \     }\n            result = result.append(paren_count)\n        }\n        return\
    \ result", "        val parens = paren_string.split(\" \")\n        val result\
    \ = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        val result_list\
    \ = result.map(Long.parseLong).toList\n        return result_list", "        var\
    \ parens = paren_string.split(\" \")\n        var result = List[Long]()\n    \
    \    for (i <- 0 until parens.length) {\n            var paren = parens[i]\n \
    \           var depth = 0\n            for (j <- 0 until paren.length) {\n   \
    \             if (paren[j] == '(') depth += 1\n                if (paren[j] ==\
    \ ')') depth -= 1\n                if (depth < 0) throw new RuntimeException(\"\
    Invalid parentheses\")\n            }\n            result = result.append(depth)\n\
    \        }\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(Problem::parseNestedParens).reduce(_.maxBy(Comparator.naturalOrder()))\n\
    \        return result", "        val parens = paren_string.split(\" \")\n   \
    \     val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n    \
    \    val result_list = result.map(Long::parseLong).toList\n        return result_list",
  "        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n\
    \        result", "        var paren_list = paren_string.split(\" \")\n      \
    \  var result = List[Long]()\n        for (i <- 0 until paren_list.length) {\n\
    \            var paren_group = paren_list[i]\n            var paren_count = 0\n\
    \            for (j <- 0 until paren_group.length) {\n                if (paren_group[j]\
    \ == \"(\" || paren_group[j] == \"{\") {\n                    paren_count += 1\n\
    \                } else if (paren_group[j] == \")\" || paren_group[j] == \"}\"\
    ) {\n                    paren_count -= 1\n                }\n            }\n\
    \            result = result.append(paren_count.toLong)\n        }\n        return\
    \ result", "        val parens = paren_string.split(\" \")\n        val result\
    \ = parens.map(s => {\n            val parens = s.split(\"(\")\n            val\
    \ depth = parens.length - 1\n            val max_depth = depth.max()\n       \
    \     return depth.map(d => d.toLong)\n        }).toList\n        return result",
  "        var parens = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (i <- 0 until parens.length) {\n            var paren = parens[i]\n\
    \            var depth = 0\n            for (j <- 0 until paren.length) {\n  \
    \              if (paren[j] == '(') {\n                    depth += 1\n      \
    \          } else if (paren[j] == ')') {\n                    depth -= 1\n   \
    \             }\n                if (depth == 0) {\n                    result\
    \ = result.append(j)\n                    break\n                }\n         \
    \   }\n        }\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(Problem.parseNestedParens_).reduce(List[Long]::concat)\n\
    \        result", "        var parens = paren_string.split(\" \")\n        var\
    \ result = List[Long]()\n        for (i <- 0 until parens.length) {\n        \
    \    var paren = parens[i]\n            if (paren.equals(\"\")) {\n          \
    \      continue\n            }\n            var depth = 0\n            for (j\
    \ <- 0 until paren.length) {\n                if (paren[j] == '(') {\n       \
    \             depth += 1\n                } else if (paren[j] == ')') {\n    \
    \                depth -= 1\n                }\n                if (depth < 0)\
    \ {\n                    throw new RuntimeException(\"Invalid parentheses\")\n\
    \                }\n            }\n            result = result.append(depth.toLong)\n\
    \        }\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"\
    ))\n        result.map(_.toLong).toList", "        var result = mutable.List[Long]()\n\
    \        var parens = paren_string.split(\" \")\n        for (i <- 0 until parens.length)\
    \ {\n            var paren = parens[i]\n            var depth = 0\n          \
    \  for (j <- 0 until paren.length) {\n                if (paren[j] == '(') {\n\
    \                    depth += 1\n                } else if (paren[j] == ')') {\n\
    \                    depth -= 1\n                }\n                if (depth\
    \ < 0) {\n                    throw new RuntimeException(\"Invalid parentheses\"\
    )\n                }\n            }\n            result = result.append(depth.toLong)\n\
    \        }\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(Problem.parseParens).reduce(List[Long]::concat)\n\
    \        result\n    }\n\n    // Input to this function is a string represented\
    \ multiple groups for nested parentheses separated by spaces.\n    // For each\
    \ of the group, output the deepest level of nesting of parentheses.\n    // E.g.\
    \ (()()) has maximum two levels of nesting while ((())) has three.\n    // >>>\
    \ parseNestedParens2((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens2(paren_string :\
    \ String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n \
    \       val result = parens.map(Problem.parseParens).reduce(List[Long]::concat)\n\
    \        result\n    }\n\n    // Input to this function is a string represented\
    \ multiple groups for nested parentheses separated by spaces.\n    // For each\
    \ of the group, output the deepest level of nesting of parentheses.\n    // E.g.\
    \ (()()) has maximum two levels of nesting while ((())) has three.\n    // >>>\
    \ parseNestedParens3((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens3(paren_string :\
    \ String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n \
    \       val result = parens.map(Problem.parseParens).reduce(List[Long]::concat)\n\
    \        result\n    }\n\n    // Input to this function is a string represented\
    \ multiple groups for nested parentheses separated by spaces.\n    // For each\
    \ of the group, output the deepest level of nesting of parentheses.\n    // E.g.\
    \ (()()) has maximum two levels of nesting while ((())) has three.\n    // >>>\
    \ parseNestedParens4((\"", "        val parens = paren_string.split(\" \")\n \
    \       val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n  \
    \      val result_list = result.map(Long.parseLong).toList\n        return result_list",
  "        var paren_list = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (i <- 0 until paren_list.length) {\n            var paren_group =\
    \ paren_list[i]\n            var paren_count = 0\n            for (j <- 0 until\
    \ paren_group.length) {\n                if (paren_group[j] == \"(\" || paren_group[j]\
    \ == \")\") {\n                    paren_count += 1\n                }\n     \
    \       }\n            result = result.append(paren_count)\n        }\n      \
    \  return result", "        val parens = paren_string.split(\" \")\n        val\
    \ paren_list = parens.map(s => s.replaceAll(\"[()]\", \"\"))\n        val paren_list_length\
    \ = paren_list.length\n        val result = paren_list.map(s => {\n          \
    \  val paren_count = 0\n            for (i <- 0 until paren_list_length) {\n \
    \               if (s[i] == '(') {\n                    paren_count += 1\n   \
    \             } else if (s[i] == ')') {\n                    paren_count -= 1\n\
    \                }\n                if (paren_count == 0) {\n                \
    \    return i\n                }\n            }\n            return -1\n     \
    \   })\n        result.sort((a, b) => a - b)\n        return result.map(i => paren_list_length\
    \ - i - 1).toList", "        val parens = paren_string.split(\" \")\n        val\
    \ result = parens.map(_.trim).map(_.replaceAll(\"(\", \"\").replaceAll(\")\",\
    \ \"\"))\n        val result_list = result.map(Long::parseLong).toList\n     \
    \   return result_list", "        val parens = paren_string.split(\" \")\n   \
    \     val result = parens.map(Problem.parseNestedParens_).reduce(List[Long]())\n\
    \        return result", "        var parens = paren_string.split(\" \")\n   \
    \     var max_nesting = 0\n        var max_nesting_index = 0\n        for (i <-\
    \ 0 until parens.length) {\n            var nesting = 0\n            for (j <-\
    \ 0 until parens[i].length) {\n                if (parens[i][j] == '(') {\n  \
    \                  nesting += 1\n                } else if (parens[i][j] == ')')\
    \ {\n                    nesting -= 1\n                }\n                if (nesting\
    \ > max_nesting) {\n                    max_nesting = nesting\n              \
    \      max_nesting_index = i\n                }\n            }\n        }\n  \
    \      var result = List[Long]()\n        for (i <- 0 until max_nesting_index)\
    \ {\n            result = result.append(i)\n        }\n        return result",
  "        var paren_list = paren_string.split(\" \")\n        var paren_list_len\
    \ = paren_list.length\n        var paren_list_len_minus_1 = paren_list_len - 1\n\
    \        var max_nesting = 0\n        var max_nesting_index = 0\n        for (i\
    \ <- 0 to paren_list_len_minus_1) {\n            var nesting = 0\n           \
    \ var nesting_index = i\n            for (j <- i to paren_list_len_minus_1) {\n\
    \                if (paren_list[j].equals(\"(\")) {\n                    nesting\
    \ += 1\n                } else if (paren_list[j].equals(\")\")) {\n          \
    \          nesting -= 1\n                }\n                if (nesting > max_nesting)\
    \ {\n                    max_nesting = nesting\n                    max_nesting_index\
    \ = nesting_index\n                }\n            }\n        }\n        var max_nesting_list\
    \ = paren_list.substring(max_nesting_index, paren_list_len_minus_1).split(\"\"\
    )\n        var max_nesting_list_len = max_nesting_list.length\n        var max_nesting_list_len_minus_1\
    \ = max_nesting_list_len - 1\n        var max_nesting_list_len_minus_2 = max_nesting_list_len\
    \ - 2\n        var max_nesting_list_len_minus_3 = max_nesting_list_len - 3\n \
    \       var max_nesting_list_len_minus_4 = max_nesting_list_len - 4\n        var\
    \ max_nesting_list_len_minus_5 = max_nesting_list_len - 5\n        var max_nesting_list_len_minus_6\
    \ = max_nesting_list_len - 6\n        var max_nesting_list_len_minus_7 = max_nesting_list_len\
    \ - 7\n        var max_nesting_list_len_minus_8 = max_nesting_list_len - 8\n \
    \       var max_nesting_list_len_minus_9 = max_nesting_list_len - 9", "      \
    \  val parens = paren_string.split(\" \")\n        val paren_list = parens.map(_.trim).map(_.replaceAll(\"\
    [()]\", \"\"))\n        val paren_list_length = paren_list.length\n        val\
    \ paren_list_length_minus_1 = paren_list_length - 1\n        val paren_list_length_minus_2\
    \ = paren_list_length - 2\n        val paren_list_length_minus_3 = paren_list_length\
    \ - 3\n        val paren_list_length_minus_4 = paren_list_length - 4\n       \
    \ val paren_list_length_minus_5 = paren_list_length - 5\n        val paren_list_length_minus_6\
    \ = paren_list_length - 6\n        val paren_list_length_minus_7 = paren_list_length\
    \ - 7\n        val paren_list_length_minus_8 = paren_list_length - 8\n       \
    \ val paren_list_length_minus_9 = paren_list_length - 9\n        val paren_list_length_minus_10\
    \ = paren_list_length - 10\n        val paren_list_length_minus_11 = paren_list_length\
    \ - 11\n        val paren_list_length_minus_12 = paren_list_length - 12\n    \
    \    val paren_list_length_minus_13 = paren_list_length - 13\n        val paren_list_length_minus_14\
    \ = paren_list_length - 14\n        val paren_list_length_minus_15 = paren_list_length\
    \ - 15\n        val paren_list_length_minus_16 = paren_list_length - 16\n    \
    \    val paren_list_length_minus_17 = paren_list_length - 17\n        val paren_list_length_minus_18\
    \ = paren_list_length - 18\n        val paren_list_length_minus_19 = paren_list_length\
    \ - 19\n        val paren_list_length_minus_20 = paren_list_length - 20\n    \
    \    val paren_list_length_minus", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(Problem::parseNestedParens).reduce(_.max)\n\
    \        return result", "        val parens = paren_string.split(\" \")\n   \
    \     val paren_list = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n\
    \        val paren_count = paren_list.map(Long.parseLong).reduce(0, (a, b) =>\
    \ a + b)\n        val max_paren_count = paren_count.max()\n        val result\
    \ = paren_list.map(l -> l.length - max_paren_count).toList\n        return result",
  "        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n\
    \        result", "        val parens = paren_string.split(\" \")\n        val\
    \ paren_counts = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"\
    [^()]\", \"\")).map(_.replaceAll(\"[^()]\", \"\")).map(_.replaceAll(\"[()]\",\
    \ \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"\
    [()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\
    \")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"\
    [()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\
    \")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"\
    [()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\
    \")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"\
    [()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\
    \")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"\
    [()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\
    \")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"\
    [()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\
    \")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"[()]\", \"\")).map(_.replaceAll(\"\
    [()", "        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"\
    (\", \"\").replaceAll(\")\", \"\"))\n        val result_list = result.map(_.split(\"\
    (\")).map(x => x.length - 1).toList\n        result_list.foreach(x => {\n    \
    \        if (x > 0) {\n                System.out.println(x)\n            }\n\
    \        })", "        val paren_list = paren_string.split(\" \")\n        val\
    \ result = paren_list.map(Problem.parseNestedParens_)\n        return result\n\
    \    }\n\n    def parseNestedParens_ (paren_string : String) : Long = {\n    \
    \    val paren_list = paren_string.split(\"(\")\n        val result = paren_list.map(Problem.parseNestedParens_)\n\
    \        return result", "        var paren_list = paren_string.split(\" \")\n\
    \        var result = List[Long]()\n        for (i <- 0 until paren_list.length)\
    \ {\n            var paren_group = paren_list[i]\n            var paren_count\
    \ = 0\n            for (j <- 0 until paren_group.length) {\n                if\
    \ (paren_group[j] == '(') {\n                    paren_count += 1\n          \
    \      } else if (paren_group[j] == ')') {\n                    paren_count -=\
    \ 1\n                }\n            }\n            result = result.append(paren_count)\n\
    \        }\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(p -> p.replaceAll(\"[()]\", \"\"))\n  \
    \      val result_list = result.map(s -> s.split(\"(\")).map(l -> l.length - 1).toList\n\
    \        result_list.sort(Comparator.comparing(l -> l))\n        return result_list",
  "        var paren_list = paren_string.split(\" \")\n        var paren_count = 0\n\
    \        var max_paren_count = 0\n        var max_paren_index = 0\n        for\
    \ (i <- 0 until paren_list.length) {\n            var paren_count_here = 0\n \
    \           var paren_count_here_max = 0\n            for (j <- 0 until paren_list[i].length)\
    \ {\n                if (paren_list[i][j] == '(') {\n                    paren_count_here\
    \ += 1\n                } else if (paren_list[i][j] == ')') {\n              \
    \      paren_count_here -= 1\n                }\n                if (paren_count_here_max\
    \ < paren_count_here) {\n                    paren_count_here_max = paren_count_here\n\
    \                    max_paren_count = paren_count\n                    max_paren_index\
    \ = i\n                }\n            }\n        }\n        var result = List[Long](max_paren_count)\n\
    \        for (i <- 0 until max_paren_index) {\n            result[i] = max_paren_count\
    \ - paren_count_here\n        }\n        return result", "        var paren_list\
    \ = paren_string.split(\" \")\n        var max_nesting = 0\n        var max_nesting_index\
    \ = 0\n        for (i <- 0 until paren_list.length) {\n            var nesting\
    \ = 0\n            for (j <- 0 until paren_list[i].length) {\n               \
    \ if (paren_list[i][j] == '(') {\n                    nesting += 1\n         \
    \       } else if (paren_list[i][j] == ')') {\n                    nesting -=\
    \ 1\n                }\n                if (nesting > max_nesting) {\n       \
    \             max_nesting = nesting\n                    max_nesting_index = i\n\
    \                }\n            }\n        }\n        var result = List[Long]()\n\
    \        for (i <- 0 until max_nesting_index) {\n            result = result.append(paren_list[i].length())\n\
    \        }\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val paren_counts = parens.map(p -> p.split(\"(\")).map(l -> l.length\
    \ - 1).toList\n        val max_paren_count = paren_counts.max()\n        val result\
    \ = paren_counts.map(i -> i - max_paren_count).toList\n        return result",
  "        var paren_list = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (i <- 0 until paren_list.length) {\n            var paren_group =\
    \ paren_list[i]\n            var paren_count = 0\n            for (j <- 0 until\
    \ paren_group.length) {\n                if (paren_group[j] == \"(\" || paren_group[j]\
    \ == \"{\") {\n                    paren_count += 1\n                } else if\
    \ (paren_group[j] == \")\" || paren_group[j] == \"}\") {\n                   \
    \ paren_count -= 1\n                }\n            }\n            result = result.append(paren_count.toLong)\n\
    \        }\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(_.toLong).toList\n        return result",
  "        val parens = paren_string.split(\" \")\n        val result = parens.map(s\
    \ => {\n            val parens = s.split(\"(\")\n            val depth = parens.length\
    \ - 1\n            val max_depth = depth.max()\n            return depth.toLong\n\
    \        })\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(Problem::parseNestedParensHelper).reduce(List[Long]::concat)\n\
    \        return result\n    }\n\n    // Helper function for parseNestedParens\n\
    \    def parseNestedParensHelper(left : String, right : String) : List[Long] =\
    \ {\n        val left_parens = left.count(\"(\").toLong\n        val right_parens\
    \ = right.count(\")\").toLong\n        if (left_parens > right_parens) {\n   \
    \         return List[Long](left_parens.toLong)\n        } else if (left_parens\
    \ < right_parens) {\n            return List[Long](right_parens.toLong)\n    \
    \    } else {\n            return List[Long](left_parens.toLong, right_parens.toLong)\n\
    \        }", "        val parens = paren_string.split(\" \")\n        val result\
    \ = parens.map(Problem.parseNestedParens1).reduce(List[Long]::concat)\n      \
    \  result", "        var paren_list = paren_string.split(\" \")\n        var max_nesting\
    \ = 0\n        var max_nesting_index = 0\n        for (i <- 0 until paren_list.length)\
    \ {\n            var nesting = 0\n            var nesting_index = 0\n        \
    \    for (j <- 0 until paren_list[i].length()) {\n                if (paren_list[i][j]\
    \ == '(') {\n                    nesting += 1\n                    nesting_index\
    \ = j\n                } else if (paren_list[i][j] == ')') {\n               \
    \     nesting -= 1\n                    nesting_index = j\n                }\n\
    \                if (nesting == 0) {\n                    break\n            \
    \    }\n            }\n            if (nesting > max_nesting) {\n            \
    \    max_nesting = nesting\n                max_nesting_index = i\n          \
    \  }\n        }\n        var result = List[Long]()\n        for (i <- 0 until\
    \ max_nesting_index) {\n            result = result.append(Long(paren_list[i].length()\
    \ - nesting_index))\n        }\n        return result", "        val parens =\
    \ paren_string.split(\" \")\n        val result = List[Long]()\n        for (i\
    \ <- 0 until parens.length) {\n            val paren = parens(i)\n           \
    \ if (paren.startsWith(\"(\")) {\n                val depth = paren.length - 1\n\
    \                val level = depth / 2\n                result = result.append(level.toLong)\n\
    \            }\n        }\n        return result", "        var paren_list = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (var i = 0; i < paren_list.length;\
    \ i++) {\n            var paren_group = paren_list[i]\n            var depth =\
    \ 0\n            for (var j = 0; j < paren_group.length(); j++) {\n          \
    \      if (paren_group.charAt(j) == '(') {\n                    depth += 1\n \
    \               } else if (paren_group.charAt(j) == ')') {\n                 \
    \   depth -= 1\n                }\n            }\n            result = result.append(depth.toLong)\n\
    \        }\n        return result", "        var paren_list = paren_string.split(\"\
    \ \")\n        var max_nesting = 0\n        var result = List[Long]()\n      \
    \  for (i <- 0 until paren_list.length) {\n            var paren_group = paren_list[i]\n\
    \            var paren_count = 0\n            for (j <- 0 until paren_group.length)\
    \ {\n                if (paren_group[j] == '(') {\n                    paren_count\
    \ += 1\n                } else if (paren_group[j] == ')') {\n                \
    \    paren_count -= 1\n                }\n                if (paren_count > max_nesting)\
    \ {\n                    max_nesting = paren_count\n                }\n      \
    \      }\n            result = result.append(max_nesting)\n        }\n       \
    \ return result", "        var paren_list = paren_string.split(\" \")\n      \
    \  var paren_count = 0\n        var max_paren_count = 0\n        var max_paren_list\
    \ = List[Long]()\n        for (i <- 0 until paren_list.length) {\n           \
    \ var paren_count_here = 0\n            for (j <- 0 until paren_list[i].length)\
    \ {\n                if (paren_list[i][j] == '(') {\n                    paren_count_here\
    \ += 1\n                } else if (paren_list[i][j] == ')') {\n              \
    \      paren_count_here -= 1\n                }\n                if (paren_count_here\
    \ == 0) {\n                    break\n                }\n            }\n     \
    \       if (paren_count_here > max_paren_count) {\n                max_paren_count\
    \ = paren_count_here\n                max_paren_list = List[Long](i.toLong, j.toLong)\n\
    \            }\n        }\n        return max_paren_list", "        val parens\
    \ = paren_string.split(\" \")\n        val result = parens.map(p -> {\n      \
    \      val parens = p.split(\"(\")\n            val parens_count = parens.length\
    \ - 1\n            val max_nesting = parens_count.max()\n            return max_nesting\n\
    \        })\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n\
    \        result", "        val parens = paren_string.split(\" \")\n        val\
    \ result = parens.map(p -> {\n            val parens = p.split(\"(\")\n      \
    \      val parens_len = parens.length\n            if (parens_len == 1) {\n  \
    \              return 1l\n            } else {\n                return parens_len\n\
    \            }\n        }).toList\n        return result", "        val parens\
    \ = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(_.maxBy(l\
    \ -> l))\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(Problem.parseNestedParens).reduce(List[Long]())\n\
    \        return result\n    }\n\n    // Input to this function is a string represented\
    \ multiple groups for nested parentheses separated by spaces.\n    // For each\
    \ of the group, output the deepest level of nesting of parentheses.\n    // E.g.\
    \ (()()) has maximum two levels of nesting while ((())) has three.\n    // >>>\
    \ parseNestedParens2((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens2(paren_string :\
    \ String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n \
    \       val result = parens.map(Problem.parseNestedParens2).reduce(List[Long]())\n\
    \        return result\n    }\n\n    // Input to this function is a string represented\
    \ multiple groups for nested parentheses separated by spaces.\n    // For each\
    \ of the group, output the deepest level of nesting of parentheses.\n    // E.g.\
    \ (()()) has maximum two levels of nesting while ((())) has three.\n    // >>>\
    \ parseNestedParens3((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens3(paren_string :\
    \ String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n \
    \       val result = parens.map(Problem.parseNestedParens3).reduce(List[Long]())\n\
    \        return result\n    }\n\n    // Input to this function is a string represented\
    \ multiple groups for nested parentheses separated by spaces.\n    // For each\
    \ of the group, output the deepest level of nesting of parentheses.\n    // E.g.\
    \ (()()) has maximum two levels of nesting while ((())) has three.\n    // >>>\
    \ parseNestedParens4", "        val parens = paren_string.split(\" \")\n     \
    \   val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n      \
    \  result.map(_.toLong).toList", "        val parens = paren_string.split(\" \"\
    )\n        val paren_list = parens.map(s => s.replaceAll(\"[()]\", \"\"))\n  \
    \      val paren_list_len = paren_list.length\n        val max_nesting = paren_list_len.max()\n\
    \        val result = paren_list.map(s => s.length() - max_nesting)\n        return\
    \ result", "        var paren_list = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (var i = 0; i < paren_list.length; i++) {\n    \
    \        var paren_group = paren_list[i]\n            var depth = 0\n        \
    \    for (var j = 0; j < paren_group.length(); j++) {\n                if (paren_group.charAt(j)\
    \ == '(') {\n                    depth += 1\n                } else if (paren_group.charAt(j)\
    \ == ')') {\n                    depth -= 1\n                }\n             \
    \   if (depth < 0) {\n                    throw new RuntimeException(\"Invalid\
    \ parentheses string\")\n                }\n            }\n            result\
    \ = result.append(depth)\n        }\n        return result", "        var parens\
    \ = paren_string.split(\" \")\n        var max_nesting = 0\n        var result\
    \ = List[Long]()\n        for (i <- 0 until parens.length) {\n            var\
    \ cur_nesting = 0\n            for (j <- 0 until parens[i].length) {\n       \
    \         if (parens[i][j] == '(') {\n                    cur_nesting += 1\n \
    \               } else if (parens[i][j] == ')') {\n                    cur_nesting\
    \ -= 1\n                }\n                if (cur_nesting > max_nesting) {\n\
    \                    max_nesting = cur_nesting\n                }\n          \
    \  }\n            result = result.append(max_nesting)\n        }\n        return\
    \ result", "        val parens = paren_string.split(\" \")\n        val result\
    \ = parens.map(_.toLong).toList\n        return result", "        val parens =\
    \ paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n\
    \        result", "        var paren_list = paren_string.split(\" \")\n      \
    \  var paren_count = 0\n        var max_paren_count = 0\n        var result =\
    \ List[Long]()\n        for (i <- 0 until paren_list.length) {\n            if\
    \ (paren_list[i] == \"\") continue\n            if (paren_list[i] == \"(\" ||\
    \ paren_list[i] == \"{\" || paren_list[i] == \"[\") {\n                paren_count\
    \ += 1\n            } else if (paren_list[i] == \")\" || paren_list[i] == \"}\"\
    \ || paren_list[i] == \"]\") {\n                paren_count -= 1\n           \
    \ }\n            if (paren_count > max_paren_count) {\n                max_paren_count\
    \ = paren_count\n            }\n        }\n        for (i <- 0 until paren_list.length)\
    \ {\n            if (paren_list[i] == \"\") continue\n            if (paren_list[i]\
    \ == \"(\" || paren_list[i] == \"{\" || paren_list[i] == \"[\") {\n          \
    \      result = result.append(max_paren_count)\n            }\n        }\n   \
    \     return result", "        var paren_list = paren_string.split(\" \")\n  \
    \      var max_nesting = 0\n        var max_nesting_index = 0\n        for (i\
    \ <- 0 until paren_list.length) {\n            var nesting = 0\n            for\
    \ (j <- 0 until paren_list[i].length) {\n                if (paren_list[i][j]\
    \ == '(') {\n                    nesting += 1\n                } else if (paren_list[i][j]\
    \ == ')') {\n                    nesting -= 1\n                }\n           \
    \     if (nesting > max_nesting) {\n                    max_nesting = nesting\n\
    \                    max_nesting_index = i\n                }\n            }\n\
    \        }\n        var result = List[Long]()\n        for (i <- 0 until max_nesting_index)\
    \ {\n            result = result.append(max_nesting)\n        }\n        return\
    \ result", "        val parens = paren_string.split(\" \")\n        val result\
    \ = parens.map(Problem.parseNestedParens1).reduce(List[Long]())\n        return\
    \ result", "        var parens = paren_string.split(\" \")\n        var max_nesting\
    \ = 0\n        var max_nesting_index = 0\n        for (i <- 0 until parens.length)\
    \ {\n            var nesting = 0\n            for (j <- 0 until parens[i].length)\
    \ {\n                if (parens[i][j] == '(') {\n                    nesting +=\
    \ 1\n                } else if (parens[i][j] == ')') {\n                    nesting\
    \ -= 1\n                }\n                if (nesting > max_nesting) {\n    \
    \                max_nesting = nesting\n                    max_nesting_index\
    \ = i\n                }\n            }\n        }\n        var result = List[Long]()\n\
    \        for (i <- 0 until max_nesting_index) {\n            result = result.append(max_nesting)\n\
    \        }\n        return result", "        var paren_list = paren_string.split(\"\
    \ \")\n        var paren_count = 0\n        var max_paren_count = 0\n        var\
    \ max_paren_list = List[Long]()\n        for (i <- 0 until paren_list.length)\
    \ {\n            var paren_count_here = 0\n            for (j <- 0 until paren_list[i].length)\
    \ {\n                if (paren_list[i][j] == '(') {\n                    paren_count_here\
    \ += 1\n                } else if (paren_list[i][j] == ')') {\n              \
    \      paren_count_here -= 1\n                }\n                if (paren_count_here\
    \ == 0) {\n                    break\n                }\n            }\n     \
    \       if (paren_count_here > max_paren_count) {\n                max_paren_count\
    \ = paren_count_here\n                max_paren_list = List[Long](i.toLong, j.toLong)\n\
    \            }\n        }\n        return max_paren_list", "        val parens\
    \ = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens1).reduce(List[Long]::concat)\n\
    \        return result", "        val parens = paren_string.split(\" \")\n   \
    \     val paren_list = parens.map(_.trim).map(Problem::parseParens).toList\n \
    \       val max_nesting = paren_list.foldLeft(0l, (acc, paren) -> {\n        \
    \    val depth = paren.count(\"(\") - paren.count(\")\")\n            return depth\
    \ > acc ? depth : acc\n        })\n        val result = paren_list.map(l -> l.length\
    \ - max_nesting)\n        return result\n    }\n\n    // Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n    // For each of the group, output the deepest level of nesting of\
    \ parentheses.\n    // E.g. (()()) has maximum two levels of nesting while ((()))\
    \ has three.\n    // >>> parseNestedParens2((\"(()()) ((())) () ((())()())\"))\n\
    \    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens2(paren_string\
    \ : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n\
    \        val paren_list = parens.map(_.trim).map(Problem::parseParens).toList\n\
    \        val max_nesting = paren_list.foldLeft(0l, (acc, paren) -> {\n       \
    \     val depth = paren.count(\"(\") - paren.count(\")\")\n            return\
    \ depth > acc ? depth : acc\n        })\n        val result = paren_list.map(l\
    \ -> l.length - max_nesting)\n        return result\n    }\n\n    // Input to\
    \ this function is a string represented multiple groups for nested parentheses\
    \ separated by spaces.\n    // For each of the group, output the deepest level\
    \ of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of nesting\
    \ while ((())) has three.\n    // >>> parseNestedParens3((\"(()()) ((())) () ((())()())\"\
    ))\n    // (List[Long](2l.toLong", "        var paren_list = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (i <- 0 until paren_list.length)\
    \ {\n            var paren_group = paren_list[i].split(\"(\")\n            var\
    \ paren_depth = paren_group.length - 1\n            for (j <- 0 until paren_depth)\
    \ {\n                if (paren_group[j].charAt(0) == '(') {\n                \
    \    paren_depth = j\n                    break\n                }\n         \
    \   }\n            result = result.append(paren_depth)\n        }\n        return\
    \ result", "        val parens = paren_string.split(\" \")\n        val result\
    \ = parens.map(s => {\n            val parens = s.split(\"(\")\n            val\
    \ parens_count = parens.length - 1\n            val max_parens_count = parens_count.max()\n\
    \            val max_parens_count_index = parens_count.index(max_parens_count)\n\
    \            val max_parens_count_count = parens_count.get(max_parens_count_index)\n\
    \            val max_parens_count_parens = parens.get(max_parens_count_index)\n\
    \            val max_parens_count_parens_count = max_parens_count_parens.length\
    \ - 1\n            return max_parens_count_parens_count\n        })\n        return\
    \ result.toList", "        var paren_list = paren_string.split(\" \")\n      \
    \  var max_nesting = 0\n        var max_nesting_index = 0\n        for (i in 0\
    \ until paren_list.length) {\n            var nesting = 0\n            for (j\
    \ in 0 until i) {\n                if (paren_list[i].charAt(j) == '(') {\n   \
    \                 nesting += 1\n                } else if (paren_list[i].charAt(j)\
    \ == ')') {\n                    nesting -= 1\n                }\n           \
    \     if (nesting > max_nesting) {\n                    max_nesting = nesting\n\
    \                    max_nesting_index = j\n                }\n            }\n\
    \        }\n        var result = List[Long]()\n        for (i in 0 until max_nesting_index)\
    \ {\n            result = result.append(Long(paren_list[max_nesting_index].charAt(i)\
    \ - '0'))\n        }\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n\
    \        result", "        val parens = paren_string.split(\" \")\n        val\
    \ paren_list = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        val\
    \ paren_counts = paren_list.map(paren_count).toList\n        val max_paren_count\
    \ = paren_counts.max()\n        val max_paren_index = paren_counts.indexOf(max_paren_count)\n\
    \        val max_paren_count_list = paren_counts.take(max_paren_index + 1)\n \
    \       val max_paren_count_list_long = max_paren_count_list.map(l.toLong)\n \
    \       return max_paren_count_list_long", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(_.trim).map(Problem::parseNestedParens).reduce(List[Long]::concat)\n\
    \        result", "        val parens = paren_string.split(\" \")\n        val\
    \ paren_list = parens.map(p -> p.replaceAll(\"[()]\", \"\"))\n        val paren_count\
    \ = paren_list.length\n        val result = paren_list.map(p -> p.length() - p.replaceAll(\"\
    [()]\", \"\").length())\n        return result", "        var parens = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (i <- 0 until parens.length)\
    \ {\n            var paren = parens[i]\n            var depth = 0\n          \
    \  for (j <- 0 until paren.length) {\n                if (paren[j] == '(') {\n\
    \                    depth += 1\n                } else if (paren[j] == ')') {\n\
    \                    depth -= 1\n                }\n            }\n          \
    \  result = result.append(depth.toLong)\n        }\n        return result", " \
    \       var parens = paren_string.split(\" \")\n        var max_nesting = 0\n\
    \        var max_nesting_index = 0\n        for (i <- 0 until parens.length) {\n\
    \            var nesting = 0\n            for (j <- 0 until parens[i].length)\
    \ {\n                if (parens[i][j] == '(') {\n                    nesting +=\
    \ 1\n                } else if (parens[i][j] == ')') {\n                    nesting\
    \ -= 1\n                }\n                if (nesting > max_nesting) {\n    \
    \                max_nesting = nesting\n                    max_nesting_index\
    \ = i\n                }\n            }\n        }\n        var result = List[Long]()\n\
    \        for (i <- 0 until max_nesting_index) {\n            result = result.append(i)\n\
    \        }\n        return result", "        var result = List[Long]()\n     \
    \   var stack = List[String]()\n        var paren_count = 0\n        var max_paren_count\
    \ = 0\n        var max_index = 0\n        var max_paren_count_index = 0\n    \
    \    var paren_count_index = 0\n        var paren_count_stack = List[Long]()\n\
    \        var paren_count_stack_index = 0\n        var paren_count_stack_max =\
    \ 0\n        var paren_count_stack_max_index = 0\n        var paren_count_stack_max_count\
    \ = 0\n        var paren_count_stack_max_count_index = 0\n        var paren_count_stack_max_count_count\
    \ = 0\n        var paren_count_stack_max_count_count_index = 0\n        var paren_count_stack_max_count_count_count\
    \ = 0\n        var paren_count_stack_max_count_count_count_index = 0\n       \
    \ var paren_count_stack_max_count_count_count_count = 0\n        var paren_count_stack_max_count_count_count_count_index\
    \ = 0\n        var paren_count_stack_max_count_count_count_count_count = 0\n \
    \       var paren_count_stack_max_count_count_count_count_count_index = 0\n  \
    \      var paren_count_stack_max_count_count_count_count_count_count = 0\n   \
    \     var paren_count_stack_max_count_count_count_count_count_count_index = 0\n\
    \        var paren_count_stack_max_count_count_count_count_count_count_count =\
    \ 0\n        var paren_count_stack_max_count_count_count_count_count_count_count_index\
    \ = 0\n        var paren_count_stack_max_count_count_count_count_count_count_count_count\
    \ = 0\n        var paren_count_stack_max_count_count_count_count_count_count_count_count_index\
    \ = 0\n        var paren_count_stack_max_count_count_count_count", "        val\
    \ parens = paren_string.split(\" \")\n        val result = parens.map(Problem.parseNestedParens).reduce(List[Long]::concat)\n\
    \        result", "        val parens = paren_string.split(\" \")\n        val\
    \ result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n\
    \        return result", "        val parens = paren_string.split(\" \")\n   \
    \     val result = parens.map(s => {\n            val parens = s.split(\"(\")\n\
    \            val parens_count = parens.length - 1\n            val max_parens_count\
    \ = parens_count.max()\n            return max_parens_count\n        }).toList\n\
    \        return result", "        val parens = paren_string.split(\" \")\n   \
    \     val result = parens.map(s => s.replaceAll(\"[()]\", \"\"))\n        val\
    \ result_list = result.map(s => s.split(\"(\")).map(s => s.length - 1).toList\n\
    \        result_list.sort((a, b) => a - b)\n        return result_list", "   \
    \     val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n\
    \        result", "        val parens = paren_string.split(\" \")\n        val\
    \ result = parens.map(s => {\n            val parens = s.split(\"(\")\n      \
    \      val depth = parens.length - 1\n            val max_depth = depth.max()\n\
    \            return max_depth\n        }).toList\n        return result", "  \
    \      var paren_list = paren_string.split(\" \")\n        var paren_count = 0\n\
    \        var max_paren_count = 0\n        var result = List[Long]()\n        for\
    \ (i <- 0 until paren_list.length) {\n            var paren_count_here = 0\n \
    \           for (j <- 0 until paren_list[i].length) {\n                if (paren_list[i][j]\
    \ == '(') {\n                    paren_count_here += 1\n                } else\
    \ if (paren_list[i][j] == ')') {\n                    paren_count_here -= 1\n\
    \                }\n                if (paren_count_here == 0) {\n           \
    \         break\n                }\n            }\n            if (paren_count_here\
    \ > max_paren_count) {\n                max_paren_count = paren_count_here\n \
    \           }\n            if (paren_count_here == 0) {\n                result\
    \ = result.append(i)\n            }\n        }\n        return result.map(x =>\
    \ x.toLong)", "        val parens = paren_string.split(\" \")\n        val paren_list\
    \ = parens.map(_.trim).filter(s => !s.isEmpty()).toList\n        val paren_counts\
    \ = paren_list.map(s => s.count(\"(\"))\n        val max_paren_count = paren_counts.max()\n\
    \        val max_paren_index = paren_counts.indexOf(max_paren_count)\n       \
    \ val max_paren_count_list = paren_counts.take(max_paren_index + 1)\n        val\
    \ max_paren_count_list_long = max_paren_count_list.map(s => s.toLong)\n      \
    \  return max_paren_count_list_long", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"\
    ))\n        val result_list = result.map(Long::parseLong).toList\n        return\
    \ result_list", "        var paren_list = paren_string.split(\" \")\n        var\
    \ max_nesting = 0\n        var max_nesting_index = 0\n        for (i <- 0 until\
    \ paren_list.length) {\n            var paren_count = 0\n            for (j <-\
    \ 0 until paren_list[i].length) {\n                if (paren_list[i][j] == '(')\
    \ {\n                    paren_count += 1\n                } else if (paren_list[i][j]\
    \ == ')') {\n                    paren_count -= 1\n                }\n       \
    \         if (paren_count > max_nesting) {\n                    max_nesting =\
    \ paren_count\n                    max_nesting_index = i\n                }\n\
    \            }\n        }\n        var result = List[Long]()\n        for (i <-\
    \ 0 until max_nesting_index) {\n            result = result.append(i)\n      \
    \  }\n        return result", "        val parens = paren_string.split(\" \")\n\
    \        val result = parens.map(Problem.parseNestedParens_).reduce(List[Long]::concat)\n\
    \        return result", "        val parens = paren_string.split(\" \")\n   \
    \     val paren_list = parens.map(p -> p.replaceAll(\"[()]\", \"\"))\n       \
    \ val paren_list_len = paren_list.length\n        val max_nesting = paren_list_len.max()\n\
    \        val result = paren_list.map(p -> p.length() - max_nesting)\n        return\
    \ result", "        val parens = paren_string.split(\" \")\n        val result\
    \ = parens.map(Problem::parseNestedParens_).reduce(List[Long]::concat)\n     \
    \   result\n    }\n\n    // Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    // For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    // E.g. (()()) has\
    \ maximum two levels of nesting while ((())) has three.\n    // >>> parseNestedParens_(\"\
    (()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
    \ 3l.toLong))\n    def parseNestedParens_(paren_string : String) : List[Long]\
    \ = {\n        val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens_).reduce(List[Long]::concat)\n\
    \        result\n    }\n\n    // Input to this function is a string represented\
    \ multiple groups for nested parentheses separated by spaces.\n    // For each\
    \ of the group, output the deepest level of nesting of parentheses.\n    // E.g.\
    \ (()()) has maximum two levels of nesting while ((())) has three.\n    // >>>\
    \ parseNestedParens_(\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens_1(paren_string\
    \ : String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n\
    \        val result = parens.map(Problem::parseNestedParens_).reduce(List[Long]::concat)\n\
    \        result\n    }\n\n    // Input to this function is a string represented\
    \ multiple groups for nested parentheses separated by spaces.\n    // For each\
    \ of the group, output the deepest level of nesting of parentheses.\n    // E.g.\
    \ (()()) has maximum two levels of nesting while ((())) has three.\n    // >>>\
    \ parseN", "        val parens = paren_string.split(\" \")\n        val result\
    \ = parens.map(_.toLong).toList\n        return result", "        var paren_list\
    \ = paren_string.split(\" \")\n        var max_nesting = 0\n        var max_nesting_index\
    \ = 0\n        for (i <- 0 until paren_list.length) {\n            var paren_count\
    \ = 0\n            var paren_index = i\n            while (paren_index < paren_list.length)\
    \ {\n                if (paren_list[paren_index] == \"(\" && paren_count == 0)\
    \ {\n                    paren_count += 1\n                } else if (paren_list[paren_index]\
    \ == \")\" && paren_count > 0) {\n                    paren_count -= 1\n     \
    \           }\n                paren_index += 1\n            }\n            if\
    \ (paren_count > max_nesting) {\n                max_nesting = paren_count\n \
    \               max_nesting_index = i\n            }\n        }\n        var result\
    \ = List[Long]()\n        for (i <- 0 until max_nesting_index) {\n           \
    \ result = result.append(i)\n        }\n        return result", "        var paren_list\
    \ = paren_string.split(\" \")\n        var max_depth = 0\n        var max_depth_list\
    \ = List[Long]()\n        for (var i = 0; i < paren_list.length; i++) {\n    \
    \        var depth = depth(paren_list[i])\n            if (depth > max_depth)\
    \ {\n                max_depth = depth\n                max_depth_list = List[Long]()\n\
    \            }\n            max_depth_list = max_depth_list.append(depth)\n  \
    \      }\n        return max_depth_list", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(Problem.parseNestedParens_).reduce(List[Long]::concat)\n\
    \        result", "        val parens = paren_string.split(\" \")\n        val\
    \ result = parens.map(Problem::parseNestedParens).reduce(_.max)\n        return\
    \ result", "        var parens = paren_string.split(\" \")\n        var max_nesting\
    \ = 0\n        var result = List[Long]()\n        for (i in 0 until parens.length)\
    \ {\n            var paren_group = parens[i]\n            var nesting = 0\n  \
    \          for (j in 0 until paren_group.length) {\n                if (paren_group[j]\
    \ == '(') {\n                    nesting += 1\n                } else if (paren_group[j]\
    \ == ')') {\n                    nesting -= 1\n                }\n           \
    \     if (nesting > max_nesting) {\n                    max_nesting = nesting\n\
    \                }\n            }\n            result = result.append(max_nesting)\n\
    \        }\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val paren_list = parens.map(_.trim).map(Problem::parseParens).toList\n\
    \        val max_nesting = paren_list.foldLeft(0L, (acc, paren) => acc + paren)\n\
    \        val result = paren_list.map(l -> l.length - max_nesting)\n        return\
    \ result", "        val parens = paren_string.split(\" \")\n        val result\
    \ = List[Long]()\n        for (i <- 0 until parens.length) {\n            val\
    \ paren = parens[i]\n            val paren_count = 0\n            for (j <- 0\
    \ until paren.length) {\n                if (paren[j] == '(') {\n            \
    \        paren_count += 1\n                } else if (paren[j] == ')') {\n   \
    \                 paren_count -= 1\n                }\n            }\n       \
    \     result = result.append(paren_count)\n        }\n        return result",
  "        var parens = paren_string.split(\" \")\n        var max_nesting = 0\n \
    \       var result = List[Long]()\n        for (i <- 0 until parens.length) {\n\
    \            var paren = parens[i]\n            var nesting = 0\n            for\
    \ (j <- 0 until paren.length) {\n                if (paren[j] == '(') {\n    \
    \                nesting += 1\n                } else if (paren[j] == ')') {\n\
    \                    nesting -= 1\n                }\n                if (nesting\
    \ > max_nesting) {\n                    max_nesting = nesting\n              \
    \  }\n            }\n            result = result.append(max_nesting.toLong)\n\
    \        }\n        return result", "        var result = List[Long]()\n     \
    \   var paren_stack = List[String]()\n        var paren_count = 0\n        var\
    \ paren_index = 0\n        var paren_length = paren_string.length()\n        var\
    \ paren_char = paren_string.charAt(0)\n        var paren_char_index = 0\n    \
    \    var paren_char_length = 1\n        var paren_char_count = 0\n        var\
    \ paren_char_count_max = 0\n        var paren_char_count_min = 0\n        var\
    \ paren_char_count_diff = 0\n        var paren_char_count_diff_max = 0\n     \
    \   var paren_char_count_diff_min = 0\n        var paren_char_count_diff_diff\
    \ = 0\n        var paren_char_count_diff_diff_max = 0\n        var paren_char_count_diff_diff_min\
    \ = 0\n        var paren_char_count_diff_diff_diff = 0\n        var paren_char_count_diff_diff_diff_max\
    \ = 0\n        var paren_char_count_diff_diff_diff_min = 0\n        var paren_char_count_diff_diff_diff_diff\
    \ = 0\n        var paren_char_count_diff_diff_diff_diff_max = 0\n        var paren_char_count_diff_diff_diff_diff_min\
    \ = 0\n        var paren_char_count_diff_diff_diff_diff_diff = 0\n        var\
    \ paren_char_count_diff_diff_diff_diff_diff_max = 0\n        var paren_char_count_diff_diff_diff_diff_diff_min\
    \ = 0\n        var paren_char_count_diff_diff_diff_diff_diff_diff = 0\n      \
    \  var paren_char_count_diff_diff_diff_diff_diff_diff_max = 0\n        var paren_char_count_diff_diff_diff_diff_diff_diff_min\
    \ = 0\n        var paren_char_count_diff_diff_diff_diff_diff_diff_diff = 0\n \
    \       var paren_char", "        val parens = paren_string.split(\" \")\n   \
    \     val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n    \
    \    val result_list = result.toList\n        val result_list_long = result_list.map(_.toLong)\n\
    \        return result_list_long", "        var parens = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (i <- 0 until parens.length)\
    \ {\n            var level = 0\n            for (j <- 0 until parens[i].length)\
    \ {\n                if (parens[i][j] == '(') {\n                    level +=\
    \ 1\n                } else if (parens[i][j] == ')') {\n                    level\
    \ -= 1\n                }\n                if (level == 0) {\n               \
    \     result = result.append(i)\n                    break\n                }\n\
    \            }\n        }\n        return result", "        var paren_list = paren_string.split(\"\
    \ \")\n        var paren_count = 0\n        var max_paren_count = 0\n        var\
    \ max_paren_index = 0\n        var paren_list_length = paren_list.length\n   \
    \     var paren_list_index = 0\n        var paren_list_index_prev = 0\n      \
    \  var paren_list_index_next = 0\n        var paren_list_index_next_prev = 0\n\
    \        var paren_list_index_next_next = 0\n        var paren_list_index_next_next_prev\
    \ = 0\n        var paren_list_index_next_next_next = 0\n        var paren_list_index_next_next_next_prev\
    \ = 0\n        var paren_list_index_next_next_next_next = 0\n        var paren_list_index_next_next_next_next_prev\
    \ = 0\n        var paren_list_index_next_next_next_next_next = 0\n        var\
    \ paren_list_index_next_next_next_next_next_prev = 0\n        var paren_list_index_next_next_next_next_next_next\
    \ = 0\n        var paren_list_index_next_next_next_next_next_next_prev = 0\n \
    \       var paren_list_index_next_next_next_next_next_next_next = 0\n        var\
    \ paren_list_index_next_next_next_next_next_next_next_prev = 0\n        var paren_list_index_next_next_next_next_next_next_next_next\
    \ = 0\n        var paren_list_index_next_next_next_next_next_next_next_next_prev\
    \ = 0\n        var paren_list_index_next_next_next_next_next_next_next_next_next\
    \ = 0\n        var paren_list_index_next_next_next_next_next_next_next_next_next_prev\
    \ = 0\n        var paren_list_index_next_next_next_next_next_next_next_next_next_next\
    \ = 0", "        var result = List[Long]()\n        var stack = List[String]()\n\
    \        var paren_count = 0\n        var max_paren_count = 0\n        var paren_level\
    \ = 0\n        var paren_level_count = 0\n        var paren_count_stack = List[Long]()\n\
    \        var paren_count_stack_index = 0\n        var paren_count_stack_count\
    \ = 0\n        var paren_count_stack_count_index = 0\n        var paren_count_stack_count_count\
    \ = 0\n        var paren_count_stack_count_count_index = 0\n        var paren_count_stack_count_count_count\
    \ = 0\n        var paren_count_stack_count_count_count_index = 0\n        var\
    \ paren_count_stack_count_count_count_count = 0\n        var paren_count_stack_count_count_count_count_index\
    \ = 0\n        var paren_count_stack_count_count_count_count_count = 0\n     \
    \   var paren_count_stack_count_count_count_count_count_index = 0\n        var\
    \ paren_count_stack_count_count_count_count_count_count = 0\n        var paren_count_stack_count_count_count_count_count_count_index\
    \ = 0\n        var paren_count_stack_count_count_count_count_count_count_count\
    \ = 0\n        var paren_count_stack_count_count_count_count_count_count_count_index\
    \ = 0\n        var paren_count_stack_count_count_count_count_count_count_count_count\
    \ = 0\n        var paren_count_stack_count_count_count_count_count_count_count_count_index\
    \ = 0\n        var paren_count_stack_count_count_count_count_count_count_count_count_count\
    \ = 0\n        var paren_count_stack_count_count_count_count_count_count_count_count_count_index\
    \ = 0\n        var paren_count_stack_count_count_count_count_count_count_count_count_count_count\
    \ =", "        var parens = paren_string.split(\" \")\n        var max_nesting\
    \ = 0\n        var max_nesting_index = 0\n        for (i <- 0 until parens.length)\
    \ {\n            var nesting = 0\n            for (j <- 0 until parens.length)\
    \ {\n                if (parens[j] == \"(\" && parens[i] == \")\") {\n       \
    \             nesting += 1\n                } else if (parens[j] == \")\" && parens[i]\
    \ == \"(\" && nesting > 0) {\n                    nesting -= 1\n             \
    \   }\n            }\n            if (nesting > max_nesting) {\n             \
    \   max_nesting = nesting\n                max_nesting_index = i\n           \
    \ }\n        }\n        var result = List[Long]()\n        for (i <- 0 until parens.length)\
    \ {\n            if (parens[i] == \"(\" && parens[max_nesting_index] == \")\"\
    ) {\n                result = result.append(i.toLong)\n            }\n       \
    \ }\n        return result", "        val parens = paren_string.split(\" \")\n\
    \        val result = parens.map(_.trim).map(Problem::parseNestedParens).reduce(_.maxBy(Comparator.naturalOrder()))\n\
    \        return result", "        var result = List[Long]()\n        var stack\
    \ = List[String]()\n        var paren_count = 0\n        var paren_index = 0\n\
    \        var paren_level = 0\n        var paren_count_max = 0\n        var paren_count_min\
    \ = 0\n        var paren_count_diff = 0\n        var paren_count_diff_max = 0\n\
    \        var paren_count_diff_min = 0\n        var paren_count_diff_diff = 0\n\
    \        var paren_count_diff_diff_max = 0\n        var paren_count_diff_diff_min\
    \ = 0\n        var paren_count_diff_diff_diff = 0\n        var paren_count_diff_diff_diff_max\
    \ = 0\n        var paren_count_diff_diff_diff_min = 0\n        var paren_count_diff_diff_diff_diff\
    \ = 0\n        var paren_count_diff_diff_diff_diff_max = 0\n        var paren_count_diff_diff_diff_diff_min\
    \ = 0\n        var paren_count_diff_diff_diff_diff_diff = 0\n        var paren_count_diff_diff_diff_diff_diff_max\
    \ = 0\n        var paren_count_diff_diff_diff_diff_diff_min = 0\n        var paren_count_diff_diff_diff_diff_diff_diff\
    \ = 0\n        var paren_count_diff_diff_diff_diff_diff_diff_max = 0\n       \
    \ var paren_count_diff_diff_diff_diff_diff_diff_min = 0\n        var paren_count_diff_diff_diff_diff_diff_diff_diff\
    \ = 0\n        var paren_count_diff_diff_diff_diff_diff_diff_diff_max = 0\n  \
    \      var paren_count_diff_diff_diff_diff_diff_diff_diff_min = 0\n        var\
    \ paren_count_diff_diff_diff_diff_diff_diff_diff_diff = 0\n        var paren_count_diff_diff_diff_diff_diff_diff_diff_diff_max\
    \ = 0\n        var paren_count", "        val parens = paren_string.split(\" \"\
    )\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n\
    \        result", "        val parens = paren_string.split(\" \")\n        val\
    \ result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n\
    \        result", "        val parens = paren_string.split(\" \")\n        val\
    \ result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n\
    \        result", "        var paren_list = paren_string.split(\" \")\n      \
    \  var max_nesting = 0\n        var max_nesting_index = 0\n        for (i <- 0\
    \ until paren_list.length) {\n            var nesting = 0\n            var nesting_index\
    \ = 0\n            for (j <- 0 until paren_list[i].length()) {\n             \
    \   if (paren_list[i][j] == '(') {\n                    nesting += 1\n       \
    \             nesting_index = j\n                } else if (paren_list[i][j] ==\
    \ ')') {\n                    nesting -= 1\n                    if (nesting ==\
    \ 0) {\n                        break\n                    }\n               \
    \ }\n            }\n            if (nesting > max_nesting) {\n               \
    \ max_nesting = nesting\n                max_nesting_index = i\n            }\n\
    \        }\n        var result = List[Long]()\n        for (i <- 0 until max_nesting_index)\
    \ {\n            result = result.append(paren_list[i].length())\n        }\n \
    \       return result", "        val parens = paren_string.split(\" \")\n    \
    \    val result = parens.map(Problem.parseNestedParens1).reduce(List[Long]::concat)\n\
    \        result", "        var paren_list = paren_string.split(\" \")\n      \
    \  var max_nesting = 0\n        var max_nesting_index = 0\n        for (i <- 0\
    \ until paren_list.length) {\n            var nesting = 0\n            for (j\
    \ <- i until paren_list.length) {\n                if (paren_list[j] == \"(\"\
    \ || paren_list[j] == \"{\" || paren_list[j] == \"[\") {\n                   \
    \ nesting += 1\n                } else if (paren_list[j] == \")\" || paren_list[j]\
    \ == \"}\" || paren_list[j] == \"]\") {\n                    nesting -= 1\n  \
    \              }\n                if (nesting > max_nesting) {\n             \
    \       max_nesting = nesting\n                    max_nesting_index = j\n   \
    \             }\n            }\n        }\n        var result = List[Long]()\n\
    \        for (i <- 0 until max_nesting_index) {\n            result = result.append(i.toLong)\n\
    \        }\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(Problem.parseNestedParens).reduce(List[Long]::concat)\n\
    \        result", "        var result = mutable.List[Long]()\n        var stack\
    \ = mutable.Stack[String]()\n        var depth = 0\n        var parens = 0\n \
    \       var paren_count = 0\n        var paren_index = 0\n        var paren_string_index\
    \ = 0\n        var paren_string_length = paren_string.length\n        var paren_string_char\
    \ = paren_string.charAt(paren_string_index)\n        while (paren_string_index\
    \ < paren_string_length) {\n            if (paren_string_char == '(') {\n    \
    \            stack.push(paren_string.substring(paren_string_index, paren_string_index\
    \ + 1))\n                parens += 1\n                paren_count += 1\n     \
    \           paren_index = paren_string_index\n                paren_string_index\
    \ += 1\n            } else if (paren_string_char == ')') {\n                stack.pop()\n\
    \                parens -= 1\n                paren_count -= 1\n             \
    \   if (stack.isEmpty()) {\n                    result.append(depth)\n       \
    \             depth = 0\n                } else {\n                    depth =\
    \ depth + 1\n                }\n                paren_index = paren_string_index\n\
    \                paren_string_index += 1\n            } else if (paren_string_char\
    \ == ' ') {\n                if (stack.isEmpty()) {\n                    result.append(depth)\n\
    \                    depth = 0\n                } else {\n                   \
    \ depth = depth + 1\n                }\n                paren_index = paren_string_index\n\
    \                paren_string_index += 1\n            } else {\n             \
    \   paren_index = paren_string_index\n                paren_string_index += 1\n\
    \            }\n        }\n        if (paren_count != 0) {\n            throw\
    \ new RuntimeException(\"Unbalanced parentheses\")\n        }\n        return\
    \ result", "        var paren_list = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (i <- 0 until paren_list.length) {\n           \
    \ var paren_group = paren_list[i].split(\"(\")\n            var paren_depth =\
    \ 0\n            for (j <- 0 until paren_group.length) {\n                if (paren_group[j].equals(\"\
    (\")) {\n                    paren_depth += 1\n                } else if (paren_group[j].equals(\"\
    )\")) {\n                    paren_depth -= 1\n                }\n           \
    \ }\n            result = result.append(paren_depth.toLong)\n        }\n     \
    \   return result", "        val paren_list = paren_string.split(\" \")\n    \
    \    val result = paren_list.map(s => {\n            val paren_list = s.split(\"\
    (\")\n            val paren_list_len = paren_list.length\n            val max_nesting\
    \ = 0\n            for (i <- 0 until paren_list_len) {\n                val paren_group\
    \ = paren_list[i]\n                val paren_group_len = paren_group.length\n\
    \                val nesting = 0\n                for (j <- 0 until paren_group_len)\
    \ {\n                    if (paren_group[j] == '(') {\n                      \
    \  nesting += 1\n                    } else if (paren_group[j] == ')') {\n   \
    \                     nesting -= 1\n                    }\n                }\n\
    \                if (nesting > max_nesting) {\n                    max_nesting\
    \ = nesting\n                }\n            }\n            return max_nesting\n\
    \        })\n        return result.toList", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(Problem::parseNestedParensHelper).reduce(_.maxBy(_.toLong))\n\
    \        return result\n    }\n\n    // Helper function for parseNestedParens\n\
    \    def parseNestedParensHelper(left : String, right : String) : Long = {\n \
    \       val left_parens = left.count(\"(\")\n        val right_parens = right.count(\"\
    (\")\n        val left_nesting = left_parens - right_parens\n        val right_nesting\
    \ = right_parens - left_parens\n        val max_nesting = Math.max(left_nesting,\
    \ right_nesting)\n        return max_nesting", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"\
    ))\n        val result_list = result.toList\n        val result_longs = result_list.map(_.toLong)\n\
    \        return result_longs", "        val parens = paren_string.split(\" \"\
    )\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n\
    \        return result", "        var paren_list = paren_string.split(\" \")\n\
    \        var result = List[Long]()\n        for (var i = 0; i < paren_list.length;\
    \ i++) {\n            var paren_group = paren_list[i]\n            var paren_count\
    \ = 0\n            for (var j = 0; j < paren_group.length(); j++) {\n        \
    \        if (paren_group.charAt(j) == '(') {\n                    paren_count\
    \ += 1\n                } else if (paren_group.charAt(j) == ')') {\n         \
    \           paren_count -= 1\n                }\n            }\n            result\
    \ = result.append(paren_count)\n        }\n        return result", "        val\
    \ parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(Problem::parseNestedParens).reduce(_.maxBy(Comparator.naturalOrder()))\n\
    \        return result", "        var paren_list = paren_string.split(\" \")\n\
    \        var max_depth = 0\n        var max_depth_index = 0\n        for (i <-\
    \ 0 until paren_list.length) {\n            var depth = 0\n            for (j\
    \ <- 0 until paren_list[i].length) {\n                if (paren_list[i][j] ==\
    \ '(') depth += 1\n                if (paren_list[i][j] == ')') depth -= 1\n \
    \               if (depth > max_depth) {\n                    max_depth = depth\n\
    \                    max_depth_index = i\n                }\n            }\n \
    \       }\n        var result = List[Long]()\n        for (i <- 0 until max_depth_index)\
    \ {\n            result = result.append(paren_list[i].length - 1 - max_depth)\n\
    \        }\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(s => {\n            val parens = s.split(\"\
    (\")\n            val max_nesting = parens.map(s => {\n                val parens2\
    \ = s.split(\")\")\n                val max_nesting2 = parens2.map(s2 => {\n \
    \                   val parens3 = s2.split(\"(\")\n                    val max_nesting3\
    \ = parens3.map(s3 => {\n                        val parens4 = s3.split(\")\"\
    )\n                        val max_nesting4 = parens4.map(s4 => {\n          \
    \                  val parens5 = s4.split(\"(\")\n                           \
    \ val max_nesting5 = parens5.map(s5 => {\n                                val\
    \ parens6 = s5.split(\")\")\n                                val max_nesting6\
    \ = parens6.map(s6 => {\n                                    val parens7 = s6.split(\"\
    (\")\n                                    val max_nesting7 = parens7.map(s7 =>\
    \ {\n                                        val parens8 = s7.split(\")\")\n \
    \                                       val max_nesting8 = parens8.map(s8 => {\n\
    \                                            val parens9 = s8.split(\"(\")\n \
    \                                           val max_nesting9 = parens9.map(s9\
    \ => {\n                                                val parens10 = s9.split(\"\
    )\")\n                                                val max_nesting10 = parens10.map(s10\
    \ => {\n                                                    val parens11 = s10.split(\"\
    (\")\n                                                    val max_nesting11 =\
    \ parens11.map(s11 => {\n                                                    \
    \    val parens12 = s11.split(\")\")\n                                       \
    \                 val max_nesting12 = parens12.map(s12 => {\n                \
    \                                            val parens13 = s12.split(\"(\")\n\
    \                                 ", "        val parens = paren_string.split(\"\
    \ \")\n        val paren_counts = parens.map(s => s.count(\"(\"))\n        val\
    \ max_paren_count = paren_counts.max()\n        val max_paren_count_index = paren_counts.index(max_paren_count)\n\
    \        val max_paren_count_parens = parens.slice(max_paren_count_index)\n  \
    \      val max_paren_count_parens_count = max_paren_count_parens.count(\"(\")\n\
    \        val max_paren_count_parens_count_index = max_paren_count_parens.index(max_paren_count_parens_count)\n\
    \        val max_paren_count_parens_count_parens = max_paren_count_parens.slice(max_paren_count_parens_count_index)\n\
    \        val max_paren_count_parens_count_parens_count = max_paren_count_parens_count_parens.count(\"\
    (\")\n        val max_paren_count_parens_count_parens_count_index = max_paren_count_parens_count_parens.index(max_paren_count_parens_count_parens_count)\n\
    \        val max_paren_count_parens_count_parens_count_parens = max_paren_count_parens_count_parens_count_parens.slice(max_paren_count_parens_count_parens_count_index)\n\
    \        val max_paren_count_parens_count_parens_count_parens_count = max_paren_count_parens_count_parens_count_parens_count.count(\"\
    (\")\n        val max_paren_count_parens_count_parens_count_parens_count_index\
    \ = max_paren_count_parens_count_parens_count_parens_count_parens.index(max_paren_count_parens_count_parens_count_parens_count)\n\
    \        val max_paren_count_parens_count_parens_count_parens_count_parens =",
  "        val parens = paren_string.split(\" \")\n        val paren_list = parens.map(_.trim).map(_.replaceAll(\"\
    [()]\", \"\"))\n        val paren_counts = paren_list.map(parens => parens.length()).toSeq\n\
    \        val max_paren_count = paren_counts.max()\n        val max_paren_count_index\
    \ = paren_counts.indexOf(max_paren_count)\n        val max_paren_count_parens\
    \ = paren_list.take(max_paren_count_index)\n        val max_paren_count_parens_list\
    \ = max_paren_count_parens.map(parens => parens.length()).toSeq\n        val max_paren_count_parens_list_count\
    \ = max_paren_count_parens_list.length\n        val max_paren_count_parens_list_list\
    \ = max_paren_count_parens_list.toSeq\n        val max_paren_count_parens_list_list_count\
    \ = max_paren_count_parens_list_count.length\n        val max_paren_count_parens_list_list_list\
    \ = max_paren_count_parens_list_list.toSeq\n        val max_paren_count_parens_list_list_list_count\
    \ = max_paren_count_parens_list_list_count.length\n        val max_paren_count_parens_list_list_list_list\
    \ = max_paren_count_parens_list_list_list_count.toSeq\n        val max_paren_count_parens_list_list_list_list_count\
    \ = max_paren_count_parens_list_list_list_count.length\n        val max_paren_count_parens_list_list_list_list_list\
    \ = max_paren_count_parens_list_list_list_list_count.toSeq\n        val max_paren_count_parens_list_list_list_list_list_count\
    \ = max_paren_count_parens_list_list_list_list_count.length\n        ", "    \
    \    val parens = paren_string.split(\" \")\n        val result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n\
    \        result", "        val parens = paren_string.split(\" \")\n        val\
    \ result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n\
    \        return result", "        var parens = paren_string.split(\" \")\n   \
    \     var result = List[Long]()\n        for (i <- 0 until parens.length) {\n\
    \            var paren = parens[i]\n            if (paren.equals(\"\")) {\n  \
    \              continue\n            }\n            var level = 0\n          \
    \  for (j <- 0 until paren.length) {\n                if (paren[j] == '(') {\n\
    \                    level += 1\n                } else if (paren[j] == ')') {\n\
    \                    level -= 1\n                }\n                if (level\
    \ == 0) {\n                    result = result.append(j.toLong)\n            \
    \        break\n                }\n            }\n        }\n        return result",
  "        var result = List[Long]()\n        var parens = paren_string.split(\" \"\
    )\n        for (i <- 0 until parens.length) {\n            var paren = parens[i]\n\
    \            var depth = 0\n            for (j <- 0 until paren.length) {\n  \
    \              if (paren[j] == '(') depth += 1\n                if (paren[j] ==\
    \ ')') depth -= 1\n                if (depth < 0) {\n                    throw\
    \ new RuntimeException(\"Invalid parentheses string\")\n                }\n  \
    \          }\n            result = result.append(depth.toLong)\n        }\n  \
    \      return result", "        var paren_list = paren_string.split(\" \")\n \
    \       var paren_count = 0\n        var max_paren_count = 0\n        var max_paren_list\
    \ = List[Long]()\n        for (i <- 0 until paren_list.length) {\n           \
    \ if (paren_list[i].equals(\"(\")) {\n                paren_count += 1\n     \
    \       } else if (paren_list[i].equals(\")\")) {\n                paren_count\
    \ -= 1\n            }\n            if (paren_count > max_paren_count) {\n    \
    \            max_paren_count = paren_count\n                max_paren_list = List[Long](i.toLong)\n\
    \            }\n        }\n        return max_paren_list", "        val parens\
    \ = paren_string.split(\" \")\n        val paren_counts = parens.map(_.toLong).toList\n\
    \        val max_paren_count = paren_counts.max()\n        val max_paren_count_index\
    \ = paren_counts.indexOf(max_paren_count)\n        val max_paren_count_parens\
    \ = parens.slice(max_paren_count_index)\n        val max_paren_count_parens_count\
    \ = max_paren_count_parens.length\n        val max_paren_count_parens_count_parens\
    \ = max_paren_count_parens.map(_.toLong).toList\n        val max_paren_count_parens_count_parens_count\
    \ = max_paren_count_parens_count_parens.max()\n        val max_paren_count_parens_count_parens_count_parens\
    \ = max_paren_count_parens_count_parens.toList\n        val max_paren_count_parens_count_parens_count_parens_count\
    \ = max_paren_count_parens_count_parens_count_parens.max()\n        val max_paren_count_parens_count_parens_count_parens_count_parens\
    \ = max_paren_count_parens_count_parens_count_parens.toList\n        val max_paren_count_parens_count_parens_count_parens_count_parens_count\
    \ = max_paren_count_parens_count_parens_count_parens_count_parens.max()\n    \
    \    val max_paren_count_parens_count_parens_count_parens_count_parens_count_parens\
    \ = max_paren_count_parens_count_parens_count_parens_count_parens.max()\n    \
    \    val max_paren_count_parens_count_parens_count_parens_count_parens_count_parens_count\
    \ = max_paren_count_parens_count_parens_count_parens_count_parens_count_parens.max()\n\
    \        val max_", "        val parens = paren_string.split(\" \")\n        val\
    \ result = parens.map(Problem.parseNestedParens_).reduce(List[Long]())\n     \
    \   return result", "        val parens = paren_string.split(\" \")\n        val\
    \ result = parens.map(Problem::parseNestedParens).reduce(List[Long]::concat)\n\
    \        return result", "        var paren_list = paren_string.split(\" \")\n\
    \        var result = List[Long]()\n        for (i <- 0 until paren_list.length)\
    \ {\n            var paren_group = paren_list[i]\n            var paren_count\
    \ = 0\n            for (j <- 0 until paren_group.length) {\n                if\
    \ (paren_group[j] == '(') {\n                    paren_count += 1\n          \
    \      } else if (paren_group[j] == ')') {\n                    paren_count -=\
    \ 1\n                }\n            }\n            result = result.append(paren_count)\n\
    \        }\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(Problem::parseNestedParens).reduce(_.max)\n\
    \        result", "        val parens = paren_string.split(\" \")\n        val\
    \ result = parens.map(Problem.parseNestedParens).reduce(List[Long]())\n      \
    \  return result", "        val parens = paren_string.split(\" \")\n        val\
    \ result = parens.map(s => {\n            val parens = s.split(\"(\")\n      \
    \      val depth = parens.length - 1\n            val max_depth = depth.max()\n\
    \            return depth.toLong\n        })\n        return result", "      \
    \  val parens = paren_string.split(\" \")\n        val result = parens.map(_.toLong).toList\n\
    \        return result", "        var paren_list = paren_string.split(\" \")\n\
    \        var max_nesting = 0\n        var max_nesting_index = 0\n        for (i\
    \ <- 0 until paren_list.length) {\n            var curr_nesting = 0\n        \
    \    var curr_nesting_index = i\n            for (j <- i until paren_list.length)\
    \ {\n                if (paren_list[j] == \"(\" && paren_list[j-1] != \"(\" &&\
    \ paren_list[j+1] != \"(\" ) {\n                    curr_nesting += 1\n      \
    \              curr_nesting_index = j\n                } else if (paren_list[j]\
    \ == \")\" && paren_list[j-1] != \"(\" && paren_list[j+1] != \"(\" ) {\n     \
    \               curr_nesting -= 1\n                    curr_nesting_index = j\n\
    \                }\n            }\n            if (curr_nesting > max_nesting)\
    \ {\n                max_nesting = curr_nesting\n                max_nesting_index\
    \ = curr_nesting_index\n            }\n        }\n        var result = List[Long]()\n\
    \        for (i <- 0 until max_nesting_index) {\n            result = result.append(i.toLong)\n\
    \        }\n        return result", "        var paren_list = paren_string.split(\"\
    \ \")\n        var max_nesting = 0\n        var result = List[Long]()\n      \
    \  for (i <- 0 until paren_list.length) {\n            var paren_group = paren_list[i]\n\
    \            var nesting = 0\n            for (j <- 0 until paren_group.length)\
    \ {\n                if (paren_group[j] == '(') {\n                    nesting\
    \ += 1\n                } else if (paren_group[j] == ')') {\n                \
    \    nesting -= 1\n                }\n                if (nesting > max_nesting)\
    \ {\n                    max_nesting = nesting\n                }\n          \
    \  }\n            result = result.append(max_nesting.toLong)\n        }\n    \
    \    return result", "        val parens = paren_string.split(\" \")\n       \
    \ val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        val\
    \ result_list = result.map(_.split(\"(\")).map(_.map(_.trim).map(_.replaceAll(\"\
    [()]\", \"\"))\n        result_list.forEach(x => {\n            val depth = x.length\
    \ - 1\n            if (depth > maxDepth) maxDepth = depth\n        })\n      \
    \  return result_list.map(x => x.length - 1).toList", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(p -> {\n            val parens = p.split(\"\
    (\")\n            val paren_count = parens.length - 1\n            if (paren_count\
    \ == 0) {\n                return 0l\n            } else {\n                return\
    \ paren_count\n            }\n        })\n        return result.toList", "   \
    \     var paren_list = paren_string.split(\" \")\n        var max_nesting = 0\n\
    \        var max_nesting_index = 0\n        for (i <- 0 until paren_list.length)\
    \ {\n            var paren_count = 0\n            var paren_index = 0\n      \
    \      for (j <- 0 until paren_list[i].length) {\n                if (paren_list[i][j]\
    \ == '(') {\n                    paren_count += 1\n                } else if (paren_list[i][j]\
    \ == ')') {\n                    paren_count -= 1\n                }\n       \
    \         if (paren_count == 0) {\n                    if (paren_count > max_nesting)\
    \ {\n                        max_nesting = paren_count\n                     \
    \   max_nesting_index = paren_index\n                    }\n                }\n\
    \                paren_index += 1\n            }\n        }\n        var result\
    \ = List[Long]()\n        for (i <- 0 until max_nesting_index) {\n           \
    \ result = result.append(max_nesting)\n        }\n        return result", "  \
    \      val parens = paren_string.split(\" \")\n        val result = List[Long]()\n\
    \        for (i <- 0 until parens.length) {\n            val paren = parens(i)\n\
    \            val depth = paren.length() - paren.replaceAll(\"[()]\", \"\").length()\n\
    \            result = result.append(depth.toLong)\n        }\n        return result",
  "        var paren_list = paren_string.split(\" \")\n        var paren_list_len\
    \ = paren_list.length\n        var max_nesting = 0\n        var max_nesting_index\
    \ = 0\n        for (var i = 0; i < paren_list_len; i++) {\n            var curr_paren_list\
    \ = paren_list[i].split(\"(\")\n            var curr_paren_list_len = curr_paren_list.length\n\
    \            var curr_nesting = 0\n            for (var j = 0; j < curr_paren_list_len;\
    \ j++) {\n                var curr_paren = curr_paren_list[j]\n              \
    \  if (curr_paren == \"\") {\n                    curr_nesting = curr_nesting\
    \ + 1\n                } else {\n                    curr_nesting = curr_nesting\
    \ - 1\n                }\n                if (curr_nesting > max_nesting) {\n\
    \                    max_nesting = curr_nesting\n                    max_nesting_index\
    \ = j\n                }\n            }\n        }\n        var max_nesting_list\
    \ = paren_list[max_nesting_index].split(\"(\")\n        var max_nesting_list_len\
    \ = max_nesting_list.length\n        var max_nesting_list_str = \"\"\n       \
    \ for (var i = 0; i < max_nesting_list_len; i++) {\n            max_nesting_list_str\
    \ = max_nesting_list_str + max_nesting_list[i]\n        }\n        return max_nesting_list_str.split(\"\
    \ \").map(Long::parseLong).toList", "        var parens = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (i <- 0 until parens.length)\
    \ {\n            var paren_group = parens[i]\n            var paren_count = 0\n\
    \            for (j <- 0 until paren_group.length) {\n                if (paren_group[j]\
    \ == '(') {\n                    paren_count += 1\n                } else {\n\
    \                    paren_count -= 1\n                }\n                if (paren_count\
    \ == 0) {\n                    result = result.append(j)\n                }\n\
    \            }\n        }\n        return result", "        var paren_list = paren_string.split(\"\
    \ \")\n        var max_nesting = 0\n        var max_nesting_index = 0\n      \
    \  for (i <- 0 until paren_list.length) {\n            var nesting = 0\n     \
    \       for (j <- 0 until paren_list[i].length) {\n                if (paren_list[i][j]\
    \ == '(') {\n                    nesting += 1\n                } else if (paren_list[i][j]\
    \ == ')') {\n                    nesting -= 1\n                }\n           \
    \     if (nesting > max_nesting) {\n                    max_nesting = nesting\n\
    \                    max_nesting_index = i\n                }\n            }\n\
    \        }\n        var result = List[Long]()\n        for (i <- 0 until max_nesting_index)\
    \ {\n            result = result.append(i)\n        }\n        return result",
  "        val parens = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"\
    [()]\", \"\"))\n        result.map(_.toLong).toList", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"\
    ))\n        val result_list = result.map(Long.parseLong).toList\n        result_list.sort(Comparator.naturalOrder())\n\
    \        return result_list", "        val parens = paren_string.split(\" \")\n\
    \        val result = parens.map(Problem.parseNestedParens).reduce(_.maxBy(l ->\
    \ l))\n        return result\n    }\n\n    // Input to this function is a string\
    \ represented multiple groups for nested parentheses separated by spaces.\n  \
    \  // For each of the group, output the deepest level of nesting of parentheses.\n\
    \    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\
    \    // >>> parseNestedParens2((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens2(paren_string :\
    \ String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n \
    \       val result = parens.map(Problem.parseNestedParens).reduce(_.maxBy(l ->\
    \ l))\n        return result\n    }\n\n    // Input to this function is a string\
    \ represented multiple groups for nested parentheses separated by spaces.\n  \
    \  // For each of the group, output the deepest level of nesting of parentheses.\n\
    \    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\
    \    // >>> parseNestedParens3((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens3(paren_string :\
    \ String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n \
    \       val result = parens.map(Problem.parseNestedParens).reduce(_.maxBy(l ->\
    \ l))\n        return result\n    }\n\n    // Input to this function is a string\
    \ represented multiple groups for nested parentheses separated by spaces.\n  \
    \  // For each of the group, output the deepest level of nesting of parentheses.\n\
    \    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\
    \    // >>>", "        var paren_list = paren_string.split(\" \")\n        var\
    \ paren_count = 0\n        var max_paren_count = 0\n        var max_paren_list\
    \ = List[Long]()\n        for (i <- 0 until paren_list.length) {\n           \
    \ var paren_count_here = 0\n            var paren_list_here = List[Long]()\n \
    \           for (j <- 0 until paren_list[i].length) {\n                if (paren_list[i][j]\
    \ == '(') {\n                    paren_count_here += 1\n                } else\
    \ if (paren_list[i][j] == ')') {\n                    paren_count_here -= 1\n\
    \                }\n                if (paren_count_here == 0) {\n           \
    \         paren_list_here.append(j)\n                }\n            }\n      \
    \      if (paren_count_here > max_paren_count) {\n                max_paren_count\
    \ = paren_count_here\n                max_paren_list = paren_list_here\n     \
    \       }\n        }\n        return max_paren_list", "        val parens = paren_string.split(\"\
    \ \")\n        val result = List[Long]()\n        for (i <- 0 until parens.length)\
    \ {\n            val paren = parens(i)\n            val depth = 0\n          \
    \  for (j <- 0 until paren.length) {\n                if (paren(j) == '(') {\n\
    \                    depth += 1\n                } else if (paren(j) == ')') {\n\
    \                    depth -= 1\n                }\n                if (depth\
    \ < 0) {\n                    throw new RuntimeException(\"Invalid parentheses\"\
    )\n                }\n            }\n            result = result.append(depth.toLong)\n\
    \        }\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"\
    )).map(_.split(\"(\")).map(_.map(_.trim).map(_.toLong).toList)\n        result",
  "        var paren_list = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (i <- 0 until paren_list.length) {\n            var paren_group =\
    \ paren_list[i]\n            var paren_count = 0\n            for (j <- 0 until\
    \ paren_group.length) {\n                if (paren_group[j] == '(') {\n      \
    \              paren_count += 1\n                } else if (paren_group[j] ==\
    \ ')') {\n                    paren_count -= 1\n                }\n          \
    \  }\n            result = result.append(paren_count)\n        }\n        return\
    \ result", "        var parens = paren_string.split(\" \")\n        var result\
    \ = List[Long]()\n        for (i <- 0 until parens.length) {\n            var\
    \ paren_group = parens[i].split(\"(\")\n            var paren_depth = paren_group[0].length()\n\
    \            for (j <- 1 until paren_group.length) {\n                if (paren_group[j].length()\
    \ > paren_depth) {\n                    paren_depth = paren_group[j].length()\n\
    \                }\n            }\n            result = result.append(paren_depth.toLong)\n\
    \        }\n        return result", "        var parens = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (i <- 0 until parens.length)\
    \ {\n            var paren_group = parens[i]\n            var paren_count = 0\n\
    \            for (j <- 0 until paren_group.length) {\n                if (paren_group[j]\
    \ == '(') {\n                    paren_count += 1\n                } else if (paren_group[j]\
    \ == ')') {\n                    paren_count -= 1\n                }\n       \
    \     }\n            result = result.append(paren_count)\n        }\n        return\
    \ result", "        val parens = paren_string.split(\" \")\n        val paren_list\
    \ = parens.map(_.trim).map(Problem::parseParens).toList\n        val result =\
    \ paren_list.map(l -> l.size()).maxBy(Comparator.naturalOrder())\n        return\
    \ result", "        var paren_list = paren_string.split(\" \")\n        var paren_list_len\
    \ = paren_list.length\n        var paren_list_len_minus_1 = paren_list_len - 1\n\
    \        var paren_list_len_minus_2 = paren_list_len - 2\n        var paren_list_len_minus_3\
    \ = paren_list_len - 3\n        var paren_list_len_minus_4 = paren_list_len -\
    \ 4\n        var paren_list_len_minus_5 = paren_list_len - 5\n        var paren_list_len_minus_6\
    \ = paren_list_len - 6\n        var paren_list_len_minus_7 = paren_list_len -\
    \ 7\n        var paren_list_len_minus_8 = paren_list_len - 8\n        var paren_list_len_minus_9\
    \ = paren_list_len - 9\n        var paren_list_len_minus_10 = paren_list_len -\
    \ 10\n        var paren_list_len_minus_11 = paren_list_len - 11\n        var paren_list_len_minus_12\
    \ = paren_list_len - 12\n        var paren_list_len_minus_13 = paren_list_len\
    \ - 13\n        var paren_list_len_minus_14 = paren_list_len - 14\n        var\
    \ paren_list_len_minus_15 = paren_list_len - 15\n        var paren_list_len_minus_16\
    \ = paren_list_len - 16\n        var paren_list_len_minus_17 = paren_list_len\
    \ - 17\n        var paren_list_len_minus_18 = paren_list_len - 18\n        var\
    \ paren_list_len_minus_19 = paren_list_len - 19\n        var paren_list_len_minus_20\
    \ = paren_list_len - 20\n        var paren_list_len_minus_21 = paren_list_len\
    \ - 21\n        var paren_list_len_minus_22 = paren_list", "        var paren_list\
    \ = paren_string.split(\" \")\n        var paren_count = 0\n        var paren_stack\
    \ = List[Long]()\n        for (i <- 0 until paren_list.length) {\n           \
    \ if (paren_list[i] == \"(\" || paren_list[i] == \"{\" || paren_list[i] == \"\
    [\") {\n                paren_count += 1\n                paren_stack = paren_stack.append(i)\n\
    \            } else if (paren_list[i] == \")\" || paren_list[i] == \"}\" || paren_list[i]\
    \ == \"]\") {\n                paren_count -= 1\n                if (paren_count\
    \ == 0) {\n                    var paren_index = paren_stack.last()\n        \
    \            var paren_level = paren_count\n                    for (j <- paren_index\
    \ - 1 until paren_index) {\n                        if (paren_list[j] == \"(\"\
    \ || paren_list[j] == \"{\" || paren_list[j] == \"[\") {\n                   \
    \         paren_level += 1\n                        } else if (paren_list[j] ==\
    \ \")\" || paren_list[j] == \"}\" || paren_list[j] == \"]\") {\n             \
    \               paren_level -= 1\n                        }\n                \
    \    }\n                    paren_stack = paren_stack.remove(paren_index)\n  \
    \                  paren_stack = paren_stack.append(paren_level)\n           \
    \     }\n            }\n        }\n        return paren_stack", "        val parens\
    \ = paren_string.split(\" \")\n        val result = parens.map(s -> {\n      \
    \      val parens = s.split(\"(\")\n            val max_nesting = parens.map(s1\
    \ -> {\n                val parens1 = s1.split(\")\")\n                return\
    \ parens1.length - 1\n            }).max()\n            return max_nesting\n \
    \       }).toList\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(Problem::parseNestedParens).reduce(_.maxBy(l\
    \ -> l))\n        return result", "        var paren_list = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (i <- 0 until paren_list.length)\
    \ {\n            var paren_group = paren_list[i]\n            var paren_count\
    \ = 0\n            for (j <- 0 until paren_group.length) {\n                if\
    \ (paren_group[j] == '(') {\n                    paren_count += 1\n          \
    \      } else if (paren_group[j] == ')') {\n                    paren_count -=\
    \ 1\n                }\n            }\n            result = result.append(paren_count)\n\
    \        }\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"(\", \"\").replaceAll(\"\
    )\", \"\"))\n        val result_list = result.map(Long::parseLong).toList\n  \
    \      result_list", "        val parens = paren_string.split(\" \")\n       \
    \ val result = parens.map(Problem.parseParens).reduce(List[Long]::concat)\n  \
    \      result", "        val parens = paren_string.split(\" \")\n        val result\
    \ = parens.map(_.trim).map(_.replaceAll(\"[()]\", \"\"))\n        val result_list\
    \ = result.map(_.toLong).toList\n        return result_list", "        val parens\
    \ = paren_string.split(\" \")\n        val result = parens.map(_.trim).map(_.replaceAll(\"\
    [()]\", \"\"))\n        val result_list = result.map(Long.parseLong).toList\n\
    \        return result_list", "        val parens = paren_string.split(\" \")\n\
    \        val result = parens.map(_.trim).map(_.replaceAll(\"(\", \"\").replaceAll(\"\
    )\", \"\")).map(_.split(\"(\")).map(x => x.length - 1).toList\n        result",
  "        val parens = paren_string.split(\" \")\n        val paren_list = parens.map(_.trim).map(Problem::parseParens).toList\n\
    \        val max_nesting = paren_list.foldLeft(0, (max, parens) => {\n       \
    \     if (parens.length == 0) return max\n            return parens.length - 1\n\
    \        })\n        val result = paren_list.map(l -> l - max_nesting).toList\n\
    \        return result\n    }\n\n    // Input to this function is a string represented\
    \ multiple groups for nested parentheses separated by spaces.\n    // For each\
    \ of the group, output the deepest level of nesting of parentheses.\n    // E.g.\
    \ (()()) has maximum two levels of nesting while ((())) has three.\n    // >>>\
    \ parseNestedParens2((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3l.toLong))\n    def parseNestedParens2(paren_string :\
    \ String) : List[Long] = {\n        val parens = paren_string.split(\" \")\n \
    \       val paren_list = parens.map(_.trim).map(Problem::parseParens).toList\n\
    \        val max_nesting = paren_list.foldLeft(0, (max, parens) => {\n       \
    \     if (parens.length == 0) return max\n            return parens.length - 1\n\
    \        })\n        val result = paren_list.map(l -> l - max_nesting).toList\n\
    \        return result\n    }\n\n    // Input to this function is a string represented\
    \ multiple groups for nested parentheses separated by spaces.\n    // For each\
    \ of the group, output the deepest level of nesting of parentheses.\n    // E.g.\
    \ (()()) has maximum two levels of nesting while ((())) has three.\n    // >>>\
    \ parseNestedParens3((\"(()()) ((())) () ((())()())\"))\n    // (List[Long](2l.toLong,\
    \ 3l.toLong, 1l.toLong, 3", "        var paren_list = paren_string.split(\" \"\
    )\n        var result = List[Long]()\n        for (i <- 0 until paren_list.length)\
    \ {\n            var paren_group = paren_list[i].split(\"(\")\n            var\
    \ max_nesting = 0\n            for (j <- 0 until paren_group.length) {\n     \
    \           var paren_group_nesting = paren_group[j].length() - paren_group[j].replace(\"\
    (\", \"\").length() - paren_group[j].replace(\")\", \"\").length()\n         \
    \       if (paren_group_nesting > max_nesting) {\n                    max_nesting\
    \ = paren_group_nesting\n                }\n            }\n            result\
    \ = result.append(max_nesting.toLong)\n        }\n        return result"]
stop_tokens:
- "\n    }\n"
