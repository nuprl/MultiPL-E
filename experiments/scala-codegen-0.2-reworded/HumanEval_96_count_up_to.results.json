{
  "name": "HumanEval_96_count_up_to",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "results": [
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Returns true if the given number is prime.\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        for (i <- 3 until Math.sqrt(n)) {\n            if (n % i == 0) {\n                return false\n            }\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293140,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpy69r8w9u.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy69r8w9u.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpy69r8w9u.scala:43:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    Double\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7l52xtgh.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        if (n == 0) {\n            return result\n        }\n        val i = n.toLong\n        while (i > 0) {\n            result = result.append(i)\n            i -= 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293139,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6l86fbqx.scala:29:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6l86fbqx.scala:30:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            i -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value -= is not a member of Long - did you mean i.!=?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = isPrime(i)\n            if (prime) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns a list of the\n    // first n integers that are prime numbers and greater than n.\n    // for example:\n    // >>> countUpToGreaterThan((5l))\n    // (List[Long](7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpToGreaterThan((11l))\n    // (List[Long](13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    // >>> countUpToGreaterThan((0l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((20l))\n    // (List[Long](13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong))\n    // >>> countUpToGreaterThan((1l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((18l))\n    // (List[Long](13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong))\n    def countUpToGreaterThan(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = isPrime(i)\n            if (prime) {\n                result = result.append(i)\n            }\n        }\n        \n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbncmga_7.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbncmga_7.scala:22:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mprime\u001b[0m = isPrime(i)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbncmga_7.scala:24:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbncmga_7.scala:47:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbncmga_7.scala:48:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mprime\u001b[0m = isPrime(i)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbncmga_7.scala:50:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = i.isPrime()\n            if (prime) {\n                result += i\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293140,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpavudlikd.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpavudlikd.scala:22:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mprime\u001b[0m = i.isPrime()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value isPrime is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpavudlikd.scala:24:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                result += i\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value += is not a member of List[Long] - did you mean result.!=?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n == 1) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293140,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkxsxr69q.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkxsxr69q.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkxsxr69q.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns a list of the\n    // first n primes.\n    // for example:\n    // >>> primesUpTo((2l, 3l, 5l, 7l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_njnhyaw.scala:58:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_njnhyaw.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_njnhyaw.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_njnhyaw.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_njnhyaw.scala:46:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_njnhyaw.scala:47:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    assert(countUpTo((\u001b[31m6l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (n == 0) {\n            return List[Long](())\n        }\n        return List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong, 101l.toLong, 103l.toLong, 107l.toLong, 109l.toLong, 113l.toLong, 127l.toLong, 131l.toLong, 137l.toLong, 139l.toLong, 149l.toLong, 151l.toLong, 157l.toLong, 163l.toLong, 167l.toLong, 173l.toLong, 179l.toLong, 181l.toLong, 191l.toLong, 193l.toLong, 197l.toLong, 199l.toLong, 211l.toLong, 223l.toLong, 227l.toLong, 229l.toLong, 233l.toLong, 239l.toLong, 241l.toLong, 251l.toLong, 257l.toLong, 263l.toLong, 269l.toLong, 271l.toLong, 277l.toLong, 281l.toLong, 283l.toLong, 293l.toLong, 307l.toLong, 311l.toLong, 313l.toLong, 317l.toLong, 331l.toLong, 337l.toLong, 347l.toLong, 349l.toLong, 353l.toLong, 359l.toLong, 367l.toLong, 373l.toLong, 379l.toLong, 383l.toLong, 389l\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293137,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpaw86phkw.scala:27:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpaw86phkw.scala:24:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mreturn\u001b[0m List[\u001b[35mLong\u001b[0m](())\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Unit\n\u001b[31m   |\u001b[0m                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns a list of the\n    // first n primes.\n    // for example:\n    // >>> primesUpTo((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((List[Long]()))\n    // (List[Long]())\n    // >>> primesUpTo((List[Long](1l.toLong)))\n    // (List[Long]())\n    // >>> primesUpTo((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    def primesUpTo(n : List[Long]) : List[Long] = {\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293140,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpthbeaiwg.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpthbeaiwg.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpthbeaiwg.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpthbeaiwg.scala:42:50 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mprimesUpTo\u001b[0m(\u001b[36mn\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m]) : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = {\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Found:    Unit\n\u001b[31m   |\u001b[0m                                                  Required: List[Long]\n\u001b[31m43 |\u001b[0m    }\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (n == 0) {\n            return result\n        }\n        val i = 0\n        while (i < n) {\n            result.append(i)\n            i += 2\n            while (i < n && !isPrime(i)) {\n                i += 2\n            }\n        }\n        return result\n    }\n\n    // Returns true if n is prime.\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        if (n < 4) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        if (n < 9) {\n            return true\n        }\n        if (n % 3 == 0) {\n            return false\n        }\n        if (n < 27) {\n            return true\n        }\n        if (n % 3 == 0) {\n            return false\n        }\n        if (n < 31) {\n            return true\n        }\n        if (n % 5 == 0) {\n            return false\n        }\n        if (n < 61) {\n            return true\n        }\n        if (n % 5 == 0) {\n            return false\n        }\n        if (n < 91) {\n            return true\n        }\n        if (n % 7 == 0) {\n            return false\n        }\n        if (n < 121) {\n            return true\n        }\n        if (n % 7 == 0) {\n            return false\n        }\n        if (n < 169) {\n            return true\n        }\n        if (n % 11 == 0) {\n            return false\n        }\n        if (n < 241) {\n            return true\n        }\n        if (n % 11 == 0) {\n            return false\n        }\n        if (n < 361) {\n            return true\n        }\n        \n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp80nby1rs.scala:29:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp80nby1rs.scala:30:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            i += \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean i.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp80nby1rs.scala:32:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                i += \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean i.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp80nby1rs.scala:103:8 --------------------\u001b[0m\u001b[0m\n\u001b[31m103 |\u001b[0m        \u001b[33mif\u001b[0m (n < \u001b[31m361\u001b[0m) {\n\u001b[31m\u001b[31m    |\u001b[0m        ^\u001b[0m\n\u001b[31m    |\u001b[0m        Found:    Unit\n\u001b[31m    |\u001b[0m        Required: Boolean\n\u001b[31m    |\u001b[0m        Maybe you are missing an else part for the conditional?\n\u001b[31m104 |\u001b[0m            \u001b[33mreturn\u001b[0m \u001b[31mtrue\u001b[0m\n\u001b[31m105 |\u001b[0m        }\n\u001b[31m    |\u001b[0m\n\u001b[31m    |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Returns true if the given number is prime.\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        for (i <- 3 until Math.sqrt(n)) {\n            if (n % i == 0) {\n                return false\n            }\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293140,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpy69r8w9u.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy69r8w9u.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpy69r8w9u.scala:43:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    Double\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7l52xtgh.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns a list of the\n    // first n primes.\n    // for example:\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l, 37l))\n    // (List[Long](2l.\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293139,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpj35ahfrg.scala:56:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpj35ahfrg.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj35ahfrg.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj35ahfrg.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj35ahfrg.scala:44:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj35ahfrg.scala:45:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m    assert(countUpTo((\u001b[31m6l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        var result = List[Long](0)\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpr672u7fu.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpr672u7fu.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpr672u7fu.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = mutable.List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        for (i <- 3 until Math.sqrt(n)) {\n            if (n % i == 0) {\n                return false\n            }\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8jhdj_tb.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8jhdj_tb.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8jhdj_tb.scala:42:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    Double\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = isPrime(i)\n            if (prime) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293140,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnak93dd0.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnak93dd0.scala:22:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mprime\u001b[0m = isPrime(i)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnak93dd0.scala:24:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        val i = 0\n        while (i < n) {\n            val prime = isPrime(i)\n            if (prime) {\n                result = result.append(i)\n            }\n            i += 1\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        val i = 0\n        while (i < n) {\n            val prime = isPrime(i)\n            if (prime) {\n                result = result.append(i)\n            }\n            i += 1\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    \n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpy9a3q_m5.scala:80:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy9a3q_m5.scala:23:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mprime\u001b[0m = isPrime(i)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy9a3q_m5.scala:25:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy9a3q_m5.scala:27:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            i += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean i.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy9a3q_m5.scala:51:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mprime\u001b[0m = isPrime(i)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy9a3q_m5.scala:53:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy9a3q_m5.scala:55:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m            i += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean i.!=?\n\u001b[31m\u001b[31m-- [E120] Nam",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result += i\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns a list of the\n    // first n primes.\n    // for example:\n    // >>> primesUpTo((2l, 3l, 5l, 7l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong,\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293140,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9gcd1ze3.scala:58:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9gcd1ze3.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9gcd1ze3.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9gcd1ze3.scala:23:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result += i\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value += is not a member of List[Long] - did you mean result.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9gcd1ze3.scala:46:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9gcd1ze3.scala:47:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    assert(countUpTo((\u001b[31m6l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        } else if (n == 2) {\n            return true\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpalv3cw22.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpalv3cw22.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpalv3cw22.scala:40:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7l52xtgh.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns a list of the\n    // first n integers that are prime numbers and greater than n.\n    // for example:\n    // >>> countUpToGreaterThan((5l))\n    // (List[Long](6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))\n    // >>> countUpToGreaterThan((11l))\n    // (List[Long](13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    // >>> countUpToGreaterThan((0l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    // >>> countUpToGreaterThan((1l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong))\n    def countUpToGreaterThan(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns a list of the\n    // first n integers that are prime numbers and less\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293140,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpmctft_ce.scala:70:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m70 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmctft_ce.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmctft_ce.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmctft_ce.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmctft_ce.scala:46:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmctft_ce.scala:47:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmctft_ce.scala:48:32 ----------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        if (n < 0) {\n            return result\n        }\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result += i\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293140,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp10x1s280.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp10x1s280.scala:25:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp10x1s280.scala:26:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result += i\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value += is not a member of List[Long] - did you mean result.!=?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        } else if (n == 2) {\n            return true\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpalv3cw22.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpalv3cw22.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpalv3cw22.scala:40:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns the number of prime numbers\n    // less than or equal to that integer.\n    // for example:\n    // >>> countPrimes(0l)\n    // 0\n    // >>> countPrimes(1l)\n    // 0\n    // >>> countPrimes(2l)\n    // 1\n    // >>> countPrimes(3l)\n    // 2\n    // >>> countPrimes(4l)\n    // 3\n    // >>> countPrimes(5l)\n    // 4\n    // >>> countPrimes(6l)\n    // 5\n    // >>> countPrimes(7l)\n    // 6\n    // >>> countPrimes(8l)\n    // 7\n    // >>> countPrimes(9l)\n    // 8\n    // >>> countPrimes(10l)\n    // 9\n    // >>> countPrimes(11l)\n    // 10\n    // >>> countPrimes(12l)\n    // 11\n    // >>> countPrimes(13l)\n    // 12\n    // >>> countPrimes(14l)\n    // 13\n    // >>> countPrimes(15l)\n    // 14\n    // >>> countPrimes(16l)\n    // 15\n    // >>> countPrimes(17l)\n    // 16\n    // >>> countPrimes(18l)\n    // 17\n    // >>> countPrimes(19l)\n    // 18\n    // >>> countPrimes(20l)\n    // 19\n    // >>> countPrimes(21l)\n    // 20\n    def countPrimes(n : Long) : Long = {\n        val result = 0l\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result += 1l\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns the number of prime numbers\n    // greater than or equal to that integer\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpmqubtt1r.scala:102:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m102 |\u001b[0m}\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmqubtt1r.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmqubtt1r.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmqubtt1r.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmqubtt1r.scala:78:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmqubtt1r.scala:79:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m79 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmqubtt1r.scala:80:23 -------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        for (i <- 3 until Math.sqrt(n)) {\n            if (n % i == 0) {\n                return false\n            }\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpobgr00fj.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpobgr00fj.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpobgr00fj.scala:42:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    Double\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = isPrime(i)\n            if (prime) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Returns true if the given integer is prime.\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        val max = scala.math.BigInt(n)\n        val maxDivisor = scala.math.BigInt(3)\n        while (maxDivisor.compareTo(max) <= 0) {\n            if (max % maxDivisor == 0) {\n                return false\n            }\n            maxDivisor = maxDivisor.add(scala.math.BigInt(2))\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5lin92ty.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5lin92ty.scala:27:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5lin92ty.scala:50:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m            maxDivisor = maxDivisor.add(scala.math.BigInt(\u001b[31m2\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value add is not a member of BigInt - did you mean maxDivisor.abs?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        if (n < 0) {\n            return result\n        }\n        val i = 0\n        while (i < n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n            i = i + 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293139,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8qzwy6uw.scala:26:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8qzwy6uw.scala:27:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp8qzwy6uw.scala:29:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            i = i + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns a list of the\n    // first n primes.\n    // for example:\n    // >>> primesUpTo((2l, 3l, 5l, 7l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_njnhyaw.scala:58:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_njnhyaw.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_njnhyaw.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_njnhyaw.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_njnhyaw.scala:46:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_njnhyaw.scala:47:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    assert(countUpTo((\u001b[31m6l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7l52xtgh.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7l52xtgh.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = isPrime(i)\n            if (prime) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and greater than n.\n    // for example:\n    // >>> countUpToGreaterThan((5l))\n    // (List[Long](6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))\n    // >>> countUpToGreaterThan((11l))\n    // (List[Long](13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    // >>> countUpToGreaterThan((0l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((20l))\n    // (List[Long](6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    // >>> countUpToGreaterThan((1l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((18l))\n    // (List[Long](13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    // >>> countUpToGreaterThan((1l))\n    // (List[Long]())\n    def countUpToGreaterThan(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime =\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293152,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpz5_r7e58.scala:56:23 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mprime\u001b[0m =\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpz5_r7e58.scala:72:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpz5_r7e58.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz5_r7e58.scala:25:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mprime\u001b[0m = isPrime(i)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpz5_r7e58.scala:27:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpz5_r7e58.scala:55:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m--",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        var i = 2L\n        while (i <= n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n            i = i + 1L\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns a list of the\n    // first n prime numbers.\n    // for example:\n    // >>> primesUpTo((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((List[Long]()))\n    // (List[Long]())\n    // >>> primesUpTo((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    \n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293151,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpl4i947kh.scala:60:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl4i947kh.scala:26:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl4i947kh.scala:27:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl4i947kh.scala:48:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl4i947kh.scala:49:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    assert(countUpTo((\u001b[31m6l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl4i947kh.scala:50:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m    assert(countUpTo((\u001b[31m7l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 0) {\n            return false\n        } else if (n == 1) {\n            return true\n        } else if (n < 4) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else if (n % 3 == 0) {\n            return false\n        } else {\n            for (i <- 4 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293153,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1fb2m_89.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1fb2m_89.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1fb2m_89.scala:41:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m4\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        for (i <- 3 until Math.sqrt(n)) {\n            if (n % i == 0) {\n                return false\n            }\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpobgr00fj.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpobgr00fj.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpobgr00fj.scala:42:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    Double\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result += i\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result += i\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293152,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpnao0g58x.scala:76:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnao0g58x.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnao0g58x.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnao0g58x.scala:23:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result += i\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value += is not a member of List[Long] - did you mean result.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnao0g58x.scala:46:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnao0g58x.scala:47:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnao0g58x.scala:48:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m4",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7l52xtgh.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7l52xtgh.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (n == 0) {\n            return Nil()\n        }\n        return List(2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l, 37l, 41l, 43l, 47l, 53l, 59l, 61l, 67l, 71l, 73l, 79l, 83l, 89l, 97l, 101l, 103l, 107l, 109l, 113l, 127l, 131l, 137l, 139l, 149l, 151l, 157l, 163l, 167l, 173l, 179l, 181l, 191l, 193l, 197l, 199l, 211l, 223l, 227l, 229l, 233l, 239l, 241l, 251l, 257l, 263l, 269l, 271l, 277l, 281l, 283l, 293l, 307l, 311l, 313l, 317l, 331l, 337l, 347l, 349l, 353l, 359l, 367l, 373l, 379l, 383l, 389l, 397l, 401l, 409l, 419l, 421l, 431l, 433l, 439l, 443l, 449l, 457l, 461l, 463l, 467l, 479l, 487l, 491l, 499l, 503l, 509l, 521l, 523l, 541l, 547l, 557l, 563l, 569l, 571l, 577l, 587l, 589l, 593l, 599l, 601l, 607l, 613l, 617l, 619l, 631l, 641l, 643l, 647l, 653l, 659l, 661l, 673l, 677l, 683l, 691l, 701l, 709l, 719l, 727l, 733l, 739l, 743l, 751l, 757l, 761l, 769l, 773l\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293149,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp1cmcfsk.scala:27:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpp1cmcfsk.scala:24:22 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mreturn\u001b[0m Nil()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): Nothing\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = i\n            if (prime.isPrime()) {\n                result = result.append(prime)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293154,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5owz11as.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5owz11as.scala:23:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m (prime.isPrime()) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value isPrime is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5owz11as.scala:24:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                result = result.append(prime)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for(i <- 0 until n) {\n            if(isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if(n == 2) {\n            return true\n        } else if(n < 2) {\n            return false\n        } else if(n % 2 == 0) {\n            return false\n        } else {\n            for(i <- 3 until Math.sqrt(n)) {\n                if(n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293154,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3hny_5us.scala:21:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    (n : Long)\n\u001b[31m   |\u001b[0m                         Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3hny_5us.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3hny_5us.scala:37:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m(i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    Double\n\u001b[31m   |\u001b[0m                             Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns a list of the\n    // first n prime numbers.\n    // for example:\n    // >>> primeNumbersUpTo((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primeNumbersUpTo((List[Long]()))\n    // (List[Long]())\n    // >>> primeNumbersUpTo((List[Long](1l.toLong)))\n    // (List[Long]())\n    // >>> primeNumbersUpTo((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    def primeNumbersUpTo(numbers : List[Long]) : List[Long] = {\n        if (numbers.isEmpty()) {\n            return List[Long]()\n        }\n        val result = List[Long]()\n        for (i <- 0 until numbers.size) {\n            if (isPrime(numbers.get(i))) {\n                result = result.append(numbers.get(i))\n            }\n        }\n        return result\n    }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293154,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpd9aowwnh.scala:69:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpd9aowwnh.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd9aowwnh.scala:25:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpd9aowwnh.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpd9aowwnh.scala:44:20 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mif\u001b[0m (numbers.isEmpty()) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mList\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd9aowwnh.scala:49:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(numbers.get(i))) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpd9aowwnh.scala:49:32 --",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        var result = List[Long]()\n        var i = 0l\n        while (i < n) {\n            result = result.append(i)\n            i = i + 1l\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293151,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj7nhkrrg.scala:23:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result += i\n            }\n        }\n        return result\n    }\n\n    // Returns true if the given number is prime.\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until n) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293154,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprwwbcpu1.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprwwbcpu1.scala:23:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result += i\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value += is not a member of List[Long] - did you mean result.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprwwbcpu1.scala:38:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (n : Long)\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        } else if (n == 2) {\n            return true\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpalv3cw22.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpalv3cw22.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpalv3cw22.scala:40:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7l52xtgh.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and greater than n.\n    // for example:\n    // >>> countUpToGreaterThan((5l))\n    // (List[Long](6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))\n    // >>> countUpToGreaterThan((11l))\n    // (List[Long](13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    // >>> countUpToGreaterThan((0l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((20l))\n    // (List[Long](6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    // >>> countUpToGreaterThan((1l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((18l))\n    // (List[Long](13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    def countUpToGreaterThan(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- n + 1 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than or equal to n.\n    // for example:\n    // >>> countUpToLessThan((5l))\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293154,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4egl9ere.scala:72:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4egl9ere.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4egl9ere.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4egl9ere.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4egl9ere.scala:47:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4egl9ere.scala:48:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4egl9ere.scala:60:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        if (n == 0) {\n            return result\n        }\n        val i = 0\n        while (i < n) {\n            val prime = isPrime(i)\n            if (prime) {\n                result = result.append(i)\n            }\n            i = i + 1\n        }\n        return result\n    }\n\n    // Returns true if the given number is prime.\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        val max = scala.math.Long.max(n - 1, 2)\n        val i = 3\n        while (i <= max) {\n            if (n % i == 0) {\n                return false\n            }\n            i = i + 2\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293154,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphdtg0un5.scala:31:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmphdtg0un5.scala:33:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            i = i + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphdtg0un5.scala:49:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = scala.math.Long.max(n - \u001b[31m1\u001b[0m, \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value Long is not a member of math\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmphdtg0un5.scala:55:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m            i = i + \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns a list of the\n    // first n prime numbers that are less than n.\n    // for example:\n    // >>> primesUpTo((2l, 3l, 5l, 7l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l))\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293154,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpifw1tb4c.scala:60:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpifw1tb4c.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpifw1tb4c.scala:25:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpifw1tb4c.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpifw1tb4c.scala:48:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpifw1tb4c.scala:49:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    assert(countUpTo((\u001b[31m6l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        var result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n == 1) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293154,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpedid8k4n.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpedid8k4n.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpedid8k4n.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        if (n < 0) {\n            return result\n        }\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        }\n        if (n < 2) {\n            return false\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        for (i <- 3 until Math.sqrt(n)) {\n            if (n % i == 0) {\n                return false\n            }\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293154,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgt53hf26.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgt53hf26.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgt53hf26.scala:42:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    Double\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (n == 0) {\n            return List[Long]()\n        }\n        val result = List[Long]()\n        result.append(2l)\n        result.append(3l)\n        for (i <- 1l) {\n            if (n < i) {\n                return result\n            }\n            val prime = isPrime(i)\n            if (prime) {\n                result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Returns true if the given number is prime.\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        for (i <- 3l) {\n            if (n % i == 0) {\n                return false\n            }\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293155,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj6v8lg60.scala:27:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        result.append(\u001b[31m2l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj6v8lg60.scala:28:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        result.append(\u001b[31m3l\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj6v8lg60.scala:29:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m1l\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj6v8lg60.scala:52:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m3l\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value foreach is not a member of Long\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        if (n < 0) {\n            return result\n        }\n        val i = 0\n        while (i < n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n            i += 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293154,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyyks4rqx.scala:26:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyyks4rqx.scala:27:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyyks4rqx.scala:29:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            i += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean i.!=?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        if (n < 0) {\n            result = List[Long]()\n        } else if (n == 0) {\n            result = List[Long]()\n        } else {\n            val i = 0\n            while (i < n) {\n                val prime = i + 1\n                val j = i + 1\n                while (j < n) {\n                    if (prime % j == 0) {\n                        j = n\n                    } else {\n                        j += 1\n                    }\n                }\n                result = result.append(prime)\n                i += 1\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293155,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpp86a7_fp.scala:22:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            result = List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpp86a7_fp.scala:24:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            result = List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpp86a7_fp.scala:32:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                        j = n\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (n : Long)\n\u001b[31m   |\u001b[0m                            Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpp86a7_fp.scala:34:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                        j += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value += is not a member of Int - did you mean j.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpp86a7_fp.scala:37:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                result = result.append(prime)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpp86a7_fp.scala:38:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                i += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean i.!=?\n6 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7l52xtgh.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        if (n < 4) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        if (n < 9) {\n            return true\n        }\n        if (n % 3 == 0) {\n            return false\n        }\n        if (n < 27) {\n            return true\n        }\n        if (n % 3 == 0) {\n            return false\n        }\n        if (n < 31) {\n            return true\n        }\n        if (n % 5 == 0) {\n            return false\n        }\n        if (n < 61) {\n            return true\n        }\n        if (n % 5 == 0) {\n            return false\n        }\n        if (n < 91) {\n            return true\n        }\n        if (n % 7 == 0) {\n            return false\n        }\n        if (n < 127) {\n            return true\n        }\n        if (n % 7 == 0) {\n            return false\n        }\n        if (n < 181) {\n            return true\n        }\n        if (n % 11 == 0) {\n            return false\n        }\n        if (n < 251) {\n            return true\n        }\n        if (n % 11 == 0) {\n            return false\n        }\n        if (n < 383) {\n            return true\n        }\n        if (n % 13 == 0) {\n            return false\n        }\n        if (n < 521) {\n            return true\n        }\n        if (n % 13 == 0)\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293154,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpysywrpkx.scala:106:4 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m106 |\u001b[0m    }\n\u001b[31m\u001b[31m    |\u001b[0m    ^\u001b[0m\n\u001b[31m    |\u001b[0m    'then' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpysywrpkx.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpysywrpkx.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7l52xtgh.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        val i = 0l\n        while (i < n) {\n            val prime = i + 1l\n            val isPrime = isPrime(prime)\n            if (isPrime) {\n                result = result.append(prime)\n            }\n            i = i + 1l\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns a list of the\n    // first n prime numbers.\n    // for example:\n    // >>> primesUpTo((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((List[Long]()))\n    // (List[Long]())\n    // >>> primesUpTo((List[Long](1l.toLong)))\n    // (List[Long]())\n    // >>> primesUpTo((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong)))\n    // (List[Long](2l.to\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293154,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmplvr8aqyg.scala:63:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmplvr8aqyg.scala:27:26 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36misPrime\u001b[0m = isPrime(prime)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Recursive \u001b[33mvalue\u001b[0m \u001b[35misPrime\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplvr8aqyg.scala:29:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                result = result.append(prime)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmplvr8aqyg.scala:31:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            i = i + \u001b[31m1l\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplvr8aqyg.scala:51:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplvr8aqyg.scala:52:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m    assert(countUpTo((\u001b[31m6l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not F",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        val i = 0\n        while (i < n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n            i = i + 1\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns a list of the\n    // first n primes.\n    // for example:\n    // >>> primesUpTo((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> primesUpTo((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong))\n    // >>> primesUpTo((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong))\n    // >>> primesUpTo((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    // >>> primesUpTo((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong,\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293154,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfghuu7wg.scala:60:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfghuu7wg.scala:26:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfghuu7wg.scala:27:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpfghuu7wg.scala:29:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            i = i + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfghuu7wg.scala:48:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfghuu7wg.scala:49:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    assert(countUpTo((\u001b[31m6l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfghuu7wg.scala:50:11 ------------------------\u001b[0m\u001b[0m\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        if (n == 0) {\n            return result\n        }\n        val i = n\n        while (i > 0) {\n            result.append(i)\n            i -= 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293155,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxjop6a15.scala:29:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxjop6a15.scala:30:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            i -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value -= is not a member of Long - did you mean i.!=?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns the sum of the\n    // integers in the list.\n    // for example:\n    // >>> sumUpTo([1, 2, 3])\n    // 6\n    // >>> sumUpTo([1, 2, 3, 4])\n    // 10\n    // >>> sumUpTo([1, 2, 3, 4, 5])\n    // 15\n    // >>> sumUpTo([1, 2, 3, 4, 5, 6])\n    // 21\n    // >>> sumUpTo([1, 2, 3, 4, 5, 6, 7])\n    // 28\n    // >>> sumUpTo([1, 2, 3, 4, 5, 6, 7, 8])\n    // 36\n    // >>> sumUpTo([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    // 45\n    // >>> sumUpTo([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    // 55\n    // >>> sumUpTo([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n    // 66\n    // >>> sumUpTo([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n    // 78\n    // >>> sumUpTo([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n    // 91\n    // >>> sumUpTo([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n    // 105\n    // >>> sumUpTo([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n    // 126\n    // >>> sumUp\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293155,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpuq5domq0.scala:76:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuq5domq0.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuq5domq0.scala:25:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuq5domq0.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuq5domq0.scala:64:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuq5domq0.scala:65:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m65 |\u001b[0m    assert(countUpTo((\u001b[31m6l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result += i\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result += i\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293152,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpnao0g58x.scala:76:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnao0g58x.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnao0g58x.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnao0g58x.scala:23:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result += i\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value += is not a member of List[Long] - did you mean result.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnao0g58x.scala:46:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnao0g58x.scala:47:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnao0g58x.scala:48:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m4",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        val i = 0\n        while (i < n) {\n            val prime = isPrime(i)\n            if (prime) {\n                result = result.append(i)\n            }\n            i = i + 1\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        val result = false\n        val i = 2\n        while (i < n) {\n            if (n % i == 0) {\n                result = false\n                break\n            }\n            i = i + 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293162,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplh_xokg1.scala:25:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmplh_xokg1.scala:27:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            i = i + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmplh_xokg1.scala:37:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                result = \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplh_xokg1.scala:38:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmplh_xokg1.scala:40:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m            i = i + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        for (i <- 3 until Math.sqrt(n)) {\n            if (n % i == 0) {\n                return false\n            }\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpobgr00fj.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpobgr00fj.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpobgr00fj.scala:42:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    Double\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        val i = 0\n        while (i < n) {\n            result = result.append(i)\n            i += 2\n            while (i < n && !isPrime(i)) {\n                i += 2\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        } else if (n == 2) {\n            return true\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            val i = 3\n            while (i <= Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n                i += 2\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxv4kx590.scala:26:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxv4kx590.scala:27:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            i += \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean i.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxv4kx590.scala:29:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                i += \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean i.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxv4kx590.scala:48:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m                i += \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean i.!=?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 0) {\n            return false\n        } else if (n == 1) {\n            return true\n        } else if (n == 2) {\n            return true\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293166,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcme2mfae.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcme2mfae.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcme2mfae.scala:39:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        if (n == 0) {\n            return result\n        }\n        val i = n.toLong\n        while (i > 0) {\n            result.append(i)\n            i -= 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbcb12vio.scala:29:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbcb12vio.scala:30:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            i -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value -= is not a member of Long - did you mean i.!=?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = mutable.List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result.append(i)\n            }\n        }\n        result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            true\n        } else if (n == 1) {\n            false\n        } else if (n % 2 == 0) {\n            false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    false\n                }\n            }\n            true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293166,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyy2yj8kj.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyy2yj8kj.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyy2yj8kj.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- [E129] Potential Issue Warning: /tmp/tmpyy2yj8kj.scala:39:20 ----------------\u001b[0m\u001b[0m\n\u001b[33m39 |\u001b[0m                    \u001b[31mfalse\u001b[0m\n\u001b[33m\u001b[33m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[33m   |\u001b[0mA pure expression does nothing in statement position; you may be omitting necessary parentheses\n\u001b[33m   |\u001b[0m\n\u001b[33m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 warning found\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 0) {\n            return false\n        } else if (n == 1) {\n            return true\n        } else if (n == 2) {\n            return true\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293166,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcme2mfae.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcme2mfae.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcme2mfae.scala:39:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        var result = List[Long]()\n        var i = 2L\n        while (i < n) {\n            if (n % i == 0) {\n                result = result.append(i)\n                i = i + 1\n            } else {\n                i = i + 1\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293166,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0lkjw7pk.scala:24:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        var result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293166,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnqn0__pk.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnqn0__pk.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnqn0__pk.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (n == 0) {\n            return List.empty()\n        }\n        return List.range(2, n + 1).filter(Problem::isPrime).toList\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns a list of the\n    // first n prime numbers that are less than n.\n    // for example:\n    // >>> primesUpTo((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    // >>> primesUpTo((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpk4th5vjm.scala:53:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpk4th5vjm.scala:24:29 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mreturn\u001b[0m List.empty()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): A\n\u001b[31m\u001b[31m-- Error: /tmp/tmpk4th5vjm.scala:26:35 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mreturn\u001b[0m List.range(\u001b[31m2\u001b[0m, n + \u001b[31m1\u001b[0m).filter(Problem::isPrime).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                No implicit Ordering defined for AnyVal.\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpk4th5vjm.scala:41:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpk4th5vjm.scala:42:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m    assert(countUpTo((\u001b[31m6l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpk4th5vjm.scala:43:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m    assert(countUpTo((\u001b[31m7l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer ex",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Returns true if the given number is prime.\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        for (i <- 3 until Math.sqrt(n)) {\n            if (n % i == 0) {\n                return false\n            }\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293140,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpy69r8w9u.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy69r8w9u.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpy69r8w9u.scala:43:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    Double\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result += i\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result += i\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293168,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpox9immre.scala:76:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m76 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpox9immre.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpox9immre.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpox9immre.scala:23:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result += i\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value += is not a member of List[Long] - did you mean result.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpox9immre.scala:46:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpox9immre.scala:47:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpox9immre.scala:48:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m4",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        if (n == 0) {\n            return result\n        }\n        val i = 1L\n        while (i <= n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n            i = i + 1L\n        }\n        return result\n    }\n\n    // Returns true if the given number is prime.\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        val i = 3L\n        while (i <= Math.sqrt(n)) {\n            if (n % i == 0) {\n                return false\n            }\n            i = i + 2L\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293166,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzr44ivob.scala:30:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpzr44ivob.scala:32:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            i = i + \u001b[31m1L\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpzr44ivob.scala:53:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m            i = i + \u001b[31m2L\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (n == 0) {\n            return Nil()\n        }\n        return List(2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l, 37l, 41l, 43l, 47l, 53l, 59l, 61l, 67l, 71l, 73l, 79l, 83l, 89l, 97l, 101l, 103l, 107l, 109l, 113l, 127l, 131l, 137l, 139l, 149l, 151l, 157l, 163l, 167l, 173l, 179l, 181l, 191l, 193l, 197l, 199l, 211l, 223l, 227l, 229l, 233l, 239l, 241l, 251l, 257l, 263l, 269l, 271l, 277l, 281l, 283l, 293l, 307l, 311l, 313l, 317l, 331l, 337l, 347l, 349l, 353l, 359l, 367l, 373l, 379l, 383l, 389l, 397l, 401l, 409l, 419l, 421l, 431l, 433l, 439l, 443l, 449l, 457l, 461l, 463l, 467l, 479l, 487l, 491l, 499l, 503l, 509l, 521l, 523l, 541l, 547l, 557l, 563l, 569l, 571l, 577l, 587l, 589l, 593l, 599l, 601l, 607l, 613l, 617l, 619l, 631l, 641l, 643l, 647l, 653l, 659l, 661l, 673l, 677l, 683l, 691l, 701l, 709l, 719l, 727l, 733l, 739l, 743l, 751l, 757l, 761l, 769l, 773l\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293149,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp1cmcfsk.scala:27:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpp1cmcfsk.scala:24:22 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mreturn\u001b[0m Nil()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): Nothing\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns a list of the\n    // first n prime numbers.\n    // for example:\n    // >>> primesUpTo((2l, 3l, 5l, 7l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpe1bvy7b_.scala:58:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpe1bvy7b_.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe1bvy7b_.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe1bvy7b_.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe1bvy7b_.scala:46:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe1bvy7b_.scala:47:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    assert(countUpTo((\u001b[31m6l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7l52xtgh.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        if (n < 0) {\n            return result\n        }\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result += i\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 0) {\n            return false\n        }\n        if (n == 1) {\n            return true\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        if (n % 3 == 0) {\n            return false\n        }\n        if (n % 5 == 0) {\n            return false\n        }\n        if (n % 7 == 0) {\n            return false\n        }\n        if (n % 11 == 0) {\n            return false\n        }\n        if (n % 13 == 0) {\n            return false\n        }\n        if (n % 17 == 0) {\n            return false\n        }\n        if (n % 19 == 0) {\n            return false\n        }\n        if (n % 23 == 0) {\n            return false\n        }\n        if (n % 29 == 0) {\n            return false\n        }\n        if (n % 31 == 0) {\n            return false\n        }\n        if (n % 37 == 0) {\n            return false\n        }\n        if (n % 41 == 0) {\n            return false\n        }\n        if (n % 43 == 0) {\n            return false\n        }\n        if (n % 47 == 0) {\n            return false\n        }\n        if (n % 53 == 0) {\n            return false\n        }\n        if (n % 59 == 0) {\n            return false\n        }\n        if (n % 61 == 0) {\n            return false\n        }\n        if (n % 67 == 0) {\n            return false\n        }\n        if (n % 71 == 0) {\n            return false\n        }\n        if (n % 73 == 0) {\n            return false\n        }\n        if (n % 79 ==\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp6wer0w4v.scala:105:21 --------------------------\u001b[0m\u001b[0m\n\u001b[31m105 |\u001b[0m        \u001b[33mif\u001b[0m (n % \u001b[31m79\u001b[0m ==\n\u001b[31m\u001b[31m    |\u001b[0m                     ^\u001b[0m\n\u001b[31m    |\u001b[0m                     expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m    |\u001b[0m\n\u001b[31m    |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6wer0w4v.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6wer0w4v.scala:26:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result += i\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value += is not a member of List[Long] - did you mean result.!=?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Returns true if the given number is prime.\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        } else if (n == 2) {\n            return true\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293168,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp850xgjmp.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp850xgjmp.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp850xgjmp.scala:41:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = i\n            if (prime.isPrime()) {\n                result = result.append(prime)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8zau1cqh.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8zau1cqh.scala:26:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (prime.isPrime()) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value isPrime is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8zau1cqh.scala:27:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result = result.append(prime)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptjb_n4_l.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptjb_n4_l.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptjb_n4_l.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (n == 0) {\n            return Nil()\n        }\n        return List(2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l, 37l, 41l, 43l, 47l, 53l, 59l, 61l, 67l, 71l, 73l, 79l, 83l, 89l, 97l, 101l, 103l, 107l, 109l, 113l, 127l, 131l, 137l, 139l, 149l, 151l, 157l, 163l, 167l, 173l, 179l, 181l, 191l, 193l, 197l, 199l, 211l, 223l, 227l, 229l, 233l, 239l, 241l, 251l, 257l, 263l, 269l, 271l, 277l, 281l, 283l, 293l, 307l, 311l, 313l, 317l, 331l, 337l, 347l, 349l, 353l, 359l, 367l, 373l, 379l, 383l, 389l, 397l, 401l, 409l, 419l, 421l, 431l, 433l, 439l, 443l, 449l, 457l, 461l, 463l, 467l, 479l, 487l, 491l, 499l, 503l, 509l, 521l, 523l, 541l, 547l, 557l, 563l, 569l, 571l, 577l, 587l, 593l, 599l, 601l, 607l, 613l, 617l, 619l, 631l, 641l, 643l, 647l, 653l, 659l, 661l, 673l, 677l, 683l, 691l, 701l, 709l, 719l, 727l, 733l, 739l, 743l, 751l, 757l, 761l, 769l, 773l, 787l\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpigpe0k5t.scala:27:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpigpe0k5t.scala:24:22 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mreturn\u001b[0m Nil()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): Nothing\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        for (i <- 3 until Math.sqrt(n)) {\n            if (n % i == 0) {\n                return false\n            }\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpobgr00fj.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpobgr00fj.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpobgr00fj.scala:42:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    Double\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns the number of prime\n    // numbers less than n.\n    // for example:\n    // >>> countPrimes(0l)\n    // 0\n    // >>> countPrimes(1l)\n    // 0\n    // >>> countPrimes(2l)\n    // 1\n    // >>> countPrimes(3l)\n    // 2\n    // >>> countPrimes(4l)\n    // 2\n    // >>> countPrimes(5l)\n    // 3\n    // >>> countPrimes(6l)\n    // 3\n    // >>> countPrimes(7l)\n    // 4\n    // >>> countPrimes(8l)\n    // 4\n    // >>> countPrimes(9l)\n    // 5\n    // >>> countPrimes(10l)\n    // 5\n    // >>> countPrimes(11l)\n    // 6\n    // >>> countPrimes(12l)\n    // 6\n    // >>> countPrimes(13l)\n    // 7\n    // >>> countPrimes(14l)\n    // 7\n    // >>> countPrimes(15l)\n    // 8\n    // >>> countPrimes(16l)\n    // 8\n    // >>> countPrimes(17l)\n    // 9\n    // >>> countPrimes(18l)\n    // 9\n    // >>> countPrimes(19l)\n    // 10\n    // >>> countPrimes(20l)\n    // 10\n    // >>> countPrimes(21l)\n    // 11\n    // >>> countPrimes(22l)\n    // 11\n    // >>> countPrimes(23l)\n    // 12\n    // >>> countPrimes(24l)\n    // 12\n    // >>> countPrimes(25l)\n    // 13\n    // >>> countPrimes(\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293166,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpebpz_jq0.scala:102:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m102 |\u001b[0m}\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpebpz_jq0.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpebpz_jq0.scala:25:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpebpz_jq0.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpebpz_jq0.scala:90:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m90 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpebpz_jq0.scala:91:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m91 |\u001b[0m    assert(countUpTo((\u001b[31m6l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 0) {\n            return false\n        } else if (n == 1) {\n            return true\n        } else if (n == 2) {\n            return true\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            return n % 3 == 0\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293168,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpo4vjdf2t.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo4vjdf2t.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = isPrime(i)\n            if (prime) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Returns true if the given number is prime.\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        val max = scala.math.maxInt(n.toInt, 2)\n        for (i <- 3 until max) {\n            if (n % i == 0) {\n                return false\n            }\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpiwppca54.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpiwppca54.scala:27:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpiwppca54.scala:44:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = scala.math.maxInt(n.toInt, \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value maxInt is not a member of math - did you mean math.BigInt?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        for (i <- 3 until Math.sqrt(n)) {\n            if (n % i == 0) {\n                return false\n            }\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpobgr00fj.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpobgr00fj.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpobgr00fj.scala:42:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    Double\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        if (n < 0) {\n            return result\n        }\n        val i = 0\n        while (i < n) {\n            val prime = isPrime(i)\n            if (prime) {\n                result = result.append(i)\n            }\n            i += 1\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        val i = 3\n        while (i * i <= n) {\n            if (n % i == 0) {\n                return false\n            }\n            i += 2\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293168,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsy3tvlw7.scala:28:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsy3tvlw7.scala:30:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            i += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean i.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsy3tvlw7.scala:50:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m            i += \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean i.!=?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        if (n < 0) {\n            return result\n        }\n        val i = 0\n        while (i < n) {\n            val prime = isPrime(i)\n            if (prime) {\n                result = result.append(i)\n            }\n            i = i + 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptk8i41d1.scala:26:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mprime\u001b[0m = isPrime(i)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptk8i41d1.scala:28:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmptk8i41d1.scala:30:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            i = i + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (n == 0) {\n            return Nil$()\n        }\n        return List(2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l, 37l, 41l, 43l, 47l, 53l, 59l, 61l, 67l, 71l, 73l, 79l, 83l, 89l, 97l, 101l, 103l, 107l, 109l, 113l, 127l, 131l, 137l, 139l, 149l, 151l, 157l, 163l, 167l, 173l, 179l, 181l, 191l, 193l, 197l, 199l, 211l, 223l, 227l, 229l, 233l, 239l, 241l, 251l, 257l, 263l, 269l, 271l, 277l, 281l, 283l, 293l, 307l, 311l, 313l, 317l, 331l, 337l, 347l, 349l, 353l, 359l, 367l, 373l, 379l, 383l, 389l, 397l, 401l, 409l, 419l, 421l, 431l, 433l, 439l, 443l, 449l, 457l, 461l, 463l, 467l, 479l, 487l, 491l, 499l, 503l, 509l, 521l, 523l, 541l, 547l, 557l, 563l, 569l, 571l, 577l, 587l, 589l, 593l, 599l, 601l, 607l, 613l, 617l, 619l, 631l, 641l, 643l, 647l, 653l, 659l, 661l, 673l, 677l, 683l, 691l, 701l, 709l, 719l, 727l, 733l, 739l, 743l, 751l, 757l, 761l, 769l, 773\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpslo43_bp.scala:27:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpslo43_bp.scala:24:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mreturn\u001b[0m Nil$()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: Nil\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7l52xtgh.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and greater than n.\n    // for example:\n    // >>> countUpToGreaterThan((5l))\n    // (List[Long](6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))\n    // >>> countUpToGreaterThan((11l))\n    // (List[Long](12l.toLong, 13l.toLong, 14l.toLong, 15l.toLong, 16l.toLong, 17l.toLong, 18l.toLong, 19l.toLong))\n    // >>> countUpToGreaterThan((0l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((20l))\n    // (List[Long](20l.toLong, 21l.toLong, 22l.toLong, 23l.toLong, 24l.toLong, 25l.toLong, 26l.toLong, 27l.toLong, 28l.toLong, 29l.toLong))\n    // >>> countUpToGreaterThan((1l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((18l))\n    // (List[Long](18l.toLong, 19l.toLong, 20l.toLong, 21l.toLong, 22l.toLong, 23l.toLong, 24l.toLong, 25l.toLong, 26l.toLong, 27l.toLong))\n    def countUpToGreaterThan(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293168,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpdj621vhh.scala:69:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdj621vhh.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdj621vhh.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdj621vhh.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdj621vhh.scala:46:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdj621vhh.scala:47:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdj621vhh.scala:48:32 ----------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = isPrime(i)\n            if (prime) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        for (i <- 3 until Math.sqrt(n)) {\n            if (n % i == 0) {\n                return false\n            }\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3dcygd7i.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3dcygd7i.scala:27:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3dcygd7i.scala:43:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    Double\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = isPrime(i)\n            if (prime) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293177,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxhw_fbap.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxhw_fbap.scala:25:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mprime\u001b[0m = isPrime(i)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxhw_fbap.scala:27:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        if (n == 0) {\n            return result\n        }\n        val i = 0\n        while (i < n) {\n            result.append(i)\n            i = i + 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgg0cscmy.scala:29:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpgg0cscmy.scala:30:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            i = i + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        val i = 0l\n        while (i < n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n            i = i + 1l\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns a list of the\n    // first n prime numbers that are less than n.\n    // for example:\n    // >>> primesUpTo((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    // >>> primesUpTo((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong)))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((List[Long]()))\n    // (List[Long]())\n    // >>> primesUpTo((List[Long](1l.toLong)))\n    // (List[Long]())\n    // >>> primesUpTo((List[Long](1l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong))\n    // >>> primesUpTo((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong))\n    \n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293177,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmprmswfma0.scala:64:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprmswfma0.scala:26:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprmswfma0.scala:27:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmprmswfma0.scala:29:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            i = i + \u001b[31m1l\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprmswfma0.scala:52:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprmswfma0.scala:53:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    assert(countUpTo((\u001b[31m6l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprmswfma0.scala:54:11 ------------------------\u001b[0m\u001b[0",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7l52xtgh.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = i\n            if (prime.isPrime()) {\n                result = result.append(prime)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8zau1cqh.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8zau1cqh.scala:26:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (prime.isPrime()) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value isPrime is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8zau1cqh.scala:27:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result = result.append(prime)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    private boolean isPrime(Long i) {\n        if (i == 0) {\n            return false\n        }\n        if (i == 1) {\n            return true\n        }\n        if (i % 2 == 0) {\n            return false\n        }\n        if (i % 3 == 0) {\n            return false\n        }\n        for (j <- 2 until Math.sqrt(i)) {\n            if (i % j == 0) {\n                return false\n            }\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293178,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E088] Syntax Error: /tmp/tmpnuj851pl.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m    \u001b[33mprivate\u001b[0m boolean isPrime(Long i) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Expected start of definition\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnuj851pl.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnuj851pl.scala:25:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnuj851pl.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns a list of the\n    // first n primes.\n    // for example:\n    // >>> primesUpTo((2l, 3l, 5l, 7l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l))\n    // (List\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293179,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_q7qo72t.scala:61:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_q7qo72t.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_q7qo72t.scala:25:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_q7qo72t.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_q7qo72t.scala:49:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_q7qo72t.scala:50:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m    assert(countUpTo((\u001b[31m6l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        } else if (n == 2) {\n            return true\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpalv3cw22.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpalv3cw22.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpalv3cw22.scala:40:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        if (n == 0) {\n            return result\n        }\n        val i = 1L\n        while (i <= n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n            i = i + 1L\n        }\n        return result\n    }\n\n    private static boolean isPrime(Long i) {\n        if (i < 2) {\n            return false\n        }\n        if (i == 2) {\n            return true\n        }\n        if (i % 2 == 0) {\n            return false\n        }\n        if (i % 3 == 0) {\n            return false\n        }\n        val b = (i - 1) / 2\n        val m = (long) Math.sqrt(b)\n        val f = 5\n        while (f <= m) {\n            if (i % f == 0) {\n                return false\n            }\n            if (i % (f + 2) == 0) {\n                return false\n            }\n            f = f + 6\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293177,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E088] Syntax Error: /tmp/tmp67f3zt11.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m    \u001b[33mprivate\u001b[0m static boolean isPrime(Long i) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Expected start of definition\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp67f3zt11.scala:29:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp67f3zt11.scala:30:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp67f3zt11.scala:32:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            i = i + \u001b[31m1L\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = i + 1\n            if (prime.isPrime()) {\n                result = result.append(prime)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293179,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2pfrk41x.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2pfrk41x.scala:26:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (prime.isPrime()) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value isPrime is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2pfrk41x.scala:27:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result = result.append(prime)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        if (n == 0) {\n            return result\n        }\n        val i = n\n        while (i > 0) {\n            result = result.append(i)\n            i -= 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293179,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdwr5dy2d.scala:29:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdwr5dy2d.scala:30:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            i -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value -= is not a member of Long - did you mean i.!=?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns a list of the\n    // first n primes.\n    // for example:\n    // >>> primesUpTo((2l, 3l, 5l, 7l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_njnhyaw.scala:58:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_njnhyaw.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_njnhyaw.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_njnhyaw.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_njnhyaw.scala:46:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_njnhyaw.scala:47:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    assert(countUpTo((\u001b[31m6l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = mutable.List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and greater than n.\n    // for example:\n    // >>> countUpToGreaterThan((5l))\n    // (List[Long](6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))\n    // >>> countUpToGreaterThan((11l))\n    // (List[Long](13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    // >>> countUpToGreaterThan((0l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((20l))\n    // (List[Long](6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    // >>> countUpToGreaterThan((1l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((18l))\n    // (List[Long](13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    def countUpToGreaterThan(n : Long) : List[Long] = {\n        val result = mutable.List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than or equal to n.\n    // for example:\n    // >>> countUpToLessThan((5l))\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293179,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmprhkrc2oq.scala:72:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprhkrc2oq.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprhkrc2oq.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprhkrc2oq.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprhkrc2oq.scala:45:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprhkrc2oq.scala:46:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation availab",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns a list of the\n    // first n primes.\n    // for example:\n    // >>> primesUpTo((2l, 3l, 5l, 7l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_njnhyaw.scala:58:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_njnhyaw.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_njnhyaw.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_njnhyaw.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_njnhyaw.scala:46:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_njnhyaw.scala:47:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    assert(countUpTo((\u001b[31m6l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7l52xtgh.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = isPrime(i)\n            if (prime) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        for (i <- 3 until Math.sqrt(n)) {\n            if (n % i == 0) {\n                return false\n            }\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3dcygd7i.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3dcygd7i.scala:27:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3dcygd7i.scala:43:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    Double\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7l52xtgh.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        if (n == 0) {\n            return result\n        }\n        val i = n\n        while (i > 0) {\n            result = result.append(i)\n            i -= 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293179,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdwr5dy2d.scala:29:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdwr5dy2d.scala:30:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            i -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value -= is not a member of Long - did you mean i.!=?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = isPrime(i)\n            if (prime) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        val result = false\n        for (i <- 2 until n) {\n            if (n % i == 0) {\n                result = false\n                break\n            }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293179,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8icofdd7.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8icofdd7.scala:24:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8icofdd7.scala:32:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m2\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp8icofdd7.scala:34:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                result = \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8icofdd7.scala:35:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (n == 0) {\n            return Nil()\n        }\n        return List(2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l, 37l, 41l, 43l, 47l, 53l, 59l, 61l, 67l, 71l, 73l, 79l, 83l, 89l, 97l, 101l, 103l, 107l, 109l, 113l, 127l, 131l, 137l, 139l, 149l, 151l, 157l, 163l, 167l, 173l, 179l, 181l, 191l, 193l, 197l, 199l, 211l, 223l, 227l, 229l, 233l, 239l, 241l, 251l, 257l, 263l, 269l, 271l, 277l, 281l, 283l, 293l, 307l, 311l, 313l, 317l, 331l, 337l, 347l, 349l, 353l, 359l, 367l, 373l, 379l, 383l, 389l, 397l, 401l, 409l, 419l, 421l, 431l, 433l, 439l, 443l, 449l, 457l, 461l, 463l, 467l, 479l, 487l, 491l, 499l, 503l, 509l, 521l, 523l, 541l, 547l, 557l, 563l, 569l, 571l, 577l, 587l, 593l, 599l, 601l, 607l, 613l, 617l, 619l, 631l, 641l, 643l, 647l, 653l, 659l, 661l, 673l, 677l, 683l, 691l, 701l, 709l, 719l, 727l, 733l, 739l, 743l, 751l, 757l, 761l, 769l, 773l, 787l\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpigpe0k5t.scala:27:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpigpe0k5t.scala:24:22 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mreturn\u001b[0m Nil()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): Nothing\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and greater than n.\n    // for example:\n    // >>> countUpToGreaterThan((5l))\n    // (List[Long](6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))\n    // >>> countUpToGreaterThan((11l))\n    // (List[Long](13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    // >>> countUpToGreaterThan((0l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((20l))\n    // (List[Long](6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    // >>> countUpToGreaterThan((1l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((18l))\n    // (List[Long](13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    def countUpToGreaterThan(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- n until n + 1) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than or equal to n.\n    // for example:\n    // >>> countUpToLessThan((5l))\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293180,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpe6h01ift.scala:72:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpe6h01ift.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe6h01ift.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe6h01ift.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe6h01ift.scala:47:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe6h01ift.scala:48:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe6h01ift.scala:60:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = i + 1\n            if (prime % 2 == 0) {\n                prime = prime / 2\n            }\n            if (prime % 3 == 0) {\n                prime = prime / 3\n            }\n            if (prime % 5 == 0) {\n                prime = prime / 5\n            }\n            if (prime % 7 == 0) {\n                prime = prime / 7\n            }\n            if (prime % 11 == 0) {\n                prime = prime / 11\n            }\n            if (prime % 13 == 0) {\n                prime = prime / 13\n            }\n            if (prime % 17 == 0) {\n                prime = prime / 17\n            }\n            if (prime % 19 == 0) {\n                prime = prime / 19\n            }\n            result = result.append(prime)\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293180,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn66bgt3q.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpn66bgt3q.scala:27:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                prime = prime / \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val prime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpn66bgt3q.scala:30:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                prime = prime / \u001b[31m3\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val prime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpn66bgt3q.scala:33:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                prime = prime / \u001b[31m5\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val prime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpn66bgt3q.scala:36:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                prime = prime / \u001b[31m7\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val prime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpn66bgt3q.scala:39:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                prime = prime / \u001b[31m11\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns the sum of the first n\n    // positive integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpToSum((5l))\n    // (Long(11l))\n    // >>> countUpToSum((11l))\n    // (Long(22l))\n    // >>> countUpToSum((0l))\n    // (Long(0l))\n    // >>> countUpToSum((20l))\n    // (Long(55l))\n    // >>> countUpToSum((1l))\n    // (Long(1l))\n    // >>> countUpToSum((18l))\n    // (Long(19l))\n    def countUpToSum(n : Long) : Long = {\n        val result = 0l\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result += i\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns the sum of the first n\n    // positive integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpToSum2((5l))\n    // (Long(11l))\n    // >>> countUpToSum2((11l))\n    // (Long(22l))\n    // >>> countUpToSum2((0l))\n    // (Long(0l))\n    // >>> countUpToSum2((20l))\n    // (Long(55l))\n    // >>> countUpToSum2((1l))\n    // (Long(1l))\n    // >>> countUpToSum2((18l))\n    // (Long(19l))\n    def countUpToSum2(n : Long) : Long = {\n        val result = 0l\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result += i\n            }\n        }\n\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293180,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpll74rqwn.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpll74rqwn.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpll74rqwn.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpll74rqwn.scala:46:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpll74rqwn.scala:47:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpll74rqwn.scala:48:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m                result += i\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              value += is not a member of Long - did y",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        for (i <- 3 until Math.sqrt(n)) {\n            if (n % i == 0) {\n                return false\n            }\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpobgr00fj.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpobgr00fj.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpobgr00fj.scala:42:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    Double\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result += i\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        }\n        if (n < 2) {\n            return false\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        for (i <- 3 until Math.sqrt(n)) {\n            if (n % i == 0) {\n                return false\n            }\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293180,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt7hhf8le.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt7hhf8le.scala:23:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result += i\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value += is not a member of List[Long] - did you mean result.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt7hhf8le.scala:39:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    Double\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (n == 0) {\n            return Nil()\n        }\n        return Cons(2l, countUpTo(n - 1))\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293177,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp0f22gs0s.scala:24:22 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mreturn\u001b[0m Nil()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): Nothing\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0f22gs0s.scala:26:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mreturn\u001b[0m Cons(\u001b[31m2l\u001b[0m, countUpTo(n - \u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Not found: Cons\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7l52xtgh.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        var result = List[Long]()\n        var i = 2L\n        while (i <= n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n            i = i + 1L\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns the number of prime\n    // numbers less than n.\n    // for example:\n    // >>> countPrimes(0l)\n    // 0l\n    // >>> countPrimes(1l)\n    // 0l\n    // >>> countPrimes(2l)\n    // 1l\n    // >>> countPrimes(3l)\n    // 2l\n    // >>> countPrimes(4l)\n    // 2l\n    // >>> countPrimes(5l)\n    // 3l\n    // >>> countPrimes(6l)\n    // 3l\n    // >>> countPrimes(7l)\n    // 4l\n    // >>> countPrimes(8l)\n    // 4l\n    // >>> countPrimes(9l)\n    // 5l\n    // >>> countPrimes(10l)\n    // 5l\n    // >>> countPrimes(11l)\n    // 6l\n    // >>> countPrimes(12l)\n    // 6l\n    // >>> countPrimes(13l)\n    // 7l\n    // >>> countPrimes(14l)\n    // 7l\n    // >>> countPrimes(15l)\n    // 8l\n    // >>> countPrimes(16l)\n    // 8l\n    // >>> countPrimes(17l)\n    // 9l\n    // >>> countPrimes(18l)\n    // 9l\n    // >>> countPrimes(19l)\n    // 10l\n    // >>> countPrimes(20l)\n    // 10l\n    def countPrimes(n : Long) : Long = {\n        var result = 0L\n        var i = 2L\n        while (i <= n) {\n            if (isPrime(i)) {\n                result = result + 1L\n            }\n            i = i + 1L\n        }\n        return result\n    }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293180,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpl0n8xxwc.scala:101:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m101 |\u001b[0m}\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl0n8xxwc.scala:23:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl0n8xxwc.scala:24:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl0n8xxwc.scala:80:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m80 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl0n8xxwc.scala:89:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m89 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl0n8xxwc.scala:90:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m90 |\u001b[0m    assert(countUpTo((\u001b[31m6l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl0n8xxwc.scala:91:11 ---------------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (n == 0) {\n            return Nil()\n        }\n        return List(2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l, 37l, 41l, 43l, 47l, 53l, 59l, 61l, 67l, 71l, 73l, 79l, 83l, 89l, 97l, 101l, 103l, 107l, 109l, 113l, 127l, 131l, 137l, 139l, 149l, 151l, 157l, 163l, 167l, 173l, 179l, 181l, 191l, 193l, 197l, 199l, 211l, 223l, 227l, 229l, 233l, 239l, 241l, 251l, 257l, 263l, 269l, 271l, 277l, 281l, 283l, 293l, 307l, 311l, 313l, 317l, 331l, 337l, 347l, 349l, 353l, 359l, 367l, 373l, 379l, 383l, 389l, 397l, 401l, 409l, 419l, 421l, 431l, 433l, 439l, 443l, 449l, 457l, 461l, 463l, 467l, 479l, 487l, 491l, 499l, 503l, 509l, 521l, 523l, 541l, 547l, 557l, 563l, 569l, 571l, 577l, 587l, 589l, 593l, 599l, 601l, 607l, 613l, 617l, 619l, 631l, 641l, 643l, 647l, 653l, 659l, 661l, 673l, 677l, 683l, 691l, 701l, 709l, 719l, 727l, 733l, 739l, 743l, 751l, 757l, 761l, 769l, 773l\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293149,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp1cmcfsk.scala:27:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpp1cmcfsk.scala:24:22 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mreturn\u001b[0m Nil()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): Nothing\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        var result = List[Long]()\n        var i = 0l\n        while (i < n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n            i = i + 1l\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293180,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp61vl6ott.scala:23:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp61vl6ott.scala:24:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7l52xtgh.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Returns true if n is prime.\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        } else if (n == 2) {\n            return true\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293181,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3qya4zql.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3qya4zql.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3qya4zql.scala:41:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        if (n < 0) {\n            return result\n        }\n        for (i <- 0 until n) {\n            val p = i\n            if (p % 2 == 0) {\n                p = p / 2\n            }\n            if (p == 1) {\n                result = result.append(i)\n            }\n            while (p < n) {\n                p = p + 2\n                if (p % 2 == 0) {\n                    p = p / 2\n                }\n                if (p == 1) {\n                    result = result.append(i)\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293181,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4zdo1zjj.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp4zdo1zjj.scala:27:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                p = p / \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val p\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4zdo1zjj.scala:30:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp4zdo1zjj.scala:33:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                p = p + \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val p\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp4zdo1zjj.scala:35:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                    p = p / \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Reassignment to val p\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4zdo1zjj.scala:38:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                    result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n6 errors",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns a list of the\n    // first n primes.\n    // for example:\n    // >>> primesUpTo((2l, 3l, 5l, 7l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_njnhyaw.scala:58:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_njnhyaw.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_njnhyaw.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_njnhyaw.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_njnhyaw.scala:46:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_njnhyaw.scala:47:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    assert(countUpTo((\u001b[31m6l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = isPrime(i)\n            if (prime) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293181,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpynlk40d0.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpynlk40d0.scala:24:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpynlk40d0.scala:38:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        if (n == 0) {\n            return result\n        }\n        val i = 0\n        while (i < n) {\n            result = result.append(i)\n            i += 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293181,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpiy_p44l3.scala:29:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpiy_p44l3.scala:30:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            i += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean i.!=?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 0) {\n            return false\n        } else if (n == 1) {\n            return true\n        } else if (n == 2) {\n            return true\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293166,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcme2mfae.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcme2mfae.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcme2mfae.scala:39:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        if (n == 0) {\n            return result\n        }\n        val i = 1L\n        while (i <= n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n            i = i + 1L\n        }\n        return result\n    }\n\n    // Returns true if the given number is prime.\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        val i = 3L\n        while (i <= Math.sqrt(n)) {\n            if (n % i == 0) {\n                return false\n            }\n            i = i + 2L\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293166,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzr44ivob.scala:30:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpzr44ivob.scala:32:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            i = i + \u001b[31m1L\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpzr44ivob.scala:53:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m            i = i + \u001b[31m2L\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Returns true if the given number is prime.\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until n) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293181,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_03nwm5r.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_03nwm5r.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_03nwm5r.scala:38:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (n : Long)\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (n == 0) {\n            return Nil()\n        }\n        return List(2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l, 37l, 41l, 43l, 47l, 53l, 59l, 61l, 67l, 71l, 73l, 79l, 83l, 89l, 97l, 101l, 103l, 107l, 109l, 113l, 127l, 131l, 137l, 139l, 149l, 151l, 157l, 163l, 167l, 173l, 179l, 181l, 191l, 193l, 197l, 199l, 211l, 223l, 227l, 229l, 233l, 239l, 241l, 251l, 257l, 263l, 269l, 271l, 277l, 281l, 283l, 293l, 307l, 311l, 313l, 317l, 331l, 337l, 347l, 349l, 353l, 359l, 367l, 373l, 379l, 383l, 389l, 397l, 401l, 409l, 419l, 421l, 431l, 433l, 439l, 443l, 449l, 457l, 461l, 463l, 467l, 479l, 487l, 491l, 499l, 503l, 509l, 521l, 523l, 541l, 547l, 557l, 563l, 569l, 571l, 577l, 587l, 593l, 599l, 601l, 607l, 613l, 617l, 619l, 631l, 641l, 643l, 647l, 653l, 659l, 661l, 673l, 677l, 683l, 691l, 701l, 709l, 719l, 727l, 733l, 739l, 743l, 751l, 757l, 761l, 769l, 773l, 787l\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpigpe0k5t.scala:27:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpigpe0k5t.scala:24:22 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mreturn\u001b[0m Nil()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): Nothing\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (n == 0) {\n            return Nil$()\n        }\n        return List(2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l, 37l, 41l, 43l, 47l, 53l, 59l, 61l, 67l, 71l, 73l, 79l, 83l, 89l, 97l, 101l, 103l, 107l, 109l, 113l, 127l, 131l, 137l, 139l, 149l, 151l, 157l, 163l, 167l, 173l, 179l, 181l, 191l, 193l, 197l, 199l, 211l, 223l, 227l, 229l, 233l, 239l, 241l, 251l, 257l, 263l, 269l, 271l, 277l, 281l, 283l, 293l, 307l, 311l, 313l, 317l, 331l, 337l, 347l, 349l, 353l, 359l, 367l, 373l, 379l, 383l, 389l, 397l, 401l, 409l, 419l, 421l, 431l, 433l, 439l, 443l, 449l, 457l, 461l, 463l, 467l, 479l, 487l, 491l, 499l, 503l, 509l, 521l, 523l, 541l, 547l, 557l, 563l, 569l, 571l, 577l, 587l, 589l, 593l, 599l, 601l, 607l, 613l, 617l, 619l, 631l, 641l, 643l, 647l, 653l, 659l, 661l, 673l, 677l, 683l, 691l, 701l, 709l, 719l, 727l, 733l, 739l, 743l, 751l, 757l, 761l, 769l, 773\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpslo43_bp.scala:27:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpslo43_bp.scala:24:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mreturn\u001b[0m Nil$()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: Nil\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and greater than n.\n    // for example:\n    // >>> countUpToGreaterThan((5l))\n    // (List[Long](7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpToGreaterThan((11l))\n    // (List[Long](13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpToGreaterThan((0l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((20l))\n    // (List[Long](13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpToGreaterThan((1l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((18l))\n    // (List[Long](13l.toLong, 17l.toLong, 19l.toLong))\n    def countUpToGreaterThan(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than or equal to n.\n    // for example:\n    // >>> countUpToLessThan((5l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong))\n    // >>> countUpToLessThan((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293189,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpts9l97kv.scala:75:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpts9l97kv.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpts9l97kv.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpts9l97kv.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpts9l97kv.scala:46:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpts9l97kv.scala:47:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpts9l97kv.scala:48:32 ----------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and greater than n.\n    // for example:\n    // >>> countUpToGreaterThan((5l))\n    // (List[Long](6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong))\n    // >>> countUpToGreaterThan((11l))\n    // (List[Long](11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    // >>> countUpToGreaterThan((0l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    // >>> countUpToGreaterThan((1l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    def countUpToGreaterThan(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293190,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0491qdxl.scala:69:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0491qdxl.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0491qdxl.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0491qdxl.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0491qdxl.scala:46:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0491qdxl.scala:47:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0491qdxl.scala:48:32 ----------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns a list of the\n    // first n primes.\n    // for example:\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l, 37l))\n    // (List[Long](2l.\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293139,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpj35ahfrg.scala:56:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpj35ahfrg.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj35ahfrg.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj35ahfrg.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj35ahfrg.scala:44:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj35ahfrg.scala:45:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m    assert(countUpTo((\u001b[31m6l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (n == 0) {\n            return result\n        }\n        val i = 0\n        while (i < n) {\n            val prime = scala.math.factorial(i)\n            if (prime > n) {\n                break\n            }\n            result = result.append(prime)\n            i = i + 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293191,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5wmp2_o3.scala:29:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mprime\u001b[0m = scala.math.factorial(i)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value factorial is not a member of math\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5wmp2_o3.scala:31:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5wmp2_o3.scala:33:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            result = result.append(prime)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp5wmp2_o3.scala:34:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            i = i + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        var result = List[Long](0)\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpr672u7fu.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpr672u7fu.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpr672u7fu.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        if (n < 0) {\n            return result\n        }\n        val i = 0\n        while (i < n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n            i = i + 1\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns a list of the\n    // first n prime numbers.\n    // for example:\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293188,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp6zvj1gkb.scala:60:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6zvj1gkb.scala:26:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6zvj1gkb.scala:27:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp6zvj1gkb.scala:29:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            i = i + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6zvj1gkb.scala:48:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6zvj1gkb.scala:49:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    assert(countUpTo((\u001b[31m6l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6zvj1gkb.scala:50:11 ------------------------\u001b[0m\u001b[0m\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7l52xtgh.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = i\n            if (prime.isPrime()) {\n                result = result.append(prime)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8zau1cqh.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8zau1cqh.scala:26:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (prime.isPrime()) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value isPrime is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8zau1cqh.scala:27:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result = result.append(prime)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and greater than n.\n    // for example:\n    // >>> countUpToGreaterThan((5l))\n    // (List[Long](6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))\n    // >>> countUpToGreaterThan((11l))\n    // (List[Long](13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    // >>> countUpToGreaterThan((0l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((20l))\n    // (List[Long](6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    // >>> countUpToGreaterThan((1l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((18l))\n    // (List[Long](13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    def countUpToGreaterThan(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- n + 1 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and greater than or equal to n.\n    // for example:\n    // >>> countUpToGreaterThanOrEqual\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293191,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpdyw6idbm.scala:72:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdyw6idbm.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdyw6idbm.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdyw6idbm.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdyw6idbm.scala:47:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdyw6idbm.scala:48:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdyw6idbm.scala:60:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and greater than n.\n    // for example:\n    // >>> countUpToGreaterThan((5l))\n    // (List[Long](7l.toLong, 11l.toLong))\n    // >>> countUpToGreaterThan((11l))\n    // (List[Long](13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpToGreaterThan((0l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpToGreaterThan((1l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((18l))\n    // (List[Long](13l.toLong, 17l.toLong, 19l.toLong))\n    def countUpToGreaterThan(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than or equal to n.\n    // for example:\n    // >>> countUpToLessThan((5l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong))\n    // >>> countUpToLessThan((11l))\n    // (List[Long](2l\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293191,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpus9dl4sq.scala:75:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpus9dl4sq.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpus9dl4sq.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpus9dl4sq.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpus9dl4sq.scala:46:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpus9dl4sq.scala:47:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpus9dl4sq.scala:48:32 ----------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = mutable.List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result.append(i)\n            }\n        }\n        result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 0) {\n            false\n        } else if (n == 1) {\n            true\n        } else if (n == 2) {\n            true\n        } else if (n % 2 == 0) {\n            false\n        } else {\n            for (i <- 3 until n) {\n                if (n % i == 0) {\n                    false\n                }\n            }\n            true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293191,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfa4155fj.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfa4155fj.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfa4155fj.scala:39:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (n : Long)\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- [E129] Potential Issue Warning: /tmp/tmpfa4155fj.scala:41:20 ----------------\u001b[0m\u001b[0m\n\u001b[33m41 |\u001b[0m                    \u001b[31mfalse\u001b[0m\n\u001b[33m\u001b[33m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[33m   |\u001b[0mA pure expression does nothing in statement position; you may be omitting necessary parentheses\n\u001b[33m   |\u001b[0m\n\u001b[33m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 warning found\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n == 3) {\n            return true\n        } else if (n % 2 == 0) {\n            return false\n        } else if (n % 3 == 0) {\n            return false\n        } else {\n            for (i <- 4 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293193,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpapsm_81e.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpapsm_81e.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpapsm_81e.scala:39:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m4\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = isPrime(i)\n            if (prime) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns a list of the\n    // first n primes.\n    // for example:\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l, 37l))\n    // (\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293193,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmphoz4tha2.scala:57:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphoz4tha2.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphoz4tha2.scala:22:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mprime\u001b[0m = isPrime(i)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphoz4tha2.scala:24:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphoz4tha2.scala:45:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphoz4tha2.scala:46:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    assert(countUpTo((\u001b[31m6l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        if (n < 0) {\n            return result\n        }\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293193,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvm2ngtkg.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvm2ngtkg.scala:25:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvm2ngtkg.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        } else if (n == 2) {\n            return true\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpalv3cw22.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpalv3cw22.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpalv3cw22.scala:40:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        if (n % 3 == 0) {\n            return false\n        }\n        val b = (n - 1) / 2\n        for (i <- 4 until b) {\n            if (n % i == 0) {\n                return false\n            }\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293193,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp58fw_l35.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp58fw_l35.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp58fw_l35.scala:46:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m4\u001b[0m until b) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (b : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Returns true if the given number is prime.\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n == 1) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293193,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq5fje2uj.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpq5fje2uj.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq5fje2uj.scala:38:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        val i = 0\n        while (i < n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n            i += 1\n        }\n        return result\n    }\n\n    // Returns true if the given number is prime.\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n == 1) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            val i = 3\n            while (i <= Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n                i += 2\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293193,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgkynk7tt.scala:24:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgkynk7tt.scala:26:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            i += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean i.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgkynk7tt.scala:45:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m                i += \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean i.!=?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = i\n            if prime.isPrime() {\n                result = result.append(prime)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293193,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpoxywsugm.scala:26:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        'then' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpoxywsugm.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpoxywsugm.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m prime.isPrime() {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               value isPrime is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpoxywsugm.scala:24:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                result = result.append(prime)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        if (n < 0) {\n            return result\n        }\n        val i = 0\n        while (i < n) {\n            val prime = isPrime(i)\n            if (prime) {\n                result = result.append(i)\n            }\n            i += 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293193,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe14xz84q.scala:26:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mprime\u001b[0m = isPrime(i)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe14xz84q.scala:28:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe14xz84q.scala:30:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            i += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean i.!=?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (n == 0) {\n            return Nil()\n        }\n        return List(2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l, 37l, 41l, 43l, 47l, 53l, 59l, 61l, 67l, 71l, 73l, 79l, 83l, 89l, 97l, 101l, 103l, 107l, 109l, 113l, 127l, 131l, 137l, 139l, 149l, 151l, 157l, 163l, 167l, 173l, 179l, 181l, 191l, 193l, 197l, 199l, 211l, 223l, 227l, 229l, 233l, 239l, 241l, 251l, 257l, 263l, 269l, 271l, 277l, 281l, 283l, 293l, 307l, 311l, 313l, 317l, 331l, 337l, 347l, 349l, 353l, 359l, 367l, 373l, 379l, 383l, 389l, 397l, 401l, 409l, 419l, 421l, 431l, 433l, 439l, 443l, 449l, 457l, 461l, 463l, 467l, 479l, 487l, 491l, 499l, 503l, 509l, 521l, 523l, 541l, 547l, 557l, 563l, 569l, 571l, 577l, 587l, 589l, 593l, 599l, 601l, 607l, 613l, 617l, 619l, 631l, 641l, 643l, 647l, 653l, 659l, 661l, 673l, 677l, 683l, 691l, 701l, 709l, 719l, 727l, 733l, 739l, 743l, 751l, 757l, 761l, 769l, 773l\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293149,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp1cmcfsk.scala:27:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpp1cmcfsk.scala:24:22 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mreturn\u001b[0m Nil()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): Nothing\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = mutable.List[Long]()\n        for (i <- 0 until n) {\n            val prime = i\n            if prime.isPrime() {\n                result.append(prime)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293194,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpckdy6d_x.scala:26:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        'then' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpckdy6d_x.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpckdy6d_x.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpckdy6d_x.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m prime.isPrime() {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               value isPrime is not a member of Int\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        if (n < 0) {\n            return result\n        }\n        val i = 0\n        while (i < n) {\n            result.append(i)\n            i = i + 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293193,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpk72c0tyw.scala:26:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpk72c0tyw.scala:27:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            i = i + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        if (n == 0) {\n            return result\n        }\n        val i = 0\n        while (i < n) {\n            result.append(i)\n            i = i + 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgg0cscmy.scala:29:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpgg0cscmy.scala:30:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            i = i + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = mutable.List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        for (i <- 3 until Math.sqrt(n)) {\n            if (n % i == 0) {\n                return false\n            }\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8jhdj_tb.scala:23:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8jhdj_tb.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8jhdj_tb.scala:42:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    Double\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = mutable.List[Long]()\n        for (i <- 0 until n) {\n            val prime = isPrime(i)\n            if (prime) {\n                result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Returns true if the given number is prime.\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            val max = (long)(Math.sqrt(n))\n            for (i <- 3 until max) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293192,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpihvar746.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpihvar746.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpihvar746.scala:39:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = (long)(Math.sqrt(n))\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7l52xtgh.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = mutable.List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result.append(i)\n            }\n        }\n        result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            true\n        } else if (n < 2) {\n            false\n        } else if (n % 2 == 0) {\n            false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    false\n                }\n            }\n            true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293194,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpup46ldmf.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpup46ldmf.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpup46ldmf.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- [E129] Potential Issue Warning: /tmp/tmpup46ldmf.scala:39:20 ----------------\u001b[0m\u001b[0m\n\u001b[33m39 |\u001b[0m                    \u001b[31mfalse\u001b[0m\n\u001b[33m\u001b[33m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[33m   |\u001b[0mA pure expression does nothing in statement position; you may be omitting necessary parentheses\n\u001b[33m   |\u001b[0m\n\u001b[33m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 warning found\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and greater than n.\n    // for example:\n    // >>> countUpToGreaterThan((5l))\n    // (List[Long](6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))\n    // >>> countUpToGreaterThan((11l))\n    // (List[Long](13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    // >>> countUpToGreaterThan((0l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    // >>> countUpToGreaterThan((1l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((18l))\n    // (List[Long](13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    def countUpToGreaterThan(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than or equal to n.\n    // for example:\n    // >>> countUpToLessThan((5l))\n    \n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293195,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5l03m8dc.scala:73:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5l03m8dc.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5l03m8dc.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5l03m8dc.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5l03m8dc.scala:46:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5l03m8dc.scala:47:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5l03m8dc.scala:48:32 ----------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptjb_n4_l.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptjb_n4_l.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptjb_n4_l.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    private boolean isPrime(Long i) {\n        if (i == 0) {\n            return false\n        }\n        if (i == 1) {\n            return true\n        }\n        if (i == 2) {\n            return true\n        }\n        if (i % 2 == 0) {\n            return false\n        }\n        if (i % 3 == 0) {\n            return false\n        }\n        for (j <- 5 until i) {\n            if (i % j == 0) {\n                return false\n            }\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293194,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E088] Syntax Error: /tmp/tmpl4ek8ypl.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m    \u001b[33mprivate\u001b[0m boolean isPrime(Long i) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Expected start of definition\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl4ek8ypl.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl4ek8ypl.scala:25:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpl4ek8ypl.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = isPrime(i)\n            if (prime) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // prime numbers.\n    // for example:\n    // >>> primesUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong))\n    // >>> primesUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong))\n    // >>> primesUpTo((0l))\n    // (List[Long]())\n    // >>> primesUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((1l))\n    // (List[Long]())\n    // >>> primesUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def primesUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = isPrime(i)\n            if (prime) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    \n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293194,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpmz2ww7tb.scala:78:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m78 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmz2ww7tb.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmz2ww7tb.scala:25:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mprime\u001b[0m = isPrime(i)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmz2ww7tb.scala:27:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmz2ww7tb.scala:53:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmz2ww7tb.scala:54:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mprime\u001b[0m = isPrime(i)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E0",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        var result = List[Long](0)\n        var i = 0\n        while (i < n) {\n            result = result.append(i)\n            i = i + 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293194,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpex5189ju.scala:23:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = i + 1\n            if (prime % 2 == 0) {\n                prime = prime / 2\n            }\n            if (prime % 3 == 0) {\n                prime = prime / 3\n            }\n            if (prime % 5 == 0) {\n                prime = prime / 5\n            }\n            if (prime % 7 == 0) {\n                prime = prime / 7\n            }\n            if (prime % 11 == 0) {\n                prime = prime / 11\n            }\n            if (prime % 13 == 0) {\n                prime = prime / 13\n            }\n            if (prime % 17 == 0) {\n                prime = prime / 17\n            }\n            if (prime % 19 == 0) {\n                prime = prime / 19\n            }\n            if (prime % 23 == 0) {\n                prime = prime / 23\n            }\n            if (prime % 29 == 0) {\n                prime = prime / 29\n            }\n            if (prime % 31 == 0) {\n                prime = prime / 31\n            }\n            if (prime % 37 == 0) {\n                prime = prime / 37\n            }\n            if (prime % 41 == 0) {\n                prime = prime / 41\n            }\n            if (prime % 43 == 0) {\n                prime = prime / 43\n            }\n            if (prime % 47 == 0) {\n                prime = prime / 47\n            }\n            if (prime % 53 == 0) {\n                prime = prime / 53\n            }\n            if (prime % 59 == 0) {\n                prime = prime / 59\n            }\n            if (prime % 61 == 0) {\n                prime = prime / 61\n            }\n            if (prime % 67 == 0) {\n                prime = prime / 67\n            }\n            if (prime % 71 == 0) {\n                prime = prime / 71\n            }\n            if (prime % 73 == 0) {\n                prime = prime / 73\n            }\n            if (prime % 79 == 0) {\n                prime =\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293201,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpq4m8z68t.scala:90:23 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m90 |\u001b[0m                prime =\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpq4m8z68t.scala:106:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m106 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq4m8z68t.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpq4m8z68t.scala:27:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                prime = prime / \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val prime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpq4m8z68t.scala:30:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                prime = prime / \u001b[31m3\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val prime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpq4m8z68t.scala:33:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                prime = prime / \u001b[31m5\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val prime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpq4m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        if (n < 0) {\n            return result\n        }\n        val i = 0\n        while (i < n) {\n            val prime = isPrime(i)\n            if (prime) {\n                result = result.append(i)\n            }\n            i += 1\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and greater than n.\n    // for example:\n    // >>> countUpToGreaterThan((5l))\n    // (List[Long](6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong))\n    // >>> countUpToGreaterThan((11l))\n    // (List[Long](11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong))\n    // >>> countUpToGreaterThan((0l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((20l))\n    // (List[Long](6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 10l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))\n    // >>> countUpToGreaterThan((1l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((18l))\n    // (List[Long](6l.toLong, 7\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293202,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqj8p9rf1.scala:64:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqj8p9rf1.scala:26:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mprime\u001b[0m = isPrime(i)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqj8p9rf1.scala:28:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqj8p9rf1.scala:30:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            i += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean i.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqj8p9rf1.scala:52:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqj8p9rf1.scala:53:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    assert(countUpTo((\u001b[31m6l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqj8p9rf1.scala:54:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m    assert(countUpTo((",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        if (n < 0) {\n            return result\n        }\n        val i = 0l\n        while (i < n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n            i += 1l\n        }\n        return result\n    }\n\n    // Returns true if the given number is prime.\n    def isPrime(n : Long) : Boolean = {\n        if (n == 0) {\n            return false\n        }\n        if (n == 1) {\n            return true\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        if (n % 3 == 0) {\n            return false\n        }\n        val i = 5l\n        while (i * i <= n) {\n            if (n % i == 0) {\n                return false\n            }\n            i += 2l\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293202,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0tjtccwm.scala:27:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0tjtccwm.scala:29:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            i += \u001b[31m1l\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean i.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0tjtccwm.scala:56:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m            i += \u001b[31m2l\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Long - did you mean i.!=?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (n == 0) {\n            return Nil()\n        }\n        return List(2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l, 37l, 41l, 43l, 47l, 53l, 59l, 61l, 67l, 71l, 73l, 79l, 83l, 89l, 97l, 101l, 103l, 107l, 109l, 113l, 127l, 131l, 137l, 139l, 149l, 151l, 157l, 163l, 167l, 173l, 179l, 181l, 191l, 193l, 197l, 199l, 211l, 223l, 227l, 229l, 233l, 239l, 241l, 251l, 257l, 263l, 269l, 271l, 277l, 281l, 283l, 293l, 307l, 311l, 313l, 317l, 331l, 337l, 347l, 349l, 353l, 359l, 367l, 373l, 379l, 383l, 389l, 397l, 401l, 409l, 419l, 421l, 431l, 433l, 439l, 443l, 449l, 457l, 461l, 463l, 467l, 479l, 487l, 491l, 499l, 503l, 509l, 521l, 523l, 541l, 547l, 557l, 563l, 569l, 571l, 577l, 587l, 589l, 593l, 599l, 601l, 607l, 613l, 617l, 619l, 631l, 641l, 643l, 647l, 653l, 659l, 661l, 673l, 677l, 683l, 691l, 701l, 709l, 719l, 727l, 733l, 739l, 743l, 751l, 757l, 761l, 769l, 773l\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293149,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp1cmcfsk.scala:27:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpp1cmcfsk.scala:24:22 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mreturn\u001b[0m Nil()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): Nothing\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        if (n < 0) {\n            result = List[Long]()\n        } else {\n            for (i <- 0 until n) {\n                val prime = i\n                if (prime.isPrime()) {\n                    result = result.append(prime)\n                }\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293203,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp8dee4emq.scala:22:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            result = List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8dee4emq.scala:24:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (n : Long)\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8dee4emq.scala:26:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mif\u001b[0m (prime.isPrime()) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value isPrime is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8dee4emq.scala:27:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                    result = result.append(prime)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 0) {\n            return false\n        } else if (n == 1) {\n            return true\n        } else if (n == 2) {\n            return true\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293166,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcme2mfae.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcme2mfae.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcme2mfae.scala:39:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        var result = List[Long]()\n        var i = 2L\n        while (i < n) {\n            if (n % i == 0) {\n                result = result.append(i)\n                i = i + 1\n            } else {\n                i = i + 1\n            }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293201,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_and82uk.scala:24:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n1 error found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    private def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        } else if (n == 2) {\n            return true\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293204,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpce8s4c26.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpce8s4c26.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpce8s4c26.scala:40:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        if (n == 0) {\n            return result\n        }\n        val i = 1L\n        while (i <= n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n            i = i + 1L\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        if (n < 4) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        if (n < 9) {\n            return true\n        }\n        if (n % 3 == 0) {\n            return false\n        }\n        if (n < 27) {\n            return true\n        }\n        if (n % 3 == 0) {\n            return false\n        }\n        if (n < 31) {\n            return true\n        }\n        if (n % 5 == 0) {\n            return false\n        }\n        if (n < 61) {\n            return true\n        }\n        if (n % 5 == 0) {\n            return false\n        }\n        if (n < 91) {\n            return true\n        }\n        if (n % 7 == 0) {\n            return false\n        }\n        if (n < 127) {\n            return true\n        }\n        if (n % 7 == 0) {\n            return false\n        }\n        if (n < 181) {\n            return true\n        }\n        if (n % 11 == 0) {\n            return false\n        }\n        if (n < 251) {\n            return true\n        }\n        if (n % 11 == 0) {\n            return false\n        }\n        if (n < 383) {\n            return true\n        }\n        if (n % 13 == 0) {\n            return false\n\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293203,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpa9pfb177.scala:122:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m122 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa9pfb177.scala:30:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpa9pfb177.scala:32:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            i = i + \u001b[31m1L\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpa9pfb177.scala:121:1 --------------------\u001b[0m\u001b[0m\n\u001b[31m121 |\u001b[0m}\n\u001b[31m\u001b[31m    |\u001b[0m ^\u001b[0m\n\u001b[31m    |\u001b[0m Found:    Unit\n\u001b[31m    |\u001b[0m Required: Boolean\n\u001b[31m    |\u001b[0m\n\u001b[31m    |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmpa9pfb177.scala:108:4 ---------------------------------------\u001b[0m\u001b[0m\n\u001b[33m108 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m    |\u001b[0m    ^\u001b[0m\n\u001b[33m    |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n4 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result += i\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293204,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpiiw2bknf.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpiiw2bknf.scala:23:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result += i\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value += is not a member of List[Long] - did you mean result.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpiiw2bknf.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        if (n < 0) {\n            return result\n        }\n        val i = 0\n        while (i < n) {\n            result.append(i)\n            i = i + 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293193,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpk72c0tyw.scala:26:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpk72c0tyw.scala:27:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            i = i + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (n == 0) {\n            return result\n        }\n        val i = n\n        while (i > 0) {\n            result.append(i)\n            i -= 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293204,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmps5fpl_5z.scala:29:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmps5fpl_5z.scala:30:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            i -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value -= is not a member of Long - did you mean i.!=?\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    private def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        for (i <- 3 until Math.sqrt(n)) {\n            if (n % i == 0) {\n                return false\n            }\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293204,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3ggcs9uc.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3ggcs9uc.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3ggcs9uc.scala:42:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    Double\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        if (n < 0) {\n            result = List[Long]()\n        } else {\n            val i = 0\n            while (i < n) {\n                val prime = scala.math.factorial(i)\n                if (prime > n) {\n                    break\n                }\n                result = result.append(prime)\n                i = i + 1\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293204,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp2__pm99m.scala:22:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            result = List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2__pm99m.scala:26:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mprime\u001b[0m = scala.math.factorial(i)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            value factorial is not a member of math\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2__pm99m.scala:28:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                    break\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2__pm99m.scala:30:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                result = result.append(prime)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp2__pm99m.scala:31:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                i = i + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = mutable.List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293204,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpa9wjqxq4.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpa9wjqxq4.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpa9wjqxq4.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result += i\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293204,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpiiw2bknf.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpiiw2bknf.scala:23:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result += i\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value += is not a member of List[Long] - did you mean result.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpiiw2bknf.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Returns true if the given number is prime.\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        val max = (long)(Math.sqrt(n))\n        for (i <- 3 until max) {\n            if (n % i == 0) {\n                return false\n            }\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293204,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu2mxcuic.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpu2mxcuic.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpu2mxcuic.scala:43:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = (long)(Math.sqrt(n))\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (n == 0) {\n            return Nil()\n        }\n        return Cons(2l, countUpTo(n - 1))\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293177,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp0f22gs0s.scala:24:22 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mreturn\u001b[0m Nil()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): Nothing\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0f22gs0s.scala:26:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mreturn\u001b[0m Cons(\u001b[31m2l\u001b[0m, countUpTo(n - \u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Not found: Cons\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns a list of the\n    // first n primes.\n    // for example:\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l, 37l\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293204,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpj3du74c0.scala:55:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpj3du74c0.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj3du74c0.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj3du74c0.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj3du74c0.scala:43:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj3du74c0.scala:44:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m    assert(countUpTo((\u001b[31m6l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        if (n == 0) {\n            return Nil()\n        }\n        return List(2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l, 37l, 41l, 43l, 47l, 53l, 59l, 61l, 67l, 71l, 73l, 79l, 83l, 89l, 97l, 101l, 103l, 107l, 109l, 113l, 127l, 131l, 137l, 139l, 149l, 151l, 157l, 163l, 167l, 173l, 179l, 181l, 191l, 193l, 197l, 199l, 211l, 223l, 227l, 229l, 233l, 239l, 241l, 251l, 257l, 263l, 269l, 271l, 277l, 281l, 283l, 293l, 307l, 311l, 313l, 317l, 331l, 337l, 347l, 349l, 353l, 359l, 367l, 373l, 379l, 383l, 389l, 397l, 401l, 409l, 419l, 421l, 431l, 433l, 439l, 443l, 449l, 457l, 461l, 463l, 467l, 479l, 487l, 491l, 499l, 503l, 509l, 521l, 523l, 541l, 547l, 557l, 563l, 569l, 571l, 577l, 587l, 589l, 593l, 599l, 601l, 607l, 613l, 617l, 619l, 631l, 641l, 643l, 647l, 653l, 659l, 661l, 673l, 677l, 683l, 691l, 701l, 709l, 719l, 727l, 733l, 739l, 743l, 751l, 757l, 761l, 769l, 773l\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293149,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpp1cmcfsk.scala:27:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpp1cmcfsk.scala:24:22 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mreturn\u001b[0m Nil()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mLinearSeqOps\u001b[0m: (n: Int): Nothing\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns a list of the\n    // first n primes.\n    // for example:\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> primesUpTo((2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l, 31l, 37l))\n    // (List[Long](2l.\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293139,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpj35ahfrg.scala:56:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpj35ahfrg.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj35ahfrg.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj35ahfrg.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj35ahfrg.scala:44:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m    assert(countUpTo((\u001b[31m5l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpj35ahfrg.scala:45:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m    assert(countUpTo((\u001b[31m6l\u001b[0m)).equals((List[\u001b[35mLong\u001b[0m](\u001b[31m2l\u001b[0m.toLong, \u001b[31m3l\u001b[0m.toLong, \u001b[31m5l\u001b[0m.toLong))));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Not found: countUpTo\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7l52xtgh.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = i\n            if (prime.isPrime()) {\n                result = result.append(prime)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8zau1cqh.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8zau1cqh.scala:26:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (prime.isPrime()) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value isPrime is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8zau1cqh.scala:27:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result = result.append(prime)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Returns true if the given number is prime.\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        for (i <- 3 until Math.sqrt(n)) {\n            if (n % i == 0) {\n                return false\n            }\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293140,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpy69r8w9u.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy69r8w9u.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpy69r8w9u.scala:43:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    Double\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        if (n == 0) {\n            return result\n        }\n        val i = 1l\n        while (i < n) {\n            result = result.append(i)\n            i = i + 1l\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293203,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphteltw5_.scala:29:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmphteltw5_.scala:30:14 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            i = i + \u001b[31m1l\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        var result = List[Long](0)\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpr672u7fu.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpr672u7fu.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean List[Long].appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpr672u7fu.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n == 2) {\n            return true\n        } else if (n < 2) {\n            return false\n        } else if (n % 2 == 0) {\n            return false\n        } else {\n            for (i <- 3 until Math.sqrt(n)) {\n                if (n % i == 0) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7l52xtgh.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7l52xtgh.scala:37:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m            \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Double\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and greater than n.\n    // for example:\n    // >>> countUpToGreaterThan((5l))\n    // (List[Long](6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))\n    // >>> countUpToGreaterThan((11l))\n    // (List[Long](13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    // >>> countUpToGreaterThan((0l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((20l))\n    // (List[Long](6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    // >>> countUpToGreaterThan((1l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((18l))\n    // (List[Long](13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    def countUpToGreaterThan(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than or equal to n.\n    // for example:\n    // >>> countUpToLessThan((5l))\n    \n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293204,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpv32hx0nc.scala:73:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv32hx0nc.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpv32hx0nc.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv32hx0nc.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv32hx0nc.scala:46:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpv32hx0nc.scala:47:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv32hx0nc.scala:48:32 ----------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = isPrime(i)\n            if (prime) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293177,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxhw_fbap.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxhw_fbap.scala:25:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mprime\u001b[0m = isPrime(i)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxhw_fbap.scala:27:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns the sum of the\n    // integers in the list.\n    // for example:\n    // >>> sumUp([1, 2, 3])\n    // 6\n    // >>> sumUp([1, 2, 3, 4])\n    // 10\n    // >>> sumUp([])\n    // 0\n    // >>> sumUp([1, 2, 3, 4, 5])\n    // 15\n    // >>> sumUp([1, 2, 3, 4, 5, 6])\n    // 21\n    def sumUp(nums : List[Long]) : Long = {\n        val result = 0l\n        for (i <- 0 until nums.length) {\n            result = result + nums[i]\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns the product of the\n    // integers in the list.\n    // for example:\n    // >>> productUp([1, 2, 3])\n    // 6\n    // >>> productUp([1, 2, 3, 4])\n    // 24\n    // >>> productUp([])\n    // 1\n    // >>> productUp([1, 2, 3, 4, 5])\n    // 120\n    // >>> productUp([1, 2, 3, 4, 5, 6])\n    // 720\n    def productUp(nums : List[Long]) : Long = {\n        val result = 1l\n        for (i <- 0 until nums.length) {\n            result = result * nums[i]\n        }\n        return result\n    }\n\n    // Implement a function that takes a list of non-negative integers and returns the product of the\n    // integers in the list.\n    // for example:\n    // >>> productUp([1, 2, 3])\n    // 6\n    // >>> productUp([1, 2, 3, 4])\n    // 24\n    // >>> productUp([])\n    // 1\n    // >>>\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293204,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp11eacpih.scala:95:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m95 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp11eacpih.scala:21:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp11eacpih.scala:22:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp11eacpih.scala:23:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp11eacpih.scala:45:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m            result = result + nums[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp11eacpih.scala:66:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m66 |\u001b[0m            result = result * nums[\u001b[35mi\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: type i\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp11eacpih.scala:83:11 -----------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    // Implement a function that takes a non-negative integer and returns a list of the first n\n    // integers that are prime numbers and greater than n.\n    // for example:\n    // >>> countUpToGreaterThan((5l))\n    // (List[Long](6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))\n    // >>> countUpToGreaterThan((11l))\n    // (List[Long](13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    // >>> countUpToGreaterThan((0l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((20l))\n    // (List[Long](6l.toLong, 7l.toLong, 8l.toLong, 9l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    // >>> countUpToGreaterThan((1l))\n    // (List[Long]())\n    // >>> countUpToGreaterThan((18l))\n    // (List[Long](13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong))\n    def countUpToGreaterThan(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    //\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293204,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpi5bx6guo.scala:75:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m75 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpi5bx6guo.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpi5bx6guo.scala:25:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi5bx6guo.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpi5bx6guo.scala:52:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpi5bx6guo.scala:53:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m            \u001b[33mif\u001b[0m (isPrime(i)) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: isPrime\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi5bx6guo.scala:54:32 ----------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            if (isPrime(i)) {\n                result = result.append(i)\n            }\n        }\n        return result\n    }\n\n    def isPrime(n : Long) : Boolean = {\n        if (n < 2) {\n            return false\n        }\n        if (n == 2) {\n            return true\n        }\n        if (n % 2 == 0) {\n            return false\n        }\n        for (i <- 3 until Math.sqrt(n)) {\n            if (n % i == 0) {\n                return false\n            }\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293141,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpobgr00fj.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpobgr00fj.scala:26:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                result = result.append(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpobgr00fj.scala:42:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m3\u001b[0m until Math.sqrt(n)) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    Double\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Implement a function that takes an non-negative integer and returns a list of the first n\n    // integers that are prime numbers and less than n.\n    // for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) : List[Long] = {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"n must be non-negative\")\n        }\n        val result = List[Long]()\n        for (i <- 0 until n) {\n            val prime = i\n            if (prime.isPrime()) {\n                result = result.append(prime)\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong, 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong, 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong, 97l.toLong))));\n    }\n\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8zau1cqh.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until n) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (n : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8zau1cqh.scala:26:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (prime.isPrime()) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value isPrime is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8zau1cqh.scala:27:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                result = result.append(prime)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of List[Long] - did you mean result.appended?\n3 errors found\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}