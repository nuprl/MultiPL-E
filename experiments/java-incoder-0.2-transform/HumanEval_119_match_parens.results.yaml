language: java
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isMatch = false;\n                    break;\n  \
    \              }\n            }\n        }\n        if (isMatch) {\n         \
    \   return \"Yes\";\n        } else {\n            return \"No\";\n        }\n\
    \    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmp0zxi3gni.java:29)\n\
    \tat Problem.main(tmp0zxi3gni.java:43)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isGood = false;\n                break;\n            }\n        }\n     \
    \   return isGood ? \"Yes\" : \"No\";\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp76_7aq9n.java:45)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            }\n        }\n        if (isGood) {\n           \
    \ return \"Yes\";\n        } else {\n            return \"No\";\n        }\n \
    \   }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmpj452l_5s.java:29)\n\
    \tat Problem.main(tmpj452l_5s.java:43)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = false;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isMatch = true;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isMatch = false;\n                break;\n            }\n        }\n    \
    \    if (isMatch) {\n            return \"Yes\";\n        } else {\n         \
    \   return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpyi24ls3o.java:49)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isGood = false;\n                break;\n            }\n        }\n     \
    \   if (isGood) {\n            return \"Yes\";\n        } else {\n           \
    \ return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmplw4ldebo.java:49)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"\
    (\")) {\n                stack.push(s);\n            } else if (s.equals(\")\"\
    )) {\n                while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n\
    \                    sb.append(stack.pop());\n                }\n            \
    \    stack.push(s);\n            } else if (s.equals(\")\")) {\n             \
    \   while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n               \
    \     sb.append(stack.pop());\n                }\n                stack.push(s);\n\
    \            } else if (s.equals(\"(\")) {\n                while (!stack.isEmpty()\
    \ && stack.peek().equals(\"(\")) {\n                    sb.append(stack.pop());\n\
    \                }\n                stack.push(s);\n            }\n        }\n\
    \        while (!stack.isEmpty()) {\n            sb.append(stack.pop());\n   \
    \     }\n        return sb.toString();\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmplc01trsk.java:51)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = false;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (top.equals(\"(\"\
    )) {\n                    isMatch = true;\n                } else {\n        \
    \            isMatch = false;\n                    break;\n                }\n\
    \            } else {\n                isMatch = false;\n                break;\n\
    \            }\n        }\n        if (isMatch) {\n            return \"Yes\"\
    ;\n        } else {\n            return \"No\";\n        }\n    }\n    public\
    \ static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpv8u8eun2.java:48)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            }\n        }\n        if (isGood) {\n           \
    \ return \"Yes\";\n        } else {\n            return \"No\";\n        }\n \
    \   }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmpj452l_5s.java:29)\n\
    \tat Problem.main(tmpj452l_5s.java:43)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            }\n        }\n        return isGood ? \"Yes\" : \"\
    No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmp4romd_3g.java:29)\n\
    \tat Problem.main(tmp4romd_3g.java:39)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        boolean isGood = true;\n        for (String\
    \ s : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                while (!stack.isEmpty()\
    \ && stack.peek().equals(\"(\")) {\n                    sb.append(stack.pop());\n\
    \                }\n                stack.pop();\n            } else {\n     \
    \           isGood = false;\n            }\n        }\n        if (stack.isEmpty())\
    \ {\n            return \"No\";\n        }\n        return \"Yes\";\n    }\n \
    \   public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmpel1_m9r8.java:33)\n\
    \tat Problem.main(tmpel1_m9r8.java:44)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = false;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (top.equals(\"(\"\
    )) {\n                    isMatch = true;\n                } else {\n        \
    \            isMatch = false;\n                    break;\n                }\n\
    \            } else {\n                isMatch = false;\n                break;\n\
    \            }\n        }\n        if (isMatch) {\n            return \"Yes\"\
    ;\n        } else {\n            return \"No\";\n        }\n    }\n    public\
    \ static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpv8u8eun2.java:48)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        boolean isGood = true;\n        for (String\
    \ s : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                while (!stack.isEmpty()\
    \ && stack.peek().equals(\"(\")) {\n                    sb.append(stack.pop());\n\
    \                }\n                stack.pop();\n            } else if (s.equals(\"\
    (\")) {\n                stack.push(s);\n            } else if (s.equals(\")\"\
    )) {\n                while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n\
    \                    sb.append(stack.pop());\n                }\n            \
    \    stack.pop();\n            }\n        }\n        if (!stack.isEmpty()) {\n\
    \            isGood = false;\n        }\n        return sb.toString();\n    }\n\
    \    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmpq7kc_ri7.java:33)\n\
    \tat Problem.main(tmpq7kc_ri7.java:49)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            }\n        }\n        if (isGood) {\n           \
    \ return \"Yes\";\n        } else {\n            return \"No\";\n        }\n \
    \   }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmpj452l_5s.java:29)\n\
    \tat Problem.main(tmpj452l_5s.java:43)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for(String s :\
    \ lst) {\n            if(s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if(s.equals(\")\")) {\n                if(!stack.isEmpty())\
    \ {\n                    String top = stack.pop();\n                    if(top.equals(\"\
    (\")) {\n                        stack.push(top);\n                    } else\
    \ {\n                        return null;\n                    }\n           \
    \     } else {\n                    return null;\n                }\n        \
    \    } else {\n                return null;\n            }\n        }\n      \
    \  if(!stack.isEmpty()) {\n            return null;\n        }\n        return\
    \ \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.NullPointerException\n\tat Problem.main(tmp8eolsopi.java:48)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = false;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (top.equals(\"(\"\
    )) {\n                    isMatch = true;\n                } else {\n        \
    \            isMatch = false;\n                    break;\n                }\n\
    \            } else {\n                isMatch = false;\n                break;\n\
    \            }\n        }\n        if (isMatch) {\n            return \"Yes\"\
    ;\n        } else {\n            return \"No\";\n        }\n    }\n    public\
    \ static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpv8u8eun2.java:48)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        List<String> list = new ArrayList<String>();\n        for (String\
    \ s : lst) {\n            list.add(s);\n        }\n        boolean flag = false;\n\
    \        Stack<String> stack = new Stack<String>();\n        stack.push(list.get(0));\n\
    \        for (int i = 1; i < list.size(); i++) {\n            if (list.get(i).equals(\"\
    (\")) {\n                stack.push(list.get(i));\n            } else if (list.get(i).equals(\"\
    )\")) {\n                String s = stack.pop();\n                if (s.equals(\"\
    (\")) {\n                    flag = true;\n                } else {\n        \
    \            flag = false;\n                }\n            } else {\n        \
    \        flag = false;\n            }\n            if (flag) {\n             \
    \   stack.push(list.get(i));\n            }\n        }\n        return stack.pop();\n\
    \    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmp9t5_9g5r.java:47)\n\
    \tat Problem.main(tmp9t5_9g5r.java:50)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                String top = stack.pop();\n\
    \                if (!top.equals(\"(\")) {\n                    return \"No\"\
    ;\n                }\n            }\n        }\n        return \"Yes\";\n    }\n\
    \    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmp4p8as5u7.java:28)\n\
    \tat Problem.main(tmp4p8as5u7.java:37)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        boolean isGood = true;\n        for (String\
    \ s : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                while (!stack.isEmpty()\
    \ && stack.peek().equals(\"(\")) {\n                    sb.append(stack.pop());\n\
    \                }\n                stack.pop();\n            } else {\n     \
    \           isGood = false;\n            }\n        }\n        if (stack.isEmpty())\
    \ {\n            return \"No\";\n        }\n        return \"Yes\";\n    }\n \
    \   public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmpel1_m9r8.java:33)\n\
    \tat Problem.main(tmpel1_m9r8.java:44)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            }\n        }\n        if (isGood) {\n           \
    \ return \"Yes\";\n        } else {\n            return \"No\";\n        }\n \
    \   }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmpj452l_5s.java:29)\n\
    \tat Problem.main(tmpj452l_5s.java:43)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isGood = false;\n                break;\n            }\n        }\n     \
    \   if (isGood) {\n            return \"Yes\";\n        } else {\n           \
    \ return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmplw4ldebo.java:49)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (!stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isGood = false;\n                break;\n            }\n        }\n     \
    \   if (isGood) {\n            return \"Yes\";\n        } else {\n           \
    \ return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpwow7r1s0.java:49)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (top.equals(\"(\"\
    )) {\n                    isGood = false;\n                    break;\n      \
    \          }\n            }\n        }\n        return isGood ? \"Yes\" : \"No\"\
    ;\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpgllefdj1.java:29)\n\
    \tat Problem.main(tmpgllefdj1.java:39)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                String top = stack.pop();\n\
    \                if (top.equals(\"(\")) {\n                    stack.push(top);\n\
    \                } else {\n                    return \"No\";\n              \
    \  }\n            } else {\n                return \"No\";\n            }\n  \
    \      }\n        return \"Yes\";\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp_vmsedtn.java:41)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isGood = false;\n                break;\n            }\n        }\n     \
    \   if (isGood) {\n            return \"Yes\";\n        } else {\n           \
    \ return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmplw4ldebo.java:49)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"\
    (\")) {\n                stack.push(s);\n            } else if (s.equals(\")\"\
    )) {\n                if (stack.size() == 0) {\n                    return \"\
    No\";\n                }\n                String top = stack.pop();\n        \
    \        sb.append(top);\n                sb.append(s);\n            } else {\n\
    \                sb.append(s);\n            }\n        }\n        if (stack.size()\
    \ != 0) {\n            return \"No\";\n        }\n        return sb.toString();\n\
    \    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp6bl_uiyw.java:45)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = false;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (!stack.isEmpty())\
    \ {\n                    isMatch = false;\n                    break;\n      \
    \          }\n                stack.push(s);\n            } else {\n         \
    \       isMatch = true;\n                break;\n            }\n        }\n  \
    \      if (isMatch) {\n            return \"Yes\";\n        } else {\n       \
    \     return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpxb6d3x07.java:51)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (!stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            }\n        }\n        if\
    \ (isGood) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n    }\n    public static void main(String[] args) {\n  \
    \  assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\"\
    )\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpnmlk2bpd.java:36)\n\
    \tat Problem.main(tmpnmlk2bpd.java:46)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = false;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isMatch = true;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isMatch = false;\n                break;\n            }\n        }\n    \
    \    return isMatch ? \"Yes\" : \"No\";\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpukd3uev0.java:45)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"\
    (\")) {\n                stack.push(s);\n            } else if (s.equals(\")\"\
    )) {\n                while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n\
    \                    sb.append(stack.pop());\n                }\n            \
    \    stack.pop();\n            } else {\n                while (!stack.isEmpty()\
    \ && stack.peek().equals(\")\")) {\n                    sb.append(stack.pop());\n\
    \                }\n                sb.append(s);\n            }\n        }\n\
    \        while (!stack.isEmpty()) {\n            sb.append(stack.pop());\n   \
    \     }\n        return sb.toString();\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpo5swtw6i.java:32)\n\
    \tat Problem.main(tmpo5swtw6i.java:46)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isGood = false;\n                break;\n            }\n        }\n     \
    \   if (isGood) {\n            return \"Yes\";\n        } else {\n           \
    \ return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmplw4ldebo.java:49)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               if (stack.isEmpty()) {\n                    isGood = false;\n\
    \                    break;\n                }\n                String top = stack.pop();\n\
    \                if (!top.equals(\"(\")) {\n                    isGood = false;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     if (isGood) {\n            return \"Yes\";\n        } else {\n         \
    \   return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpcd5km3e8.java:47)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            }\n        }\n        if (isGood) {\n           \
    \ return \"Yes\";\n        } else {\n            return \"No\";\n        }\n \
    \   }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmpj452l_5s.java:29)\n\
    \tat Problem.main(tmpj452l_5s.java:43)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for(String s :\
    \ lst) {\n            if(s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if(s.equals(\")\")) {\n                if(!stack.isEmpty())\
    \ {\n                    String top = stack.pop();\n                    if(top.equals(\"\
    (\")) {\n                        stack.push(top);\n                    } else\
    \ {\n                        return \"No\";\n                    }\n         \
    \       }\n            }\n        }\n        if(stack.isEmpty()) {\n         \
    \   return \"Yes\";\n        }\n        return \"No\";\n    }\n    public static\
    \ void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpzsxk4w7q.java:45)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (!stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isGood = false;\n                break;\n            }\n        }\n     \
    \   if (isGood) {\n            return \"Yes\";\n        } else {\n           \
    \ return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpwow7r1s0.java:49)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"\
    (\")) {\n                stack.push(s);\n            } else if (s.equals(\")\"\
    )) {\n                while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n\
    \                    sb.append(stack.pop());\n                }\n            \
    \    stack.push(s);\n            } else {\n                while (!stack.isEmpty()\
    \ && stack.peek().equals(\")\")) {\n                    sb.append(stack.pop());\n\
    \                }\n                sb.append(s);\n            }\n        }\n\
    \        while (!stack.isEmpty()) {\n            sb.append(stack.pop());\n   \
    \     }\n        return sb.toString();\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp534xkvai.java:46)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for(String s :\
    \ lst) {\n            if(s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if(s.equals(\")\")) {\n                if(!stack.isEmpty())\
    \ {\n                    if(stack.peek().equals(\"(\")) {\n                  \
    \      stack.pop();\n                    } else {\n                        stack.pop();\n\
    \                        stack.push(s);\n                    }\n             \
    \   } else {\n                    return \"No\";\n                }\n        \
    \    } else {\n                if(!stack.isEmpty()) {\n                    if(stack.peek().equals(\"\
    (\")) {\n                        stack.pop();\n                    } else {\n\
    \                        stack.pop();\n                        stack.push(s);\n\
    \                    }\n                } else {\n                    return \"\
    No\";\n                }\n            }\n        }\n        if(!stack.isEmpty())\
    \ {\n            return \"No\";\n        } else {\n            return \"Yes\"\
    ;\n        }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp3w2y0emn.java:58)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            } else {\n                isGood = false;\n     \
    \           break;\n            }\n        }\n        if (isGood) {\n        \
    \    return \"Yes\";\n        } else {\n            return \"No\";\n        }\n\
    \    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpv6_z_66z.java:46)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"\
    (\")) {\n                stack.push(s);\n            } else if (s.equals(\")\"\
    )) {\n                String top = stack.pop();\n                if (top.equals(\"\
    (\")) {\n                    sb.append(top);\n                } else {\n     \
    \               return \"No\";\n                }\n            } else {\n    \
    \            sb.append(s);\n            }\n        }\n        return sb.toString();\n\
    \    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmp6mnlutc8.java:29)\n\
    \tat Problem.main(tmp6mnlutc8.java:42)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            }\n        }\n        if (isGood) {\n           \
    \ return \"Yes\";\n        } else {\n            return \"No\";\n        }\n \
    \   }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmpj452l_5s.java:29)\n\
    \tat Problem.main(tmpj452l_5s.java:43)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        stack.push(lst.get(0));\n\
    \        for(int i = 1; i < lst.size(); i++) {\n            String s = lst.get(i);\n\
    \            while(!stack.empty() && stack.peek().equals(s)) {\n             \
    \   stack.pop();\n            }\n            stack.push(s);\n        }\n     \
    \   if(stack.size() != lst.size()) {\n            return \"No\";\n        }\n\
    \        return \"Yes\";\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpz7co2n43.java:40)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = false;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (top.equals(\"(\"\
    )) {\n                    isMatch = true;\n                    break;\n      \
    \          }\n            }\n        }\n        return isMatch ? \"Yes\" : \"\
    No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmp5xh8tc7q.java:29)\n\
    \tat Problem.main(tmp5xh8tc7q.java:39)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isGood = false;\n                break;\n            }\n        }\n     \
    \   if (isGood) {\n            return \"Yes\";\n        } else {\n           \
    \ return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmplw4ldebo.java:49)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               if (stack.isEmpty()) {\n                    isGood = false;\n\
    \                    break;\n                }\n                String top = stack.pop();\n\
    \                if (!top.equals(\"(\")) {\n                    isGood = false;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     if (isGood) {\n            return \"Yes\";\n        } else {\n         \
    \   return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpcd5km3e8.java:47)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        boolean isGood = true;\n        for (String\
    \ s : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                while (!stack.isEmpty()\
    \ && stack.peek().equals(\"(\")) {\n                    sb.append(stack.pop());\n\
    \                }\n                stack.pop();\n            } else if (s.equals(\"\
    )\")) {\n                while (!stack.isEmpty() && stack.peek().equals(\"(\"\
    )) {\n                    sb.append(stack.pop());\n                }\n       \
    \         stack.pop();\n                sb.append(s);\n            } else {\n\
    \                while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n  \
    \                  sb.append(stack.pop());\n                }\n              \
    \  stack.pop();\n                sb.append(s);\n                while (!stack.isEmpty()\
    \ && stack.peek().equals(\")\")) {\n                    sb.append(stack.pop());\n\
    \                }\n                stack.pop();\n            }\n        }\n \
    \       if (stack.isEmpty()) {\n            isGood = false;\n        }\n     \
    \   return sb.toString();\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpulrstw5q.java:44)\n\
    \tat Problem.main(tmpulrstw5q.java:58)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (!stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isGood = false;\n                break;\n            }\n        }\n     \
    \   if (isGood) {\n            return \"Yes\";\n        } else {\n           \
    \ return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpwow7r1s0.java:49)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            }\n        }\n        return isGood ? \"Yes\" : \"\
    No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmp4romd_3g.java:29)\n\
    \tat Problem.main(tmp4romd_3g.java:39)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                String top = stack.pop();\n\
    \                if (!top.equals(\"(\")) {\n                    return \"No\"\
    ;\n                }\n            }\n        }\n        return \"Yes\";\n    }\n\
    \    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmp4p8as5u7.java:28)\n\
    \tat Problem.main(tmp4p8as5u7.java:37)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                String top = stack.pop();\n\
    \                if (top.equals(\"(\")) {\n                    stack.push(top);\n\
    \                } else {\n                    return \"No\";\n              \
    \  }\n            } else {\n                return \"No\";\n            }\n  \
    \      }\n        return \"Yes\";\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp_vmsedtn.java:41)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        List<String> list = new ArrayList<String>();\n        for(String\
    \ s : lst) {\n            list.add(s);\n        }\n        boolean flag = true;\n\
    \        for(int i = 0; i < list.size(); i++) {\n            String s = list.get(i);\n\
    \            for(int j = i + 1; j < list.size(); j++) {\n                String\
    \ t = list.get(j);\n                if((s.charAt(0) == '(' && t.charAt(0) == ')')\
    \ || (s.charAt(0) == ')' && t.charAt(0) == '(')) {\n                    list.remove(j);\n\
    \                    list.remove(i);\n                    flag = false;\n    \
    \                break;\n                }\n            }\n        }\n       \
    \ if(flag) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n    }\n    public static void main(String[] args) {\n  \
    \  assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\"\
    )\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp2wekc4k3.java:47)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isMatch = false;\n                    break;\n      \
    \          }\n                stack.pop();\n            } else {\n           \
    \     isMatch = false;\n                break;\n            }\n        }\n   \
    \     if (isMatch) {\n            return \"Yes\";\n        } else {\n        \
    \    return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpppj42xdo.java:49)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isMatch = false;\n                    break;\n  \
    \              }\n            }\n        }\n        if (isMatch) {\n         \
    \   return \"Yes\";\n        } else {\n            return \"No\";\n        }\n\
    \    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmp0zxi3gni.java:29)\n\
    \tat Problem.main(tmp0zxi3gni.java:43)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = false;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               if (stack.isEmpty()) {\n                    isMatch = false;\n\
    \                    break;\n                } else {\n                    String\
    \ top = stack.pop();\n                    if (top.equals(\"(\")) {\n         \
    \               stack.push(top);\n                    } else {\n             \
    \           isMatch = false;\n                        break;\n               \
    \     }\n                }\n            } else {\n                if (stack.isEmpty())\
    \ {\n                    isMatch = false;\n                    break;\n      \
    \          } else {\n                    String top = stack.pop();\n         \
    \           if (top.equals(\"(\")) {\n                        stack.push(top);\n\
    \                    } else {\n                        isMatch = false;\n    \
    \                    break;\n                    }\n                }\n      \
    \      }\n        }\n        if (isMatch) {\n            return \"Yes\";\n   \
    \     } else {\n            return \"No\";\n        }\n    }\n    public static\
    \ void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpac4dqeqz.java:63)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                while (!stack.isEmpty()\
    \ && stack.peek().equals(\"(\")) {\n                    stack.pop();\n       \
    \         }\n                if (!stack.isEmpty()) {\n                    return\
    \ \"No\";\n                }\n                stack.push(s);\n            } else\
    \ {\n                return \"No\";\n            }\n        }\n        return\
    \ \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpxm79oryn.java:42)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                String top = stack.pop();\n\
    \                if (!top.equals(\"(\")) {\n                    return \"No\"\
    ;\n                }\n            }\n        }\n        return \"Yes\";\n    }\n\
    \    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmp4p8as5u7.java:28)\n\
    \tat Problem.main(tmp4p8as5u7.java:37)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                String top = stack.pop();\n\
    \                if (!top.equals(\"(\")) {\n                    return \"No\"\
    ;\n                }\n            }\n        }\n        return \"Yes\";\n    }\n\
    \    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmp4p8as5u7.java:28)\n\
    \tat Problem.main(tmp4p8as5u7.java:37)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"\
    (\")) {\n                stack.push(s);\n            } else if (s.equals(\")\"\
    )) {\n                while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n\
    \                    sb.append(stack.pop());\n                }\n            \
    \    stack.pop();\n            } else {\n                sb.append(s);\n     \
    \       }\n        }\n        return sb.toString();\n    }\n    public static\
    \ void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpsh3a4vr7.java:32)\n\
    \tat Problem.main(tmpsh3a4vr7.java:40)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            }\n        }\n        if (isGood) {\n           \
    \ return \"Yes\";\n        } else {\n            return \"No\";\n        }\n \
    \   }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmpj452l_5s.java:29)\n\
    \tat Problem.main(tmpj452l_5s.java:43)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (!stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isGood = false;\n                break;\n            }\n        }\n     \
    \   if (isGood) {\n            return \"Yes\";\n        } else {\n           \
    \ return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpwow7r1s0.java:49)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                String top = stack.pop();\n\
    \                if (!top.equals(\"(\")) {\n                    return \"No\"\
    ;\n                }\n            }\n        }\n        return \"Yes\";\n    }\n\
    \    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmp4p8as5u7.java:28)\n\
    \tat Problem.main(tmp4p8as5u7.java:37)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = false;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isMatch = true;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isMatch = false;\n                break;\n            }\n        }\n    \
    \    if (isMatch) {\n            return \"Yes\";\n        } else {\n         \
    \   return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpyi24ls3o.java:49)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               if (stack.isEmpty()) {\n                    isGood = false;\n\
    \                    break;\n                }\n                String top = stack.pop();\n\
    \                if (!top.equals(\"(\")) {\n                    isGood = false;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     if (isGood) {\n            return \"Yes\";\n        } else {\n         \
    \   return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpcd5km3e8.java:47)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"\
    (\")) {\n                stack.push(s);\n            } else if (s.equals(\")\"\
    )) {\n                while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n\
    \                    sb.append(stack.pop());\n                }\n            \
    \    stack.push(s);\n            } else if (stack.isEmpty()) {\n             \
    \   sb.append(s);\n            }\n        }\n        while (!stack.isEmpty())\
    \ {\n            sb.append(stack.pop());\n        }\n        return sb.toString();\n\
    \    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmplgahwmww.java:43)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        stack.push(lst.get(0));\n\
    \        for(int i = 1; i < lst.size(); i++) {\n            String str = lst.get(i);\n\
    \            if(!stack.isEmpty() && stack.peek().equals(\"(\")) {\n          \
    \      stack.pop();\n            }\n            if(!stack.isEmpty() && stack.peek().equals(\"\
    )\")) {\n                stack.pop();\n            }\n            if(!stack.isEmpty()\
    \ && stack.peek().equals(str)) {\n                stack.pop();\n            }\n\
    \            if(!stack.isEmpty() && stack.peek().equals(\"(\")) {\n          \
    \      stack.pop();\n            }\n            if(!stack.isEmpty() && stack.peek().equals(\"\
    )\")) {\n                stack.pop();\n            }\n            stack.push(str);\n\
    \        }\n        if(stack.isEmpty()) {\n            return \"No\";\n      \
    \  }\n        return \"Yes\";\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp2qz6g9ik.java:51)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        boolean isGood = true;\n        Stack<String> stack = new Stack<>();\n\
    \        for(int i = 0; i < lst.size(); i++) {\n            String str = lst.get(i);\n\
    \            if(str.equals(\"(\")) {\n                stack.push(str);\n     \
    \       } else if(str.equals(\")\")) {\n                if(!stack.isEmpty() &&\
    \ stack.peek().equals(\"(\")) {\n                    stack.pop();\n          \
    \      } else {\n                    isGood = false;\n                    break;\n\
    \                }\n            }\n        }\n        if(!stack.isEmpty()) {\n\
    \            isGood = false;\n        }\n        if(isGood) {\n            return\
    \ \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n \
    \   public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp4i7pg4kg.java:48)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        List<String> result = new ArrayList<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            isGood = isGood && matchParens(s,\
    \ result);\n        }\n        if (isGood) {\n            return \"Yes\";\n  \
    \      } else {\n            return \"No\";\n        }\n    }\n    public static\
    \ void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdiyldkq3.java:26: error: method matchParens in class Problem cannot\
    \ be applied to given types;\n            isGood = isGood && matchParens(s, result);\n\
    \                               ^\n  required: ArrayList<String>\n  found:   \
    \ String,List<String>\n  reason: actual and formal argument lists differ in length\n\
    1 error\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                String top = stack.pop();\n\
    \                if (!top.equals(\"(\")) {\n                    return \"No\"\
    ;\n                }\n            }\n        }\n        return \"Yes\";\n    }\n\
    \    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmp4p8as5u7.java:28)\n\
    \tat Problem.main(tmp4p8as5u7.java:37)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isGood = false;\n                break;\n            }\n        }\n     \
    \   if (isGood) {\n            return \"Yes\";\n        } else {\n           \
    \ return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmplw4ldebo.java:49)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            }\n        }\n        if (isGood) {\n           \
    \ return \"Yes\";\n        } else {\n            return \"No\";\n        }\n \
    \   }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmpj452l_5s.java:29)\n\
    \tat Problem.main(tmpj452l_5s.java:43)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        boolean isGood = true;\n        for (String\
    \ s : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                String top = stack.pop();\n\
    \                if (top.equals(\"(\")) {\n                    isGood = false;\n\
    \                    break;\n                }\n            }\n            sb.append(s);\n\
    \        }\n        if (isGood) {\n            return \"Yes\";\n        } else\
    \ {\n            return \"No\";\n        }\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpvuq7jj53.java:30)\n\
    \tat Problem.main(tmpvuq7jj53.java:45)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = false;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isMatch = false;\n                    break;\n  \
    \              }\n            } else {\n                isMatch = false;\n   \
    \             break;\n            }\n        }\n        if (isMatch) {\n     \
    \       return \"Yes\";\n        } else {\n            return \"No\";\n      \
    \  }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmplss_a6zj.java:46)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isGood = false;\n                break;\n            }\n        }\n     \
    \   if (isGood) {\n            return \"Yes\";\n        } else {\n           \
    \ return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmplw4ldebo.java:49)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                while (!stack.isEmpty()\
    \ && stack.peek().equals(\"(\")) {\n                    stack.pop();\n       \
    \         }\n                if (!stack.isEmpty()) {\n                    return\
    \ \"No\";\n                }\n                stack.push(s);\n            }\n\
    \        }\n        return \"Yes\";\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp89w5lm__.java:42)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (!stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            }\n        }\n        if\
    \ (isGood) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n    }\n    public static void main(String[] args) {\n  \
    \  assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\"\
    )\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpnmlk2bpd.java:36)\n\
    \tat Problem.main(tmpnmlk2bpd.java:46)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"\
    (\")) {\n                stack.push(s);\n            } else if (s.equals(\")\"\
    )) {\n                String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    sb.append(top);\n                }\n            }\n\
    \        }\n        return sb.toString();\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpjb1brucr.java:29)\n\
    \tat Problem.main(tmpjb1brucr.java:38)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        stack.push(lst.get(0));\n\
    \        for(int i = 1; i < lst.size(); i++) {\n            String str = lst.get(i);\n\
    \            if(!stack.isEmpty() && stack.peek().equals(\"(\")) {\n          \
    \      stack.push(str);\n            } else if(stack.peek().equals(\"(\")) {\n\
    \                stack.push(str);\n            } else if(stack.peek().equals(\"\
    )\")) {\n                String popped = stack.pop();\n                if(popped.equals(\"\
    (\")) {\n                    stack.push(str);\n                } else if(popped.equals(\"\
    )\")) {\n                    stack.push(str);\n                } else {\n    \
    \                return \"No\";\n                }\n            } else {\n   \
    \             return \"No\";\n            }\n        }\n        if(stack.isEmpty())\
    \ {\n            return \"Yes\";\n        } else {\n            return \"No\"\
    ;\n        }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpp9ecfdjb.java:51)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            }\n        }\n        if (isGood) {\n           \
    \ return \"Yes\";\n        } else {\n            return \"No\";\n        }\n \
    \   }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmpj452l_5s.java:29)\n\
    \tat Problem.main(tmpj452l_5s.java:43)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               if (stack.isEmpty()) {\n                    isGood = false;\n\
    \                    break;\n                } else {\n                    String\
    \ top = stack.pop();\n                    if (top.equals(\"(\")) {\n         \
    \               stack.push(top);\n                    } else {\n             \
    \           isGood = false;\n                        break;\n                \
    \    }\n                }\n            } else {\n                isGood = false;\n\
    \                break;\n            }\n        }\n        if (isGood) {\n   \
    \         return \"Yes\";\n        } else {\n            return \"No\";\n    \
    \    }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp0a3pjeww.java:53)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                String top = stack.pop();\n\
    \                if (!top.equals(\"(\")) {\n                    return \"No\"\
    ;\n                }\n            }\n        }\n        return \"Yes\";\n    }\n\
    \    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmp4p8as5u7.java:28)\n\
    \tat Problem.main(tmp4p8as5u7.java:37)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = false;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (top.equals(\"(\"\
    )) {\n                    stack.push(top);\n                } else {\n       \
    \             isMatch = false;\n                    break;\n                }\n\
    \            } else {\n                isMatch = false;\n                break;\n\
    \            }\n        }\n        if (isMatch) {\n            return \"Yes\"\
    ;\n        } else {\n            return \"No\";\n        }\n    }\n    public\
    \ static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpwdcg0ww2.java:48)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isGood = false;\n                break;\n            }\n        }\n     \
    \   if (isGood) {\n            return \"Yes\";\n        } else {\n           \
    \ return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmplw4ldebo.java:49)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            }\n        }\n        if\
    \ (isGood) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n    }\n    public static void main(String[] args) {\n  \
    \  assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\"\
    )\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpcbxu2_52.java:46)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"\
    (\")) {\n                stack.push(s);\n            } else if (s.equals(\")\"\
    )) {\n                while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n\
    \                    sb.append(stack.pop());\n                }\n            \
    \    stack.pop();\n            } else {\n                sb.append(s);\n     \
    \       }\n        }\n        return sb.toString();\n    }\n    public static\
    \ void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpsh3a4vr7.java:32)\n\
    \tat Problem.main(tmpsh3a4vr7.java:40)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"\
    (\")) {\n                stack.push(s);\n            } else if (s.equals(\")\"\
    )) {\n                while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n\
    \                    sb.append(stack.pop());\n                }\n            \
    \    stack.pop();\n            }\n        }\n        if (stack.isEmpty()) {\n\
    \            return \"No\";\n        }\n        return \"Yes\";\n    }\n    public\
    \ static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpoqdzajy9.java:32)\n\
    \tat Problem.main(tmpoqdzajy9.java:41)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            }\n        }\n        if (isGood) {\n           \
    \ return \"Yes\";\n        } else {\n            return \"No\";\n        }\n \
    \   }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmpj452l_5s.java:29)\n\
    \tat Problem.main(tmpj452l_5s.java:43)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (!stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isGood = false;\n                break;\n            }\n        }\n     \
    \   if (isGood) {\n            return \"Yes\";\n        } else {\n           \
    \ return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpwow7r1s0.java:49)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (top.equals(\"(\"\
    )) {\n                    isGood = false;\n                    break;\n      \
    \          }\n            }\n        }\n        if (isGood) {\n            return\
    \ \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n \
    \   public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpqmozg44f.java:29)\n\
    \tat Problem.main(tmpqmozg44f.java:43)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            }\n        }\n        if (isGood) {\n           \
    \ return \"Yes\";\n        } else {\n            return \"No\";\n        }\n \
    \   }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmpj452l_5s.java:29)\n\
    \tat Problem.main(tmpj452l_5s.java:43)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isMatch = false;\n                    break;\n      \
    \          }\n                stack.pop();\n            } else {\n           \
    \     isMatch = false;\n                break;\n            }\n        }\n   \
    \     if (isMatch) {\n            return \"Yes\";\n        } else {\n        \
    \    return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpppj42xdo.java:49)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = false;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isMatch = true;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isMatch = false;\n                break;\n            }\n        }\n    \
    \    if (isMatch) {\n            return \"Yes\";\n        } else {\n         \
    \   return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpyi24ls3o.java:49)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               if (stack.isEmpty()) {\n                    isGood = false;\n\
    \                    break;\n                }\n                String top = stack.pop();\n\
    \                if (!top.equals(\"(\")) {\n                    isGood = false;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     if (isGood) {\n            return \"Yes\";\n        } else {\n         \
    \   return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpcd5km3e8.java:47)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        List<String> lst2 = new ArrayList<String>();\n        boolean\
    \ flag = false;\n        for (String s : lst) {\n            if (s.equals(\"(\"\
    )) {\n                flag = true;\n            }\n            if (s.equals(\"\
    )\")) {\n                flag = false;\n            }\n            if (flag) {\n\
    \                lst2.add(s);\n            }\n        }\n        boolean flag2\
    \ = false;\n        for (String s : lst2) {\n            if (s.equals(\"(\"))\
    \ {\n                flag2 = true;\n            }\n            if (s.equals(\"\
    )\")) {\n                flag2 = false;\n            }\n            if (flag2)\
    \ {\n                return \"Yes\";\n            }\n        }\n        return\
    \ \"No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpkgk4l3qw.java:51)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = false;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isMatch = true;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isMatch = false;\n                break;\n            }\n        }\n    \
    \    if (isMatch) {\n            return \"Yes\";\n        } else {\n         \
    \   return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpyi24ls3o.java:49)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"\
    (\")) {\n                stack.push(s);\n            } else if (s.equals(\")\"\
    )) {\n                String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    sb.append(top);\n                }\n            }\n\
    \        }\n        return sb.toString();\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpjb1brucr.java:29)\n\
    \tat Problem.main(tmpjb1brucr.java:38)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        stack.push(lst.get(0));\n\
    \        boolean isGood = true;\n        for (int i = 1; i < lst.size(); i++)\
    \ {\n            if (lst.get(i).equals(\"(\")) {\n                stack.push(lst.get(i));\n\
    \            } else if (lst.get(i).equals(\")\")) {\n                String s\
    \ = stack.pop();\n                if (!s.equals(\"(\")) {\n                  \
    \  isGood = false;\n                    break;\n                }\n          \
    \  }\n        }\n        if (isGood) {\n            return \"Yes\";\n        }\
    \ else {\n            return \"No\";\n        }\n    }\n    public static void\
    \ main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpnmbqqtlm.java:44)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (!stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            }\n        }\n        return\
    \ isGood ? \"Yes\" : \"No\";\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpo1ocbrpm.java:36)\n\
    \tat Problem.main(tmpo1ocbrpm.java:42)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"\
    (\")) {\n                stack.push(s);\n            } else if (s.equals(\")\"\
    )) {\n                String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    sb.append(top);\n                }\n            }\n\
    \        }\n        return sb.toString();\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpjb1brucr.java:29)\n\
    \tat Problem.main(tmpjb1brucr.java:38)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        List<String> lst2 = new ArrayList<String>();\n        boolean\
    \ flag = false;\n        for (String s : lst) {\n            if (s.equals(\"(\"\
    )) {\n                flag = true;\n            } else if (s.equals(\")\")) {\n\
    \                flag = false;\n            } else if (flag) {\n             \
    \   lst2.add(s);\n            }\n        }\n        if (lst2.size() == lst.size())\
    \ {\n            return \"Yes\";\n        } else {\n            return \"No\"\
    ;\n        }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpqc_d4v5u.java:41)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            }\n        }\n        if (isGood) {\n           \
    \ return \"Yes\";\n        } else {\n            return \"No\";\n        }\n \
    \   }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmpj452l_5s.java:29)\n\
    \tat Problem.main(tmpj452l_5s.java:43)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = false;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (!stack.isEmpty())\
    \ {\n                    isMatch = false;\n                    break;\n      \
    \          }\n                stack.push(s);\n            } else {\n         \
    \       isMatch = true;\n            }\n        }\n        if (isMatch) {\n  \
    \          return \"Yes\";\n        } else {\n            return \"No\";\n   \
    \     }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpj50faarp.java:50)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (!stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isGood = false;\n                break;\n            }\n        }\n     \
    \   if (isGood) {\n            return \"Yes\";\n        } else {\n           \
    \ return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpwow7r1s0.java:49)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isGood = false;\n                break;\n            }\n        }\n     \
    \   if (isGood) {\n            return \"Yes\";\n        } else {\n           \
    \ return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmplw4ldebo.java:49)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            }\n        }\n        if (isGood) {\n           \
    \ return \"Yes\";\n        } else {\n            return \"No\";\n        }\n \
    \   }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmpj452l_5s.java:29)\n\
    \tat Problem.main(tmpj452l_5s.java:43)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            }\n        }\n        return isGood ? \"Yes\" : \"\
    No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmp4romd_3g.java:29)\n\
    \tat Problem.main(tmp4romd_3g.java:39)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                if (stack.peek().equals(\"\
    (\")) {\n                    stack.pop();\n                } else {\n        \
    \            return \"No\";\n                }\n            } else {\n       \
    \         return \"No\";\n            }\n        }\n        return \"Yes\";\n\
    \    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmprimgyl5e.java:40)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"\
    (\")) {\n                stack.push(s);\n            } else if (s.equals(\")\"\
    )) {\n                String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    sb.append(top);\n                }\n            }\n\
    \        }\n        return sb.toString();\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpjb1brucr.java:29)\n\
    \tat Problem.main(tmpjb1brucr.java:38)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               if (stack.isEmpty()) {\n                    isMatch = false;\n\
    \                    break;\n                } else {\n                    String\
    \ top = stack.pop();\n                    if (top.equals(\"(\")) {\n         \
    \               stack.push(top);\n                    } else {\n             \
    \           isMatch = false;\n                        break;\n               \
    \     }\n                }\n            }\n        }\n        if (isMatch) {\n\
    \            return \"Yes\";\n        } else {\n            return \"No\";\n \
    \       }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpm_6wppr4.java:50)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                while (!stack.isEmpty()\
    \ && stack.peek().equals(\"(\")) {\n                    stack.pop();\n       \
    \         }\n                if (!stack.isEmpty()) {\n                    return\
    \ \"No\";\n                }\n                stack.push(s);\n            }\n\
    \        }\n        return \"Yes\";\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp89w5lm__.java:42)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        boolean isGood = true;\n        Stack<String> stack = new Stack<>();\n\
    \        for (String s : lst) {\n            if (s.equals(\"(\")) {\n        \
    \        stack.push(s);\n            } else if (s.equals(\")\")) {\n         \
    \       while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n           \
    \         stack.pop();\n                }\n                if (!stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            }\n        }\n        if\
    \ (isGood) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n    }\n    public static void main(String[] args) {\n  \
    \  assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\"\
    )\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmp19lwol04.java:36)\n\
    \tat Problem.main(tmp19lwol04.java:46)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (!stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n            }\n        }\n        if (isGood) {\n            return\
    \ \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n \
    \   public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpqqae5d7j.java:46)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        List<String> lst1 = new ArrayList<String>();\n        List<String>\
    \ lst2 = new ArrayList<String>();\n        List<String> lst3 = new ArrayList<String>();\n\
    \        List<String> lst4 = new ArrayList<String>();\n        List<String> lst5\
    \ = new ArrayList<String>();\n        List<String> lst6 = new ArrayList<String>();\n\
    \        List<String> lst7 = new ArrayList<String>();\n        List<String> lst8\
    \ = new ArrayList<String>();\n        List<String> lst9 = new ArrayList<String>();\n\
    \        List<String> lst10 = new ArrayList<String>();\n        List<String> lst11\
    \ = new ArrayList<String>();\n        List<String> lst12 = new ArrayList<String>();\n\
    \        List<String> lst13 = new ArrayList<String>();\n        List<String> lst14\
    \ = new ArrayList<String>();\n        List<String> lst15 = new ArrayList<String>();\n\
    \        List<String> lst16 = new ArrayList<String>();\n        List<String> lst17\
    \ = new ArrayList<String>();\n        List<String> lst18 = new ArrayList<String>();\n\
    \        List<String> lst19 = new ArrayList<String>();\n        List<String> lst20\
    \ = new ArrayList<String>();\n        List<String> lst21 = new ArrayList<String>();\n\
    \        List<String> lst22 = new ArrayList<String>();\n        List<String> lst23\
    \ = new ArrayList<String>();\n        List<String> lst24 = new ArrayList<String>();\n\
    \        List<String> lst25 = new ArrayList<String>();\n        List<String> lst26\
    \ = new ArrayList<String>();\n        List<String> lst27 = new ArrayList<String>();\n\
    \        List<String> lst28 = new ArrayList<String>();\n        List<String> lst29\
    \ = new ArrayList<String>();\n        List<String> lst30 = new ArrayList<String>();\n\
    \        List<String> lst31 = new ArrayList<String>();\n        List<String> lst32\
    \ = new ArrayList<String>();\n        List<String> lst33 = new ArrayList<String>();\n\
    \        List<String> lst34 = new ArrayList<String>();\n        List<String> lst35\
    \ = new ArrayList<String>();\n        List<String> lst36 = new ArrayList<String>();\n\
    \        List<String> lst37 = new ArrayList<String>();\n        List<String> lst38\
    \ = new ArrayList<String>();\n        List<String> lst39 = new ArrayList<String>();\n\
    \        List<String> lst40 = new ArrayList<String>();\n        List<String> lst41\
    \ = new ArrayList<String>();\n        List<String> lst42 = new ArrayList<String>();\n\
    \        List<String> lst43 = new ArrayList<String>();\n        List<String> lst44\
    \ = new ArrayList<String>();\n        List<String> lst45 = new ArrayList<String>();\n\
    \        List<String> lst46 = new ArrayList<String>();\n        List<String> lst47\
    \ = new ArrayList<String>();\n        List<String> lst48 = new ArrayList<String>();\n\
    \        List<String> lst49 = new ArrayList<String>();\n        List<String> lst50\
    \ = new ArrayList<String>();\n        List<String> lst51 = \n    }\n    public\
    \ static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpccg1lzyl.java:74: error: illegal start of expression\n    }\n \
    \   ^\n1 error\n"
  stdout: ''
  timestamp: 1659794682
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"\
    (\")) {\n                stack.push(s);\n            } else if (s.equals(\")\"\
    )) {\n                while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n\
    \                    sb.append(stack.pop());\n                }\n            \
    \    stack.push(s);\n            } else {\n                while (!stack.isEmpty()\
    \ && stack.peek().equals(\")\")) {\n                    sb.append(stack.pop());\n\
    \                }\n                sb.append(s);\n            }\n        }\n\
    \        while (!stack.isEmpty()) {\n            sb.append(stack.pop());\n   \
    \     }\n        return sb.toString();\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp534xkvai.java:46)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                String top = stack.pop();\n\
    \                if (!top.equals(\"(\")) {\n                    return \"No\"\
    ;\n                }\n            }\n        }\n        return \"Yes\";\n    }\n\
    \    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmp4p8as5u7.java:28)\n\
    \tat Problem.main(tmp4p8as5u7.java:37)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = false;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isMatch = true;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isMatch = false;\n                break;\n            }\n        }\n    \
    \    if (isMatch) {\n            return \"Yes\";\n        } else {\n         \
    \   return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpyi24ls3o.java:49)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (top.equals(\"(\"\
    )) {\n                    isGood = false;\n                    break;\n      \
    \          }\n            }\n        }\n        return isGood ? \"Yes\" : \"No\"\
    ;\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpgllefdj1.java:29)\n\
    \tat Problem.main(tmpgllefdj1.java:39)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            }\n        }\n        if (isGood) {\n           \
    \ return \"Yes\";\n        } else {\n            return \"No\";\n        }\n \
    \   }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmpj452l_5s.java:29)\n\
    \tat Problem.main(tmpj452l_5s.java:43)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (!stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            }\n        }\n        return\
    \ isGood ? \"Yes\" : \"No\";\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpo1ocbrpm.java:36)\n\
    \tat Problem.main(tmpo1ocbrpm.java:42)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                String top = stack.pop();\n\
    \                if (!top.equals(\"(\")) {\n                    return \"No\"\
    ;\n                }\n            }\n        }\n        return \"Yes\";\n    }\n\
    \    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmp4p8as5u7.java:28)\n\
    \tat Problem.main(tmp4p8as5u7.java:37)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (top.equals(\"(\"\
    )) {\n                    isGood = false;\n                    break;\n      \
    \          }\n            }\n        }\n        if (isGood) {\n            return\
    \ \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n \
    \   public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpqmozg44f.java:29)\n\
    \tat Problem.main(tmpqmozg44f.java:43)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = false;\n        for(int i = 0; i < lst.size(); i++) {\n            String\
    \ str = lst.get(i);\n            if(str.equals(\"(\")) {\n                stack.push(str);\n\
    \            } else if(str.equals(\")\")) {\n                if(!stack.isEmpty())\
    \ {\n                    String top = stack.pop();\n                    if(top.equals(\"\
    (\")) {\n                        stack.push(top);\n                    } else\
    \ {\n                        isMatch = false;\n                    }\n       \
    \         } else {\n                    isMatch = false;\n                }\n\
    \            }\n        }\n        if(!stack.isEmpty()) {\n            isMatch\
    \ = false;\n        }\n        if(isMatch) {\n            return \"Yes\";\n  \
    \      } else {\n            return \"No\";\n        }\n    }\n    public static\
    \ void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpwst09fkt.java:52)\n"
  stdout: ''
  timestamp: 1659794684
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = false;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (!stack.isEmpty())\
    \ {\n                    isMatch = false;\n                    break;\n      \
    \          }\n                stack.push(s);\n            } else if (s.equals(\"\
    )\")) {\n                while (!stack.isEmpty() && stack.peek().equals(\"(\"\
    )) {\n                    stack.pop();\n                }\n                if\
    \ (!stack.isEmpty()) {\n                    isMatch = false;\n               \
    \     break;\n                }\n                stack.push(s);\n            }\
    \ else if (s.equals(\"(\")) {\n                while (!stack.isEmpty() && stack.peek().equals(\"\
    )\")) {\n                    stack.pop();\n                }\n               \
    \ if (!stack.isEmpty()) {\n                    isMatch = false;\n            \
    \        break;\n                }\n                stack.push(s);\n         \
    \   }\n        }\n        if (!stack.isEmpty()) {\n            isMatch = false;\n\
    \        }\n        if (isMatch) {\n            return \"Yes\";\n        } else\
    \ {\n            return \"No\";\n        }\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmprwx_deay.java:67)\n"
  stdout: ''
  timestamp: 1659794684
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                if (stack.isEmpty())\
    \ {\n                    return \"No\";\n                }\n                String\
    \ top = stack.pop();\n                if (!top.equals(\"(\")) {\n            \
    \        return \"No\";\n                }\n            }\n        }\n       \
    \ return \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpcv71hbb2.java:40)\n"
  stdout: ''
  timestamp: 1659794684
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (!stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            }\n        }\n        if\
    \ (isGood) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n    }\n    public static void main(String[] args) {\n  \
    \  assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\"\
    )\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpnmlk2bpd.java:36)\n\
    \tat Problem.main(tmpnmlk2bpd.java:46)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for(String s :\
    \ lst) {\n            if(s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if(s.equals(\")\")) {\n                if(!stack.isEmpty())\
    \ {\n                    String top = stack.pop();\n                    if(top.equals(\"\
    (\")) {\n                        stack.push(top);\n                    } else\
    \ {\n                        if(stack.peek().equals(\"(\")) {\n              \
    \              stack.push(top);\n                        } else {\n          \
    \                  return \"No\";\n                        }\n               \
    \     }\n                }\n            }\n        }\n        if(stack.size()\
    \ == 0) {\n            return \"Yes\";\n        } else {\n            return \"\
    No\";\n        }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpzvmjm8p6.java:50)\n"
  stdout: ''
  timestamp: 1659794684
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        List<String> lst2 = new ArrayList<String>();\n        lst2.add(\"\
    (\");\n        lst2.add(\")\");\n        lst2.add(\"(\");\n        lst2.add(\"\
    )\");\n        lst2.add(\"(\");\n        lst2.add(\")\");\n        lst2.add(\"\
    (\");\n        lst2.add(\")\");\n        lst2.add(\"(\");\n        lst2.add(\"\
    )\");\n        lst2.add(\"(\");\n        lst2.add(\")\");\n        lst2.add(\"\
    (\");\n        lst2.add(\")\");\n        lst2.add(\"(\");\n        lst2.add(\"\
    )\");\n        lst2.add(\"(\");\n        lst2.add(\")\");\n        lst2.add(\"\
    (\");\n        lst2.add(\")\");\n        lst2.add(\"(\");\n        lst2.add(\"\
    )\");\n        lst2.add(\"(\");\n        lst2.add(\")\");\n        lst2.add(\"\
    (\");\n        lst2.add(\")\");\n        lst2.add(\"(\");\n        lst2.add(\"\
    )\");\n        lst2.add(\"(\");\n        lst2.add(\")\");\n        lst2.add(\"\
    (\");\n        lst2.add(\")\");\n        lst2.add(\"(\");\n        lst2.add(\"\
    )\");\n        lst2.add(\"(\");\n        lst2.add(\")\");\n        lst2.add(\"\
    (\");\n        lst2.add(\")\");\n        lst2.add(\"(\");\n        lst2.add(\"\
    )\");\n        lst2.add(\"(\");\n        lst2.add(\")\");\n        lst2.add(\"\
    (\");\n        lst2.add(\")\");\n        lst2.add(\"(\");\n        lst2.add(\"\
    )\");\n        lst2.add(\"(\");\n        lst2.add(\")\");\n        lst2.add(\"\
    (\");\n        lst2.add(\")\");\n        lst2.add(\"(\");\n        lst2.add(\"\
    )\");\n        lst2.add(\"(\");\n        lst2.add(\")\");\n        lst2.add(\"\
    (\");\n        lst2.add(\")\");\n        lst2.add(\"(\");\n        lst2.add(\"\
    )\");\n        lst2.add(\"(\");\n        lst2.add(\")\");\n        lst2.add(\"\
    (\");\n        lst2.add(\")\");\n        lst2.add(\"(\"\n    }\n    public static\
    \ void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8a8yv58d.java:86: error: ')' expected\n        lst2.add(\"(\"\n\
    \                    ^\n1 error\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (top.equals(\"(\"\
    )) {\n                    isGood = false;\n                    break;\n      \
    \          }\n            }\n        }\n        if (isGood) {\n            return\
    \ \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n \
    \   public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpqmozg44f.java:29)\n\
    \tat Problem.main(tmpqmozg44f.java:43)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                String top = stack.pop();\n\
    \                if (top.equals(\"(\")) {\n                    stack.push(top);\n\
    \                } else {\n                    return \"No\";\n              \
    \  }\n            } else {\n                return \"No\";\n            }\n  \
    \      }\n        return \"Yes\";\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp_vmsedtn.java:41)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"\
    (\")) {\n                stack.push(s);\n            } else if (s.equals(\")\"\
    )) {\n                String top = stack.pop();\n                if (top.equals(\"\
    (\")) {\n                    sb.append(top);\n                } else {\n     \
    \               return \"No\";\n                }\n            } else {\n    \
    \            sb.append(s);\n            }\n        }\n        if (stack.size()\
    \ > 0) {\n            return \"No\";\n        } else {\n            return \"\
    Yes\";\n        }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmp490jgebn.java:29)\n\
    \tat Problem.main(tmp490jgebn.java:46)\n"
  stdout: ''
  timestamp: 1659794684
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        List<String> list = new ArrayList<String>();\n        for (String\
    \ s : lst) {\n            list.add(s);\n        }\n        boolean flag = true;\n\
    \        Stack<String> stack = new Stack<String>();\n        for (String s : list)\
    \ {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n    \
    \        } else if (s.equals(\")\")) {\n                while (!stack.isEmpty()\
    \ && stack.peek().equals(\"(\")) {\n                    stack.pop();\n       \
    \         }\n                if (stack.isEmpty()) {\n                    flag\
    \ = false;\n                    break;\n                }\n                stack.pop();\n\
    \            }\n        }\n        if (flag) {\n            return \"Yes\";\n\
    \        } else {\n            return \"No\";\n        }\n    }\n    public static\
    \ void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpxu25cnax.java:50)\n"
  stdout: ''
  timestamp: 1659794684
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (top.equals(\"(\"\
    )) {\n                    isGood = false;\n                    break;\n      \
    \          }\n            }\n        }\n        if (isGood) {\n            return\
    \ \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n \
    \   public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpqmozg44f.java:29)\n\
    \tat Problem.main(tmpqmozg44f.java:43)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                String top = stack.pop();\n\
    \                if (!top.equals(\"(\")) {\n                    return \"No\"\
    ;\n                }\n            }\n        }\n        return \"Yes\";\n    }\n\
    \    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmp4p8as5u7.java:28)\n\
    \tat Problem.main(tmp4p8as5u7.java:37)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (top.equals(\"(\"\
    )) {\n                    isGood = false;\n                    break;\n      \
    \          }\n            }\n        }\n        if (isGood) {\n            return\
    \ \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n \
    \   public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpqmozg44f.java:29)\n\
    \tat Problem.main(tmpqmozg44f.java:43)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        List<String> lst2 = new ArrayList<String>();\n        boolean\
    \ flag = false;\n        for (String s : lst) {\n            if (s.equals(\"(\"\
    )) {\n                flag = true;\n            }\n            if (s.equals(\"\
    )\")) {\n                flag = false;\n            }\n            if (flag) {\n\
    \                lst2.add(s);\n            }\n        }\n        if (lst2.size()\
    \ == 0) {\n            return \"No\";\n        }\n        boolean flag2 = false;\n\
    \        for (String s : lst2) {\n            if (s.equals(\"(\")) {\n       \
    \         flag2 = true;\n            }\n            if (s.equals(\")\")) {\n \
    \               flag2 = false;\n            }\n            if (flag2) {\n    \
    \            return \"Yes\";\n            }\n        }\n        return \"No\"\
    ;\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpqkih5aih.java:54)\n"
  stdout: ''
  timestamp: 1659794684
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            }\n        }\n        if (isGood) {\n           \
    \ return \"Yes\";\n        } else {\n            return \"No\";\n        }\n \
    \   }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmpj452l_5s.java:29)\n\
    \tat Problem.main(tmpj452l_5s.java:43)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        List<String> lst2 = new ArrayList<String>();\n        boolean\
    \ flag = false;\n        for (String s : lst) {\n            if (s.equals(\"(\"\
    )) {\n                flag = true;\n            } else if (s.equals(\")\")) {\n\
    \                flag = false;\n            } else {\n                lst2.add(s);\n\
    \            }\n        }\n        if (flag) {\n            return \"Yes\";\n\
    \        } else {\n            return \"No\";\n        }\n    }\n    public static\
    \ void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp03tpbc9t.java:41)\n"
  stdout: ''
  timestamp: 1659794684
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                while (!stack.isEmpty()\
    \ && stack.peek().equals(\"(\")) {\n                    stack.pop();\n       \
    \         }\n                if (!stack.isEmpty()) {\n                    return\
    \ \"No\";\n                }\n                stack.push(s);\n            } else\
    \ {\n                return \"No\";\n            }\n        }\n        return\
    \ \"Yes\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpxm79oryn.java:42)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (!stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            }\n        }\n        return\
    \ isGood ? \"Yes\" : \"No\";\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpo1ocbrpm.java:36)\n\
    \tat Problem.main(tmpo1ocbrpm.java:42)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            }\n        }\n        return isGood ? \"Yes\" : \"\
    No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmp4romd_3g.java:29)\n\
    \tat Problem.main(tmp4romd_3g.java:39)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        boolean isGood = true;\n        Stack<String> stack = new Stack<>();\n\
    \        for(String s : lst) {\n            if(s.equals(\"(\")) {\n          \
    \      stack.push(s);\n            } else if(s.equals(\")\")) {\n            \
    \    if(!stack.isEmpty()) {\n                    String top = stack.pop();\n \
    \                   if(!top.equals(\"(\")) {\n                        isGood =\
    \ false;\n                    }\n                }\n            }\n        }\n\
    \        if(isGood) {\n            return \"Yes\";\n        } else {\n       \
    \     return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpqszc4t6w.java:45)\n"
  stdout: ''
  timestamp: 1659794684
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        boolean isGood = true;\n        for (String\
    \ s : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                while (!stack.isEmpty()\
    \ && stack.peek().equals(\"(\")) {\n                    sb.append(stack.pop());\n\
    \                }\n                stack.pop();\n            } else {\n     \
    \           isGood = false;\n                break;\n            }\n        }\n\
    \        if (stack.isEmpty()) {\n            return \"No\";\n        }\n     \
    \   return \"Yes\";\n    }\n    public static void main(String[] args) {\n   \
    \ assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\"\
    )\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmph_j1em8t.java:45)\n"
  stdout: ''
  timestamp: 1659794685
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (!stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n            }\n        }\n        if (isGood) {\n            return\
    \ \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n \
    \   public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpqqae5d7j.java:46)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = false;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isMatch = true;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isMatch = false;\n                break;\n            }\n        }\n    \
    \    if (isMatch) {\n            return \"Yes\";\n        } else {\n         \
    \   return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpyi24ls3o.java:49)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (top.equals(\"(\"\
    )) {\n                    isGood = false;\n                    break;\n      \
    \          }\n            }\n        }\n        return isGood ? \"Yes\" : \"No\"\
    ;\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpgllefdj1.java:29)\n\
    \tat Problem.main(tmpgllefdj1.java:39)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isGood = false;\n                break;\n            }\n        }\n     \
    \   if (isGood) {\n            return \"Yes\";\n        } else {\n           \
    \ return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmplw4ldebo.java:49)\n"
  stdout: ''
- exit_code: -1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        boolean isGood = true;\n        Stack<String> stack = new Stack<>();\n\
    \        stack.addAll(lst);\n        while(!stack.isEmpty()) {\n            String\
    \ s = stack.pop();\n            if(s.equals(\"(\")) {\n                stack.push(\"\
    )\");\n            } else if(s.equals(\")\")) {\n                stack.push(\"\
    (\");\n            } else {\n                isGood = false;\n            }\n\
    \        }\n        if(isGood) {\n            return \"Yes\";\n        } else\
    \ {\n            return \"No\";\n        }\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659794690
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = false;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (!stack.isEmpty())\
    \ {\n                    isMatch = false;\n                    break;\n      \
    \          }\n                stack.push(s);\n            } else {\n         \
    \       isMatch = true;\n                break;\n            }\n        }\n  \
    \      if (isMatch) {\n            return \"Yes\";\n        } else {\n       \
    \     return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpxb6d3x07.java:51)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                while (!stack.isEmpty()\
    \ && stack.peek().equals(\"(\")) {\n                    stack.pop();\n       \
    \         }\n                if (!stack.isEmpty()) {\n                    return\
    \ \"No\";\n                }\n                stack.push(s);\n            }\n\
    \        }\n        return \"Yes\";\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp89w5lm__.java:42)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"\
    (\")) {\n                stack.push(s);\n            } else if (s.equals(\")\"\
    )) {\n                String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    sb.append(top);\n                }\n            }\n\
    \        }\n        return sb.toString();\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpjb1brucr.java:29)\n\
    \tat Problem.main(tmpjb1brucr.java:38)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               if (stack.isEmpty()) {\n                    isGood = false;\n\
    \                    break;\n                }\n                String top = stack.pop();\n\
    \                if (!top.equals(\"(\")) {\n                    isGood = false;\n\
    \                    break;\n                }\n            } else {\n       \
    \         isGood = false;\n                break;\n            }\n        }\n\
    \        if (isGood) {\n            return \"Yes\";\n        } else {\n      \
    \      return \"No\";\n        }\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpxiw7izn_.java:50)\n"
  stdout: ''
  timestamp: 1659794685
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            }\n        }\n        if (isGood) {\n           \
    \ return \"Yes\";\n        } else {\n            return \"No\";\n        }\n \
    \   }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmpj452l_5s.java:29)\n\
    \tat Problem.main(tmpj452l_5s.java:43)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            }\n        }\n        return isGood ? \"Yes\" : \"\
    No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmp4romd_3g.java:29)\n\
    \tat Problem.main(tmp4romd_3g.java:39)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for(String s :\
    \ lst) {\n            if(s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if(s.equals(\")\")) {\n                if(!stack.isEmpty())\
    \ {\n                    String top = stack.pop();\n                    if(top.equals(\"\
    (\")) {\n                        stack.push(top);\n                    } else\
    \ {\n                        if(stack.peek().equals(\"(\")) {\n              \
    \              stack.push(top);\n                        } else {\n          \
    \                  return \"No\";\n                        }\n               \
    \     }\n                } else {\n                    return \"No\";\n      \
    \          }\n            } else {\n                if(!stack.isEmpty()) {\n \
    \                   String top = stack.pop();\n                    if(top.equals(\"\
    (\")) {\n                        stack.push(top);\n                    } else\
    \ {\n                        if(stack.peek().equals(\"(\")) {\n              \
    \              stack.push(top);\n                        } else {\n          \
    \                  return \"No\";\n                        }\n               \
    \     }\n                } else {\n                    return \"No\";\n      \
    \          }\n            }\n        }\n        return \"Yes\";\n    }\n    public\
    \ static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpxiqgdmyb.java:62)\n"
  stdout: ''
  timestamp: 1659794685
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                String top = stack.pop();\n\
    \                if (top.equals(\"(\")) {\n                    stack.push(top);\n\
    \                } else {\n                    return \"No\";\n              \
    \  }\n            } else {\n                return \"No\";\n            }\n  \
    \      }\n        return \"Yes\";\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp_vmsedtn.java:41)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for(String s :\
    \ lst) {\n            if(s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if(s.equals(\")\")) {\n                if(!stack.isEmpty())\
    \ {\n                    if(stack.peek().equals(\"(\")) {\n                  \
    \      stack.pop();\n                    } else {\n                        return\
    \ \"No\";\n                    }\n                } else {\n                 \
    \   return \"No\";\n                }\n            }\n        }\n        if(stack.isEmpty())\
    \ {\n            return \"Yes\";\n        } else {\n            return \"No\"\
    ;\n        }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp2bj8g8vc.java:46)\n"
  stdout: ''
  timestamp: 1659794685
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"\
    (\")) {\n                stack.push(s);\n            } else if (s.equals(\")\"\
    )) {\n                String top = stack.pop();\n                if (top.equals(\"\
    (\")) {\n                    sb.append(top);\n                } else {\n     \
    \               return \"No\";\n                }\n            } else {\n    \
    \            sb.append(s);\n            }\n        }\n        return sb.toString();\n\
    \    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmp6mnlutc8.java:29)\n\
    \tat Problem.main(tmp6mnlutc8.java:42)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = false;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (top.equals(\"(\"\
    )) {\n                    isMatch = true;\n                }\n            }\n\
    \        }\n        return isMatch ? \"Yes\" : \"No\";\n    }\n    public static\
    \ void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmp0mndwjel.java:29)\n\
    \tat Problem.main(tmp0mndwjel.java:38)\n"
  stdout: ''
  timestamp: 1659794685
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               if (stack.isEmpty()) {\n                    isGood = false;\n\
    \                    break;\n                }\n                String top = stack.pop();\n\
    \                if (!top.equals(\"(\")) {\n                    isGood = false;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     if (isGood) {\n            return \"Yes\";\n        } else {\n         \
    \   return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpcd5km3e8.java:47)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (top.equals(\"(\"\
    )) {\n                    isGood = false;\n                    break;\n      \
    \          }\n            }\n        }\n        if (isGood) {\n            return\
    \ \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n \
    \   public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpqmozg44f.java:29)\n\
    \tat Problem.main(tmpqmozg44f.java:43)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (top.equals(\"(\"\
    )) {\n                    isGood = false;\n                    break;\n      \
    \          }\n            }\n        }\n        if (isGood) {\n            return\
    \ \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n \
    \   public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpqmozg44f.java:29)\n\
    \tat Problem.main(tmpqmozg44f.java:43)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        boolean isGood = true;\n        Stack<String> stack = new Stack<>();\n\
    \        stack.push(lst.get(0));\n        for(int i = 1; i < lst.size(); i++)\
    \ {\n            String s = lst.get(i);\n            boolean isParenthesisOpen\
    \ = s.charAt(0) == '(';\n            boolean isParenthesisClose = s.charAt(s.length()\
    \ - 1) == ')';\n            if(!isParenthesisOpen && !isParenthesisClose) {\n\
    \                isGood = false;\n                break;\n            }\n    \
    \        if(!isParenthesisOpen && isParenthesisClose) {\n                isGood\
    \ = false;\n                break;\n            }\n            if(!isParenthesisClose\
    \ && isParenthesisOpen) {\n                isGood = false;\n                break;\n\
    \            }\n            if(!isParenthesisOpen && !isParenthesisClose) {\n\
    \                isGood = false;\n                break;\n            }\n    \
    \        if(!isParenthesisOpen && isParenthesisClose) {\n                isGood\
    \ = false;\n                break;\n            }\n            if(!isParenthesisClose\
    \ && isParenthesisOpen) {\n                isGood = false;\n                break;\n\
    \            }\n            if(!isParenthesisOpen && !isParenthesisClose) {\n\
    \                isGood = false;\n                break;\n            }\n    \
    \        if(!isParenthesisOpen && isParenthesisClose) {\n                isGood\
    \ = false;\n                break;\n            }\n            if(!isParenthesisClose\
    \ && isParenthesisOpen) {\n                isGood = false;\n                break;\n\
    \            }\n            if(!isParenthesisOpen && !isParenthesisClose) {\n\
    \                isGood = false;\n                break;\n            }\n    \
    \        if(!isParenthesisOpen && isParenthesisClose) {\n                isGood\
    \ = false;\n                break;\n            }\n            if(!isParenthesisClose\
    \ && isParenthesisOpen) {\n                isGood = false;\n                break;\n\
    \            }\n            if(!isParenthesisOpen && !isParenthesisClose) {\n\
    \                isGood = false;\n                break;\n            }\n    \
    \        if(!isParenthesisOpen && isParenthesisClose) {\n                isGood\
    \ = false;\n                break;\n            }\n            if(!isParenthesisClose\
    \ && isParenthesisOpen) {\n                isGood = false;\n                break;\n\
    \            }\n            if(!isParenthesisOpen && !isParenthesisClose) {\n\
    \                isGood = false;\n                break;\n            }\n    \
    \        if(!isParenthesisOpen && isParenthesisClose) {\n                isGood\
    \ = false;\n                break;\n            }\n            if(!isParenthesisClose\
    \ && isParenthesisOpen) {\n                isGood = false;\n                break;\n\
    \            }\n            if(!isParenthesisOpen && !\n    }\n    public static\
    \ void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp24la1usr.java:103: error: illegal start of expression\n    }\n\
    \    ^\n/tmp/tmp24la1usr.java:104: error: illegal start of expression\n    public\
    \ static void main(String[] args) {\n    ^\n2 errors\n"
  stdout: ''
  timestamp: 1659794684
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isGood = false;\n                break;\n            }\n        }\n     \
    \   if (isGood) {\n            return \"Yes\";\n        } else {\n           \
    \ return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmplw4ldebo.java:49)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (!stack.isEmpty())\
    \ {\n                    isMatch = false;\n                    break;\n      \
    \          }\n                stack.pop();\n            } else {\n           \
    \     isMatch = false;\n                break;\n            }\n        }\n   \
    \     if (isMatch) {\n            return \"Yes\";\n        } else {\n        \
    \    return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpk3lewfk_.java:49)\n"
  stdout: ''
  timestamp: 1659794685
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = false;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               if (stack.peek().equals(\"(\")) {\n                    stack.pop();\n\
    \                } else {\n                    isMatch = false;\n            \
    \        break;\n                }\n            } else {\n                isMatch\
    \ = false;\n                break;\n            }\n        }\n        if (isMatch)\
    \ {\n            return \"Yes\";\n        } else {\n            return \"No\"\
    ;\n        }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp068afwxb.java:47)\n"
  stdout: ''
  timestamp: 1659794685
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"\
    (\")) {\n                stack.push(s);\n            } else if (s.equals(\")\"\
    )) {\n                while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n\
    \                    sb.append(stack.pop());\n                }\n            \
    \    stack.pop();\n            }\n        }\n        while (!stack.isEmpty())\
    \ {\n            sb.append(stack.pop());\n        }\n        return sb.toString();\n\
    \    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmp9oajghwd.java:32)\n\
    \tat Problem.main(tmp9oajghwd.java:41)\n"
  stdout: ''
  timestamp: 1659794685
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = false;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (top.equals(\"(\"\
    )) {\n                    isMatch = true;\n                } else {\n        \
    \            isMatch = false;\n                    break;\n                }\n\
    \            } else {\n                isMatch = false;\n                break;\n\
    \            }\n        }\n        if (isMatch) {\n            return \"Yes\"\
    ;\n        } else {\n            return \"No\";\n        }\n    }\n    public\
    \ static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpv8u8eun2.java:48)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                String top = stack.pop();\n\
    \                if (top.equals(\"(\")) {\n                    stack.push(s);\n\
    \                } else {\n                    return \"No\";\n              \
    \  }\n            } else {\n                return \"No\";\n            }\n  \
    \      }\n        return \"Yes\";\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp4rf3aiwe.java:41)\n"
  stdout: ''
  timestamp: 1659794685
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (!stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            }\n        }\n        if\
    \ (isGood) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n    }\n    public static void main(String[] args) {\n  \
    \  assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\"\
    )\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpnmlk2bpd.java:36)\n\
    \tat Problem.main(tmpnmlk2bpd.java:46)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for(String s:\
    \ lst) {\n            if(s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if(s.equals(\")\")) {\n                if(!stack.isEmpty()\
    \ && stack.peek().equals(\"(\")) {\n                    stack.pop();\n       \
    \         } else {\n                    return \"No\";\n                }\n  \
    \          } else {\n                return \"No\";\n            }\n        }\n\
    \        if(stack.isEmpty()) {\n            return \"Yes\";\n        } else {\n\
    \            return \"No\";\n        }\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp0b8m50tz.java:44)\n"
  stdout: ''
  timestamp: 1659794685
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (top.equals(\"(\"\
    )) {\n                    isGood = false;\n                    break;\n      \
    \          }\n            }\n        }\n        if (isGood) {\n            return\
    \ \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n \
    \   public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpqmozg44f.java:29)\n\
    \tat Problem.main(tmpqmozg44f.java:43)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (top.equals(\"(\"\
    )) {\n                    isGood = false;\n                    break;\n      \
    \          }\n            }\n        }\n        if (isGood) {\n            return\
    \ \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n \
    \   public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpqmozg44f.java:29)\n\
    \tat Problem.main(tmpqmozg44f.java:43)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                if (stack.size() ==\
    \ 0) {\n                    return \"No\";\n                }\n              \
    \  String top = stack.pop();\n                if (!top.equals(\"(\")) {\n    \
    \                return \"No\";\n                }\n            }\n        }\n\
    \        return \"Yes\";\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpb5lu2ve3.java:40)\n"
  stdout: ''
  timestamp: 1659794685
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        boolean isGood = true;\n        Stack<String> stack = new Stack<>();\n\
    \        for(String s : lst) {\n            if(s.equals(\"(\")) {\n          \
    \      stack.push(s);\n            } else if(s.equals(\")\")) {\n            \
    \    if(!stack.isEmpty()) {\n                    String top = stack.pop();\n \
    \                   if(top.equals(\"(\")) {\n                        stack.push(top);\n\
    \                    } else {\n                        isGood = false;\n     \
    \               }\n                }\n            }\n        }\n        if(isGood)\
    \ {\n            return \"Yes\";\n        } else {\n            return \"No\"\
    ;\n        }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpa0phf_18.java:47)\n"
  stdout: ''
  timestamp: 1659794685
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (!stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            }\n        }\n        if\
    \ (isGood) {\n            return \"Yes\";\n        } else {\n            return\
    \ \"No\";\n        }\n    }\n    public static void main(String[] args) {\n  \
    \  assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\", (String)\"\
    )\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpnmlk2bpd.java:36)\n\
    \tat Problem.main(tmpnmlk2bpd.java:46)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = false;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isMatch = true;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n              \
    \      stack.pop();\n                }\n                stack.push(s);\n     \
    \       }\n        }\n        return isMatch ? \"Yes\" : \"No\";\n    }\n    public\
    \ static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpk1arbxc0.java:47)\n"
  stdout: ''
  timestamp: 1659794685
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = false;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isMatch = true;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isMatch = false;\n                break;\n            }\n        }\n    \
    \    if (isMatch) {\n            return \"Yes\";\n        } else {\n         \
    \   return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpyi24ls3o.java:49)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (!stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            }\n        }\n        if\
    \ (!stack.isEmpty()) {\n            isGood = false;\n        }\n        if (isGood)\
    \ {\n            return \"Yes\";\n        } else {\n            return \"No\"\
    ;\n        }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmptj0v_0_h.java:36)\n\
    \tat Problem.main(tmptj0v_0_h.java:49)\n"
  stdout: ''
  timestamp: 1659794685
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                String top = stack.pop();\n\
    \                if (top.equals(\"(\")) {\n                    stack.push(top);\n\
    \                } else {\n                    return \"No\";\n              \
    \  }\n            } else {\n                return \"No\";\n            }\n  \
    \      }\n        return \"Yes\";\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp_vmsedtn.java:41)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = false;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (top.equals(\"(\"\
    )) {\n                    isMatch = true;\n                    break;\n      \
    \          }\n            }\n        }\n        return isMatch ? \"Yes\" : \"\
    No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmp5xh8tc7q.java:29)\n\
    \tat Problem.main(tmp5xh8tc7q.java:39)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isMatch = false;\n                    break;\n  \
    \              }\n            }\n        }\n        if (isMatch) {\n         \
    \   return \"Yes\";\n        } else {\n            return \"No\";\n        }\n\
    \    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmp0zxi3gni.java:29)\n\
    \tat Problem.main(tmp0zxi3gni.java:43)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        stack.push(lst.get(0));\n\
    \        for(int i = 1; i < lst.size(); i++) {\n            String str = lst.get(i);\n\
    \            if(!stack.empty() && stack.peek().equals(\"(\")) {\n            \
    \    stack.push(str);\n            } else if(!stack.empty() && stack.peek().equals(\"\
    )\")) {\n                String top = stack.pop();\n                if(!top.equals(\"\
    (\")) {\n                    return \"No\";\n                }\n            }\n\
    \        }\n        return \"Yes\";\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp03p2xavi.java:41)\n"
  stdout: ''
  timestamp: 1659794685
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (top.equals(\"(\"\
    )) {\n                    isGood = false;\n                    break;\n      \
    \          }\n            }\n        }\n        if (isGood) {\n            return\
    \ \"Yes\";\n        } else {\n            return \"No\";\n        }\n    }\n \
    \   public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpqmozg44f.java:29)\n\
    \tat Problem.main(tmpqmozg44f.java:43)\n"
  stdout: ''
  timestamp: 1659794683
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (!stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isGood = false;\n                break;\n            }\n        }\n     \
    \   if (isGood) {\n            return \"Yes\";\n        } else {\n           \
    \ return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpwow7r1s0.java:49)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                String top = stack.pop();\n\
    \                if (!top.equals(\"(\")) {\n                    return \"No\"\
    ;\n                }\n            }\n        }\n        return \"Yes\";\n    }\n\
    \    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmp4p8as5u7.java:28)\n\
    \tat Problem.main(tmp4p8as5u7.java:37)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        boolean isGood = true;\n        Stack<String> stack = new Stack<>();\n\
    \        for (String s : lst) {\n            if (s.equals(\"(\")) {\n        \
    \        stack.push(s);\n            } else if (s.equals(\")\")) {\n         \
    \       if (stack.isEmpty()) {\n                    isGood = false;\n        \
    \            break;\n                }\n                String top = stack.pop();\n\
    \                if (!top.equals(\"(\")) {\n                    isGood = false;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     if (isGood) {\n            return \"Yes\";\n        } else {\n         \
    \   return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpfgsvgw8b.java:47)\n"
  stdout: ''
  timestamp: 1659794685
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            }\n        }\n        if (isGood) {\n           \
    \ return \"Yes\";\n        } else {\n            return \"No\";\n        }\n \
    \   }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmpj452l_5s.java:29)\n\
    \tat Problem.main(tmpj452l_5s.java:43)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            }\n        }\n        if (isGood) {\n           \
    \ return \"Yes\";\n        } else {\n            return \"No\";\n        }\n \
    \   }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmpj452l_5s.java:29)\n\
    \tat Problem.main(tmpj452l_5s.java:43)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                String top = stack.pop();\n\
    \                if (!top.equals(\"(\")) {\n                    return \"No\"\
    ;\n                }\n            }\n        }\n        return \"Yes\";\n    }\n\
    \    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmp4p8as5u7.java:28)\n\
    \tat Problem.main(tmp4p8as5u7.java:37)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isMatch\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isMatch = false;\n                    break;\n      \
    \          }\n                stack.pop();\n            } else {\n           \
    \     isMatch = false;\n                break;\n            }\n        }\n   \
    \     if (isMatch) {\n            return \"Yes\";\n        } else {\n        \
    \    return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpppj42xdo.java:49)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (!stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isGood = false;\n                break;\n            }\n        }\n     \
    \   if (isGood) {\n            return \"Yes\";\n        } else {\n           \
    \ return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpwow7r1s0.java:49)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                String top = stack.pop();\n\
    \                if (!top.equals(\"(\")) {\n                    return \"No\"\
    ;\n                }\n            }\n        }\n        return \"Yes\";\n    }\n\
    \    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmp4p8as5u7.java:28)\n\
    \tat Problem.main(tmp4p8as5u7.java:37)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                String top = stack.pop();\n\
    \                if (!top.equals(\"(\")) {\n                    return \"No\"\
    ;\n                }\n            }\n        }\n        return \"Yes\";\n    }\n\
    \    public static void main(String[] args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmp4p8as5u7.java:28)\n\
    \tat Problem.main(tmp4p8as5u7.java:37)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n   \
    \                 stack.pop();\n                }\n                if (stack.isEmpty())\
    \ {\n                    isGood = false;\n                    break;\n       \
    \         }\n                stack.pop();\n            } else {\n            \
    \    isGood = false;\n                break;\n            }\n        }\n     \
    \   if (isGood) {\n            return \"Yes\";\n        } else {\n           \
    \ return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmplw4ldebo.java:49)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               if (stack.isEmpty()) {\n                    isGood = false;\n\
    \                    break;\n                }\n                String top = stack.pop();\n\
    \                if (!top.equals(\"(\")) {\n                    isGood = false;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     if (isGood) {\n            return \"Yes\";\n        } else {\n         \
    \   return \"No\";\n        }\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpcd5km3e8.java:47)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               if (stack.isEmpty()) {\n                    isGood = false;\n\
    \                    break;\n                } else {\n                    String\
    \ top = stack.pop();\n                    if (top.equals(\"(\")) {\n         \
    \               stack.push(top);\n                    } else {\n             \
    \           isGood = false;\n                        break;\n                \
    \    }\n                }\n            }\n        }\n        if (isGood) {\n \
    \           return \"Yes\";\n        } else {\n            return \"No\";\n  \
    \      }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmpmdugjqr0.java:50)\n"
  stdout: ''
  timestamp: 1659794685
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"\
    (\")) {\n                stack.push(s);\n            } else if (s.equals(\")\"\
    )) {\n                while (!stack.isEmpty() && stack.peek().equals(\"(\")) {\n\
    \                    sb.append(stack.pop());\n                }\n            \
    \    stack.push(s);\n            } else {\n                while (!stack.isEmpty()\
    \ && stack.peek().equals(\")\")) {\n                    sb.append(stack.pop());\n\
    \                }\n                sb.append(s);\n            }\n        }\n\
    \        while (!stack.isEmpty()) {\n            sb.append(stack.pop());\n   \
    \     }\n        return sb.toString();\n    }\n    public static void main(String[]\
    \ args) {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp534xkvai.java:46)\n"
  stdout: ''
  timestamp: 1659794681
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for(String s :\
    \ lst) {\n            if(s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if(s.equals(\")\")) {\n                if(!stack.isEmpty())\
    \ {\n                    String top = stack.pop();\n                    if(top.equals(\"\
    (\")) {\n                        stack.push(top);\n                    } else\
    \ {\n                        return \"No\";\n                    }\n         \
    \       }\n            } else {\n                return \"No\";\n            }\n\
    \        }\n        if(!stack.isEmpty()) {\n            return \"No\";\n     \
    \   }\n        return \"Yes\";\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp5s4s7i9v.java:46)\n"
  stdout: ''
  timestamp: 1659794685
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        for (String s\
    \ : lst) {\n            if (s.equals(\"(\")) {\n                stack.push(s);\n\
    \            } else if (s.equals(\")\")) {\n                while (!stack.isEmpty()\
    \ && stack.peek().equals(\"(\")) {\n                    stack.pop();\n       \
    \         }\n                if (stack.isEmpty()) {\n                    return\
    \ \"No\";\n                }\n                String top = stack.pop();\n    \
    \            if (!top.equals(\"(\")) {\n                    return \"No\";\n \
    \               }\n                stack.push(top);\n            }\n        }\n\
    \        return \"Yes\";\n    }\n    public static void main(String[] args) {\n\
    \    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\",\
    \ (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp_19dcuwa.java:44)\n"
  stdout: ''
  timestamp: 1659794685
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            }\n        }\n        return isGood ? \"Yes\" : \"\
    No\";\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmp4romd_3g.java:29)\n\
    \tat Problem.main(tmp4romd_3g.java:39)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        boolean isGood\
    \ = true;\n        for (String s : lst) {\n            if (s.equals(\"(\")) {\n\
    \                stack.push(s);\n            } else if (s.equals(\")\")) {\n \
    \               String top = stack.pop();\n                if (!top.equals(\"\
    (\")) {\n                    isGood = false;\n                    break;\n   \
    \             }\n            }\n        }\n        if (isGood) {\n           \
    \ return \"Yes\";\n        } else {\n            return \"No\";\n        }\n \
    \   }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:102)\n\
    \tat java.util.Stack.pop(Stack.java:84)\n\tat Problem.matchParens(tmpj452l_5s.java:29)\n\
    \tat Problem.main(tmpj452l_5s.java:43)\n"
  stdout: ''
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        StringBuilder\
    \ sb = new StringBuilder();\n        for (String s : lst) {\n            if (s.equals(\"\
    (\")) {\n                stack.push(s);\n            } else if (s.equals(\")\"\
    )) {\n                String top = stack.pop();\n                if (top.equals(\"\
    (\")) {\n                    sb.append(top);\n                } else {\n     \
    \               return \"No\";\n                }\n            } else {\n    \
    \            sb.append(s);\n            }\n        }\n        if (stack.size()\
    \ != 0) {\n            return \"No\";\n        } else {\n            return \"\
    Yes\";\n        }\n    }\n    public static void main(String[] args) {\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()(\", (String)\")\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.util.EmptyStackException\n\tat java.base/java.util.Stack.peek(Stack.java:101)\n\
    \tat java.base/java.util.Stack.pop(Stack.java:83)\n\tat Problem.matchParens(tmpyybcjgty.java:29)\n\
    \tat Problem.main(tmpyybcjgty.java:46)\n"
  stdout: ''
  timestamp: 1659794685
- exit_code: 1
  program: "import java.util.*;\nimport java.lang.reflect.*;\nimport org.javatuples.*;\n\
    import java.security.*;\nimport java.math.*;\nimport java.io.*;\nimport java.util.stream.*;\n\
    class Problem {\n    // You are given a list of two strings, both strings consist\
    \ of open\n    // parentheses '(' or close parentheses ')' only.\n    // Your\
    \ job is to check if it is possible to concatenate the two strings in\n    //\
    \ some order, that the resulting string will be good.\n    // A string S is considered\
    \ to be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    ()(\", (String)\")\"))))\n    // (\"Yes\")\n    // >>> matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\"))))\n    // (\"No\")\n    public static String matchParens(ArrayList<String>\
    \ lst) {\n        Stack<String> stack = new Stack<>();\n        stack.push(lst.get(0));\n\
    \        for(int i = 1; i < lst.size(); i++) {\n            String s = lst.get(i);\n\
    \            while(!stack.empty() && stack.peek().equals(s)) {\n             \
    \   stack.pop();\n            }\n            if(!stack.empty() && stack.peek().equals(s))\
    \ {\n                stack.pop();\n                stack.push(s);\n          \
    \  }\n            else {\n                return \"No\";\n            }\n    \
    \    }\n        return \"Yes\";\n    }\n    public static void main(String[] args)\
    \ {\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"()(\"\
    , (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\")\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(())\", (String)\"())())\")))).equals((\"No\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\")())\", (String)\"(()()(\")))).equals((\"\
    Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (())))\", (String)\"(()())((\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"()\", (String)\"())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (()(\", (String)\"()))()\")))).equals((\"Yes\")));\n    assert(matchParens((new\
    \ ArrayList<String>(Arrays.asList((String)\"((((\", (String)\"((())\")))).equals((\"\
    No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(()\", (String)\"(()(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )(\", (String)\")(\")))).equals((\"No\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    (\", (String)\")\")))).equals((\"Yes\")));\n    assert(matchParens((new ArrayList<String>(Arrays.asList((String)\"\
    )\", (String)\"(\")))).equals((\"Yes\")));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmph30oa7kr.java:41)\n"
  stdout: ''
  timestamp: 1659794685
