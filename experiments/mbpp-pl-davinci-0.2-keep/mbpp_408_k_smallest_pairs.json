{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "pl",
  "prompt": "# Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nsub k_smallest_pairs {\n    my($nums1, $nums2, $k) = @_;\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&k_smallest_pairs;\n        if(eq_deeply($candidate->([1, 3, 7], [2, 4, 6], 2),[[1, 2], [1, 4]])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 3, 7], [2, 4, 6], 1),[[1, 2]])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 3, 7], [2, 4, 6], 7),[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
  "stop_tokens": [
    "\nsub",
    "\n#",
    "\n\n"
  ],
  "completions": [
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        push @result, [$nums1->[$i], $nums2->[$j]];\n        if ($i == @$nums1 - 1) {\n            $j++;\n        } elsif ($j == @$nums2 - 1) {\n            $i++;\n        } else {\n            if ($nums1->[$i + 1] + $nums2->[$j] < $nums1->[$i] + $nums2->[$j + 1]) {\n                $i++;\n            } else {\n                $j++;\n            }\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $m = @$nums1;\n    my $n = @$nums2;\n    return [] if $m == 0 || $n == 0;\n    my $i = 0;\n    my $j = 0;\n    while ($i < $m && $j < $n && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($i + 1 < $m && $j + 1 < $n) {\n            my $sum1 = $nums1->[$i + 1] + $nums2->[$j];\n            my $sum2 = $nums1->[$i] + $nums2->[$j + 1];\n            if ($sum1 < $sum2) {\n                push @result, [$nums1->[$i + 1], $nums2->[$j]];\n                $i++;\n            } else {\n                push @result, [$nums1->[$i], $nums2->[$j + 1]];\n                $j++;\n            }\n        } elsif ($i + 1 < $m) {\n            push @result, [$nums1->[$i + 1], $nums2->[$j]];\n            $i++;\n        } elsif ($j + 1 < $n) {\n            push @result, [$nums1->[$i], $nums2->[$j + 1]];\n            $j++;\n        }\n    }\n    return \\@result;\n}",
    "    my @res;\n    return @res if @$nums1 == 0 || @$nums2 == 0 || $k == 0;\n    my $len1 = @$nums1;\n    my $len2 = @$nums2;\n    my $i = 0;\n    my $j = 0;\n    my $count = 0;\n    while ($count < $k && $i < $len1 && $j < $len2) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum <= $nums1->[$i + 1] + $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i + 1], $nums2->[$j]];\n            $i++;\n        }\n        $count++;\n    }\n    return @res;\n}",
    "    my @res;\n    return @res if $k == 0;\n    my $m = scalar @$nums1;\n    my $n = scalar @$nums2;\n    return @res if $m == 0 || $n == 0;\n    my $max_k = $m * $n;\n    $k = $max_k if $k > $max_k;\n    my $i = 0;\n    my $j = 0;\n    while ($k > 0) {\n        my $min_i = $i;\n        my $min_j = $j;\n        for my $x ($i .. $m - 1) {\n            if ($nums1->[$x] + $nums2->[$j] < $nums1->[$min_i] + $nums2->[$min_j]) {\n                $min_i = $x;\n                $min_j = $j;\n            }\n        }\n        for my $y ($j + 1 .. $n - 1) {\n            if ($nums1->[$i] + $nums2->[$y] < $nums1->[$min_i] + $nums2->[$min_j]) {\n                $min_i = $i;\n                $min_j = $y;\n            }\n        }\n        push @res, [$nums1->[$min_i], $nums2->[$min_j]];\n        $i = $min_i;\n        $j = $min_j + 1;\n        $k--;\n    }\n    return @res;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i+1], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2) {\n        if($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i+1], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return @result;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum <= $nums1->[$i+1] + $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@res;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < scalar(@$nums1) && $j < scalar(@$nums2)) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum <= $k) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        } else {\n            $j++;\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    return \\@result if $len1 == 0 || $len2 == 0;\n    my $max = $nums1->[0] + $nums2->[0];\n    my $min = $nums1->[-1] + $nums2->[-1];\n    return \\@result if $max < $min;\n    my $count = 0;\n    for my $i (0 .. $len1 - 1) {\n        for my $j (0 .. $len2 - 1) {\n            my $sum = $nums1->[$i] + $nums2->[$j];\n            if ($sum <= $max) {\n                push @result, [$nums1->[$i], $nums2->[$j]];\n                $count++;\n            }\n            last if $count == $k;\n        }\n    }\n    return \\@result;\n}",
    "    my $len1 = @$nums1;\n    my $len2 = @$nums2;\n    my @result;\n    return \\@result if $len1 == 0 || $len2 == 0 || $k == 0;\n    my @heap;\n    my $i = 0;\n    my $j = 0;\n    for (1..$k) {\n        push @heap, [$i, $j, $nums1->[$i] + $nums2->[$j]];\n        $j++;\n        if ($j == $len2) {\n            $i++;\n            $j = 0;\n        }\n        last if $i == $len1;\n    }\n    while (@heap) {\n        my $node = shift @heap;\n        my($i, $j, $sum) = @$node;\n        push @result, [$nums1->[$i], $nums2->[$j]];\n        $j++;\n        if ($j == $len2) {\n            $i++;\n            $j = 0;\n        }\n        last if $i == $len1;\n        push @heap, [$i, $j, $nums1->[$i] + $nums2->[$j]];\n        @heap = sort {$a->[2] <=> $b->[2]} @heap;\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if($sum > 0) {\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my @res;\n    return @res if @$nums1 == 0 || @$nums2 == 0 || $k == 0;\n    my @heap;\n    my $i = 0;\n    while ($i < @$nums1 && $i < $k) {\n        push @heap, [$nums1->[$i] + $nums2->[0], $i, 0];\n        $i++;\n    }\n    while ($k-- > 0) {\n        my $t = shift @heap;\n        push @res, [$nums1->[$t->[1]], $nums2->[$t->[2]]];\n        if ($t->[2] == $#$nums2) {\n            next;\n        }\n        push @heap, [$nums1->[$t->[1]] + $nums2->[$t->[2] + 1], $t->[1], $t->[2] + 1];\n        @heap = sort {$a->[0] <=> $b->[0]} @heap;\n    }\n    return @res;\n}",
    "    my @result;\n    my @heap;\n    my $i = 0;\n    my $j = 0;\n    while ($i < scalar(@$nums1) && $j < scalar(@$nums2)) {\n        my $pair = [$nums1->[$i], $nums2->[$j]];\n        push @heap, $pair;\n        $i++;\n        $j++;\n    }\n    while ($i < scalar(@$nums1)) {\n        my $pair = [$nums1->[$i], $nums2->[0]];\n        push @heap, $pair;\n        $i++;\n    }\n    while ($j < scalar(@$nums2)) {\n        my $pair = [$nums1->[0], $nums2->[$j]];\n        push @heap, $pair;\n        $j++;\n    }\n    my $count = 0;\n    while ($count < $k && scalar(@heap) > 0) {\n        my $pair = pop @heap;\n        push @result, $pair;\n        $count++;\n    }\n    return \\@result;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($i == 0 || $nums1->[$i] + $nums2->[$j-1] < $sum) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        } else {\n            push @res, [$nums1->[$i-1], $nums2->[$j]];\n            $j++;\n        }\n    }\n    while ($i < @$nums1 && @res < $k) {\n        push @res, [$nums1->[$i], $nums2->[$j-1]];\n        $i++;\n    }\n    while ($j < @$nums2 && @res < $k) {\n        push @res, [$nums1->[$i-1], $nums2->[$j]];\n        $j++;\n    }\n    return \\@res;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    my $min_len = $len1 < $len2 ? $len1 : $len2;\n    my $max_len = $len1 > $len2 ? $len1 : $len2;\n    my $min_idx = 0;\n    my $max_idx = 0;\n    my $min_arr = $len1 < $len2 ? $nums1 : $nums2;\n    my $max_arr = $len1 > $len2 ? $nums1 : $nums2;\n    my $res = [];\n    while ($min_idx < $min_len && $max_idx < $max_len && $k > 0) {\n        my $min_val = $min_arr->[$min_idx];\n        my $max_val = $max_arr->[$max_idx];\n        my $sum = $min_val + $max_val;\n        my $i = $max_idx;\n        while ($i < $max_len && $max_arr->[$i] <= $sum) {\n            push @$res, [$min_val, $max_arr->[$i]];\n            $i++;\n            $k--;\n            last if $k == 0;\n        }\n        $max_idx = $i;\n        $min_idx++;\n    }\n    return $res;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum < $nums1->[$i+1] + $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@res;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i + 1] + $nums2->[$j + 1]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    for my $i (0..$#$nums1) {\n        for my $j (0..$#$nums2) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n        }\n    }\n    @result = sort { $a->[0] + $a->[1] <=> $b->[0] + $b->[1] } @result;\n    return [@result[0..$k-1]];\n}",
    "    my @result;\n    my $n1 = scalar @$nums1;\n    my $n2 = scalar @$nums2;\n    my $i = 0;\n    my $j = 0;\n    my $count = 0;\n    while ($i < $n1 && $j < $n2 && $count < $k) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n        $count++;\n    }\n    return \\@result;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    return [] if $len1 == 0 || $len2 == 0;\n    my $heap = [];\n    my $res = [];\n    push @$heap, [$nums1->[0] + $nums2->[0], 0, 0];\n    while (@$heap && @$res < $k) {\n        my $cur = shift @$heap;\n        push @$res, [$nums1->[$cur->[1]], $nums2->[$cur->[2]]];\n        if ($cur->[1] + 1 < $len1) {\n            push @$heap, [$nums1->[$cur->[1] + 1] + $nums2->[$cur->[2]], $cur->[1] + 1, $cur->[2]];\n        }\n        if ($cur->[1] == 0 && $cur->[2] + 1 < $len2) {\n            push @$heap, [$nums1->[$cur->[1]] + $nums2->[$cur->[2] + 1], $cur->[1], $cur->[2] + 1];\n        }\n    }\n    return $res;\n}",
    "    my @result;\n    my $m = scalar @$nums1;\n    my $n = scalar @$nums2;\n    return [] if $m == 0 || $n == 0;\n    my $i = 0;\n    my $j = 0;\n    while ($i < $m && $j < $n && $k > 0) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum < 0) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $k--;\n        } elsif ($sum > 0) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n            $k--;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n            $k--;\n        }\n    }\n    return \\@result;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        if($nums1->[$i] < $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        }\n    }\n    return \\@res;\n}",
    "    my @result;\n    my @heap;\n    my $n1 = scalar @$nums1;\n    my $n2 = scalar @$nums2;\n    return [] if $n1 == 0 || $n2 == 0;\n    my $i = 0;\n    while ($i < $n1 && $i < $k) {\n        push @heap, [$nums1->[$i] + $nums2->[0], $i, 0];\n        $i++;\n    }\n    while ($k-- > 0) {\n        my $top = shift @heap;\n        last unless defined $top;\n        push @result, [$nums1->[$top->[1]], $nums2->[$top->[2]]];\n        if ($top->[2] < $n2 - 1) {\n            push @heap, [$nums1->[$top->[1]] + $nums2->[$top->[2] + 1], $top->[1], $top->[2] + 1];\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my @heap;\n    my $m = scalar @$nums1;\n    my $n = scalar @$nums2;\n    return \\@result if $m == 0 || $n == 0 || $k == 0;\n    for(my $i = 0; $i < $m; $i++) {\n        push @heap, [$nums1->[$i] + $nums2->[0], $i, 0];\n    }\n    build_min_heap(\\@heap);\n    for(my $i = 0; $i < $k; $i++) {\n        last if scalar @heap == 0;\n        my $pair = shift @heap;\n        push @result, [$nums1->[$pair->[1]], $nums2->[$pair->[2]]];\n        if($pair->[2] < $n - 1) {\n            push @heap, [$nums1->[$pair->[1]] + $nums2->[$pair->[2] + 1], $pair->[1], $pair->[2] + 1];\n            min_heapify(\\@heap, 0);\n        }\n    }\n    return \\@result;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        push @res, [$nums1->[$i], $nums2->[$j]];\n        if ($i == @$nums1 - 1) {\n            $j++;\n        } elsif ($j == @$nums2 - 1) {\n            $i++;\n        } elsif ($nums1->[$i] + $nums2->[$j + 1] < $nums1->[$i + 1] + $nums2->[$j]) {\n            $j++;\n        } else {\n            $i++;\n        }\n    }\n    return \\@res;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if($sum <= $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum <= $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($i + 1 < @$nums1 && $nums1->[$i + 1] + $nums2->[$j] < $sum) {\n            $i++;\n        } elsif ($j + 1 < @$nums2 && $nums1->[$i] + $nums2->[$j + 1] < $sum) {\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n        }\n    }\n    return \\@result;\n}",
    "    my $len1 = scalar(@$nums1);\n    my $len2 = scalar(@$nums2);\n    my @res;\n    if ($len1 == 0 || $len2 == 0 || $k == 0) {\n        return \\@res;\n    }\n    my $min_heap = new Heap::Binary();\n    $min_heap->add([0, 0, $nums1->[0] + $nums2->[0]]);\n    my %visited;\n    $visited{0}{0} = 1;\n    while ($k > 0 && $min_heap->size() > 0) {\n        my $pair = $min_heap->extract_top();\n        my $i = $pair->[0];\n        my $j = $pair->[1];\n        push @res, [$nums1->[$i], $nums2->[$j]];\n        $k--;\n        if ($i + 1 < $len1 && !exists $visited{$i + 1}{$j}) {\n            $min_heap->add([$i + 1, $j, $nums1->[$i + 1] + $nums2->[$j]]);\n            $visited{$i + 1}{$j} = 1;\n        }\n        if ($j + 1 < $len2 && !exists $visited{$i}{$j + 1}) {\n            $min_heap->add([$i, $j + 1, $nums1->[$i] + $nums2->[$j + 1]]);\n            $visited{$i}{$j + 1} = 1;\n        }\n    }\n    return \\@res;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if($i == 0 || $j == 0 || $sum < $nums1->[$i-1] + $nums2->[$j-1]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            if($j == @$nums2 - 1) {\n                $i++;\n            } else {\n                $j++;\n            }\n        } else {\n            $i++;\n        }\n    }\n    return \\@res;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i+1], $nums2->[$j]];\n            $i++;\n        }\n        if (@result == $k) {\n            last;\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i + 1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my @heap;\n    my %seen;\n    my $i = 0;\n    my $j = 0;\n    my $count = 0;\n    while ($count < $k && $i < @$nums1 && $j < @$nums2) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if (!exists $seen{$i}{$j}) {\n            $seen{$i}{$j} = 1;\n            push @heap, [$sum, $i, $j];\n            $count++;\n        }\n        if ($j + 1 < @$nums2 && !exists $seen{$i}{$j + 1}) {\n            $seen{$i}{$j + 1} = 1;\n            push @heap, [$nums1->[$i] + $nums2->[$j + 1], $i, $j + 1];\n            $count++;\n        }\n        if ($i + 1 < @$nums1 && !exists $seen{$i + 1}{$j}) {\n            $seen{$i + 1}{$j} = 1;\n            push @heap, [$nums1->[$i + 1] + $nums2->[$j], $i + 1, $j];\n            $count++;\n        }\n        my $min = pop @heap;\n        $i = $min->[1];\n        $j = $min->[2];\n        push @result, [$nums1->[$i], $nums2->[$j]];\n    }\n    return \\@result;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i + 1] + $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i + 1], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@res;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum < 0) {\n            $i++;\n        } elsif ($sum > 0) {\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n        }\n    }\n    return \\@result;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    my @res;\n    my $i = 0;\n    my $j = 0;\n    my $count = 0;\n    while ($i < $len1 && $j < $len2 && $count < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum < $nums1->[$i+1] + $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n        $count++;\n    }\n    return \\@res;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum < 0) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        } elsif ($sum > 0) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n        }\n        last if @result == $k;\n    }\n    return \\@result;\n}",
    "    my @res;\n    my %map;\n    for my $i (0..$#$nums1) {\n        for my $j (0..$#$nums2) {\n            my $sum = $nums1->[$i] + $nums2->[$j];\n            push @{$map{$sum}}, [$nums1->[$i], $nums2->[$j]];\n        }\n    }\n    my @keys = sort {$a <=> $b} keys %map;\n    for my $key (@keys) {\n        for my $pair (@{$map{$key}}) {\n            push @res, $pair;\n            last if @res == $k;\n        }\n        last if @res == $k;\n    }\n    return \\@res;\n}",
    "    my @result;\n    my @heap;\n    my $n1 = scalar @$nums1;\n    my $n2 = scalar @$nums2;\n    return [] if $n1 == 0 || $n2 == 0;\n    for (my $i = 0; $i < $n1; $i++) {\n        push @heap, [$nums1->[$i] + $nums2->[0], $i, 0];\n    }\n    while ($k > 0 && @heap) {\n        my $pair = shift @heap;\n        push @result, [$nums1->[$pair->[1]], $nums2->[$pair->[2]]];\n        $k--;\n        if ($pair->[2] < $n2 - 1) {\n            push @heap, [$nums1->[$pair->[1]] + $nums2->[$pair->[2] + 1], $pair->[1], $pair->[2] + 1];\n        }\n        @heap = sort {$a->[0] <=> $b->[0]} @heap;\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($i + 1 < @$nums1 && $nums1->[$i + 1] + $nums2->[$j] < $sum) {\n            $i++;\n        } elsif ($j + 1 < @$nums2 && $nums1->[$i] + $nums2->[$j + 1] < $sum) {\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n        }\n    }\n    return \\@result;\n}",
    "    my $len1 = scalar(@$nums1);\n    my $len2 = scalar(@$nums2);\n    my $len = $len1 * $len2;\n    my @pairs;\n    for (my $i = 0; $i < $len1; $i++) {\n        for (my $j = 0; $j < $len2; $j++) {\n            push @pairs, [$nums1->[$i], $nums2->[$j]];\n        }\n    }\n    my @sorted = sort {$a->[0] + $a->[1] <=> $b->[0] + $b->[1]} @pairs;\n    my @res;\n    for (my $i = 0; $i < $k; $i++) {\n        push @res, $sorted[$i];\n    }\n    return \\@res;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    return [] if $len1 == 0 || $len2 == 0;\n    my $max_len = $len1 * $len2;\n    $k = $max_len if $k > $max_len;\n    my $result = [];\n    my $heap = [];\n    push @$heap, [0, 0, $nums1->[0] + $nums2->[0]];\n    my %visited;\n    $visited{\"0,0\"} = 1;\n    while (scalar @$result < $k) {\n        my $pair = shift @$heap;\n        push @$result, [$nums1->[$pair->[0]], $nums2->[$pair->[1]]];\n        my $i = $pair->[0];\n        my $j = $pair->[1];\n        if ($i + 1 < $len1 && !$visited{\"$i,$j\"}) {\n            push @$heap, [$i + 1, $j, $nums1->[$i + 1] + $nums2->[$j]];\n            $visited{\"$i,$j\"} = 1;\n        }\n        if ($j + 1 < $len2 && !$visited{\"$i,$j\"}) {\n            push @$heap, [$i, $j + 1, $nums1->[$i] + $nums2->[$j + 1]];\n            $visited{\"$i,$j\"} = 1;\n        }\n    }\n    return $result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2) {\n        if ($nums1->[$i] + $nums2->[$j] <= $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i+1], $nums2->[$j]];\n            $i++;\n        }\n        last if @result == $k;\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if($sum <= $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i + 1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i + 1], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my @heap;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2) {\n        push @heap, [$nums1->[$i] + $nums2->[$j], $i, $j];\n        $i++;\n    }\n    while($k > 0 && @heap) {\n        my $pair = shift @heap;\n        push @result, [$nums1->[$pair->[1]], $nums2->[$pair->[2]]];\n        $k--;\n        if($pair->[2] < @$nums2 - 1) {\n            push @heap, [$nums1->[$pair->[1]] + $nums2->[$pair->[2] + 1], $pair->[1], $pair->[2] + 1];\n        }\n    }\n    return @result;\n}",
    "    my @result;",
    "    my $len1 = scalar(@$nums1);\n    my $len2 = scalar(@$nums2);\n    my $i = 0;\n    my $j = 0;\n    my $res = [];\n    while ($i < $len1 && $j < $len2 && scalar(@$res) < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($i + 1 < $len1 && $j + 1 < $len2) {\n            my $sum1 = $nums1->[$i] + $nums2->[$j + 1];\n            my $sum2 = $nums1->[$i + 1] + $nums2->[$j];\n            if ($sum1 < $sum2) {\n                $j++;\n            } else {\n                $i++;\n            }\n        } elsif ($i + 1 < $len1) {\n            $i++;\n        } elsif ($j + 1 < $len2) {\n            $j++;\n        } else {\n            last;\n        }\n        push @$res, [$nums1->[$i], $nums2->[$j]];\n    }\n    return $res;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && $k > 0) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i+1], $nums2->[$j]];\n            $i++;\n        }\n        $k--;\n    }\n    return \\@res;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum <= $nums1->[$i+1] + $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i+1], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@res;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && $k > 0) {\n        if ($nums1->[$i] < $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        }\n        $k--;\n    }\n    while ($i < @$nums1 && $k > 0) {\n        push @res, [$nums1->[$i], $nums2->[$j]];\n        $i++;\n        $k--;\n    }\n    while ($j < @$nums2 && $k > 0) {\n        push @res, [$nums1->[$i], $nums2->[$j]];\n        $j++;\n        $k--;\n    }\n    return \\@res;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2) {\n        push @res, [$nums1->[$i], $nums2->[$j]];\n        if ($i + 1 < @$nums1 && $j + 1 < @$nums2) {\n            if ($nums1->[$i + 1] + $nums2->[$j] < $nums1->[$i] + $nums2->[$j + 1]) {\n                $i++;\n            } else {\n                $j++;\n            }\n        } elsif ($i + 1 < @$nums1) {\n            $i++;\n        } else {\n            $j++;\n        }\n        last if @res == $k;\n    }\n    return @res;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if($sum <= $nums1->[$i+1] + $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i+1], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@res;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    my $i = 0;\n    my $j = 0;\n    my @res;\n    my $count = 0;\n    while ($i < $len1 && $j < $len2) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum < 0) {\n            $i++;\n        } elsif ($sum > 0) {\n            $j++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $count++;\n            if ($count == $k) {\n                last;\n            }\n            $i++;\n            $j++;\n        }\n    }\n    return \\@res;\n}",
    "    my @res;\n    my @heap;\n    for my $i (0..$#$nums1) {\n        for my $j (0..$#$nums2) {\n            my $sum = $nums1->[$i] + $nums2->[$j];\n            if (@heap < $k) {\n                push @heap, [$sum, $i, $j];\n                heapify(\\@heap, scalar @heap - 1);\n            } elsif ($sum < $heap[0]->[0]) {\n                $heap[0] = [$sum, $i, $j];\n                heapify(\\@heap, 0);\n            }\n        }\n    }\n    for my $i (0..$k-1) {\n        last if $i >= @heap;\n        my $node = pop @heap;\n        push @res, [$nums1->[$node->[1]], $nums2->[$node->[2]]];\n    }\n    return \\@res;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i+1], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my $m = scalar(@$nums1);\n    my $n = scalar(@$nums2);\n    my @result;\n    my @heap;\n    my $i = 0;\n    my $j = 0;\n    my $count = 0;\n    while ($i < $m && $j < $n && $count < $k) {\n        my $pair = [$nums1->[$i], $nums2->[$j]];\n        push @heap, $pair;\n        $count++;\n        $i++;\n        $j++;\n    }\n    while ($count < $k) {\n        my $pair = [$nums1->[$i], $nums2->[$j]];\n        push @heap, $pair;\n        $count++;\n        $i++;\n        $j++;\n    }\n    heapify(\\@heap);\n    while ($count < $k) {\n        my $pair = pop @heap;\n        push @result, $pair;\n        $count++;\n    }\n    return \\@result;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($i + 1 < @$nums1 && $nums1->[$i + 1] + $nums2->[$j] < $sum) {\n            $i++;\n        } elsif ($j + 1 < @$nums2 && $nums1->[$i] + $nums2->[$j + 1] < $sum) {\n            $j++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n        }\n    }\n    return \\@res;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    my $n1 = scalar @$nums1;\n    my $n2 = scalar @$nums2;\n    while ($i < $n1 and $j < $n2 and scalar @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($i + 1 < $n1 and $j + 1 < $n2) {\n            my $sum1 = $nums1->[$i + 1] + $nums2->[$j];\n            my $sum2 = $nums1->[$i] + $nums2->[$j + 1];\n            if ($sum1 < $sum2) {\n                push @result, [$nums1->[$i + 1], $nums2->[$j]];\n                $i++;\n            } else {\n                push @result, [$nums1->[$i], $nums2->[$j + 1]];\n                $j++;\n            }\n        } elsif ($i + 1 < $n1) {\n            push @result, [$nums1->[$i + 1], $nums2->[$j]];\n            $i++;\n        } elsif ($j + 1 < $n2) {\n            push @result, [$nums1->[$i], $nums2->[$j + 1]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n        }\n    }\n    return \\@result;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    my $len1 = scalar(@$nums1);\n    my $len2 = scalar(@$nums2);\n    while ($i < $len1 && $j < $len2 && scalar(@res) < $k) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i + 1] + $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@res;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2) {\n        push @result, [$nums1->[$i], $nums2->[$j]];\n        if ($i + 1 < @$nums1 && $j + 1 < @$nums2) {\n            if ($nums1->[$i + 1] + $nums2->[$j] < $nums1->[$i] + $nums2->[$j + 1]) {\n                $i++;\n            } else {\n                $j++;\n            }\n        } elsif ($i + 1 < @$nums1) {\n            $i++;\n        } else {\n            $j++;\n        }\n        last if @result == $k;\n    }\n    return @result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if($sum <= $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my @res;\n    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    return [] if $len1 == 0 || $len2 == 0;\n    my $min_heap = Heap::Simple->new(\n        order => '<',\n        elements => 'Any',\n    );\n    $min_heap->insert([0, 0, $nums1->[0] + $nums2->[0]]);\n    my %seen;\n    while ($k-- > 0 && $min_heap->count > 0) {\n        my $pair = $min_heap->extract_top;\n        my($i, $j, $sum) = @$pair;\n        push @res, [$nums1->[$i], $nums2->[$j]];\n        if ($j + 1 < $len2 && !$seen{\"$i,$j+1\"}) {\n            $min_heap->insert([$i, $j + 1, $nums1->[$i] + $nums2->[$j + 1]]);\n            $seen{\"$i,$j+1\"} = 1;\n        }\n        if ($i + 1 < $len1 && !$seen{\"$i+1,$j\"}) {\n            $min_heap->insert([$i + 1, $j, $nums1->[$i + 1] + $nums2->[$j]]);\n            $seen{\"$i+1,$j\"} = 1;\n        }\n    }\n    return \\@res;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@res;\n}",
    "    my @res;\n    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    return \\@res if $len1 == 0 || $len2 == 0 || $k == 0;\n    my $max = $nums1->[0] + $nums2->[0];\n    my $min = $nums1->[$len1-1] + $nums2->[$len2-1];\n    return \\@res if $max < $min;\n    my $mid = ($max + $min) / 2;\n    my $count = 0;\n    my $i = 0;\n    my $j = $len2 - 1;\n    while ($i < $len1 && $j >= 0) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum <= $mid) {\n            $count += $j + 1;\n            $i++;\n        } else {\n            $j--;\n        }\n    }\n    if ($count >= $k) {\n        my $nums2_copy = [@$nums2];\n        my $res = k_smallest_pairs($nums1, $nums2_copy, $k);\n        return $res;\n    } else {\n        my $nums1_copy = [@$nums1];\n        my $res = k_smallest_pairs($nums1_copy, $nums2, $k - $count);\n        return $res;\n    }\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum <= $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i+1], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($i + 1 < @$nums1 && $nums1->[$i + 1] + $nums2->[$j] < $sum) {\n            $i++;\n        } elsif ($j + 1 < @$nums2 && $nums1->[$i] + $nums2->[$j + 1] < $sum) {\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n        }\n    }\n    return \\@result;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if($sum <= $nums1->[$i+1] + $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i+1], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@res;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum <= $k) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        } else {\n            $j++;\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        if($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    my $count = 0;\n    while($count < $k) {\n        if($i >= scalar(@$nums1) || $j >= scalar(@$nums2)) {\n            last;\n        }\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if($i == 0 || $j == 0) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $count++;\n        } else {\n            my $last_sum = $result[-1][0] + $result[-1][1];\n            if($sum < $last_sum) {\n                push @result, [$nums1->[$i], $nums2->[$j]];\n                $count++;\n            }\n        }\n        if($i == scalar(@$nums1) - 1) {\n            $j++;\n        } elsif($j == scalar(@$nums2) - 1) {\n            $i++;\n        } else {\n            my $sum1 = $nums1->[$i + 1] + $nums2->[$j];\n            my $sum2 = $nums1->[$i] + $nums2->[$j + 1];\n            if($sum1 < $sum2) {\n                $i++;\n            } else {\n                $j++;\n            }\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if($sum <= $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i+1], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && $k > 0) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i+1], $nums2->[$j]];\n            $i++;\n        }\n        $k--;\n    }\n    return \\@res;\n}",
    "    my @pairs;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2) {\n        push @pairs, [$nums1->[$i], $nums2->[$j]];\n        if ($i < @$nums1 - 1 && $j < @$nums2 - 1) {\n            if ($nums1->[$i+1] + $nums2->[$j] < $nums1->[$i] + $nums2->[$j+1]) {\n                $i++;\n            } else {\n                $j++;\n            }\n        } elsif ($i < @$nums1 - 1) {\n            $i++;\n        } else {\n            $j++;\n        }\n    }\n    return \\@pairs;\n}",
    "    my @pairs;\n    for my $i (0..$#$nums1) {\n        for my $j (0..$#$nums2) {\n            push @pairs, [$nums1->[$i], $nums2->[$j]];\n        }\n    }\n    @pairs = sort { $a->[0] + $a->[1] <=> $b->[0] + $b->[1] } @pairs;\n    return [@pairs[0..$k-1]];\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && $k > 0) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum <= $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i+1], $nums2->[$j]];\n            $i++;\n        }\n        $k--;\n    }\n    while ($i < @$nums1 && $k > 0) {\n        push @result, [$nums1->[$i], $nums2->[$j]];\n        $i++;\n        $k--;\n    }\n    while ($j < @$nums2 && $k > 0) {\n        push @result, [$nums1->[$i], $nums2->[$j]];\n        $j++;\n        $k--;\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if($sum <= $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        if($nums1->[$i] < $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        }\n    }\n    return \\@result;\n}",
    "    my @res;\n    return @res if @$nums1 == 0 || @$nums2 == 0;\n    my $len1 = @$nums1;\n    my $len2 = @$nums2;\n    my $max = $nums1->[0] + $nums2->[0];\n    my $min = $nums1->[$len1 - 1] + $nums2->[$len2 - 1];\n    my $mid = ($max + $min) / 2;\n    my $count = 0;\n    for (my $i = 0; $i < $len1; $i++) {\n        for (my $j = 0; $j < $len2; $j++) {\n            if ($nums1->[$i] + $nums2->[$j] <= $mid) {\n                $count++;\n            }\n        }\n    }\n    if ($count >= $k) {\n        for (my $i = 0; $i < $len1; $i++) {\n            for (my $j = 0; $j < $len2; $j++) {\n                if ($nums1->[$i] + $nums2->[$j] <= $mid) {\n                    push @res, [$nums1->[$i], $nums2->[$j]];\n                }\n            }\n        }\n    } else {\n        for (my $i = 0; $i < $len1; $i++) {\n            for (my $j = 0; $j < $len2; $j++) {\n                if ($nums1->[$i] + $nums2->[$j] > $mid) {\n                    push @res, [$nums1->[$i], $nums2->[$j]];\n                }\n            }\n        }\n    }\n    @res = sort {$a->[0] + $a->[1] <=> $b->[0] + $b->[1]} @res;\n    return @res[0..$k-1];\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        if($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@res;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2) {\n        push @res, [$nums1->[$i], $nums2->[$j]];\n        if ($i == @$nums1 - 1) {\n            $j++;\n        } elsif ($j == @$nums2 - 1) {\n            $i++;\n        } elsif ($nums1->[$i] + $nums2->[$j + 1] < $nums1->[$i + 1] + $nums2->[$j]) {\n            $j++;\n        } else {\n            $i++;\n        }\n    }\n    return [@res[0 .. $k - 1]];\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if($sum < 0) {\n            $i++;\n        } elsif($sum > 0) {\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n        }\n    }\n    return \\@result;\n}",
    "    my @res;\n    my @pq;\n    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    return [] if $len1 == 0 || $len2 == 0;\n    for my $i (0..$len1-1) {\n        push @pq, [$nums1->[$i] + $nums2->[0], $i, 0];\n    }\n    while ($k-- > 0 && scalar @pq > 0) {\n        my $top = shift @pq;\n        push @res, [$nums1->[$top->[1]], $nums2->[$top->[2]]];\n        if ($top->[2] < $len2-1) {\n            push @pq, [$nums1->[$top->[1]] + $nums2->[$top->[2]+1], $top->[1], $top->[2]+1];\n        }\n    }\n    return \\@res;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while($i < scalar(@$nums1) && $j < scalar(@$nums2) && scalar(@result) < $k) {\n        if($nums1->[$i] + $nums2->[$j] < $nums1->[$i] + $nums2->[$j+1]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($i + 1 < @$nums1 && $nums1->[$i + 1] + $nums2->[$j] < $sum) {\n            $i++;\n        } elsif ($j + 1 < @$nums2 && $nums1->[$i] + $nums2->[$j + 1] < $sum) {\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my @heap;\n    my $size1 = scalar @$nums1;\n    my $size2 = scalar @$nums2;\n    return [] if $size1 == 0 || $size2 == 0;\n    for (my $i = 0; $i < $size1; $i++) {\n        push @heap, [$nums1->[$i] + $nums2->[0], $i, 0];\n    }\n    build_heap(\\@heap);\n    for (my $i = 0; $i < $k && $i < $size1 * $size2; $i++) {\n        my $pair = shift @heap;\n        push @result, [$nums1->[$pair->[1]], $nums2->[$pair->[2]]];\n        if ($pair->[2] < $size2 - 1) {\n            push @heap, [$nums1->[$pair->[1]] + $nums2->[$pair->[2] + 1], $pair->[1], $pair->[2] + 1];\n            heapify(\\@heap, 0);\n        }\n    }\n    return \\@result;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if($i + 1 < @$nums1 && $nums1->[$i + 1] + $nums2->[$j] < $sum) {\n            $i++;\n        } elsif($j + 1 < @$nums2 && $nums1->[$i] + $nums2->[$j + 1] < $sum) {\n            $j++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n        }\n    }\n    return \\@res;\n}",
    "    my @res;\n    my @queue;\n    my $i = 0;\n    my $j = 0;\n    push @queue, [$i, $j, $nums1->[$i] + $nums2->[$j]];\n    while($k--) {\n        my $cur = shift @queue;\n        push @res, [$nums1->[$cur->[0]], $nums2->[$cur->[1]]];\n        if($cur->[0] < $#$nums1 && $cur->[1] == 0) {\n            push @queue, [$cur->[0] + 1, 0, $nums1->[$cur->[0] + 1] + $nums2->[0]];\n        }\n        if($cur->[1] < $#$nums2) {\n            push @queue, [$cur->[0], $cur->[1] + 1, $nums1->[$cur->[0]] + $nums2->[$cur->[1] + 1]];\n        }\n    }\n    return \\@res;\n}",
    "    my @res;\n    return @res if @$nums1 == 0 || @$nums2 == 0;\n    my $i = 0;\n    my $j = 0;\n    while(@res < $k) {\n        if($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j+1]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i+1], $nums2->[$j+1]];\n            $i++;\n        }\n    }\n    return @res;\n}",
    "    my @result;\n    my @queue;\n    my $i = 0;\n    my $j = 0;\n    push @queue, [0, 0];\n    while (@queue && @result < $k) {\n        my $pair = shift @queue;\n        my $i = $pair->[0];\n        my $j = $pair->[1];\n        push @result, [$nums1->[$i], $nums2->[$j]];\n        if ($j + 1 < @$nums2) {\n            push @queue, [$i, $j + 1];\n        }\n        if ($j == 0 && $i + 1 < @$nums1) {\n            push @queue, [$i + 1, $j];\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2) {\n        push @result, [$nums1->[$i], $nums2->[$j]];\n        if ($i == @$nums1 - 1) {\n            $j++;\n        } elsif ($j == @$nums2 - 1) {\n            $i++;\n        } elsif ($nums1->[$i] + $nums2->[$j + 1] < $nums1->[$i + 1] + $nums2->[$j]) {\n            $j++;\n        } else {\n            $i++;\n        }\n        last if @result == $k;\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($i + 1 < @$nums1 && $nums1->[$i + 1] + $nums2->[$j] < $sum) {\n            $i++;\n        } elsif ($j + 1 < @$nums2 && $nums1->[$i] + $nums2->[$j + 1] < $sum) {\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n        }\n    }\n    return \\@result;\n}",
    "    my @pairs;\n    for my $i (0..$#$nums1) {\n        for my $j (0..$#$nums2) {\n            push @pairs, [$nums1->[$i], $nums2->[$j]];\n        }\n    }\n    @pairs = sort { $a->[0] + $a->[1] <=> $b->[0] + $b->[1] } @pairs;\n    return [@pairs[0..$k-1]];\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        if($nums1->[$i] + $nums2->[$j] <= $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i+1], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my @res;\n    my @pq;\n    my $i = 0;\n    my $j = 0;\n    push @pq, [0, 0, $nums1->[0] + $nums2->[0]];\n    while ($k > 0 && $i < @$nums1 && $j < @$nums2) {\n        my $min = pop @pq;\n        push @res, [$nums1->[$min->[0]], $nums2->[$min->[1]]];\n        $k--;\n        if ($min->[0] + 1 < @$nums1) {\n            push @pq, [$min->[0] + 1, $min->[1], $nums1->[$min->[0] + 1] + $nums2->[$min->[1]]];\n        }\n        if ($min->[0] == 0 && $min->[1] + 1 < @$nums2) {\n            push @pq, [$min->[0], $min->[1] + 1, $nums1->[$min->[0]] + $nums2->[$min->[1] + 1]];\n        }\n    }\n    return \\@res;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($i + 1 < @$nums1 && $nums1->[$i + 1] + $nums2->[$j] < $sum) {\n            $i++;\n        } elsif ($j + 1 < @$nums2 && $nums1->[$i] + $nums2->[$j + 1] < $sum) {\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n        }\n    }\n    return \\@result;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i+1], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@res;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    return [] if $len1 == 0 || $len2 == 0;\n    my $min_heap = [];\n    my $res = [];\n    my $count = 0;\n    my $i = 0;\n    my $j = 0;\n    while($i < $len1 && $j < $len2) {\n        my $pair = [$nums1->[$i], $nums2->[$j]];\n        push @$min_heap, $pair;\n        $i++;\n        $j++;\n    }\n    while($count < $k && scalar @$min_heap > 0) {\n        my $pair = shift @$min_heap;\n        push @$res, $pair;\n        $count++;\n    }\n    return $res;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < scalar(@$nums1) && $j < scalar(@$nums2) && scalar(@result) < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($i + 1 < scalar(@$nums1) && $nums1->[$i + 1] + $nums2->[$j] < $sum) {\n            $i++;\n        } elsif ($j + 1 < scalar(@$nums2) && $nums1->[$i] + $nums2->[$j + 1] < $sum) {\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n        }\n    }\n    return \\@result;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        if($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@res;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2) {\n        if($nums1->[$i] < $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        }\n        last if @res == $k;\n    }\n    return \\@res;\n}",
    "    my @pairs;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @pairs < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($i + 1 < @$nums1 && $nums1->[$i + 1] + $nums2->[$j] < $sum) {\n            $i++;\n        } elsif ($j + 1 < @$nums2 && $nums1->[$i] + $nums2->[$j + 1] < $sum) {\n            $j++;\n        } else {\n            push @pairs, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n        }\n    }\n    return \\@pairs;\n}",
    "    my @ret;\n    my $i = 0;\n    my $j = 0;\n    my $count = 0;\n    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    while ($count < $k && $i < $len1 && $j < $len2) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum < 0) {\n            $i++;\n        } elsif ($sum > 0) {\n            $j++;\n        } else {\n            push @ret, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n            $count++;\n        }\n    }\n    return \\@ret;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i+1], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@res;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        if($nums1->[$i] + $nums2->[$j] <= $nums1->[$i + 1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i + 1], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    my @res;\n    return \\@res if $len1 == 0 || $len2 == 0;\n    my $pq = new PriorityQueue;\n    $pq->enqueue(0, 0, $nums1->[0] + $nums2->[0]);\n    my %visited;\n    $visited{0}{0} = 1;\n    while ($k-- > 0 && !$pq->isEmpty) {\n        my($i, $j, $sum) = $pq->dequeue;\n        push @res, [$nums1->[$i], $nums2->[$j]];\n        if ($i + 1 < $len1 && !$visited{$i + 1}{$j}) {\n            $pq->enqueue($i + 1, $j, $nums1->[$i + 1] + $nums2->[$j]);\n            $visited{$i + 1}{$j} = 1;\n        }\n        if ($j + 1 < $len2 && !$visited{$i}{$j + 1}) {\n            $pq->enqueue($i, $j + 1, $nums1->[$i] + $nums2->[$j + 1]);\n            $visited{$i}{$j + 1} = 1;\n        }\n    }\n    return \\@res;\n}",
    "    return [] if @$nums1 == 0 || @$nums2 == 0;\n    my @res;\n    my $min_heap = Heap::Simple->new(\n        order => '<',\n        elements => 'Any',\n        use_extract_priority => 1,\n    );\n    $min_heap->insert([0, 0, $nums1->[0] + $nums2->[0]]);\n    my %visited;\n    while ($min_heap->count > 0 && @res < $k) {\n        my $pair = $min_heap->extract_top;\n        my($i, $j, $sum) = @$pair;\n        push @res, [$nums1->[$i], $nums2->[$j]];\n        if ($i + 1 < @$nums1 && !$visited{\"$i,$j\"}) {\n            $min_heap->insert([$i + 1, $j, $nums1->[$i + 1] + $nums2->[$j]]);\n            $visited{\"$i,$j\"} = 1;\n        }\n        if ($j + 1 < @$nums2 && !$visited{\"$i,$j\"}) {\n            $min_heap->insert([$i, $j + 1, $nums1->[$i] + $nums2->[$j + 1]]);\n            $visited{\"$i,$j\"} = 1;\n        }\n    }\n    return \\@res;\n}",
    "    my @result;\n    return @result if @$nums1 == 0 || @$nums2 == 0;\n    my @heap;\n    my $i = 0;\n    my $j = 0;\n    my $count = 0;\n    while ($count < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($i < @$nums1 && $j < @$nums2) {\n            push @heap, [$sum, $i, $j];\n            $i++;\n        }\n        if ($i == @$nums1) {\n            $j++;\n            $i = 0;\n        }\n        $count++;\n    }\n    make_heap(\\@heap);\n    while ($count < @$nums1 * @$nums2) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum < $heap[0][0]) {\n            pop @heap;\n            push @heap, [$sum, $i, $j];\n            make_heap(\\@heap);\n        }\n        $i++;\n        if ($i == @$nums1) {\n            $j++;\n            $i = 0;\n        }\n        $count++;\n    }\n    for my $pair (@heap) {\n        push @result, [$nums1->[$pair->[1]], $nums2->[$pair->[2]]];\n    }\n    return @result;\n}",
    "    my @res;\n    my $n1 = scalar @$nums1;\n    my $n2 = scalar @$nums2;\n    my $i = 0;\n    my $j = 0;\n    while ($i < $n1 && $j < $n2 && scalar @res < $k) {\n        if ($nums1->[$i] < $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        }\n    }\n    return \\@res;\n}",
    "    my @pairs;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2) {\n        push @pairs, [$nums1->[$i], $nums2->[$j]];\n        if ($i + 1 < @$nums1 && $j + 1 < @$nums2) {\n            if ($nums1->[$i + 1] + $nums2->[$j] < $nums1->[$i] + $nums2->[$j + 1]) {\n                $i++;\n            } else {\n                $j++;\n            }\n        } elsif ($i + 1 < @$nums1) {\n            $i++;\n        } else {\n            $j++;\n        }\n    }\n    return \\@pairs;\n}",
    "    my $size1 = scalar @$nums1;\n    my $size2 = scalar @$nums2;\n    my $min_size = $size1 < $size2 ? $size1 : $size2;\n    my $max_size = $size1 > $size2 ? $size1 : $size2;\n    my $size = $min_size * $max_size;\n    my $result = [];\n    my $pairs = [];\n    my $i = 0;\n    my $j = 0;\n    my $count = 0;\n    while ($count < $size) {\n        my $pair = [$nums1->[$i], $nums2->[$j]];\n        push @$pairs, $pair;\n        if ($i < $min_size - 1) {\n            $i++;\n        } else {\n            $j++;\n        }\n        $count++;\n    }\n    my @sorted_pairs = sort { $a->[0] + $a->[1] <=> $b->[0] + $b->[1] } @$pairs;\n    for (my $i = 0; $i < $k; $i++) {\n        push @$result, $sorted_pairs[$i];\n    }\n    return $result;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    my $max_len = $len1 > $len2 ? $len1 : $len2;\n    my $min_len = $len1 < $len2 ? $len1 : $len2;\n    my $max_k = $max_len * $min_len;\n    $k = $max_k if $k > $max_k;\n    my @result;\n    my $i = 0;\n    my $j = 0;\n    while($k > 0) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if($len1 > $len2) {\n            if($i == $len1 - 1) {\n                push @result, [$nums1->[$i], $nums2->[$j]];\n                $j++;\n            } else {\n                my $next_sum = $nums1->[$i+1] + $nums2->[$j];\n                if($next_sum < $sum) {\n                    $i++;\n                } else {\n                    push @result, [$nums1->[$i], $nums2->[$j]];\n                    $j++;\n                }\n            }\n        } else {\n            if($j == $len2 - 1) {\n                push @result, [$nums1->[$i], $nums2->[$j]];\n                $i++;\n            } else {\n                my $next_sum = $nums1->[$i] + $nums2->[$j+1];\n                if($next_sum < $sum) {\n                    $j++;\n                } else {\n                    push @result, [$nums1->[$i], $nums2->[$j]];\n                    $i++;\n                }\n            }\n        }\n        $k--;\n    }\n    return \\@result;\n}",
    "    my @result;\n    for my $i (0..$#$nums1) {\n        for my $j (0..$#$nums2) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n        }\n    }\n    @result = sort { $a->[0] + $a->[1] <=> $b->[0] + $b->[1] } @result;\n    return [@result[0..$k-1]];\n}",
    "    my @result;\n    my @heap;\n    my %visited;\n    my $size1 = scalar @$nums1;\n    my $size2 = scalar @$nums2;\n    return [] if $size1 == 0 || $size2 == 0;\n    push @heap, [$nums1->[0] + $nums2->[0], 0, 0];\n    $visited{0}{0} = 1;\n    while (@heap && scalar @result < $k) {\n        my $pair = pop @heap;\n        push @result, [$nums1->[$pair->[1]], $nums2->[$pair->[2]]];\n        if ($pair->[1] + 1 < $size1 && !$visited{$pair->[1] + 1}{$pair->[2]}) {\n            push @heap, [$nums1->[$pair->[1] + 1] + $nums2->[$pair->[2]], $pair->[1] + 1, $pair->[2]];\n            $visited{$pair->[1] + 1}{$pair->[2]} = 1;\n        }\n        if ($pair->[2] + 1 < $size2 && !$visited{$pair->[1]}{$pair->[2] + 1}) {\n            push @heap, [$nums1->[$pair->[1]] + $nums2->[$pair->[2] + 1], $pair->[1], $pair->[2] + 1];\n            $visited{$pair->[1]}{$pair->[2] + 1} = 1;\n        }\n    }\n    return \\@result;\n}",
    "    my @pairs;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @pairs < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($i < @$nums1 - 1 && $nums1->[$i + 1] + $nums2->[$j] < $sum) {\n            $i++;\n        } elsif ($j < @$nums2 - 1 && $nums1->[$i] + $nums2->[$j + 1] < $sum) {\n            $j++;\n        } else {\n            push @pairs, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n        }\n    }\n    return \\@pairs;\n}",
    "    my @res;\n    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    return [] if $len1 == 0 || $len2 == 0;\n    my $len = $len1 * $len2;\n    my $i = 0;\n    my $j = 0;\n    my $count = 0;\n    my $min = $nums1->[0] + $nums2->[0];\n    my $min_i = 0;\n    my $min_j = 0;\n    while ($count < $k && $count < $len) {\n        $min = $nums1->[$i] + $nums2->[$j];\n        $min_i = $i;\n        $min_j = $j;\n        if ($i + 1 < $len1 && $nums1->[$i + 1] + $nums2->[$j] < $min) {\n            $min = $nums1->[$i + 1] + $nums2->[$j];\n            $min_i = $i + 1;\n            $min_j = $j;\n        }\n        if ($j + 1 < $len2 && $nums1->[$i] + $nums2->[$j + 1] < $min) {\n            $min = $nums1->[$i] + $nums2->[$j + 1];\n            $min_i = $i;\n            $min_j = $j + 1;\n        }\n        push @res, [$nums1->[$min_i], $nums2->[$min_j]];\n        $i = $min_i;\n        $j = $min_j;\n        $count++;\n    }\n    return \\@res;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($i + 1 < @$nums1 && $nums1->[$i + 1] + $nums2->[$j] < $sum) {\n            $i++;\n        } elsif ($j + 1 < @$nums2 && $nums1->[$i] + $nums2->[$j + 1] < $sum) {\n            $j++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n        }\n    }\n    return \\@res;\n}",
    "    my @res;\n    return @res if @$nums1 == 0 || @$nums2 == 0;\n    my $i = 0;\n    my $j = 0;\n    while ($k--) {\n        if ($nums1->[$i] + $nums2->[$j] <= $nums1->[$i+1] + $nums2->[$j+1]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++ if $j < @$nums2 - 1;\n        } else {\n            push @res, [$nums1->[$i+1], $nums2->[$j+1]];\n            $i++ if $i < @$nums1 - 1;\n        }\n    }\n    return @res;\n}",
    "    my @pairs;\n    for my $i (0..$#$nums1) {\n        for my $j (0..$#$nums2) {\n            push @pairs, [$nums1->[$i], $nums2->[$j]];\n        }\n    }\n    @pairs = sort { $a->[0] + $a->[1] <=> $b->[0] + $b->[1] } @pairs;\n    return [@pairs[0..$k-1]];\n}",
    "\n    my @result;\n    my $i = 0;\n    my $j = 0;",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        if($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i+1], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return @result;\n}",
    "    my @res;\n    return @res if @$nums1 == 0 || @$nums2 == 0;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        if($nums1->[$i] < $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        }\n    }\n    return @res;\n}",
    "    my @res;\n    for my $i (0..$#$nums1) {\n        for my $j (0..$#$nums2) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n        }\n    }\n    @res = sort { $a->[0] + $a->[1] <=> $b->[0] + $b->[1] } @res;\n    return [@res[0..$k-1]];\n}",
    "    my @pairs;\n    for my $i (0 .. $#$nums1) {\n        for my $j (0 .. $#$nums2) {\n            push @pairs, [$nums1->[$i], $nums2->[$j]];\n        }\n    }\n    return [sort {$a->[0] + $a->[1] <=> $b->[0] + $b->[1]} @pairs][0 .. $k-1];\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        if($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i+1], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my $n1 = scalar @$nums1;\n    my $n2 = scalar @$nums2;\n    return [] if $n1 == 0 || $n2 == 0;\n    my $min_heap = Heap::Simple->new(\n        order => '<',\n        elements => 'Any',\n        use_module => 'Heap::Simple::XS',\n    );\n    $min_heap->insert([0, 0, $nums1->[0] + $nums2->[0]]);\n    my $visited = {};\n    my $result = [];\n    while ($min_heap->count > 0 && scalar @$result < $k) {\n        my $pair = $min_heap->extract_first;\n        my($i, $j, $sum) = @$pair;\n        push @$result, [$nums1->[$i], $nums2->[$j]];\n        if ($i + 1 < $n1 && !exists $visited->{\"$i,$j\"}) {\n            $min_heap->insert([$i + 1, $j, $nums1->[$i + 1] + $nums2->[$j]]);\n            $visited->{\"$i,$j\"} = 1;\n        }\n        if ($j + 1 < $n2 && !exists $visited->{\"$i,$j\"}) {\n            $min_heap->insert([$i, $j + 1, $nums1->[$i] + $nums2->[$j + 1]]);\n            $visited->{\"$i,$j\"} = 1;\n        }\n    }\n    return $result;\n}",
    "    my $m = scalar @$nums1;\n    my $n = scalar @$nums2;\n    return [] if $m == 0 || $n == 0;\n    my $min_heap = [];\n    my $result = [];\n    my $i = 0;\n    while ($i < $m && $i < $k) {\n        push @$min_heap, [$nums1->[$i], $nums2->[0], 0];\n        $i++;\n    }\n    while ($k > 0 && scalar @$min_heap > 0) {\n        my $pair = shift @$min_heap;\n        push @$result, [$pair->[0], $pair->[1]];\n        $k--;\n        if ($pair->[2] < $n - 1) {\n            push @$min_heap, [$pair->[0], $nums2->[$pair->[2] + 1], $pair->[2] + 1];\n        }\n        @$min_heap = sort {$a->[0] + $a->[1] <=> $b->[0] + $b->[1]} @$min_heap;\n    }\n    return $result;\n}",
    "    my @pairs;\n    for my $i (0 .. $#{$nums1}) {\n        for my $j (0 .. $#{$nums2}) {\n            push @pairs, [$nums1->[$i], $nums2->[$j]];\n        }\n    }\n    @pairs = sort { $a->[0] + $a->[1] <=> $b->[0] + $b->[1] } @pairs;\n    return [@pairs[0 .. $k - 1]];\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum <= $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i + 1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    my $count = 0;\n    while ($i < @$nums1 && $j < @$nums2 && $count < $k) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        }\n        $count++;\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if($i + 1 < @$nums1 && $nums1->[$i + 1] + $nums2->[$j] < $sum) {\n            $i++;\n        } elsif($j + 1 < @$nums2 && $nums1->[$i] + $nums2->[$j + 1] < $sum) {\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n        }\n    }\n    return \\@result;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while ($i < scalar(@$nums1) and $j < scalar(@$nums2)) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum <= 0) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        }\n        last if scalar(@res) == $k;\n    }\n    return \\@res;\n}",
    "\n    my @res;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i + 1] + $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i + 1], $nums2->[$j]];\n            $i++;\n        }\n    }",
    "    my @res;\n    my @heap;\n    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    return [] if $len1 == 0 || $len2 == 0;\n    for (my $i = 0; $i < $len1; $i++) {\n        push @heap, [$nums1->[$i] + $nums2->[0], $i, 0];\n    }\n    while ($k > 0 && @heap) {\n        my $pair = shift @heap;\n        push @res, [$nums1->[$pair->[1]], $nums2->[$pair->[2]]];\n        if ($pair->[2] < $len2 - 1) {\n            push @heap, [$nums1->[$pair->[1]] + $nums2->[$pair->[2] + 1], $pair->[1], $pair->[2] + 1];\n        }\n        $k--;\n    }\n    return \\@res;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    return [] if $len1 == 0 || $len2 == 0;\n    my $res = [];\n    my $heap = [];\n    my $visited = {};\n    push @$heap, [0, 0, $nums1->[0] + $nums2->[0]];\n    $visited->{'0,0'} = 1;\n    while (@$heap > 0 && @$res < $k) {\n        my $pair = shift @$heap;\n        my($i, $j, $sum) = @$pair;\n        push @$res, [$nums1->[$i], $nums2->[$j]];\n        if ($i + 1 < $len1 && !exists $visited->{($i + 1) . ',' . $j}) {\n            push @$heap, [$i + 1, $j, $nums1->[$i + 1] + $nums2->[$j]];\n            $visited->{($i + 1) . ',' . $j} = 1;\n        }\n        if ($j + 1 < $len2 && !exists $visited->{$i . ',' . ($j + 1)}) {\n            push @$heap, [$i, $j + 1, $nums1->[$i] + $nums2->[$j + 1]];\n            $visited->{$i . ',' . ($j + 1)} = 1;\n        }\n    }\n    return $res;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    my @pairs;\n    for(my $i = 0; $i < $len1; $i++) {\n        for(my $j = 0; $j < $len2; $j++) {\n            push @pairs, [$nums1->[$i], $nums2->[$j]];\n        }\n    }\n    @pairs = sort {$a->[0] + $a->[1] <=> $b->[0] + $b->[1]} @pairs;\n    return [@pairs[0..$k-1]];\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    my $len = $len1 * $len2;\n    my $i = 0;\n    my $j = 0;\n    my $count = 0;\n    my $result = [];\n    my $heap = [];\n    my $hash = {};\n    my $key = \"$i,$j\";\n    push @$heap, [$nums1->[$i] + $nums2->[$j], $key];\n    $hash->{$key} = 1;\n    while ($count < $k && $count < $len) {\n        my $min = shift @$heap;\n        my $key = $min->[1];\n        my($i, $j) = split /,/, $key;\n        push @$result, [$nums1->[$i], $nums2->[$j]];\n        $count++;\n        if ($i + 1 < $len1) {\n            my $key = ($i + 1) . \",\" . $j;\n            if (!exists $hash->{$key}) {\n                push @$heap, [$nums1->[$i + 1] + $nums2->[$j], $key];\n                $hash->{$key} = 1;\n            }\n        }\n        if ($j + 1 < $len2) {\n            my $key = $i . \",\" . ($j + 1);\n            if (!exists $hash->{$key}) {\n                push @$heap, [$nums1->[$i] + $nums2->[$j + 1], $key];\n                $hash->{$key} = 1;\n            }\n        }\n    }\n    return $result;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    my @result;\n    my @queue;\n    my $i = 0;\n    my $j = 0;\n    my $count = 0;\n    my $pair = [$nums1->[$i], $nums2->[$j], $i, $j];\n    push @queue, $pair;\n    while ($count < $k && scalar @queue > 0) {\n        my $pair = shift @queue;\n        push @result, [$pair->[0], $pair->[1]];\n        $count++;\n        if ($pair->[3] < $len2 - 1) {\n            my $new_pair = [$pair->[0], $nums2->[$pair->[3] + 1], $pair->[2], $pair->[3] + 1];\n            push @queue, $new_pair;\n        }\n        if ($pair->[2] < $len1 - 1) {\n            my $new_pair = [$nums1->[$pair->[2] + 1], $pair->[1], $pair->[2] + 1, $pair->[3]];\n            push @queue, $new_pair;\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j+1]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i+1], $nums2->[$j+1]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "\n    my @res;\n    my $m = @$nums1;\n    my $n = @$nums2;\n    return \\@res if $m == 0 || $n == 0 || $k == 0;",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i + 1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i + 1], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my $pairs = [];\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2) {\n        push @$pairs, [$nums1->[$i], $nums2->[$j]];\n        if ($i + 1 < @$nums1 && $j + 1 < @$nums2) {\n            if ($nums1->[$i + 1] + $nums2->[$j] < $nums1->[$i] + $nums2->[$j + 1]) {\n                $i++;\n            } else {\n                $j++;\n            }\n        } elsif ($i + 1 < @$nums1) {\n            $i++;\n        } else {\n            $j++;\n        }\n    }\n    return [@$pairs[0 .. $k - 1]];\n}",
    "    my @result;\n    return @result if @$nums1 == 0 || @$nums2 == 0;\n    my @heap;\n    my $i = 0;\n    while ($i < @$nums1 && $i < $k) {\n        push @heap, [$nums1->[$i] + $nums2->[0], $i, 0];\n        $i++;\n    }\n    while ($k-- > 0 && @heap) {\n        my $top = shift @heap;\n        push @result, [$nums1->[$top->[1]], $nums2->[$top->[2]]];\n        if ($top->[2] < @$nums2 - 1) {\n            push @heap, [$nums1->[$top->[1]] + $nums2->[$top->[2] + 1], $top->[1], $top->[2] + 1];\n        }\n        @heap = sort {$a->[0] <=> $b->[0]} @heap;\n    }\n    return @result;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if($i + 1 < @$nums1 && $nums1->[$i + 1] + $nums2->[$j] < $sum) {\n            $i++;\n        }\n        elsif($j + 1 < @$nums2 && $nums1->[$i] + $nums2->[$j + 1] < $sum) {\n            $j++;\n        }\n        else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n        }\n    }\n    return \\@res;\n}",
    "    my @result;\n    return @result if @$nums1 == 0 || @$nums2 == 0;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($i + 1 < @$nums1 && $nums1->[$i + 1] + $nums2->[$j] < $sum) {\n            $i++;\n        } elsif ($j + 1 < @$nums2 && $nums1->[$i] + $nums2->[$j + 1] < $sum) {\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n        }\n    }\n    return @result;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@res;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    return [] if $len1 == 0 || $len2 == 0;\n    my $pairs = [];\n    my $heap = [];\n    my $visited = {};\n    my $push = sub {\n        my($i, $j) = @_;\n        my $key = \"$i,$j\";\n        return if exists $visited->{$key};\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        push @$heap, [$sum, $i, $j];\n        $visited->{$key} = 1;\n    };\n    $push->(0, 0);\n    while (@$heap && @$pairs < $k) {\n        my $pair = shift @$heap;\n        my($sum, $i, $j) = @$pair;\n        push @$pairs, [$nums1->[$i], $nums2->[$j]];\n        $push->($i, $j + 1) if $j + 1 < $len2;\n        $push->($i + 1, $j) if $i + 1 < $len1;\n    }\n    return $pairs;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while (scalar(@res) < $k) {\n        if ($i >= scalar(@$nums1) || $j >= scalar(@$nums2)) {\n            last;\n        }\n        push @res, [$nums1->[$i], $nums2->[$j]];\n        if ($i == scalar(@$nums1) - 1) {\n            $j++;\n        } elsif ($j == scalar(@$nums2) - 1) {\n            $i++;\n        } elsif ($nums1->[$i] + $nums2->[$j + 1] < $nums1->[$i + 1] + $nums2->[$j]) {\n            $j++;\n        } else {\n            $i++;\n        }\n    }\n    return \\@res;\n}",
    "    my @res;\n    for my $i (0..$#$nums1) {\n        for my $j (0..$#$nums2) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n        }\n    }\n    @res = sort {$a->[0] + $a->[1] <=> $b->[0] + $b->[1]} @res;\n    return [@res[0..$k-1]];\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    return [] if $len1 == 0 || $len2 == 0;\n    my $min_heap = MinHeap->new(sub {$_[0]->[0] + $_[0]->[1] <=> $_[1]->[0] + $_[1]->[1]});\n    for my $i (0..$len1-1) {\n        for my $j (0..$len2-1) {\n            $min_heap->insert([$nums1->[$i], $nums2->[$j]]);\n        }\n    }\n    my @res;\n    while($k-- > 0) {\n        my $pair = $min_heap->extract_top;\n        last if !defined $pair;\n        push @res, $pair;\n    }\n    return \\@res;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        if($nums1->[$i] < $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        }\n    }\n    return \\@res;\n}",
    "    my @pairs;\n    my $m = scalar(@$nums1);\n    my $n = scalar(@$nums2);\n    return [] if $m == 0 || $n == 0;\n    my $i = 0;\n    my $j = 0;\n    while ($i < $m && $j < $n) {\n        push @pairs, [$nums1->[$i], $nums2->[$j]];\n        if ($i == $m - 1) {\n            $j++;\n        } elsif ($j == $n - 1) {\n            $i++;\n        } elsif ($nums1->[$i + 1] + $nums2->[$j] < $nums1->[$i] + $nums2->[$j + 1]) {\n            $i++;\n        } else {\n            $j++;\n        }\n    }\n    return [@pairs[0..$k - 1]];\n}",
    "    my $n1 = scalar @$nums1;\n    my $n2 = scalar @$nums2;\n    my $i = 0;\n    my $j = 0;\n    my @heap;\n    my @res;\n    if ($n1 == 0 || $n2 == 0) {\n        return [];\n    }\n    push @heap, [$nums1->[0] + $nums2->[0], 0, 0];\n    while ($k > 0 && $i < $n1 && $j < $n2) {\n        my $min = shift @heap;\n        push @res, [$nums1->[$min->[1]], $nums2->[$min->[2]]];\n        if ($min->[1] + 1 < $n1) {\n            push @heap, [$nums1->[$min->[1] + 1] + $nums2->[$min->[2]], $min->[1] + 1, $min->[2]];\n        }\n        if ($min->[1] == 0 && $min->[2] + 1 < $n2) {\n            push @heap, [$nums1->[$min->[1]] + $nums2->[$min->[2] + 1], $min->[1], $min->[2] + 1];\n        }\n        $k--;\n    }\n    return \\@res;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum <= $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my @heap;\n    my $n = scalar @$nums1;\n    my $m = scalar @$nums2;\n    return [] if $n == 0 || $m == 0 || $k == 0;\n    for (my $i = 0; $i < $n; $i++) {\n        push @heap, [$nums1->[$i] + $nums2->[0], $i, 0];\n    }\n    build_heap(\\@heap);\n    for (my $i = 0; $i < $k && $i < $n * $m; $i++) {\n        my $pair = shift @heap;\n        push @result, [$nums1->[$pair->[1]], $nums2->[$pair->[2]]];\n        if ($pair->[2] < $m - 1) {\n            push @heap, [$nums1->[$pair->[1]] + $nums2->[$pair->[2] + 1], $pair->[1], $pair->[2] + 1];\n        }\n        build_heap(\\@heap);\n    }\n    return \\@result;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    my @pairs;\n    my @indexes;\n    for (my $i = 0; $i < $len1; $i++) {\n        push @indexes, 0;\n    }\n    for (my $i = 0; $i < $k; $i++) {\n        my $min = undef;\n        my $min_index = undef;\n        for (my $j = 0; $j < $len1; $j++) {\n            if ($indexes[$j] < $len2) {\n                if (!defined $min || $nums1->[$j] + $nums2->[$indexes[$j]] < $min) {\n                    $min = $nums1->[$j] + $nums2->[$indexes[$j]];\n                    $min_index = $j;\n                }\n            }\n        }\n        if (defined $min_index) {\n            push @pairs, [$nums1->[$min_index], $nums2->[$indexes[$min_index]]];\n            $indexes[$min_index]++;\n        }\n    }\n    return \\@pairs;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    return [] if $len1 == 0 || $len2 == 0;\n    my $min_heap = Heap::Simple->new(\n        order => '<',\n        elements => 'Any',\n    );\n    my $res = [];\n    for (my $i = 0; $i < $len1; $i++) {\n        $min_heap->insert([$nums1->[$i] + $nums2->[0], $i, 0]);\n    }\n    while ($min_heap->count > 0 && $k > 0) {\n        my $pair = $min_heap->extract_first;\n        push @$res, [$nums1->[$pair->[1]], $nums2->[$pair->[2]]];\n        $k--;\n        if ($pair->[2] + 1 < $len2) {\n            $min_heap->insert([$nums1->[$pair->[1]] + $nums2->[$pair->[2] + 1], $pair->[1], $pair->[2] + 1]);\n        }\n    }\n    return $res;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum <= $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my $m = @$nums1;\n    my $n = @$nums2;\n    my $i = 0;\n    my $j = 0;\n    my $result = [];\n    my $heap = [];\n    my $count = 0;\n    my $pair = {};\n    my $min_pair = {};\n    my $min_pair_index = 0;\n    my $min_pair_sum = 0;\n    my $min_pair_sum_index = 0;\n    my $min_pair_sum_value = 0;\n    my $min_pair_sum_value_index = 0;\n    my $pair_sum = 0;\n    my $pair_sum_value = 0;\n    my $pair_sum_value_index = 0;\n    my $pair_sum_value_index_value = 0;\n    my $pair_sum_value_index_value_index = 0;\n    my $pair_sum_value_index_value_index_value = 0;\n    my $pair_sum_value_index_value_index_value_index = 0;\n    my $pair_sum_value_index_value_index_value_index_value = 0;\n    my $pair_sum_value_index_value_index_value_index_value_index = 0;\n    my $pair_sum_value_index_value_index_value_index_value_index_value = 0;\n    my $pair_sum_value_index_value_index_value_index_value_index_value_index = 0;\n    my $pair_sum_value_index_value_index_value_index_value_index_value_index_value = 0;\n    my $pair_sum_value_index_value_index_value_index_value_index_value_index_value_index = 0;\n    my $pair_sum_value_index_value_index_value_index_value_index_value_index_value_index_value = 0;\n    my $pair_sum_value_index_value_index_value_index_value_index_value_index_value_index_value_index = 0;\n    my",
    "    my @result;\n    my @heap;\n    my $n = scalar @$nums1;\n    my $m = scalar @$nums2;\n    return [] if $n == 0 || $m == 0;\n    for my $i (0..$n-1) {\n        push @heap, [$nums1->[$i] + $nums2->[0], $i, 0];\n    }\n    my $count = 0;\n    while ($count < $k && scalar @heap > 0) {\n        my $pair = shift @heap;\n        push @result, [$nums1->[$pair->[1]], $nums2->[$pair->[2]]];\n        $count++;\n        if ($pair->[2] < $m - 1) {\n            push @heap, [$nums1->[$pair->[1]] + $nums2->[$pair->[2] + 1], $pair->[1], $pair->[2] + 1];\n        }\n    }\n    return \\@result;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if($i + 1 < @$nums1 && $nums1->[$i + 1] + $nums2->[$j] < $sum) {\n            $i++;\n        } else {\n            $j++;\n        }\n        push @res, [$nums1->[$i], $nums2->[$j]];\n    }\n    return \\@res;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    my @result;\n    my %seen;\n    my @queue = map { [$_, 0, $nums1->[$_] + $nums2->[0]] } 0..$len1-1;\n    while (@queue) {\n        my $pair = shift @queue;\n        my($i, $j, $sum) = @$pair;\n        push @result, [$nums1->[$i], $nums2->[$j]];\n        last if @result == $k;\n        if ($j < $len2-1) {\n            my $next_j = $j + 1;\n            my $next_sum = $nums1->[$i] + $nums2->[$next_j];\n            if (!$seen{\"$i,$next_j\"}) {\n                push @queue, [$i, $next_j, $next_sum];\n                $seen{\"$i,$next_j\"} = 1;\n            }\n        }\n        @queue = sort { $a->[2] <=> $b->[2] } @queue;\n    }\n    return \\@result;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    my @ret;\n    my @idx;\n    my $i;\n    for ($i = 0; $i < $len1; $i++) {\n        push @idx, 0;\n    }\n    while ($k > 0) {\n        my $min_val = $nums1->[0] + $nums2->[0];\n        my $min_idx = 0;\n        for ($i = 0; $i < $len1; $i++) {\n            if ($idx[$i] < $len2 && $nums1->[$i] + $nums2->[$idx[$i]] < $min_val) {\n                $min_val = $nums1->[$i] + $nums2->[$idx[$i]];\n                $min_idx = $i;\n            }\n        }\n        push @ret, [$nums1->[$min_idx], $nums2->[$idx[$min_idx]]];\n        $idx[$min_idx]++;\n        $k--;\n    }\n    return \\@ret;\n}",
    "    my @result;\n    my @heap;\n    my $size1 = scalar(@$nums1);\n    my $size2 = scalar(@$nums2);\n    return \\@result if $size1 == 0 || $size2 == 0 || $k == 0;\n    for(my $i = 0; $i < $size1; $i++) {\n        push @heap, [$nums1->[$i] + $nums2->[0], $i, 0];\n    }\n    build_min_heap(\\@heap);\n    for(my $i = 0; $i < $k && $i < $size1 * $size2; $i++) {\n        my $min = shift @heap;\n        push @result, [$nums1->[$min->[1]], $nums2->[$min->[2]]];\n        if($min->[2] < $size2 - 1) {\n            push @heap, [$nums1->[$min->[1]] + $nums2->[$min->[2] + 1], $min->[1], $min->[2] + 1];\n        }\n        build_min_heap(\\@heap);\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2) {\n        push @result, [$nums1->[$i], $nums2->[$j]];\n        if ($i + 1 < @$nums1 && $j + 1 < @$nums2) {\n            if ($nums1->[$i + 1] + $nums2->[$j] < $nums1->[$i] + $nums2->[$j + 1]) {\n                $i++;\n            } else {\n                $j++;\n            }\n        } else {\n            if ($i + 1 < @$nums1) {\n                $i++;\n            } else {\n                $j++;\n            }\n        }\n        last if @result == $k;\n    }\n    return \\@result;\n}",
    "    my @res;\n    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    return @res if($len1 == 0 || $len2 == 0 || $k == 0);\n    my $i = 0;\n    my $j = 0;\n    while($i < $len1 && $j < $len2 && $k > 0) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if($sum < 0) {\n            $i++;\n        } elsif($sum > 0) {\n            $j++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n            $k--;\n        }\n    }\n    return @res;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    my $count = 0;\n    while($i < scalar(@$nums1) && $j < scalar(@$nums2) && $count < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if($sum < $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n        $count++;\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($i + 1 < @$nums1 && $nums1->[$i + 1] + $nums2->[$j] < $sum) {\n            $i++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        if($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i+1], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@res;\n}",
    "    my @result;\n    my @heap;\n    my $m = scalar @$nums1;\n    my $n = scalar @$nums2;\n    return [] if $m == 0 || $n == 0;\n    for (my $i = 0; $i < $m; $i++) {\n        push @heap, [$nums1->[$i] + $nums2->[0], $i, 0];\n    }\n    heapify(\\@heap);\n    for (my $i = 0; $i < $k && $i < $m * $n; $i++) {\n        my $pair = shift @heap;\n        push @result, [$nums1->[$pair->[1]], $nums2->[$pair->[2]]];\n        if ($pair->[2] < $n - 1) {\n            push @heap, [$nums1->[$pair->[1]] + $nums2->[$pair->[2] + 1], $pair->[1], $pair->[2] + 1];\n        }\n        heapify(\\@heap);\n    }\n    return \\@result;\n}",
    "    my $n1 = scalar @$nums1;\n    my $n2 = scalar @$nums2;\n    my $i = 0;\n    my $j = 0;\n    my $res = [];\n    while ($i < $n1 && $j < $n2 && scalar @$res < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum <= $nums1->[$i+1] + $nums2->[$j]) {\n            push @$res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @$res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return $res;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if(@result == 0 || $sum > $result[-1][0] + $result[-1][1]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n        }\n        if($i == @$nums1 - 1) {\n            $j++;\n        } elsif($j == @$nums2 - 1) {\n            $i++;\n        } else {\n            if($nums1->[$i+1] + $nums2->[$j] < $nums1->[$i] + $nums2->[$j+1]) {\n                $i++;\n            } else {\n                $j++;\n            }\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if($sum < $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    my @res;\n    return \\@res if $len1 == 0 || $len2 == 0;\n    my $i = 0;\n    my $j = 0;\n    while ($i < $len1 && $j < $len2 && $k > 0) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum < 0) {\n            $i++;\n        } elsif ($sum > 0) {\n            $j++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n            $k--;\n        }\n    }\n    return \\@res;\n}",
    "    my @ret;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @ret < $k) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i + 1] + $nums2->[$j]) {\n            push @ret, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @ret, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@ret;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    my $i = 0;\n    my $j = 0;\n    my @res;\n    my $count = 0;\n    while($i < $len1 && $j < $len2 && $count < $k) {\n        if($nums1->[$i] < $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        }\n        $count++;\n    }\n    while($i < $len1 && $count < $k) {\n        push @res, [$nums1->[$i], $nums2->[$j]];\n        $i++;\n        $count++;\n    }\n    while($j < $len2 && $count < $k) {\n        push @res, [$nums1->[$i], $nums2->[$j]];\n        $j++;\n        $count++;\n    }\n    return \\@res;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum <= $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i+1], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($i + 1 < @$nums1 && $nums1->[$i + 1] + $nums2->[$j] < $sum) {\n            $i++;\n        } elsif ($j + 1 < @$nums2 && $nums1->[$i] + $nums2->[$j + 1] < $sum) {\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n        }\n    }\n    return \\@result;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    return [] if $len1 == 0 || $len2 == 0;\n    my $max = $nums1->[0] + $nums2->[0];\n    my $min = $nums1->[$len1 - 1] + $nums2->[$len2 - 1];\n    return [] if $max < $min;\n    my $res = [];\n    for my $i (0 .. $len1 - 1) {\n        for my $j (0 .. $len2 - 1) {\n            my $sum = $nums1->[$i] + $nums2->[$j];\n            if ($sum <= $max) {\n                push @$res, [$nums1->[$i], $nums2->[$j]];\n            }\n        }\n    }\n    return [@$res[0 .. $k - 1]];\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum <= $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    my @res;\n    return \\@res if $len1 == 0 || $len2 == 0;\n    my $min_heap = Heap::Simple->new(\n        order => '<',\n        elements => 'Any',\n        use_modules => ['Heap::Simple::XS'],\n    );\n    $min_heap->insert([0, 0, $nums1->[0] + $nums2->[0]]);\n    my $visited = {};\n    while ($min_heap->count > 0 && $k > 0) {\n        my $pair = $min_heap->extract_first;\n        my($i, $j, $sum) = @$pair;\n        push @res, [$nums1->[$i], $nums2->[$j]];\n        $k--;\n        if ($i + 1 < $len1 && !exists $visited->{$i + 1}{$j}) {\n            $min_heap->insert([$i + 1, $j, $nums1->[$i + 1] + $nums2->[$j]]);\n            $visited->{$i + 1}{$j} = 1;\n        }\n        if ($j + 1 < $len2 && !exists $visited->{$i}{$j + 1}) {\n            $min_heap->insert([$i, $j + 1, $nums1->[$i] + $nums2->[$j + 1]]);\n            $visited->{$i}{$j + 1} = 1;\n        }\n    }\n    return \\@res;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    return [] if $len1 == 0 || $len2 == 0;\n    my @pairs;\n    for my $i (0..$len1-1) {\n        for my $j (0..$len2-1) {\n            push @pairs, [$nums1->[$i], $nums2->[$j]];\n        }\n    }\n    my @sorted = sort { $a->[0] + $a->[1] <=> $b->[0] + $b->[1] } @pairs;\n    return [@sorted[0..$k-1]];\n}",
    "    my $n1 = scalar @$nums1;\n    my $n2 = scalar @$nums2;\n    my $i = 0;\n    my $j = 0;\n    my $res = [];\n    while ($i < $n1 && $j < $n2 && scalar @$res < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum <= $nums1->[$i + 1] + $nums2->[$j]) {\n            push @$res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @$res, [$nums1->[$i + 1], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return $res;\n}",
    "    my @res;\n    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    return [] if $len1 == 0 || $len2 == 0;\n    my $min = $nums1->[0] + $nums2->[0];\n    my $max = $nums1->[$len1-1] + $nums2->[$len2-1];\n    my $mid = $min + ($max - $min) / 2;\n    my $count = 0;\n    my $i = 0;\n    my $j = $len2 - 1;\n    while ($i < $len1 && $j >= 0) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum <= $mid) {\n            $count += $j + 1;\n            $i++;\n        } else {\n            $j--;\n        }\n    }\n    if ($count >= $k) {\n        my @left;\n        my @right;\n        $i = 0;\n        $j = $len2 - 1;\n        while ($i < $len1 && $j >= 0) {\n            my $sum = $nums1->[$i] + $nums2->[$j];\n            if ($sum <= $mid) {\n                push @left, [$nums1->[$i], $nums2->[$j]];\n                $i++;\n            } else {\n                push @right, [$nums1->[$i], $nums2->[$j]];\n                $j--;\n            }\n        }\n        @res = (@left, @right);\n    } else {\n        @res = k_smallest_pairs($nums1, $nums2, $k - $count);\n    }\n    return [@res[0..$k-1]];\n}",
    "    my @pairs;\n    for my $i (0..$#{$nums1}) {\n        for my $j (0..$#{$nums2}) {\n            push @pairs, [$nums1->[$i], $nums2->[$j]];\n        }\n    }\n    @pairs = sort { $a->[0] + $a->[1] <=> $b->[0] + $b->[1] } @pairs;\n    return [@pairs[0..$k-1]];\n}",
    "    my @pairs;\n    for my $i (0..$#$nums1) {\n        for my $j (0..$#$nums2) {\n            push @pairs, [$nums1->[$i], $nums2->[$j]];\n        }\n    }\n    @pairs = sort { $a->[0] + $a->[1] <=> $b->[0] + $b->[1] } @pairs;\n    return [@pairs[0..$k-1]];\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        if($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i+1], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && $k > 0) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum <= $nums1->[$i+1] + $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i+1], $nums2->[$j]];\n            $i++;\n        }\n        $k--;\n    }\n    return \\@res;\n}",
    "    my @result;\n    my %hash;\n    my $i = 0;\n    my $j = 0;\n    my $count = 0;\n    while($i < scalar(@$nums1) && $j < scalar(@$nums2)) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if(!exists $hash{$sum}) {\n            $hash{$sum} = [$i, $j];\n            $count++;\n        }\n        if($count == $k) {\n            last;\n        }\n        if($nums1->[$i] < $nums2->[$j]) {\n            $i++;\n        } else {\n            $j++;\n        }\n    }\n    my @keys = sort {$a <=> $b} keys %hash;\n    for(my $i = 0; $i < scalar(@keys); $i++) {\n        my $key = $keys[$i];\n        my $value = $hash{$key};\n        my $i = $value->[0];\n        my $j = $value->[1];\n        push @result, [$nums1->[$i], $nums2->[$j]];\n    }\n    return \\@result;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        push @res, [$nums1->[$i], $nums2->[$j]];\n        if ($nums1->[$i] + $nums2->[$j + 1] < $nums1->[$i + 1] + $nums2->[$j]) {\n            $j++;\n        } else {\n            $i++;\n        }\n    }\n    return \\@res;\n}",
    "    my $len1 = scalar(@$nums1);\n    my $len2 = scalar(@$nums2);\n    return [] if $len1 == 0 || $len2 == 0;\n    my $pq = new Heap::Binary();\n    my $visited = {};\n    my $res = [];\n    push @$res, [$nums1->[0], $nums2->[0]];\n    $visited->{\"0,0\"} = 1;\n    if ($len1 > 1) {\n        $pq->add([$nums1->[0] + $nums2->[1], 0, 1]);\n    }\n    if ($len2 > 1) {\n        $pq->add([$nums1->[1] + $nums2->[0], 1, 0]);\n    }\n    while (scalar(@$res) < $k && $pq->size() > 0) {\n        my $pair = $pq->extract_top();\n        my $i = $pair->[1];\n        my $j = $pair->[2];\n        push @$res, [$nums1->[$i], $nums2->[$j]];\n        if ($i + 1 < $len1 && !$visited->{\"$i,$j\"}) {\n            $pq->add([$nums1->[$i + 1] + $nums2->[$j], $i + 1, $j]);\n        }\n        if ($j + 1 < $len2 && !$visited->{\"$i,$j\"}) {\n            $pq->add([$nums1->[$i] + $nums2->[$j + 1], $i, $j + 1]);\n        }\n        $visited->{\"$i,$j\"} = 1;\n    }\n    return $res;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    my @pairs;\n    my $i = 0;\n    my $j = 0;\n    while ($i < $len1 && $j < $len2) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum < 0) {\n            push @pairs, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        } else {\n            push @pairs, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        }\n    }\n    while ($i < $len1) {\n        push @pairs, [$nums1->[$i], $nums2->[$j]];\n        $i++;\n    }\n    while ($j < $len2) {\n        push @pairs, [$nums1->[$i], $nums2->[$j]];\n        $j++;\n    }\n    return [@pairs[0..$k-1]];\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    my $count = 0;\n    while($count < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if($i == $#$nums1) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        }\n        elsif($j == $#$nums2) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n        elsif($sum < $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        }\n        else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n        $count++;\n    }\n    return \\@result;\n}",
    "    my @pairs;\n    for my $i (0..$#$nums1) {\n        for my $j (0..$#$nums2) {\n            my $sum = $nums1->[$i] + $nums2->[$j];\n            push @pairs, [$sum, $i, $j];\n        }\n    }\n    my @result;\n    for my $pair (sort {$a->[0] <=> $b->[0]} @pairs) {\n        push @result, [$nums1->[$pair->[1]], $nums2->[$pair->[2]]];\n        last if @result == $k;\n    }\n    return \\@result;\n}",
    "    my @result;\n    my @heap;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        push @heap, [$sum, $i, $j];\n        $i++ if $i < @$nums1 - 1;\n        $j++ if $j < @$nums2 - 1;\n    }\n    while (@heap && @result < $k) {\n        my $min = pop @heap;\n        push @result, [$nums1->[$min->[1]], $nums2->[$min->[2]]];\n        my $i = $min->[1];\n        my $j = $min->[2] + 1;\n        if ($j < @$nums2) {\n            my $sum = $nums1->[$i] + $nums2->[$j];\n            push @heap, [$sum, $i, $j];\n        }\n    }\n    return @result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($i + 1 < @$nums1 && $nums1->[$i + 1] + $nums2->[$j] < $sum) {\n            $i++;\n        } elsif ($j + 1 < @$nums2 && $nums1->[$i] + $nums2->[$j + 1] < $sum) {\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n            $j++;\n        }\n    }\n    return \\@result;\n}",
    "    my @pairs;\n    my $i = 0;\n    my $j = 0;\n    while($i < scalar(@$nums1) and $j < scalar(@$nums2)) {\n        push @pairs, [$nums1->[$i], $nums2->[$j]];\n        if($i == scalar(@$nums1) - 1) {\n            $j++;\n        } elsif($j == scalar(@$nums2) - 1) {\n            $i++;\n        } elsif($nums1->[$i+1] + $nums2->[$j] < $nums1->[$i] + $nums2->[$j+1]) {\n            $i++;\n        } else {\n            $j++;\n        }\n    }\n    return @pairs[0..$k-1];\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    my $len = $len1 * $len2;\n    my $i = 0;\n    my $j = 0;\n    my $k_smallest_pairs = [];\n    my $count = 0;\n    while ($count < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        my $min_sum = $nums1->[0] + $nums2->[0];\n        my $min_i = 0;\n        my $min_j = 0;\n        for (my $i = 0; $i < $len1; $i++) {\n            for (my $j = 0; $j < $len2; $j++) {\n                my $sum = $nums1->[$i] + $nums2->[$j];\n                if ($sum < $min_sum) {\n                    $min_sum = $sum;\n                    $min_i = $i;\n                    $min_j = $j;\n                }\n            }\n        }\n        push @$k_smallest_pairs, [$nums1->[$min_i], $nums2->[$min_j]];\n        $nums1->[$min_i] = $len;\n        $nums2->[$min_j] = $len;\n        $count++;\n    }\n    return $k_smallest_pairs;\n}"
  ]
}