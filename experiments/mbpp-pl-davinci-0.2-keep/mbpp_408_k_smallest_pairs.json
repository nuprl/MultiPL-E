{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "pl",
  "prompt": "# Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nsub k_smallest_pairs {\n    my($nums1, $nums2, $k) = @_;\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&k_smallest_pairs;\n        if(eq_deeply($candidate->([1, 3, 7], [2, 4, 6], 2),[[1, 2], [1, 4]])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 3, 7], [2, 4, 6], 1),[[1, 2]])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 3, 7], [2, 4, 6], 7),[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
  "stop_tokens": [
    "\nsub",
    "\n#",
    "\n\n"
  ],
  "completions": [
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        push @result, [$nums1->[$i], $nums2->[$j]];\n        if ($i == @$nums1 - 1) {\n            $j++;\n        } elsif ($j == @$nums2 - 1) {\n            $i++;\n        } else {\n            if ($nums1->[$i + 1] + $nums2->[$j] < $nums1->[$i] + $nums2->[$j + 1]) {\n                $i++;\n            } else {\n                $j++;\n            }\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $m = @$nums1;\n    my $n = @$nums2;\n    return [] if $m == 0 || $n == 0;\n    my $i = 0;\n    my $j = 0;\n    while ($i < $m && $j < $n && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($i + 1 < $m && $j + 1 < $n) {\n            my $sum1 = $nums1->[$i + 1] + $nums2->[$j];\n            my $sum2 = $nums1->[$i] + $nums2->[$j + 1];\n            if ($sum1 < $sum2) {\n                push @result, [$nums1->[$i + 1], $nums2->[$j]];\n                $i++;\n            } else {\n                push @result, [$nums1->[$i], $nums2->[$j + 1]];\n                $j++;\n            }\n        } elsif ($i + 1 < $m) {\n            push @result, [$nums1->[$i + 1], $nums2->[$j]];\n            $i++;\n        } elsif ($j + 1 < $n) {\n            push @result, [$nums1->[$i], $nums2->[$j + 1]];\n            $j++;\n        }\n    }\n    return \\@result;\n}",
    "    my @res;\n    return @res if @$nums1 == 0 || @$nums2 == 0 || $k == 0;\n    my $len1 = @$nums1;\n    my $len2 = @$nums2;\n    my $i = 0;\n    my $j = 0;\n    my $count = 0;\n    while ($count < $k && $i < $len1 && $j < $len2) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum <= $nums1->[$i + 1] + $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i + 1], $nums2->[$j]];\n            $i++;\n        }\n        $count++;\n    }\n    return @res;\n}",
    "    my @res;\n    return @res if $k == 0;\n    my $m = scalar @$nums1;\n    my $n = scalar @$nums2;\n    return @res if $m == 0 || $n == 0;\n    my $max_k = $m * $n;\n    $k = $max_k if $k > $max_k;\n    my $i = 0;\n    my $j = 0;\n    while ($k > 0) {\n        my $min_i = $i;\n        my $min_j = $j;\n        for my $x ($i .. $m - 1) {\n            if ($nums1->[$x] + $nums2->[$j] < $nums1->[$min_i] + $nums2->[$min_j]) {\n                $min_i = $x;\n                $min_j = $j;\n            }\n        }\n        for my $y ($j + 1 .. $n - 1) {\n            if ($nums1->[$i] + $nums2->[$y] < $nums1->[$min_i] + $nums2->[$min_j]) {\n                $min_i = $i;\n                $min_j = $y;\n            }\n        }\n        push @res, [$nums1->[$min_i], $nums2->[$min_j]];\n        $i = $min_i;\n        $j = $min_j + 1;\n        $k--;\n    }\n    return @res;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i+1], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2) {\n        if($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i+1], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return @result;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum <= $nums1->[$i+1] + $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@res;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < scalar(@$nums1) && $j < scalar(@$nums2)) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum <= $k) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        } else {\n            $j++;\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    return \\@result if $len1 == 0 || $len2 == 0;\n    my $max = $nums1->[0] + $nums2->[0];\n    my $min = $nums1->[-1] + $nums2->[-1];\n    return \\@result if $max < $min;\n    my $count = 0;\n    for my $i (0 .. $len1 - 1) {\n        for my $j (0 .. $len2 - 1) {\n            my $sum = $nums1->[$i] + $nums2->[$j];\n            if ($sum <= $max) {\n                push @result, [$nums1->[$i], $nums2->[$j]];\n                $count++;\n            }\n            last if $count == $k;\n        }\n    }\n    return \\@result;\n}",
    "    my $len1 = @$nums1;\n    my $len2 = @$nums2;\n    my @result;\n    return \\@result if $len1 == 0 || $len2 == 0 || $k == 0;\n    my @heap;\n    my $i = 0;\n    my $j = 0;\n    for (1..$k) {\n        push @heap, [$i, $j, $nums1->[$i] + $nums2->[$j]];\n        $j++;\n        if ($j == $len2) {\n            $i++;\n            $j = 0;\n        }\n        last if $i == $len1;\n    }\n    while (@heap) {\n        my $node = shift @heap;\n        my($i, $j, $sum) = @$node;\n        push @result, [$nums1->[$i], $nums2->[$j]];\n        $j++;\n        if ($j == $len2) {\n            $i++;\n            $j = 0;\n        }\n        last if $i == $len1;\n        push @heap, [$i, $j, $nums1->[$i] + $nums2->[$j]];\n        @heap = sort {$a->[2] <=> $b->[2]} @heap;\n    }\n    return \\@result;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if($sum > 0) {\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my @res;\n    return @res if @$nums1 == 0 || @$nums2 == 0 || $k == 0;\n    my @heap;\n    my $i = 0;\n    while ($i < @$nums1 && $i < $k) {\n        push @heap, [$nums1->[$i] + $nums2->[0], $i, 0];\n        $i++;\n    }\n    while ($k-- > 0) {\n        my $t = shift @heap;\n        push @res, [$nums1->[$t->[1]], $nums2->[$t->[2]]];\n        if ($t->[2] == $#$nums2) {\n            next;\n        }\n        push @heap, [$nums1->[$t->[1]] + $nums2->[$t->[2] + 1], $t->[1], $t->[2] + 1];\n        @heap = sort {$a->[0] <=> $b->[0]} @heap;\n    }\n    return @res;\n}",
    "    my @result;\n    my @heap;\n    my $i = 0;\n    my $j = 0;\n    while ($i < scalar(@$nums1) && $j < scalar(@$nums2)) {\n        my $pair = [$nums1->[$i], $nums2->[$j]];\n        push @heap, $pair;\n        $i++;\n        $j++;\n    }\n    while ($i < scalar(@$nums1)) {\n        my $pair = [$nums1->[$i], $nums2->[0]];\n        push @heap, $pair;\n        $i++;\n    }\n    while ($j < scalar(@$nums2)) {\n        my $pair = [$nums1->[0], $nums2->[$j]];\n        push @heap, $pair;\n        $j++;\n    }\n    my $count = 0;\n    while ($count < $k && scalar(@heap) > 0) {\n        my $pair = pop @heap;\n        push @result, $pair;\n        $count++;\n    }\n    return \\@result;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($i == 0 || $nums1->[$i] + $nums2->[$j-1] < $sum) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        } else {\n            push @res, [$nums1->[$i-1], $nums2->[$j]];\n            $j++;\n        }\n    }\n    while ($i < @$nums1 && @res < $k) {\n        push @res, [$nums1->[$i], $nums2->[$j-1]];\n        $i++;\n    }\n    while ($j < @$nums2 && @res < $k) {\n        push @res, [$nums1->[$i-1], $nums2->[$j]];\n        $j++;\n    }\n    return \\@res;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    my $min_len = $len1 < $len2 ? $len1 : $len2;\n    my $max_len = $len1 > $len2 ? $len1 : $len2;\n    my $min_idx = 0;\n    my $max_idx = 0;\n    my $min_arr = $len1 < $len2 ? $nums1 : $nums2;\n    my $max_arr = $len1 > $len2 ? $nums1 : $nums2;\n    my $res = [];\n    while ($min_idx < $min_len && $max_idx < $max_len && $k > 0) {\n        my $min_val = $min_arr->[$min_idx];\n        my $max_val = $max_arr->[$max_idx];\n        my $sum = $min_val + $max_val;\n        my $i = $max_idx;\n        while ($i < $max_len && $max_arr->[$i] <= $sum) {\n            push @$res, [$min_val, $max_arr->[$i]];\n            $i++;\n            $k--;\n            last if $k == 0;\n        }\n        $max_idx = $i;\n        $min_idx++;\n    }\n    return $res;\n}",
    "    my @res;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @res < $k) {\n        my $sum = $nums1->[$i] + $nums2->[$j];\n        if ($sum < $nums1->[$i+1] + $nums2->[$j]) {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@res;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2 && @result < $k) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i + 1] + $nums2->[$j + 1]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n    }\n    return \\@result;\n}",
    "    my @result;\n    for my $i (0..$#$nums1) {\n        for my $j (0..$#$nums2) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n        }\n    }\n    @result = sort { $a->[0] + $a->[1] <=> $b->[0] + $b->[1] } @result;\n    return [@result[0..$k-1]];\n}",
    "    my @result;\n    my $n1 = scalar @$nums1;\n    my $n2 = scalar @$nums2;\n    my $i = 0;\n    my $j = 0;\n    my $count = 0;\n    while ($i < $n1 && $j < $n2 && $count < $k) {\n        if ($nums1->[$i] + $nums2->[$j] < $nums1->[$i+1] + $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        }\n        $count++;\n    }\n    return \\@result;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    return [] if $len1 == 0 || $len2 == 0;\n    my $heap = [];\n    my $res = [];\n    push @$heap, [$nums1->[0] + $nums2->[0], 0, 0];\n    while (@$heap && @$res < $k) {\n        my $cur = shift @$heap;\n        push @$res, [$nums1->[$cur->[1]], $nums2->[$cur->[2]]];\n        if ($cur->[1] + 1 < $len1) {\n            push @$heap, [$nums1->[$cur->[1] + 1] + $nums2->[$cur->[2]], $cur->[1] + 1, $cur->[2]];\n        }\n        if ($cur->[1] == 0 && $cur->[2] + 1 < $len2) {\n            push @$heap, [$nums1->[$cur->[1]] + $nums2->[$cur->[2] + 1], $cur->[1], $cur->[2] + 1];\n        }\n    }\n    return $res;\n}"
  ]
}