{
  "name": "mbpp_308_large_product",
  "language": "pl",
  "prompt": "# Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nsub large_product {\n    my($nums1, $nums2, $N) = @_;\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py",
  "prompt_terminology": "verbatim",
  "tests": "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&large_product;\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3),[60, 54, 50])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 4),[60, 54, 50, 48])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 5),[60, 54, 50, 48, 45])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
  "stop_tokens": [
    "\nsub",
    "\n#",
    "\n\n"
  ],
  "completions": [
    "    my @products;\n    for my $num1 (@$nums1) {\n        for my $num2 (@$nums2) {\n            push @products, $num1 * $num2;\n        }\n    }\n    @products = sort { $b <=> $a } @products;\n    return @products[0..$N-1];\n}",
    "    my @products;\n    for my $i (0..$#$nums1) {\n        for my $j (0..$#$nums2) {\n            push @products, $nums1->[$i] * $nums2->[$j];\n        }\n    }\n    @products = sort { $b <=> $a } @products;\n    return @products[0..$N-1];\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    my $n1 = scalar @$nums1;\n    my $n2 = scalar @$nums2;\n    while ($i < $n1 && $j < $n2) {\n        my $p1 = $nums1->[$i];\n        my $p2 = $nums2->[$j];\n        if ($p1 < $p2) {\n            $i++;\n        } elsif ($p1 > $p2) {\n            $j++;\n        } else {\n            push @result, [$p1, $p2];\n            $i++;\n            $j++;\n        }\n    }\n    return @result[0..$N-1];\n}",
    "    my @result;\n    my @sorted1 = sort {$b <=> $a} @$nums1;\n    my @sorted2 = sort {$b <=> $a} @$nums2;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @sorted1 && $j < @sorted2) {\n        if ($sorted1[$i] * $sorted2[$j] > $sorted1[$i] * $sorted2[$j+1]) {\n            push @result, [$sorted1[$i], $sorted2[$j]];\n            $j++;\n        } else {\n            push @result, [$sorted1[$i], $sorted2[$j+1]];\n            $i++;\n        }\n    }\n    return @result[0..$N-1];\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2) {\n        if ($nums1->[$i] > $nums2->[$j]) {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $i++;\n        } else {\n            push @result, [$nums1->[$i], $nums2->[$j]];\n            $j++;\n        }\n    }\n    while ($i < @$nums1) {\n        push @result, [$nums1->[$i], $nums2->[-1]];\n        $i++;\n    }\n    while ($j < @$nums2) {\n        push @result, [$nums1->[-1], $nums2->[$j]];\n        $j++;\n    }\n    return @result[0..$N-1];\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    my $size1 = scalar(@$nums1);\n    my $size2 = scalar(@$nums2);\n    while ($i < $size1 && $j < $size2) {\n        if ($nums1->[$i] < $nums2->[$j]) {\n            push @result, $nums1->[$i] * $nums2->[$j];\n            $i++;\n        } else {\n            push @result, $nums1->[$i] * $nums2->[$j];\n            $j++;\n        }\n    }\n    while ($i < $size1) {\n        push @result, $nums1->[$i] * $nums2->[$size2 - 1];\n        $i++;\n    }\n    while ($j < $size2) {\n        push @result, $nums1->[$size1 - 1] * $nums2->[$j];\n        $j++;\n    }\n    @result = sort {$b <=> $a} @result;\n    return @result[0..$N - 1];\n}",
    "    my $max = 0;\n    my $max_i = 0;\n    my $max_j = 0;\n    for(my $i = 0; $i < @$nums1; $i++) {\n        for(my $j = 0; $j < @$nums2; $j++) {\n            my $prod = $nums1->[$i] * $nums2->[$j];\n            if($prod > $max) {\n                $max = $prod;\n                $max_i = $i;\n                $max_j = $j;\n            }\n        }\n    }\n    my $result = [];\n    push @$result, $max_i;\n    push @$result, $max_j;\n    return $result;\n}",
    "    my @products;\n    for my $i (0..$#$nums1) {\n        for my $j (0..$#$nums2) {\n            push @products, $nums1->[$i] * $nums2->[$j];\n        }\n    }\n    @products = sort { $b <=> $a } @products;\n    return @products[0..$N-1];\n}",
    "    my @products = ();\n    for my $i (@$nums1) {\n        for my $j (@$nums2) {\n            push @products, $i * $j;\n        }\n    }\n    @products = sort {$b <=> $a} @products;\n    return @products[0..$N-1];\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    my $k = 0;\n    my $m = scalar(@$nums1);\n    my $n = scalar(@$nums2);\n    while ($i < $m && $j < $n && $k < $N) {\n        if ($nums1->[$i] < $nums2->[$j]) {\n            $result[$k++] = $nums1->[$i++];\n        } else {\n            $result[$k++] = $nums2->[$j++];\n        }\n    }\n    while ($i < $m && $k < $N) {\n        $result[$k++] = $nums1->[$i++];\n    }\n    while ($j < $n && $k < $N) {\n        $result[$k++] = $nums2->[$j++];\n    }\n    return \\@result;\n}",
    "    my $max_product = 0;\n    my $max_product_pair = [];\n    my $max_product_pairs = [];\n    for my $i (0 .. $#$nums1) {\n        for my $j (0 .. $#$nums2) {\n            my $product = $nums1->[$i] * $nums2->[$j];\n            if ($product > $max_product) {\n                $max_product = $product;\n                $max_product_pair = [$i, $j];\n            }\n        }\n    }\n    push @$max_product_pairs, $max_product_pair;\n    my $count = 1;\n    while ($count < $N) {\n        my $max_product = 0;\n        my $max_product_pair = [];\n        for my $i (0 .. $#$nums1) {\n            for my $j (0 .. $#$nums2) {\n                my $product = $nums1->[$i] * $nums2->[$j];\n                if ($product > $max_product) {\n                    my $is_duplicate = 0;\n                    for my $pair (@$max_product_pairs) {\n                        if ($pair->[0] == $i || $pair->[1] == $j) {\n                            $is_duplicate = 1;\n                            last;\n                        }\n                    }\n                    if (!$is_duplicate) {\n                        $max_product = $product;\n                        $max_product_pair = [$i, $j];\n                    }\n                }\n            }\n        }\n        push @$max_product_pairs, $max_product_pair;\n        $count++;\n    }\n    return $max_product_pairs;\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    my $k = 0;\n    my $m = scalar(@$nums1);\n    my $n = scalar(@$nums2);\n    my $product = $nums1->[0] * $nums2->[0];\n    my $max_product = $product;\n    my $max_i = 0;\n    my $max_j = 0;\n    my $max_k = 0;\n    my $max_m = 0;\n    my $max_n = 0;\n    while ($k < $N) {\n        if ($i < $m && $j < $n) {\n            if ($nums1->[$i] < $nums2->[$j]) {\n                $product = $nums1->[$i] * $nums2->[$j];\n                $i++;\n            } else {\n                $product = $nums1->[$i] * $nums2->[$j];\n                $j++;\n            }\n        } elsif ($i < $m) {\n            $product = $nums1->[$i] * $nums2->[$j-1];\n            $i++;\n        } elsif ($j < $n) {\n            $product = $nums1->[$i-1] * $nums2->[$j];\n            $j++;\n        }\n        if ($product > $max_product) {\n            $max_product = $product;\n            $max_i = $i;\n            $max_j = $j;\n            $max_k = $k;\n            $max_m = $m;\n            $max_n = $n;\n        }\n        $k++;\n    }\n    $i = $max_i;\n    $j = $max_j;\n    $k = $max_k;\n    $m = $max_m;\n    $n = $max_n;\n    while ($k < $N) {\n        if ($i < $m && $j < $n) {\n            if",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @$nums1 && $j < @$nums2) {\n        if ($nums1->[$i] > $nums2->[$j]) {\n            push @result, $nums1->[$i] * $nums2->[$j];\n            $j++;\n        } else {\n            push @result, $nums1->[$i] * $nums2->[$j];\n            $i++;\n        }\n    }\n    return @result[0..$N-1];\n}",
    "    my @sorted1 = sort {$b <=> $a} @$nums1;\n    my @sorted2 = sort {$b <=> $a} @$nums2;\n    my @result;\n    for (my $i = 0; $i < $N; $i++) {\n        my $max = 0;\n        my $max_i;\n        my $max_j;\n        for (my $i1 = 0; $i1 < @sorted1; $i1++) {\n            for (my $i2 = 0; $i2 < @sorted2; $i2++) {\n                my $product = $sorted1[$i1] * $sorted2[$i2];\n                if ($product > $max) {\n                    $max = $product;\n                    $max_i = $i1;\n                    $max_j = $i2;\n                }\n            }\n        }\n        push @result, $max;\n        $sorted1[$max_i] = 0;\n        $sorted2[$max_j] = 0;\n    }\n    return @result;\n}",
    "    my @result;\n    my @sorted1 = sort {$b <=> $a} @$nums1;\n    my @sorted2 = sort {$b <=> $a} @$nums2;\n    my $i = 0;\n    my $j = 0;\n    while ($N > 0) {\n        if ($sorted1[$i] * $sorted2[$j] > $sorted1[$i] * $sorted2[$j + 1]) {\n            push @result, [$sorted1[$i], $sorted2[$j]];\n            $j++;\n        } else {\n            push @result, [$sorted1[$i], $sorted2[$j + 1]];\n            $i++;\n        }\n        $N--;\n    }\n    return @result;\n}",
    "    my $len1 = scalar @$nums1;\n    my $len2 = scalar @$nums2;\n    my @res;\n    my $i = 0;\n    my $j = $len2 - 1;\n    while ($i < $len1 && $j >= 0) {\n        my $product = $nums1->[$i] * $nums2->[$j];\n        if ($product > $res[0]) {\n            if (scalar @res < $N) {\n                push @res, $product;\n                @res = sort {$b <=> $a} @res;\n            } else {\n                shift @res;\n                push @res, $product;\n                @res = sort {$b <=> $a} @res;\n            }\n        }\n        if ($nums1->[$i] > $nums2->[$j]) {\n            $i++;\n        } else {\n            $j--;\n        }\n    }\n    return \\@res;\n}",
    "    my @products = map { $nums1->[$_] * $nums2->[$_] } (0 .. $#$nums1);\n    @products[0 .. $N - 1];\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    my $k = 0;\n    my $m = scalar @$nums1;\n    my $n = scalar @$nums2;\n    my $p = $m * $n;\n    my $max = $nums1->[0] * $nums2->[0];\n    my $min = $nums1->[0] * $nums2->[0];\n    my $max_i = 0;\n    my $max_j = 0;\n    my $min_i = 0;\n    my $min_j = 0;\n    my $max_k = 0;\n    my $min_k = 0;\n    while ($k < $N) {\n        if ($i < $m && $j < $n) {\n            if ($nums1->[$i] * $nums2->[$j] > $max) {\n                $max = $nums1->[$i] * $nums2->[$j];\n                $max_i = $i;\n                $max_j = $j;\n            }\n            if ($nums1->[$i] * $nums2->[$j] < $min) {\n                $min = $nums1->[$i] * $nums2->[$j];\n                $min_i = $i;\n                $min_j = $j;\n            }\n            $i++;\n            $j++;\n        } elsif ($i < $m) {\n            if ($nums1->[$i] * $nums2->[$n - 1] > $max) {\n                $max = $nums1->[$i] * $nums2->[$n - 1];\n                $max_i = $i;\n                $max_j = $n - 1;\n            }\n            if ($nums1->[$i] * $nums2->[0] < $min) {\n                $min = $nums1->[$i] * $nums2->[0];\n                $min_i = $i;",
    "    my @res;\n    my @nums1 = sort {$b <=> $a} @$nums1;\n    my @nums2 = sort {$b <=> $a} @$nums2;\n    my $i = 0;\n    my $j = 0;\n    while ($i < @nums1 && $j < @nums2) {\n        if ($nums1[$i] * $nums2[$j] > $nums1[$i] * $nums2[$j+1]) {\n            push @res, [$nums1[$i], $nums2[$j]];\n            $j++;\n        } else {\n            push @res, [$nums1[$i], $nums2[$j+1]];\n            $i++;\n        }\n    }\n    return @res[0..$N-1];\n}",
    "    my @result;\n    my $i = 0;\n    my $j = 0;\n    my $k = 0;\n    my $m = 0;\n    my $n = 0;\n    my $product;\n    my $max_product;\n    my $max_i;\n    my $max_j;\n    my $max_k;\n    my $max_m;\n    my $max_n;"
  ]
}