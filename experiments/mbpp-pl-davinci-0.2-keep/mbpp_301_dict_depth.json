{
  "name": "mbpp_301_dict_depth",
  "language": "pl",
  "prompt": "# Write a function to find the depth of a dictionary.\nsub dict_depth {\n    my($d) = @_;\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_301_dict_depth.py",
  "prompt_terminology": "verbatim",
  "tests": "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&dict_depth;\n        if(eq_deeply($candidate->({\"a\" => 1, \"b\" => {\"c\" => {\"d\" => {}}}}),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->({\"a\" => 1, \"b\" => {\"c\" => \"python\"}}),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->({1 => \"Sun\", 2 => {3 => {4 => \"Mon\"}}}),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();",
  "stop_tokens": [
    "\nsub",
    "\n#",
    "\n\n"
  ],
  "completions": [
    "    my($depth) = 0;\n    foreach my $k (keys %$d) {\n        my($v) = $d->{$k};\n        if (ref($v) eq 'HASH') {\n            my($d2) = dict_depth($v);\n            if ($d2 > $depth) {\n                $depth = $d2;\n            }\n        }\n    }\n    return $depth + 1;\n}",
    "    my $depth = 0;\n    my @stack = ($d);\n    while (@stack) {\n        my $d = shift @stack;\n        if (ref $d eq 'HASH') {\n            push @stack, values %$d;\n        }\n        elsif (ref $d eq 'ARRAY') {\n            push @stack, @$d;\n        }\n        else {\n            $depth++;\n        }\n    }\n    return $depth;\n}",
    "    my $depth = 0;\n    my $max_depth = 0;\n    my $key;\n    my $value;\n    my $ref;\n    my $ref_type;\n    while (($key, $value) = each %$d) {\n        $ref = ref $value;\n        if ($ref) {\n            $ref_type = ref $value;\n            if ($ref_type eq 'HASH') {\n                $depth = dict_depth($value) + 1;\n            }\n            elsif ($ref_type eq 'ARRAY') {\n                $depth = array_depth($value) + 1;\n            }\n            else {\n                $depth = 1;\n            }\n        }\n        else {\n            $depth = 1;\n        }\n        $max_depth = $depth if $depth > $max_depth;\n    }\n    return $max_depth;\n}",
    "    my $depth = 1;\n    my $max_depth = 1;\n    my @keys = keys %$d;\n    for my $k (@keys) {\n        if (ref($d->{$k}) eq 'HASH') {\n            $depth = 1 + dict_depth($d->{$k});\n            $max_depth = $depth if $depth > $max_depth;\n        }\n    }\n    return $max_depth;\n}",
    "    my $depth = 0;\n    my $ref = ref $d;\n    if ($ref eq 'HASH') {\n        my $max = 0;\n        foreach my $k (keys %$d) {\n            my $v = $d->{$k};\n            my $ref = ref $v;\n            if ($ref eq 'HASH' || $ref eq 'ARRAY') {\n                my $d = dict_depth($v);\n                if ($d > $max) {\n                    $max = $d;\n                }\n            }\n        }\n        $depth = $max + 1;\n    }\n    elsif ($ref eq 'ARRAY') {\n        my $max = 0;\n        foreach my $v (@$d) {\n            my $ref = ref $v;\n            if ($ref eq 'HASH' || $ref eq 'ARRAY') {\n                my $d = dict_depth($v);\n                if ($d > $max) {\n                    $max = $d;\n                }\n            }\n        }\n        $depth = $max + 1;\n    }\n    return $depth;\n}",
    "    my $depth = 1;\n    foreach my $k (keys %$d) {\n        my $v = $d->{$k};\n        if (ref($v) eq 'HASH') {\n            my $d = dict_depth($v);\n            $depth = $d + 1 if $d + 1 > $depth;\n        }\n    }\n    return $depth;\n}",
    "    my($depth) = 0;\n    foreach my $k (keys %$d) {\n        my($v) = $d->{$k};\n        if (ref($v) eq 'HASH') {\n            my($d2) = dict_depth($v);\n            if ($d2 > $depth) {\n                $depth = $d2;\n            }\n        }\n    }\n    return $depth + 1;\n}",
    "    my $depth = 0;\n    my @queue = ($d);\n    while (my $e = shift @queue) {\n        if (ref($e) eq 'HASH') {\n            $depth = @queue if @queue > $depth;\n            unshift @queue, values %$e;\n        }\n    }\n    return $depth;\n}",
    "    my $depth = 1;\n    my $max = 0;\n    my $sub_depth = 0;\n    foreach my $key (keys %$d) {\n        if (ref($d->{$key}) eq 'HASH') {\n            $sub_depth = dict_depth($d->{$key});\n            $max = $sub_depth if $sub_depth > $max;\n        }\n    }\n    return $depth + $max;\n}",
    "    my $depth = 0;\n    for my $k (keys %$d) {\n        my $v = $d->{$k};\n        if (ref $v eq 'HASH') {\n            my $d = dict_depth($v);\n            $depth = $d if $d > $depth;\n        }\n    }\n    return $depth + 1;\n}",
    "    my $max = 0;\n    for my $k (keys %$d) {\n        my $v = $d->{$k};\n        if (ref($v) eq 'HASH') {\n            my $depth = dict_depth($v) + 1;\n            $max = $depth if $depth > $max;\n        }\n    }\n    return $max;\n}",
    "    my $max = 0;\n    my $depth = 0;\n    my @stack = ($d);\n    while (@stack) {\n        my $e = pop @stack;\n        if (ref($e) eq 'HASH') {\n            $depth++;\n            push @stack, values %$e;\n        }\n        elsif (ref($e) eq 'ARRAY') {\n            $depth++;\n            push @stack, @$e;\n        }\n        else {\n            $depth--;\n        }\n        $max = $depth if $depth > $max;\n    }\n    return $max;\n}",
    "    my $max = 0;\n    for my $k (keys %$d) {\n        my $v = $d->{$k};\n        if (ref($v) eq 'HASH') {\n            my $depth = dict_depth($v) + 1;\n            $max = $depth if $depth > $max;\n        }\n    }\n    return $max;\n}",
    "    my($depth) = 0;\n    my($key);\n    my($value);\n    my($subdepth);",
    "    my $depth = 1;\n    for my $k (keys %$d) {\n        my $v = $d->{$k};\n        if (ref $v eq 'HASH') {\n            my $d = dict_depth($v);\n            $depth = $d + 1 if $d + 1 > $depth;\n        }\n    }\n    return $depth;\n}",
    "    my $depth = 0;\n    for my $k (keys %$d) {\n        my $v = $d->{$k};\n        if (ref $v eq 'HASH') {\n            my $d = dict_depth($v);\n            $depth = $d if $d > $depth;\n        }\n    }\n    return $depth + 1;\n}",
    "    my($max) = 0;\n    foreach my $k (keys %$d) {\n        my($v) = $d->{$k};\n        if (ref($v) eq 'HASH') {\n            my($depth) = dict_depth($v);\n            $max = $depth if $depth > $max;\n        }\n    }\n    return $max + 1;\n}",
    "    my $depth = 1;\n    foreach my $key (keys %$d) {\n        my $value = $d->{$key};\n        if (ref($value) eq 'HASH') {\n            $depth = max($depth, 1 + dict_depth($value));\n        }\n    }\n    return $depth;\n}",
    "    my($depth) = 0;\n    my($k, $v);\n    while (($k, $v) = each %$d) {\n\t$depth = dict_depth($v) if ref($v) eq 'HASH';\n    }\n    return $depth + 1;\n}",
    "    my $depth = 0;\n    my $cur_depth = 0;\n    my $key;\n    my $val;\n    while (($key, $val) = each %$d) {\n        $cur_depth = 0;\n        if (ref($val) eq 'HASH') {\n            $cur_depth = dict_depth($val);\n        }\n        if ($cur_depth > $depth) {\n            $depth = $cur_depth;\n        }\n    }\n    return $depth + 1;\n}"
  ]
}