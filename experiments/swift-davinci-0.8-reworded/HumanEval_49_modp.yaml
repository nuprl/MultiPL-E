name: HumanEval_49_modp
language: swift
prompt: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3, p:\
  \ 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
  /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\nfunc\
  \ modp(n: Int, p: Int) -> Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101,\
  \ p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
  assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
  \ 31, p: 5) == 3)"
completions: ["    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n   \
    \     let new_n = n / 2\n        let new_p = modp(n: new_n, p: p)\n        return\
    \ (new_p * new_p) % p\n    } else {\n        let new_n = (n - 1) / 2\n       \
    \ let new_p = modp(n: new_n, p: p)\n        return (new_p * new_p * 2) % p\n \
    \   }", '    return Int(BigUInt(n).power(p)) % p', "  var n = n\n  var result\
    \ = 1\n  while n > 0 {\n    if n % 2 == 1 {\n      result = (result * n) % p\n\
    \    }\n    n = n / 2\n  }\n  return result", "    var bin = String(n, radix:\
    \ 2)\n    var result = 1\n    var i = 0\n    while i < bin.count {\n        if\
    \ bin[i] == \"1\" {\n            result = (result * result) % p\n        }\n \
    \       if i + 1 < bin.count {\n            result = (result * result) % p\n \
    \       }\n        i += 1\n    }\n    return result", "    if n == 0 {\n     \
    \   return 1\n    }\n    if n % 2 == 0 {\n        return modp(n: n / 2, p: p)\
    \ * modp(n: n / 2, p: p) % p\n    } else {\n        return modp(n: n - 1, p: p)\
    \ * modp(n: n, p: p) % p\n    }", "  // small numbers: compute directly\n  if\
    \ n < p * p {\n    var result = 1\n    for _ in 0..<n {\n      result = (result\
    \ * 2) % p\n    }\n    return result\n  }\n  // large numbers: reduce via modulo\
    \ p\n  var (half, full) = (n / 2, n)\n  if half % 2 == 1 {\n    full /= 2\n  \
    \  half += 1\n  }\n  return (modp(n: half, p: p) * modp(n: full, p: p)) % p",
  "    let a = Int(pow(Double(n), Double(p - 2)))\n    return a % p", "    let res\
    \ = exponentiation_modulo(base: 2, exponent: n, p: p)\n    return res", "    if\
    \ n == 0 {\n        return 1\n    } else if n % 2 == 0 {\n        let modp_n =\
    \ modp(n: n / 2, p: p)\n        return (modp_n * modp_n) % p\n    } else {\n \
    \       return (modp(n: n - 1, p: p) * n) % p\n    }", "  if n == 0 {\n    return\
    \ 1\n  }\n  var x = modp(n: n / 2, p: p)\n  x = (x * x) % p\n  if n % 2 == 1 {\n\
    \    x = (x * 2) % p\n  }\n  return x", "    if n == 0 {\n        return 1\n \
    \   }\n    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n /\
    \ 2, p: p) % p\n    } else {\n        return 2 * modp(n: n - 1, p: p) % p\n  \
    \  }", "\tvar result = 1\n\tfor _ in 0..<n {\n\t\tresult = (result * 2) % p\n\t\
    }\n\treturn result", "\tvar result = 1\n\t\n\tif p == 0 {\n\t\treturn 0\n\t}\n\
    \t\n\tfor _ in 0..<n {\n\t\tresult = (result * 2) % p\n\t}\n\t\n\treturn result",
  "    var (p, n) = (p, n)\n    var result = 1\n    var b = 2\n    while n > 0 {\n\
    \        if n % 2 == 1 {\n            result = (result * b) % p\n        }\n \
    \       n /= 2\n        b = (b * b) % p\n    }\n    return result", "    guard\
    \ n > 0 else { return 1 }\n    let x = modp(n: n / 2, p: p)\n    var result =\
    \ x * x % p\n    if n % 2 == 1 {\n        result = result * 2 % p\n    }\n   \
    \ return result", "    let n = n % p\n    var result = 1\n    for _ in 1...n {\n\
    \        result = (result * 2) % p\n    }\n    return result", "    // YOUR CODE\
    \ HERE\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    } else {\n    \
    \    return modp(n: n - 1, p: p) * modp(n: n - 1, p: p) * 2 % p\n    }\n    ",
  "    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        let y =\
    \ modp(n: n / 2, p: p)\n        return (y * y) % p\n    }\n    return (modp(n:\
    \ n - 1, p: p) * n) % p", "    var sum = 1\n    var i = 0\n    while i < n {\n\
    \        sum = (sum * 2) % p\n        i += 1\n    }\n    return sum", '    return
    Int(pow(Double(p), Double(n))) % p', "    if n < p {\n        return Int(pow(Double(n),\
    \ Double(p - 2)) + 0.5) % p\n    } else {\n        return Int(pow(Double(n) %\
    \ Double(p), Double(p - 2)) + 0.5) % p\n    }", '    return BigInt(n).modpow(1,
    modulus: BigInt(p)).description.toInt()!', "    if n == 0 {\n        return 1\n\
    \    }\n    var result = 1\n    var product = 2\n    while n > 0 {\n        if\
    \ n % 2 == 1 {\n            result = (result * product) % p\n        }\n     \
    \   product = (product * product) % p\n        n /= 2\n    }\n    return result",
  "    var n = n\n    var p = p\n    if n == 0 {\n        return 1\n    }\n    var\
    \ res = 1\n    for _ in 0..<n {\n        res = (res * 2) % p\n    }\n    return\
    \ res", "    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n        return\
    \ n % p\n    }\n    var n_1 = n - 1\n    if n_1 % 2 == 0 {\n        let temp =\
    \ modp(n: n_1 / 2, p: p)\n        return (temp * temp) % p\n    } else {\n   \
    \     let temp = modp(n: n_1 / 2, p: p)\n        return (temp * temp * n) % p\n\
    \    }", "    if n == 0 {\n        return 1\n    }\n    else if n % 2 == 0 {\n\
    \        let y = modp(n: n / 2, p: p)\n        return (y * y) % p\n    }\n   \
    \ else {\n        return (n * modp(n: n - 1, p: p)) % p\n    }", "    let b =\
    \ n.digits(radix: 2)\n    var p_current = p\n    var result = 1\n    for i in\
    \ (0..<b.count).reversed() {\n        if b[i] == 1 {\n            result = (result\
    \ * p_current) % p\n        }\n        p_current = (p_current * p_current) % p\n\
    \    }\n    return result", "    guard n != 0 else { return 1 }\n    guard n !=\
    \ 1 else { return 0 }\n    guard p != 0 else { return 1 }\n    guard p != 1 else\
    \ { return 0 }\n    var n = n\n    var p = p\n    var result = 1\n    var m =\
    \ n % p\n    while m != 0 {\n        result = result * m % p\n        m = m *\
    \ m % p\n        n = n >> 1\n    }\n    return result", "    if n < 0 {\n    \
    \    let o = modp(n: -n, p: p)\n        return (p - o) % p\n    }\n    if n ==\
    \ 0 {\n        return 1\n    }\n    if n == 1 {\n        return n\n    }\n   \
    \ if n % 2 == 0 {\n        let m = modp(n: n / 2, p: p)\n        return (m * m)\
    \ % p\n    }\n    let m = modp(n: n - 1, p: p)\n    return (m * n) % p", "   \
    \ if n == 0 {\n        return 1\n    }\n    else if n == 1 {\n        return n\
    \ % p\n    }\n    else {\n        return (n * modp(n: n - 1, p: p)) % p\n    }",
  "    // The `if` here makes the code a lot shorter.\n    if n == 0 {\n        return\
    \ 1\n    } else {\n        var b = modp(n/2, p: p)\n        b = b * b % p\n  \
    \      // b = b^2 % p\n        if n % 2 == 1 {\n            b = b * 2 % p\n  \
    \      }\n        return b\n    }", "    let d = n / p\n    let m = n - d * p\n\
    \    return d % 2 == 0 ? m : p - m", "    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result", "    var n = n\n    var\
    \ result = 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result =\
    \ (result * n) % p\n        }\n        n = n / 2\n    }\n    return result", " \
    \   precondition(n >= 0, \"n must be non-negative\")\n    precondition(p > 1,\
    \ \"p must be greater than 1\")\n    if n == 0 {\n        return 1\n    }\n  \
    \  var a = 2\n    var b = 0\n    while n > 0 {\n        if n % 2 == 1 {\n    \
    \        b = (b + a) % p\n        }\n        a = (a * 2) % p\n        n = n /\
    \ 2\n    }\n    return b", "    var result = 1\n    var n = n\n    var p = p\n\
    \    while n > 0 {\n        if n & 1 != 0 {\n            result = (result * n)\
    \ % p\n        }\n        n = n >> 1\n        p = (p * p) % p\n    }\n    return\
    \ result", "    if p == 0 { return n }\n    let result = modp(n: n, p: p / 2)\n\
    \    if p % 2 == 0 {\n        return (result * result) % p\n    } else {\n   \
    \     return (n * result * result) % p\n    }", "    let answer = pow(Decimal(2),\
    \ Decimal(n), Decimal(p))\n    return Int(answer)", "    var m = n\n    var k\
    \ = 1\n    while m > 0 {\n        if m % 2 == 1 {\n            k = (k * n) % p\n\
    \        }\n        m = m / 2\n        n = (n * n) % p\n    }\n    return k",
  "    var a = 1\n    var b = n\n    while b > 0 {\n        if b & 1 != 0 {\n    \
    \        a = (a * n) % p\n        }\n        b >>= 1\n        n = (n * n) % p\n\
    \    }\n    return a", "  var i = 1\n  var k = n\n  while k > 0 {\n    if k %\
    \ 2 == 1 {\n      i = (i * n) % p\n    }\n    n = (n * n) % p\n    k = k / 2\n\
    \  }\n  return i", "    var result = 1\n    var prime = p\n    var power = n\n\
    \    while power > 0 {\n        if power % 2 == 1 {\n            result = (result\
    \ * prime) % p\n        }\n        power /= 2\n        prime = (prime * prime)\
    \ % p\n    }\n    return result", "    var exp = n\n    var mul = 1\n    while\
    \ exp > 0 {\n        if exp % 2 == 1 {\n            mul = (mul * 2) % p\n    \
    \    }\n        exp = exp / 2\n    }\n    return mul", "    if n < p {\n     \
    \   return n\n    }\n    var d: (Int, Int) = (1, n)\n    while d.1 > 1 {\n   \
    \     if d.1 % 2 == 0 {\n            d.1 /= 2\n            d.0 *= 2\n        }\
    \ else {\n            d.1 -= 1\n            d.0 += 1\n        }\n    }\n    return\
    \ d.0", "    var result = 1\n    var i = 0\n    var pow2 = n\n    while i < p\
    \ {\n        if pow2 % 2 != 0 {\n            result = (result * 2) % p\n     \
    \   }\n        pow2 = pow2 / 2\n        i += 1\n    }\n    return result", " \
    \   var n = n\n    var res = 1\n    while n > 0 {\n        if n & 1 == 1 {\n \
    \           res = (res * n) % p\n        }\n        n = n >> 1\n    }\n    return\
    \ res", "  let zero = 0.0\n  let one = 1.0\n  let two = 2.0\n  let p = Float(p)\n\
    \  var result = one\n  for i in 0..<n {\n    result = mod(result * two, p)\n \
    \ }\n  return Int(result)", "  var res = 1\n  var i = n\n  var exp = 1\n  while\
    \ i > 0 {\n    if i & 1 != 0 {\n      res = (res * exp) % p\n    }\n    exp =\
    \ (exp * exp) % p\n    i >>= 1\n  }\n  return res", "    precondition(p > 0)\n\
    \    precondition(p < 20_000_000)\n    precondition(n >= 0)\n    precondition(n\
    \ < 20_000_000)\n    return Int(Double(n).truncatingRemainder(dividingBy: Double(p)))",
  "    precondition(p > 0)\n    precondition(n >= 0)\n    if n < p {\n        return\
    \ n\n    }\n    var r = n\n    var z = n\n    for _ in 1..<p {\n        z = z\
    \ * n\n        z = z % p\n        r = z\n    }\n    return r", "    if n == 0\
    \ {\n        return 1\n    } else if n % 2 == 0 {\n        let t = modp(n: n /\
    \ 2, p: p)\n        return (t * t) % p\n    } else {\n        return (modp(n:\
    \ n - 1, p: p) * n) % p\n    }", "    if n == 0 {\n        return 1\n    } else\
    \ if n == 1 {\n        return 2 % p\n    } else {\n        return modp(n: n -\
    \ 1, p: p) * 2 % p\n    }", "    var power = 1\n    var base = n % p\n    var\
    \ exp = p - 2\n    while exp > 0 {\n        if exp % 2 == 1 {\n            power\
    \ = (power * base) % p\n        }\n        base = (base * base) % p\n        exp\
    \ /= 2\n    }\n    return power", "    let base = n % p\n    var exponent = n\
    \ / p\n    var result = 1\n    while exponent > 0 {\n        if exponent % 2 ==\
    \ 1 {\n            result = (result * base) % p\n        }\n        exponent =\
    \ exponent / 2\n        base = (base * base) % p\n    }\n    return result", " \
    \   let m = BigInt(n)\n    let power = BigInt(2).power(m)\n    let mod = power\
    \ % BigInt(p)\n    return Int(mod)", "    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n & 1 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n >> 1\n    }\n    return result", "    guard n > 0 && p\
    \ > 0 else { return 0 }\n    guard n != 1 else { return 1 }\n    guard n != 2\
    \ else { return p % 2 == 0 ? 0 : 1 }\n    if n % 2 == 0 {\n        let res = modp(n:\
    \ n / 2, p: p)\n        return (res * res) % p\n    } else {\n        return (2\
    \ * modp(n: n - 1, p: p)) % p\n    }", "    var result = 1\n    var exponent =\
    \ n\n    var base = p % p\n    while exponent > 0 {\n        if exponent % 2 ==\
    \ 1 {\n            result = (result * base) % p\n        }\n        exponent >>=\
    \ 1\n        base = (base * base) % p\n    }\n    return result", "    precondition(n\
    \ >= 0, \"n must be >= 0\")\n    precondition(p > 0, \"p must be > 0\")\n    if\
    \ p == 1 {\n        return 0\n    }\n    var result = 1\n    var b = n\n    var\
    \ e = p - 2\n    while b > 0 {\n        if b % 2 == 1 {\n            result =\
    \ (result * e) % p\n        }\n        e = (e * e) % p\n        b /= 2\n    }\n\
    \    return result", "    var x = 1\n    for _ in 0..<n {\n        x = (x * 2)\
    \ % p\n    }\n    return x", "    // Check for special case where p is 2.\n  \
    \  if p == 2 {\n        return n % 2\n    }\n    // Raise 2 to the power of n\
    \ modulo p.\n    var r = 1\n    for _ in 0..<n {\n        r = (r * 2) % p\n  \
    \  }\n    return r", "    let r = n % p\n    return r < 0 ? r + p : r", "    var\
    \ result = 1\n    var i = n\n    var b = p - 2\n    while b > 0 {\n        if\
    \ b % 2 == 1 {\n            result = (result * i) % p\n        }\n        i =\
    \ (i * i) % p\n        b /= 2\n    }\n    return result", "    var res = 1\n \
    \   var base = n % p\n    var exp = p - 2\n    while exp > 0 {\n        if exp\
    \ % 2 == 1 {\n            res = (res * base) % p\n        }\n        base = (base\
    \ * base) % p\n        exp /= 2\n    }\n    return res", "    // TODO: Implement\
    \ me!\n    return 0", "    if n == 0 {\n        return 1\n    }\n    else if n\
    \ % 2 == 0 {\n        let nmodp = modp(n: n / 2, p: p)\n        return (nmodp\
    \ * nmodp) % p\n    }\n    else {\n        return (modp(n: n - 1, p: p) * n) %\
    \ p\n    }", "    if n % p == 0 {\n        return 0\n    }\n    else if n < p\
    \ {\n        return n\n    }\n    else {\n        let t = n / p\n        let s\
    \ = n - t * p\n        return s\n    }", "    if n == 0 {\n        return 1\n\
    \    }\n    var result = modp(n: n / 2, p: p)\n    result = (result * result)\
    \ % p\n    if n % 2 == 1 {\n        result = (result * 2) % p\n    }\n    return\
    \ result", "\tif n == 0 {\n\t\treturn 1\n\t}\n\tvar r = 1\n\tvar m = n\n\twhile\
    \ m > 0 {\n\t\tif m % 2 == 1 {\n\t\t\tr = (r * r) % p\n\t\t}\n\t\tm = m / 2\n\t\
    }\n\treturn r", '    return ((1<<n) % p)', "    if n == 0 {\n        return 1\n\
    \    } else if n % 2 == 0 {\n        let y = modp(n: n / 2, p: p)\n        return\
    \ (y * y) % p\n    } else {\n        return (n % p * modp(n: n - 1, p: p)) % p\n\
    \    }", "    var pow = n\n    var res = 1\n    while pow > 0 {\n        if pow\
    \ & 1 == 1 {\n            res = (res * n) % p\n        }\n        n = (n * n)\
    \ % p\n        pow = pow >> 1\n    }\n    return res", "  var result = 1\n  for\
    \ _ in 0..<n {\n    result = (result * 2) % p\n  }\n  return result", "    var\
    \ n = n\n    var a = 1\n    while n > 0 {\n        if n & 1 == 1 {\n         \
    \   a = (a * n) % p\n        }\n        n = n >> 1\n    }\n    return a", "  \
    \  let r = modp(n: n, p: p, n: n)\n    return r", "    if n == 0 {\n        return\
    \ 1\n    } else if n == 1 {\n        return n % p\n    } else {\n        var a\
    \ = modp(n: n - 1, p: p)\n        a = a * n\n        a = a % p\n        return\
    \ a\n    }", "    var result = 1\n    for _ in 0..<n {\n        result = (result\
    \ * 2) % p\n    }\n    return result", "    if n < 0 {\n        return p - modp(n:\
    \ abs(n), p: p)\n    }\n    if n == 0 {\n        return 1\n    }\n    if n ==\
    \ 1 {\n        return n\n    }\n    if n % 2 == 0 {\n        return modp(n: n/2,\
    \ p: p) * modp(n: n/2, p: p) % p\n    }\n    else {\n        return modp(n: n/2,\
    \ p: p) * modp(n: n/2, p: p) * 2 % p\n    }", "    if n == 0 {\n        return\
    \ 1\n    }\n    else if n == 1 {\n        return n % p\n    }\n    else {\n  \
    \      let result = modp(n: n/2, p: p)\n        if n % 2 == 0 {\n            return\
    \ (result * result) % p\n        }\n        else {\n            return (result\
    \ * result * n) % p\n        }\n    }", "    if n == 0 {\n        return 1\n \
    \   } else if n == 1 {\n        return 2 % p\n    } else {\n        let prev =\
    \ modp(n: n - 1, p: p)\n        return (prev * 2) % p\n    }", "    // \u0420\u0435\
    \u043A\u0443\u0440\u0441\u0438\u0432\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\
    \u0430\u043D\u0442 \u0441\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0435\u0434\
    \u043B\u0435\u043D\u043D\u044B\u0439\n    // \u0432 \u043F\u0435\u0440\u0432\u043E\
    \u043C \u0432\u0430\u0440\u0438\u0430\u043D\u0442\u0435 \u043F\u0435\u0440\u0435\
    \u043F\u043E\u043B\u043D\u0435\u043D\u0438\u0435 \u0441\u0442\u0435\u043A\u0430\
    \ \u0431\u044B\u043B\u043E \u043D\u0430 \u043F\u0435\u0440\u0432\u043E\u043C \u0442\
    \u0435\u0441\u0442\u0435 - \u043F\u0440\u0438 \u0432\u044B\u0447\u0438\u0441\u043B\
    \u0435\u043D\u0438\u0438 \u0434\u0432\u043E\u0439\u043A\u0438 \u0432 \u0441\u0442\
    \u0435\u043F\u0435\u043D\u0438 65536\n    // \u0432\u043E \u0432\u0442\u043E\u0440\
    \u043E\u043C \u043F\u0435\u0440\u0435\u043F\u043E\u043B\u043D\u0435\u043D\u0438\
    \u0435 \u0441\u0442\u0435\u043A\u0430 \u043F\u0440\u043E\u0438\u0441\u0445\u043E\
    \u0434\u0438\u0442 \u043D\u0430 \u0432\u0442\u043E\u0440\u043E\u043C \u0442\u0435\
    \u0441\u0442\u0435\n    // \u043A \u0442\u043E\u043C\u0443 \u0436\u0435 \u0432\
    \u0440\u0435\u043C\u044F \u0432\u044B\u043F\u043E\u043B\u043D\u0435\u043D\u0438\
    \u044F \u0441\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\
    \u043E\u0435\n    //if n == 0 {\n    //    return 1\n    //}\n    //if n % 2 ==\
    \ 0 {\n    //    return modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    //}\
    \ else {\n    //    return 2 * modp(n: n - 1, p: p) % p\n    //}\n    \n    var\
    \ res = 1\n    var cur = 2\n    var pow = n\n    while pow > 0 {\n        if pow\
    \ % 2 == 1 {\n            res = (res * cur) % p\n        }\n        cur = (cur\
    \ * cur) % p\n        pow /= 2\n    }\n    return res", "    if n == 0 {\n   \
    \     return 1\n    }\n    var res = 1\n    for _ in 0..<n {\n        res = (res\
    \ * 2) % p\n    }\n    return res", "    var r = 1\n    var i = 1\n    var x =\
    \ n\n    let modp = p\n    while i <= n {\n        if (x & 1) == 1 {\n       \
    \     r = (r * i) % modp\n        }\n        x = x >> 1\n        i = (i * 2) %\
    \ modp\n    }\n    return r", '    return 1 << n % p', "    var res = 1\n    for\
    \ _ in 1...n {\n        res = res * 2 % p\n    }\n    return res", "    var result\
    \ = n\n    for _ in 1..<n {\n        result = (result * n) % p\n    }\n    return\
    \ result", "  let power = min(n, p - 1)\n  var result = 1\n  for _ in 0..<power\
    \ {\n    result = (result * 2) % p\n  }\n  return result", "    // TODO: implementation\n\
    \    var a = 1\n    for _ in 0...n{\n        a = (a * 2) % p\n    }\n    return\
    \ a", "\tguard n != 0 else { return 1 }\n\tguard n % 2 == 0 else { return (pow(n,\
    \ p) % p) }\n\tlet half = modp(n: n / 2, p: p)\n\treturn (half * half) % p", " \
    \   precondition(p > 0)\n    precondition(n >= 0)\n    guard n > 0 else { return\
    \ 1 }\n    return modp(n: (n-1)/2, p: p) * modp(n: (n+1)/2, p: p) % p", "    //\
    \ precondition: p is prime\n    var res = 1\n    var mul = n\n    var pow = p\
    \ - 2\n    while pow > 0 {\n        if pow & 1 == 1 {\n            res = (res\
    \ * mul) % p\n        }\n        mul = (mul * mul) % p\n        pow >>= 1\n  \
    \  }\n    return res", "    let n1 = n % p\n    var r = 1\n    for _ in 1...n1\
    \ {\n        r = (r * 2) % p\n    }\n    return r", "    var result = 1\n    for\
    \ _ in 0..<n {\n        result = (result * 2) % p\n    }\n    return result",
  "    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 == 1 {\n\
    \            result = (result * n) % p\n        }\n        n = n / 2\n    }\n\
    \    return result", "  var power = n\n  var result = 1\n  while power > 0 {\n\
    \    if power % 2 == 1 {\n      result = (result * n) % p\n    }\n    power /=\
    \ 2\n    n = (n * n) % p\n  }\n  return result", "    return (1..<n).reduce(1)\
    \ { (result, _) in\n        return (result * 2) % p\n    }", '  return Int(pow(Double(n),
    Double(p - 2))) % p', "    var prod = 1\n    for _ in 0..<n {\n        prod =\
    \ (prod * 2) % p\n    }\n    return prod", "  // Only compute n % p if n is large\n\
    \  if n >= p {\n    return Int(BigUInt(n) % BigUInt(p))\n  }\n  // BigInt.modPow\
    \ is too slow (probably due to a bug)\n  var res = 1\n  for _ in 0..<n {\n   \
    \ res = (res * 2) % p\n  }\n  return res", "    precondition(n >= 0, \"n >= 0\"\
    )\n    precondition(p > 0, \"p > 0\")\n    if n == 0 {\n        return 1\n   \
    \ }\n    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2,\
    \ p: p) % p\n    }\n    return 2 * modp(n: n - 1, p: p) % p", "  var result =\
    \ 1\n  for _ in 0..<n {\n    result = (result * 2) % p\n  }\n  return result",
  "  precondition(p > 0)\n  precondition(n >= 0)\n  var x = 1\n  var m = n\n  while\
    \ m > 0 {\n    if m % 2 == 1 {\n      x = (x * x) % p\n    }\n    m = m / 2\n\
    \  }\n  return x", "\treturn Int(pow(Double(n), Double(p - 2))) % p", "    var\
    \ a = 1\n    for _ in 0..<n {\n        a = a * 2 % p\n    }\n    return a", " \
    \ let x = (n % p) + p\n  return x % p", "    var r = 1\n    var n = n\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            r = (r * (n % p)) % p\n      \
    \  }\n        n /= 2\n    }\n    return r", "    var d = p, s = 0, t = 1\n   \
    \ while (n > 0) {\n        let (q, r) = divide(n, d)\n        (n, d) = (d, r)\n\
    \        (s, t) = (t, s-q*t)\n    }\n    if (d > 1) {\n        return 0\n    }\n\
    \    if (s < 0) {\n        s += p\n    }\n    return s", "    if n == 0 {\n  \
    \      return 1\n    }\n    if n % 2 == 0 {\n        let y = modp(n / 2, p: p)\n\
    \        return (y * y) % p\n    }\n    else {\n        return (modp(n - 1, p:\
    \ p) * n) % p\n    }", "    if p == 0 {\n        return n == 0 ? 1 : 0\n    }\n\
    \    if n < 0 {\n        return modp(n: n + p, p: p)\n    }\n    if n == 0 {\n\
    \        return 1\n    }\n    if n == 1 {\n        return 0\n    }\n    if n %\
    \ 2 == 0 {\n        return modp(n: (n / 2) * (n / 2), p: p)\n    }\n    return\
    \ modp(n: (n / 2) * (n / 2), p: p) * 2", "    let r: Int\n    if n == 0 {\n  \
    \      r = 1\n    } else if n == 1 {\n        r = 0\n    } else {\n        let\
    \ a = modp(n: n - 1, p: p)\n        let b = modp(n: n - 2, p: p)\n        r =\
    \ (a + b) % p\n    }\n    return r", "    if p == 1 {\n        return 0\n    }\n\
    \    var out = 1\n    for _ in 0..<n {\n        out = (out * 2) % p\n    }\n \
    \   return out", "    if n == 0 {\n        return 1\n    } else if n % 2 == 0\
    \ {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    } else\
    \ {\n        return n * modp(n: n - 1, p: p) % p\n    }", "    var r = 1\n   \
    \ var x = n\n    var y = p\n    while y > 0 {\n        if y & 1 > 0 {\n      \
    \      r = (r * x) % p\n        }\n        y = y >> 1\n        x = (x * x) % p\n\
    \    }\n    return r", "    if n == 0 {\n        return 1\n    }\n    if n % 2\
    \ == 0 {\n        let b = modp(n: n / 2, p: p)\n        return (b * b) % p\n \
    \   }\n    return (n % p) * modp(n: n - 1, p: p) % p", "  var n = n\n  var result\
    \ = 1\n  for _ in 0..<n {\n    result = (result * 2) % p\n  }\n  return result",
  "    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n        return n % p\n\
    \    }\n    var ret = modp(n: n/2, p: p)\n    ret = (ret * ret) % p\n    if n\
    \ % 2 == 1 {\n        ret = (ret * 2) % p\n    }\n    return ret", "    var n\
    \ = n\n    var result = 1\n    while n > 0 {\n        if n & 1 == 1 {\n      \
    \      result = (result * n) % p\n        }\n        n = n >> 1\n    }\n    return\
    \ result", '    return Int(pow(Double(n), Double(p - 2))) % p', "    let k = mod(n,\
    \ p)\n    let d = p - 1\n    return mod(k, d)", "    if n == 0 {\n        return\
    \ 1\n    }\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n\
    \ % 2 == 1 {\n            result = (result * (2 % p)) % p\n        }\n       \
    \ n = n / 2\n    }\n    return result", "    if n == 0 {\n        return 1\n \
    \   }\n    if n % 2 == 0 {\n        return square(n: modp(n: n / 2, p: p)) % p\n\
    \    } else {\n        return (n % p) * modp(n: n - 1, p: p) % p\n    }", "  \
    \  if n < 0 {\n        return modp(n: p - (-n % p), p: p)\n    }\n    if n ==\
    \ 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return ((modp(n:\
    \ n / 2, p: p) % p) * (modp(n: n / 2, p: p) % p)) % p\n    }\n    return ((modp(n:\
    \ n / 2, p: p) % p) * (modp(n: n / 2, p: p) % p) * 2) % p", "    let nlz = n.leadingZeroBitCount\n\
    \    var _n = n << nlz\n    var res = 1\n    var p_prod = p\n    var i = 1\n \
    \   while _n > 0 {\n        if _n & 1 != 0 {\n            res = (res * p_prod)\
    \ % p\n        }\n        p_prod = (p_prod * p_prod) % p\n        _n >>= 1\n \
    \       i += 1\n    }\n    return res", "    var (r, a) = (1, n % p)\n    var\
    \ b = n\n    while b > 0 {\n        if b % 2 == 1 {\n            r = (r * a) %\
    \ p\n        }\n        a = (a * a) % p\n        b /= 2\n    }\n    return r",
  "    // Did you know that a % b is the same as a - ((a / b) * b)?\n    // var a\
    \ = n % p;\n    // while a < 0 {\n    //     a += p;\n    // }\n    // return\
    \ a;\n    return n % p;", "    var out = 1\n    for _ in 0..<n {\n        out\
    \ = (out * 2) % p\n    }\n    return out", "    var result = 1\n    var t = n\n\
    \    while t > 0 {\n        if t % 2 == 1 {\n            result = (result * n)\
    \ % p\n        }\n        t /= 2\n        n = (n * n) % p\n    }\n    return result",
  "    if n == 0 {\n        return 1\n    } else if n%2 == 0 {\n        return modp(n:\
    \ n/2, p: p)**2 % p\n    } else {\n        return modp(n: n-1, p: p) * modp(n:\
    \ 1, p: p) % p\n    }", '  return Int(pow(Double(n), Double(p - 2))) % p', " \
    \   if p == 0 {\n        return 1\n    }\n    else if n == 0 {\n        return\
    \ 1\n    }\n    else if n == 1 {\n        return n\n    }\n    else if n == 2\
    \ {\n        return (n % p)\n    }\n    else {\n        var pow : Int = 1\n  \
    \      for _ in 0..<n {\n            pow = (pow * 2) % p\n        }\n        return\
    \ pow\n    }", '    return powmod(n: 2, p: n, m: p)', "    if n < 0 {\n      \
    \  return modp(n: -n, p: p)\n    }\n    if n == 0 {\n        return 1\n    }\n\
    \    var x = 1\n    for _ in 0..<n {\n        x = (x * 2) % p\n    }\n    return\
    \ x", "    var k = n\n    var r = 1\n    while k > 0 {\n        if k % 2 == 1\
    \ {\n            r = (r * 2) % p\n        }\n        k = k / 2\n    }\n    return\
    \ r", "    var r = 1\n    var n = n\n    var p = p\n    while n > 0 {\n      \
    \  if n & 1 != 0 {\n            r = (r * n) % p\n        }\n        n >>= 1\n\
    \    }\n    return r", "    if n == 0 {\n        return 1\n    } else if n ==\
    \ 1 {\n        return n % p\n    } else {\n        var result = 1\n        var\
    \ power = n\n        while power > 0 {\n            result = (result * power)\
    \ % p\n            power /= 2\n        }\n        return result\n    }", "  var\
    \ r = 1\n  var b = n\n  while b > 0 {\n    if b % 2 == 1 {\n      r = (r * n)\
    \ % p\n    }\n    b = b / 2\n    n = (n * n) % p\n  }\n  return r", '    return
    1', "    if n == 0 {\n        return 1\n    } else if n == 1 {\n        return\
    \ n % p\n    } else {\n        var i = 1\n        var m = modp(n: n / 2, p: p)\n\
    \        var q = (m * m) % p\n        if n % 2 == 1 {\n            q = (q * modp(n:\
    \ n - 1, p: p)) % p\n        }\n        return q\n    }", "    let a = pow(2,\
    \ Double(n))\n    let b = pow(2, Double(p))\n    let c = Int(Double(a).truncatingRemainder(dividingBy:\
    \ b))\n    return c", "    if n % p == 0 {\n        return 0\n    }\n    var result\
    \ = 1\n    for _ in 0..<n {\n        result = (result * 2) % p\n    }\n    return\
    \ result", "    if n == 0 {\n        return 1\n    } else if n == 1 {\n      \
    \  return 2 % p\n    } else {\n        var ret = modp(n: n / 2, p: p)\n      \
    \  ret = (ret * ret) % p\n        if n % 2 == 1 {\n            ret = (ret * 2)\
    \ % p\n        }\n        return ret\n    }", '    return Int(pow(Double(n), Double(p
    - 2))) % p', "    if n == 0 {\n        return 1\n    }\n    else if n % 2 == 0\
    \ {\n        let t = modp(n: n / 2, p: p)\n        return (t * t) % p\n    }\n\
    \    else {\n        return (n * modp(n: n - 1, p: p)) % p\n    }", "    var res\
    \ = 1\n    for _ in 0..<n {\n        res = (res * 2) % p\n    }\n    return res",
  "    var result = 1\n    var base = n % p\n    var exponent = n\n    while exponent\
    \ > 0 {\n        if exponent % 2 == 1 {\n            result = (result * base)\
    \ % p\n        }\n        exponent >>= 1\n        base = (base * base) % p\n \
    \   }\n    return result", "    if n == 0 {\n        return 1\n    }\n    if n\
    \ % 2 == 0 {\n        let y = modp(n: n / 2, p: p)\n        return (y * y) % p\n\
    \    }\n    else {\n        return (n * modp(n: n - 1, p: p)) % p\n    }", " \
    \   if n == 0 {\n        return 1\n    }\n    var res = modp(n: n / 2, p: p)\n\
    \    res = (res * res) % p\n    if n % 2 == 1 {\n        res = (res * 2) % p\n\
    \    }\n    return res", "    // Decompose n\n    var r = 0, k = n\n    while\
    \ k > 0 {\n        let t = k & -k\n        k ^= t\n        r = (r + t) % p\n \
    \   }\n    return r", "    if n == 0 {\n        return 1\n    } else if n == 1\
    \ {\n        return n % p\n    } else {\n        var res = 1\n        let m =\
    \ n % p\n        for _ in 1..<m {\n            res = (res * 2) % p\n        }\n\
    \        return res\n    }", "    var sum = 1\n    var product = 2\n    var nCopy\
    \ = n\n    while nCopy > 0 {\n        if nCopy & 1 == 1 {\n            sum = (sum\
    \ * product) % p\n        }\n        product = (product * product) % p\n     \
    \   nCopy = nCopy >> 1\n    }\n    return sum", "    var d: Double = 1\n    for\
    \ _ in 0..<n {\n        d = (d * 2) % Double(p)\n    }\n    return Int(d)", " \
    \   if p == 1 {\n        return 0\n    }\n    var result = 1\n    var base = n\
    \ % p\n    var exp = n\n    while exp > 0 {\n        if exp % 2 == 1 {\n     \
    \       result = (result * base) % p\n        }\n        exp /= 2\n        base\
    \ = (base * base) % p\n    }\n    return result", "  var d = 1\n  var k = 0\n\
    \  var m = n\n  while m > 0 {\n    if m & 1 == 1 {\n      d = (d * d) % p\n  \
    \    k += 1\n    }\n    m >>= 1\n  }\n  return d", "    var res = 1\n    var n\
    \ = n\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * res)\
    \ % p\n        }\n        n /= 2\n    }\n    return res", "    if n <= 0 {\n \
    \       return 1\n    }\n    if n == 1 {\n        return 0\n    }\n    if n ==\
    \ 2 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return (modp(n: n\
    \ / 2, p: p) * modp(n: n / 2, p: p) + 1) % p\n    }\n    return (modp(n: n / 2,\
    \ p: p) * modp(n: n / 2, p: p) + modp(n: n / 2 + 1, p: p) * modp(n: n / 2 + 1,\
    \ p: p) + 1) % p", "    if n == 0 {\n        return 1\n    }\n    var modp = modp(n:\
    \ n >> 1, p: p)\n    modp = (modp * modp) % p\n    if n & 1 == 1 {\n        modp\
    \ = (modp * 2) % p\n    }\n    return modp", "    if n == 0 {\n        return\
    \ 1\n    }\n    let half = n/2\n    let halfmod = modp(n: half, p: p)\n    if\
    \ n % 2 == 0 {\n        return (halfmod * halfmod) % p\n    } else {\n       \
    \ return (halfmod * halfmod * 2) % p\n    }", "    guard n > 0 else { return 1\
    \ }\n    var s = n\n    var r = 1\n    while s > 0 {\n        if s % 2 == 1 {\n\
    \            r = (r * n) % p\n        }\n        n = (n * n) % p\n        s /=\
    \ 2\n    }\n    return r", "  if n == 0 {\n    return 1\n  } else if n % 2 ==\
    \ 0 {\n    let x = modp(n: n / 2, p: p)\n    return (x * x) % p\n  } else {\n\
    \    return (n * modp(n: n - 1, p: p)) % p\n  }", "    let binary: [Int] = toBinary(n:\
    \ n)\n    var a = 1\n    for _ in 0..<binary.count {\n        a = (a * a) % p\n\
    \        if binary[binary.count - 1] == 1 {\n            a = (a * 2) % p\n   \
    \     }\n    }\n    return a", "    if n == 0 {\n        return 1\n    }\n   \
    \ var rem = 1\n    var pow = n\n    while pow != 0 {\n        if pow & 1 == 1\
    \ {\n            rem = (rem * n) % p\n        }\n        pow = pow >> 1\n    \
    \    n = (n * n) % p\n    }\n    return rem", "    var c = Int(ceil(Double(n)\
    \ / Double(p)))\n    while (p * c < n) {\n        c += 1\n    }\n    return n\
    \ - p * c", "    precondition(n >= 0)\n    precondition(p > 0)\n    var result\
    \ = 1\n    for _ in 0..<n {\n        result = (result * 2) % p\n    }\n    return\
    \ result", "\tvar (\n\t\tr = 1\n\t\td = n\n\t)\n\twhile d > 0 {\n\t\tif d & 1\
    \ != 0 {\n\t\t\tr = (r * n) % p\n\t\t}\n\t\td >>= 1\n\t\tn = (n * n) % p\n\t}\n\
    \treturn r", "    var pow = n\n    var result = 1\n    while pow > 0 {\n     \
    \   if pow % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = (n * n) % p\n        pow /= 2\n    }\n    return result", "    var res\
    \ = 1\n    if n == 0 {\n        return res\n    }\n    else if n == 1 {\n    \
    \    return 2\n    }\n    else {\n        for _ in 0..<n {\n            res =\
    \ (res * 2) % p\n        }\n        return res\n    }", "    var res = 1\n   \
    \ var i = n\n    while i > 0 {\n        let q = i / p\n        let r = i - q *\
    \ p\n        let s = res * r\n        let t = s / p\n        res = s - t * p\n\
    \        i = q\n    }\n    return res", "    var result = 1\n    for _ in 0..<n\
    \ {\n        result = (result * 2) % p\n    }\n    return result", "    if n ==\
    \ 0 {\n        return 1\n    } else if n % 2 == 0 {\n        let res = modp(n:\
    \ n / 2, p: p)\n        return res * res % p\n    } else {\n        return (n\
    \ % p) * modp(n: n - 1, p: p) % p\n    }", "    var res = 1\n    for _ in 0..<n\
    \ {\n        res = (res * 2) % p\n    }\n    return res", "    var x = 1\n   \
    \ for _ in 0..<n {\n        x = x * 2 % p\n    }\n    return x", "    if p ==\
    \ 1 {\n        return 0\n    }\n    var result = 1\n    for _ in 0..<n {\n   \
    \     result = (result * 2) % p\n    }\n    return result", "    // PRECONDITION:\
    \ n >= 0 and p > 0\n    if n == 0 {\n        return 1\n    }\n    if n % 2 ==\
    \ 0 {\n        let t = modp(n: n / 2, p: p)\n        return (t * t) % p\n    }\n\
    \    return (modp(n: n - 1, p: p) * p) % n", "\tlet result = powmod(2, n, p)\n\
    \treturn result", "    precondition(n >= 0)\n    precondition(p > 0)\n    if p\
    \ == 1 {\n        return 0\n    }\n    var r = 1\n    var nn = n\n    while nn\
    \ != 0 {\n        if nn & 1 != 0 {\n            r = (r * n) % p\n        }\n \
    \       nn >>= 1\n        n = (n * n) % p\n    }\n    return r", "    if p ==\
    \ 1 {\n        return 0\n    }\n    if n == 0 {\n        return 1\n    }\n   \
    \ var b = 1\n    var np = p\n    var nn = n\n    while nn > 0 {\n        if nn\
    \ % 2 == 1 {\n            b = (b * np) % p\n        }\n        np = (np * np)\
    \ % p\n        nn /= 2\n    }\n    return b", "    var nn = n\n    var result\
    \ = 1\n    while nn > 0 {\n        if nn & 1 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        nn = nn >> 1\n        n = (n * n) % p\n    }\n\
    \    return result", "    var num: Int = 1\n    var i: Int = 0\n    while i <\
    \ n {\n        num = (num * 2) % p\n        i += 1\n    }\n    return num", " \
    \ precondition(p > 0, \"modp: only positive p supported\")\n  if p == 1 { return\
    \ 0 }\n  var b = 1\n  var e = n\n  while e > 0 {\n    if e & 1 == 1 {\n      b\
    \ = b * n % p\n    }\n    e >>= 1\n    n = n * n % p\n  }\n  return b", "    let\
    \ nn = Int(floor(log(Double(n)) / log(2.0)))\n    var result = 1\n    var a =\
    \ 2\n    for i in 0...nn {\n        if n & (1 << i) != 0 {\n            result\
    \ = (result * a) % p\n        }\n        a = (a * a) % p\n    }\n    return result",
  '    return pow(2, n) % p', "    let (quotient, remainder) = Int.divMod(dividend:\
    \ n, divisor: p, truncatingRemainder: true)\n    return Int.minimum(p - remainder,\
    \ remainder)", "    var res = 1\n    for _ in 1...n {\n        res = (res * 2)\
    \ % p\n    }\n    return res", "    precondition(p >= 1)\n    precondition(n >=\
    \ 0)\n    var result = 1\n    var power = n\n    while power > 0 {\n        if\
    \ power % 2 == 1 {\n            result = (result * n) % p\n        }\n       \
    \ n = (n * n) % p\n        power = power / 2\n    }\n    return result", "\tif\
    \ p <= 0 {\n\t\treturn 0\n\t}\n\tvar result = 1\n\tvar base = n % p\n\tvar exponent\
    \ = n\n\twhile exponent > 0 {\n\t\tif exponent % 2 == 1 {\n\t\t\tresult = (result\
    \ * base) % p\n\t\t}\n\t\texponent = exponent >> 1\n\t\tbase = (base * base) %\
    \ p\n\t}\n\treturn result", "    // YOUR CODE HERE\n    if n == 0 {\n        return\
    \ 1\n    } else {\n        var temp = n\n        var num = p\n        var ans\
    \ = 1\n        while temp > 0 {\n            if temp % 2 == 1 {\n            \
    \    ans = (ans * num) % p\n            }\n            num = (num * num) % p\n\
    \            temp = temp / 2\n        }\n        return ans\n    }", "    var\
    \ n = n\n    var prod = 1\n    let p = p\n    while n > 0 {\n        if n % 2\
    \ == 1 {\n            prod = (prod * p) % modulo\n        }\n        n = n / 2\n\
    \    }\n    return prod", "    if n == 0 {\n        return 1\n    }\n    if n\
    \ % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n\
    \    } else {\n        return n * modp(n: n - 1, p: p) % p\n    }", "  // Implementation\
    \ detail of the algorithm.\n  func b(n: Int, p: Int) -> Int {\n    if n == 0 {\n\
    \      return 1\n    }\n    if n == 1 {\n      return 2\n    }\n    if n.isMultiple(of:\
    \ 2) {\n      return b(n: n/2, p: p).square() % p\n    }\n    return (2 * b(n:\
    \ n-1, p: p)) % p\n  }\n  return b(n: n, p: p) % p", "    if n == 0 {\n      \
    \  return 1\n    }\n    else if n % 2 == 0 {\n        return modp(n: n / 2, p:\
    \ p) * modp(n: n / 2, p: p) % p\n    }\n    else {\n        return modp(n: n -\
    \ 1, p: p) * modp(n: 2, p: p) % p\n    }", '    return (1 << n) % p', "    var\
    \ c = 1\n    var i = 0\n    let cp = p\n    while i < n {\n        c = (c * cp)\
    \ % p\n        i += 1\n    }\n    return c", "    var x = 1\n    var n = n\n \
    \   var p = p\n    while n > 0 {\n        if n % 2 == 1 {\n            x = (x\
    \ * n) % p\n        }\n        n = n >> 1\n        p = (p * p) % 100\n    }\n\
    \    return x", "  var temp = 1\n  for _ in 0..<n {\n    temp = (temp * 2) % p\n\
    \  }\n  return temp", "    if n == 0 {\n        return 1\n    }\n    if n % 2\
    \ == 0 {\n        return (modp(n: n / 2, p: p) * modp(n: n / 2, p: p)) % p\n \
    \   } else {\n        return (modp(n: n / 2, p: p) * modp(n: n / 2, p: p) * 2)\
    \ % p\n    }", "    let comp = BigInt(p)\n    return BigInt(n).modPow(2, modulus:\
    \ comp).description.trimZeros()", "    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let c = modp(n: n / 2, p: p)\n        return (c\
    \ * c) % p\n    } else {\n        return (modp(n: n - 1, p: p) * modp(n: n, p:\
    \ p)) % p\n    }", "  assert(p > 0)\n  var result = 1\n  for _ in 0..<n {\n  \
    \  result = (result * 2) % p\n  }\n  return result", "    if n == 0 {\n      \
    \  return 1\n    }\n    if n == 1 {\n        return n % p\n    }\n    let half\
    \ = modp(n: n / 2, p: p)\n    let halfP = (half * half) % p\n    if n % 2 == 0\
    \ {\n        return halfP\n    } else {\n        return (halfP * n) % p\n    }",
  "    var total = 1\n    for _ in 0..<n {\n        total = total * 2 % p\n    }\n\
    \    return total"]
stop_tokens:
- "\n}"
