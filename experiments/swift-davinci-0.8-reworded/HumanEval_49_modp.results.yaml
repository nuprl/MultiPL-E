language: swift
name: HumanEval_49_modp
results:
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let new_n = n / 2\n        let new_p = modp(n: new_n,\
    \ p: p)\n        return (new_p * new_p) % p\n    } else {\n        let new_n =\
    \ (n - 1) / 2\n        let new_p = modp(n: new_n, p: p)\n        return (new_p\
    \ * new_p * 2) % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014425
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return Int(BigUInt(n).power(p)) % p\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpi2h9yb5r.swift:14:16: error: cannot find 'BigUInt' in scope\n \
    \   return Int(BigUInt(n).power(p)) % p\n               ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014425
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  var n = n\n  var result = 1\n  while n >\
    \ 0 {\n    if n % 2 == 1 {\n      result = (result * n) % p\n    }\n    n = n\
    \ / 2\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp9vme0r9z/tmp9vme0r9z.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b16d932cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b16d9023b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b16d9023988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b16d90227b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9vme0r9z                        0x000056516c8902cd <unavailable> + 4813

    5    libc.so.6                          0x00002b16d9518460 __libc_start_main +
    245

    6    tmp9vme0r9z                        0x000056516c88fef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014425
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var bin = String(n, radix: 2)\n    var\
    \ result = 1\n    var i = 0\n    while i < bin.count {\n        if bin[i] == \"\
    1\" {\n            result = (result * result) % p\n        }\n        if i + 1\
    \ < bin.count {\n            result = (result * result) % p\n        }\n     \
    \   i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmppc9bject.swift:18:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if bin[i]\
    \ == \"1\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmppc9bject.swift:14:9: warning: variable 'bin'\
    \ was never mutated; consider changing to 'let' constant\n    var bin = String(n,\
    \ radix: 2)\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014425
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014292
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  // small numbers: compute directly\n  if\
    \ n < p * p {\n    var result = 1\n    for _ in 0..<n {\n      result = (result\
    \ * 2) % p\n    }\n    return result\n  }\n  // large numbers: reduce via modulo\
    \ p\n  var (half, full) = (n / 2, n)\n  if half % 2 == 1 {\n    full /= 2\n  \
    \  half += 1\n  }\n  return (modp(n: half, p: p) * modp(n: full, p: p)) % p\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmps9szds0o/tmps9szds0o.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b66eb14bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b66eae42b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b66eae42988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b66eae417b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps9szds0o                        0x0000562ff61625bc <unavailable> + 5564

    5    libc.so.6                          0x00002b66eb337460 __libc_start_main +
    245

    6    tmps9szds0o                        0x0000562ff6161fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014425
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let a = Int(pow(Double(n), Double(p -\
    \ 2)))\n    return a % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpsla38nm_.swift:14:17: error: cannot find 'pow' in scope\n    let\
    \ a = Int(pow(Double(n), Double(p - 2)))\n                ^~~\n"
  stdout: ''
  timestamp: 1660014425
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let res = exponentiation_modulo(base:\
    \ 2, exponent: n, p: p)\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3svr497f.swift:14:15: error: cannot find 'exponentiation_modulo'\
    \ in scope\n    let res = exponentiation_modulo(base: 2, exponent: n, p: p)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014425
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    } else\
    \ if n % 2 == 0 {\n        let modp_n = modp(n: n / 2, p: p)\n        return (modp_n\
    \ * modp_n) % p\n    } else {\n        return (modp(n: n - 1, p: p) * n) % p\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpr_hre2h4/tmpr_hre2h4.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b68c9b41c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b68c9838b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b68c9838988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b68c98377b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr_hre2h4                        0x000055dc30c732cd <unavailable> + 4813

    5    libc.so.6                          0x00002b68c9d2d460 __libc_start_main +
    245

    6    tmpr_hre2h4                        0x000055dc30c72ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014425
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  }\n  var x\
    \ = modp(n: n / 2, p: p)\n  x = (x * x) % p\n  if n % 2 == 1 {\n    x = (x * 2)\
    \ % p\n  }\n  return x\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014425
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return 2 * modp(n: n - 1, p: p) % p\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014425
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tvar result = 1\n\tfor _ in 0..<n {\n\t\t\
    result = (result * 2) % p\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014425
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tvar result = 1\n\t\n\tif p == 0 {\n\t\t\
    return 0\n\t}\n\t\n\tfor _ in 0..<n {\n\t\tresult = (result * 2) % p\n\t}\n\t\n\
    \treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014425
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var (p, n) = (p, n)\n    var result =\
    \ 1\n    var b = 2\n    while n > 0 {\n        if n % 2 == 1 {\n            result\
    \ = (result * b) % p\n        }\n        n /= 2\n        b = (b * b) % p\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014425
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    guard n > 0 else { return 1 }\n    let\
    \ x = modp(n: n / 2, p: p)\n    var result = x * x % p\n    if n % 2 == 1 {\n\
    \        result = result * 2 % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014425
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let n = n % p\n    var result = 1\n  \
    \  for _ in 1...n {\n        result = (result * 2) % p\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp1gycub71/tmp1gycub71.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9dac252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9dabf49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9dabf49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9dabf487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1gycub71                        0x00005638b1ea23bd <unavailable> + 5053

    5    libc.so.6                          0x00002b9dac43e460 __libc_start_main +
    245

    6    tmp1gycub71                        0x00005638b1ea1fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014425
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    // YOUR CODE HERE\n    if n == 0 {\n \
    \       return 1\n    }\n    if n % 2 == 0 {\n        return modp(n: n / 2, p:\
    \ p) * modp(n: n / 2, p: p) % p\n    } else {\n        return modp(n: n - 1, p:\
    \ p) * modp(n: n - 1, p: p) * 2 % p\n    }\n    \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpx9p1aih0/tmpx9p1aih0.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4285744c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b428543bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b428543b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b428543a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx9p1aih0                        0x0000558af97dd24d <unavailable> + 4685

    5    libc.so.6                          0x00002b4285930460 __libc_start_main +
    245

    6    tmpx9p1aih0                        0x0000558af97dcef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014425
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let y = modp(n: n / 2, p: p)\n        return (y\
    \ * y) % p\n    }\n    return (modp(n: n - 1, p: p) * n) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpoo3bxk74/tmpoo3bxk74.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7b3dfb7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7b3dcaeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7b3dcae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7b3dcad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoo3bxk74                        0x000055f44d17b2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b7b3e1a3460 __libc_start_main +
    245

    6    tmpoo3bxk74                        0x000055f44d17aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var sum = 1\n    var i = 0\n    while\
    \ i < n {\n        sum = (sum * 2) % p\n        i += 1\n    }\n    return sum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014425
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return Int(pow(Double(p), Double(n)))\
    \ % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpwv46cg3j.swift:14:16: error: cannot find 'pow' in scope\n    return\
    \ Int(pow(Double(p), Double(n))) % p\n               ^~~\n"
  stdout: ''
  timestamp: 1660014425
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < p {\n        return Int(pow(Double(n),\
    \ Double(p - 2)) + 0.5) % p\n    } else {\n        return Int(pow(Double(n) %\
    \ Double(p), Double(p - 2)) + 0.5) % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpscw1b3gp.swift:15:20: error: cannot find 'pow' in scope\n     \
    \   return Int(pow(Double(n), Double(p - 2)) + 0.5) % p\n                   ^~~\n\
    /tmp/tmpscw1b3gp.swift:17:20: error: cannot find 'pow' in scope\n        return\
    \ Int(pow(Double(n) % Double(p), Double(p - 2)) + 0.5) % p\n                 \
    \  ^~~\n"
  stdout: ''
  timestamp: 1660014430
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return BigInt(n).modpow(1, modulus: BigInt(p)).description.toInt()!\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp01142r8i.swift:14:12: error: cannot find 'BigInt' in scope\n  \
    \  return BigInt(n).modpow(1, modulus: BigInt(p)).description.toInt()!\n     \
    \      ^~~~~~\n/tmp/tmp01142r8i.swift:14:41: error: cannot find 'BigInt' in scope\n\
    \    return BigInt(n).modpow(1, modulus: BigInt(p)).description.toInt()!\n   \
    \                                     ^~~~~~\n"
  stdout: ''
  timestamp: 1660014425
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    var result = 1\n    var product = 2\n    while n > 0 {\n        if n % 2\
    \ == 1 {\n            result = (result * product) % p\n        }\n        product\
    \ = (product * product) % p\n        n /= 2\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp66igehon.swift:24:11: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n        n /= 2\n        ~ ^\n"
  stdout: ''
  timestamp: 1660014425
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var p = p\n    if n ==\
    \ 0 {\n        return 1\n    }\n    var res = 1\n    for _ in 0..<n {\n      \
    \  res = (res * 2) % p\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014425
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return n % p\n    }\n    var n_1 = n - 1\n    if n_1\
    \ % 2 == 0 {\n        let temp = modp(n: n_1 / 2, p: p)\n        return (temp\
    \ * temp) % p\n    } else {\n        let temp = modp(n: n_1 / 2, p: p)\n     \
    \   return (temp * temp * n) % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpsp8x877b/tmpsp8x877b.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0df09ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0df06d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0df06d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0df06d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsp8x877b                        0x00005569b00c024d <unavailable> + 4685

    5    libc.so.6                          0x00002b0df0bc9460 __libc_start_main +
    245

    6    tmpsp8x877b                        0x00005569b00bfef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014425
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    else if n % 2 == 0 {\n        let y = modp(n: n / 2, p: p)\n        return\
    \ (y * y) % p\n    }\n    else {\n        return (n * modp(n: n - 1, p: p)) %\
    \ p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpkveiyjgb/tmpkveiyjgb.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad403dbdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad403ab4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad403ab4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad403ab37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkveiyjgb                        0x000055c918f6a2cd <unavailable> + 4813

    5    libc.so.6                          0x00002ad403fa9460 __libc_start_main +
    245

    6    tmpkveiyjgb                        0x000055c918f69ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014425
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let b = n.digits(radix: 2)\n    var p_current\
    \ = p\n    var result = 1\n    for i in (0..<b.count).reversed() {\n        if\
    \ b[i] == 1 {\n            result = (result * p_current) % p\n        }\n    \
    \    p_current = (p_current * p_current) % p\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpyneat_bk.swift:14:15: error: value of type 'Int' has no member\
    \ 'digits'\n    let b = n.digits(radix: 2)\n            ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014425
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    guard n != 0 else { return 1 }\n    guard\
    \ n != 1 else { return 0 }\n    guard p != 0 else { return 1 }\n    guard p !=\
    \ 1 else { return 0 }\n    var n = n\n    var p = p\n    var result = 1\n    var\
    \ m = n % p\n    while m != 0 {\n        result = result * m % p\n        m =\
    \ m * m % p\n        n = n >> 1\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014430
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        let o = modp(n: -n,\
    \ p: p)\n        return (p - o) % p\n    }\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  let m = modp(n: n / 2, p: p)\n        return (m * m) % p\n    }\n    let m\
    \ = modp(n: n - 1, p: p)\n    return (m * n) % p\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpzxg0_s6_/tmpzxg0_s6_.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3e8b971c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3e8b668b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3e8b668988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3e8b6677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxg0_s6_                        0x000055e0cb3812cd <unavailable> + 4813

    5    libc.so.6                          0x00002b3e8bb5d460 __libc_start_main +
    245

    6    tmpzxg0_s6_                        0x000055e0cb380ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014425
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    else if n == 1 {\n        return n % p\n    }\n    else {\n        return\
    \ (n * modp(n: n - 1, p: p)) % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpoa4146ny/tmpoa4146ny.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b20fa3bbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b20fa0b2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b20fa0b2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b20fa0b17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoa4146ny                        0x0000561ca322124d <unavailable> + 4685

    5    libc.so.6                          0x00002b20fa5a7460 __libc_start_main +
    245

    6    tmpoa4146ny                        0x0000561ca3220ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014425
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    // The `if` here makes the code a lot\
    \ shorter.\n    if n == 0 {\n        return 1\n    } else {\n        var b = modp(n/2,\
    \ p: p)\n        b = b * b % p\n        // b = b^2 % p\n        if n % 2 == 1\
    \ {\n            b = b * 2 % p\n        }\n        return b\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpgjqjv755.swift:18:21: error: missing argument label 'n:' in call\n\
    \        var b = modp(n/2, p: p)\n                    ^\n                    \
    \ n: \n/tmp/tmpgjqjv755.swift:19:15: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        b = b * b % p\n              ^\n"
  stdout: ''
  timestamp: 1660014425
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let d = n / p\n    let m = n - d * p\n\
    \    return d % 2 == 0 ? m : p - m\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmposy357t1/tmposy357t1.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1766bec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1763b5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1763b5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1763b47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmposy357t1                        0x000055979ca412cd <unavailable> + 4813

    5    libc.so.6                          0x00002ad1768aa460 __libc_start_main +
    245

    6    tmposy357t1                        0x000055979ca40ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014425
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    precondition(n >= 0, \"n must be non-negative\"\
    )\n    precondition(p > 1, \"p must be greater than 1\")\n    if n == 0 {\n  \
    \      return 1\n    }\n    var a = 2\n    var b = 0\n    while n > 0 {\n    \
    \    if n % 2 == 1 {\n            b = (b + a) % p\n        }\n        a = (a *\
    \ 2) % p\n        n = n / 2\n    }\n    return b\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp2l034k6k.swift:26:9: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n        n = n / 2\n        ^\n"
  stdout: ''
  timestamp: 1660014425
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var n = n\n    var\
    \ p = p\n    while n > 0 {\n        if n & 1 != 0 {\n            result = (result\
    \ * n) % p\n        }\n        n = n >> 1\n        p = (p * p) % p\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b0cbfe95c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0cbfb8c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0cbfb8c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0cbfb8c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0cbfb8bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpotp3l6_c                        0x00005608ed6ee6a5 <unavailable> + 5797

    6    tmpotp3l6_c                        0x00005608ed6ee1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b0cc0081460 __libc_start_main +
    245

    8    tmpotp3l6_c                        0x00005608ed6edef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014425
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if p == 0 { return n }\n    let result\
    \ = modp(n: n, p: p / 2)\n    if p % 2 == 0 {\n        return (result * result)\
    \ % p\n    } else {\n        return (n * result * result) % p\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpsbl_l9ge/tmpsbl_l9ge.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3ac025bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3abff52b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3abff52988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3abff517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsbl_l9ge                        0x0000557871b1924d <unavailable> + 4685

    5    libc.so.6                          0x00002b3ac0447460 __libc_start_main +
    245

    6    tmpsbl_l9ge                        0x0000557871b18ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014425
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let answer = pow(Decimal(2), Decimal(n),\
    \ Decimal(p))\n    return Int(answer)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpnp1mhtc9.swift:14:18: error: cannot find 'pow' in scope\n    let\
    \ answer = pow(Decimal(2), Decimal(n), Decimal(p))\n                 ^~~\n/tmp/tmpnp1mhtc9.swift:14:22:\
    \ error: cannot find 'Decimal' in scope\n    let answer = pow(Decimal(2), Decimal(n),\
    \ Decimal(p))\n                     ^~~~~~~\n/tmp/tmpnp1mhtc9.swift:14:34: error:\
    \ cannot find 'Decimal' in scope\n    let answer = pow(Decimal(2), Decimal(n),\
    \ Decimal(p))\n                                 ^~~~~~~\n/tmp/tmpnp1mhtc9.swift:14:46:\
    \ error: cannot find 'Decimal' in scope\n    let answer = pow(Decimal(2), Decimal(n),\
    \ Decimal(p))\n                                             ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014425
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var m = n\n    var k = 1\n    while m\
    \ > 0 {\n        if m % 2 == 1 {\n            k = (k * n) % p\n        }\n   \
    \     m = m / 2\n        n = (n * n) % p\n    }\n    return k\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7makc_71.swift:21:9: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n        n = (n * n) % p\n        ^\n"
  stdout: ''
  timestamp: 1660014425
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var a = 1\n    var b = n\n    while b\
    \ > 0 {\n        if b & 1 != 0 {\n            a = (a * n) % p\n        }\n   \
    \     b >>= 1\n        n = (n * n) % p\n    }\n    return a\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_7dk71i_.swift:21:9: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n        n = (n * n) % p\n        ^\n"
  stdout: ''
  timestamp: 1660014425
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  var i = 1\n  var k = n\n  while k > 0 {\n\
    \    if k % 2 == 1 {\n      i = (i * n) % p\n    }\n    n = (n * n) % p\n    k\
    \ = k / 2\n  }\n  return i\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpb3nc7uwk.swift:20:5: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n    n = (n * n) % p\n    ^\n"
  stdout: ''
  timestamp: 1660014425
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var prime = p\n  \
    \  var power = n\n    while power > 0 {\n        if power % 2 == 1 {\n       \
    \     result = (result * prime) % p\n        }\n        power /= 2\n        prime\
    \ = (prime * prime) % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpay5jbjjh/tmpay5jbjjh.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1e14f21c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1e14c18b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1e14c18988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1e14c177b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpay5jbjjh                        0x00005584c424824d <unavailable> + 4685

    5    libc.so.6                          0x00002b1e1510d460 __libc_start_main +
    245

    6    tmpay5jbjjh                        0x00005584c4247ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014425
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var exp = n\n    var mul = 1\n    while\
    \ exp > 0 {\n        if exp % 2 == 1 {\n            mul = (mul * 2) % p\n    \
    \    }\n        exp = exp / 2\n    }\n    return mul\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp30wijxrs/tmp30wijxrs.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8dc34c2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8dc31b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8dc31b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8dc31b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp30wijxrs                        0x000055847470b24d <unavailable> + 4685

    5    libc.so.6                          0x00002b8dc36ae460 __libc_start_main +
    245

    6    tmp30wijxrs                        0x000055847470aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014425
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < p {\n        return n\n    }\n\
    \    var d: (Int, Int) = (1, n)\n    while d.1 > 1 {\n        if d.1 % 2 == 0\
    \ {\n            d.1 /= 2\n            d.0 *= 2\n        } else {\n          \
    \  d.1 -= 1\n            d.0 += 1\n        }\n    }\n    return d.0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpkaig1h1n/tmpkaig1h1n.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af15cb49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af15c840b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af15c840988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af15c83f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkaig1h1n                        0x000055e23e02f2cd <unavailable> + 4813

    5    libc.so.6                          0x00002af15cd35460 __libc_start_main +
    245

    6    tmpkaig1h1n                        0x000055e23e02eef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014425
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var i = 0\n    var\
    \ pow2 = n\n    while i < p {\n        if pow2 % 2 != 0 {\n            result\
    \ = (result * 2) % p\n        }\n        pow2 = pow2 / 2\n        i += 1\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpwy2qsqoy/tmpwy2qsqoy.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeebaed6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeebabcdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeebabcd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeebabcc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwy2qsqoy                        0x000055e20ba3f24d <unavailable> + 4685

    5    libc.so.6                          0x00002aeebb0c2460 __libc_start_main +
    245

    6    tmpwy2qsqoy                        0x000055e20ba3eef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014425
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var res = 1\n    while\
    \ n > 0 {\n        if n & 1 == 1 {\n            res = (res * n) % p\n        }\n\
    \        n = n >> 1\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpaqan4efb/tmpaqan4efb.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac6da0f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac6d9deeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac6d9dee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac6d9ded7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaqan4efb                        0x0000555fc41e62cd <unavailable> + 4813

    5    libc.so.6                          0x00002ac6da2e3460 __libc_start_main +
    245

    6    tmpaqan4efb                        0x0000555fc41e5ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  let zero = 0.0\n  let one = 1.0\n  let two\
    \ = 2.0\n  let p = Float(p)\n  var result = one\n  for i in 0..<n {\n    result\
    \ = mod(result * two, p)\n  }\n  return Int(result)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpgth3pru5.swift:20:14: error: cannot find 'mod' in scope\n    result\
    \ = mod(result * two, p)\n             ^~~\n"
  stdout: ''
  timestamp: 1660014425
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  var res = 1\n  var i = n\n  var exp = 1\n\
    \  while i > 0 {\n    if i & 1 != 0 {\n      res = (res * exp) % p\n    }\n  \
    \  exp = (exp * exp) % p\n    i >>= 1\n  }\n  return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp7csqxt58/tmp7csqxt58.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abca5abac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abca57b1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abca57b1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abca57b07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7csqxt58                        0x000055d687b3624d <unavailable> + 4685

    5    libc.so.6                          0x00002abca5ca6460 __libc_start_main +
    245

    6    tmp7csqxt58                        0x000055d687b35ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014425
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    precondition(p > 0)\n    precondition(p\
    \ < 20_000_000)\n    precondition(n >= 0)\n    precondition(n < 20_000_000)\n\
    \    return Int(Double(n).truncatingRemainder(dividingBy: Double(p)))\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpvisd2hl1/tmpvisd2hl1.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0db7480c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0db7177b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0db7177988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0db71767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvisd2hl1                        0x0000560579c563ad <unavailable> + 5037

    5    libc.so.6                          0x00002b0db766c460 __libc_start_main +
    245

    6    tmpvisd2hl1                        0x0000560579c55fd9 <unavailable> + 4057

    '
  stdout: ''
  timestamp: 1660014425
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    precondition(p > 0)\n    precondition(n\
    \ >= 0)\n    if n < p {\n        return n\n    }\n    var r = n\n    var z = n\n\
    \    for _ in 1..<p {\n        z = z * n\n        z = z % p\n        r = z\n \
    \   }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp3wkloilt/tmp3wkloilt.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b99382efc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9937fe6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9937fe6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9937fe57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3wkloilt                        0x000055e9199fa3bd <unavailable> + 5053

    5    libc.so.6                          0x00002b99384db460 __libc_start_main +
    245

    6    tmp3wkloilt                        0x000055e9199f9fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014425
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    } else\
    \ if n % 2 == 0 {\n        let t = modp(n: n / 2, p: p)\n        return (t * t)\
    \ % p\n    } else {\n        return (modp(n: n - 1, p: p) * n) % p\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpe4xqrgk1/tmpe4xqrgk1.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b37ab41ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b37ab115b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b37ab115988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b37ab1147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe4xqrgk1                        0x000055c9785202cd <unavailable> + 4813

    5    libc.so.6                          0x00002b37ab60a460 __libc_start_main +
    245

    6    tmpe4xqrgk1                        0x000055c97851fef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014425
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    } else\
    \ if n == 1 {\n        return 2 % p\n    } else {\n        return modp(n: n -\
    \ 1, p: p) * 2 % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var power = 1\n    var base = n % p\n\
    \    var exp = p - 2\n    while exp > 0 {\n        if exp % 2 == 1 {\n       \
    \     power = (power * base) % p\n        }\n        base = (base * base) % p\n\
    \        exp /= 2\n    }\n    return power\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp54u2eips/tmp54u2eips.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b16e222dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b16e1f24b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b16e1f24988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b16e1f237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp54u2eips                        0x0000557e4e43c24d <unavailable> + 4685

    5    libc.so.6                          0x00002b16e2419460 __libc_start_main +
    245

    6    tmp54u2eips                        0x0000557e4e43bef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let base = n % p\n    var exponent = n\
    \ / p\n    var result = 1\n    while exponent > 0 {\n        if exponent % 2 ==\
    \ 1 {\n            result = (result * base) % p\n        }\n        exponent =\
    \ exponent / 2\n        base = (base * base) % p\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp75dk6coc.swift:22:9: error: cannot assign to value: 'base' is a\
    \ 'let' constant\n        base = (base * base) % p\n        ^~~~\n/tmp/tmp75dk6coc.swift:14:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let base = n % p\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660014425
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let m = BigInt(n)\n    let power = BigInt(2).power(m)\n\
    \    let mod = power % BigInt(p)\n    return Int(mod)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpnjhiq6uc.swift:14:13: error: cannot find 'BigInt' in scope\n  \
    \  let m = BigInt(n)\n            ^~~~~~\n/tmp/tmpnjhiq6uc.swift:15:17: error:\
    \ cannot find 'BigInt' in scope\n    let power = BigInt(2).power(m)\n        \
    \        ^~~~~~\n/tmp/tmpnjhiq6uc.swift:16:23: error: cannot find 'BigInt' in\
    \ scope\n    let mod = power % BigInt(p)\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660014425
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n & 1 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n >> 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpe4jzi5ce/tmpe4jzi5ce.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8c3363fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8c33336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8c33336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8c333357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe4jzi5ce                        0x00005635f429d2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b8c3382b460 __libc_start_main +
    245

    6    tmpe4jzi5ce                        0x00005635f429cef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    guard n > 0 && p > 0 else { return 0 }\n\
    \    guard n != 1 else { return 1 }\n    guard n != 2 else { return p % 2 == 0\
    \ ? 0 : 1 }\n    if n % 2 == 0 {\n        let res = modp(n: n / 2, p: p)\n   \
    \     return (res * res) % p\n    } else {\n        return (2 * modp(n: n - 1,\
    \ p: p)) % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmppix3p1dc/tmppix3p1dc.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4a5512cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4a54e23b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4a54e23988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4a54e227b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppix3p1dc                        0x0000557683a3424d <unavailable> + 4685

    5    libc.so.6                          0x00002b4a55318460 __libc_start_main +
    245

    6    tmppix3p1dc                        0x0000557683a33ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var exponent = n\n\
    \    var base = p % p\n    while exponent > 0 {\n        if exponent % 2 == 1\
    \ {\n            result = (result * base) % p\n        }\n        exponent >>=\
    \ 1\n        base = (base * base) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpbi6akexi/tmpbi6akexi.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74caa80c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74ca777b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74ca777988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74ca7767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbi6akexi                        0x00005608cb90d24d <unavailable> + 4685

    5    libc.so.6                          0x00002b74cac6c460 __libc_start_main +
    245

    6    tmpbi6akexi                        0x00005608cb90cef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    precondition(n >= 0, \"n must be >= 0\"\
    )\n    precondition(p > 0, \"p must be > 0\")\n    if p == 1 {\n        return\
    \ 0\n    }\n    var result = 1\n    var b = n\n    var e = p - 2\n    while b\
    \ > 0 {\n        if b % 2 == 1 {\n            result = (result * e) % p\n    \
    \    }\n        e = (e * e) % p\n        b /= 2\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpvrqts8fy/tmpvrqts8fy.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba0013f8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba0010efb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba0010ef988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba0010ee7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvrqts8fy                        0x000055816c2612dd <unavailable> + 4829

    5    libc.so.6                          0x00002ba0015e4460 __libc_start_main +
    245

    6    tmpvrqts8fy                        0x000055816c260f89 <unavailable> + 3977

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var x = 1\n    for _ in 0..<n {\n    \
    \    x = (x * 2) % p\n    }\n    return x\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014426
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    // Check for special case where p is 2.\n\
    \    if p == 2 {\n        return n % 2\n    }\n    // Raise 2 to the power of\
    \ n modulo p.\n    var r = 1\n    for _ in 0..<n {\n        r = (r * 2) % p\n\
    \    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let r = n % p\n    return r < 0 ? r +\
    \ p : r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpsefzi6ut/tmpsefzi6ut.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab177cebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab1779e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab1779e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab1779e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsefzi6ut                        0x000055ec04d722cd <unavailable> + 4813

    5    libc.so.6                          0x00002ab177ed7460 __libc_start_main +
    245

    6    tmpsefzi6ut                        0x000055ec04d71ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var i = n\n    var\
    \ b = p - 2\n    while b > 0 {\n        if b % 2 == 1 {\n            result =\
    \ (result * i) % p\n        }\n        i = (i * i) % p\n        b /= 2\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2d75abj_/tmp2d75abj_.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b50b8c9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b50b8995b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b50b8995988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b50b89947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2d75abj_                        0x000055d12bca824d <unavailable> + 4685

    5    libc.so.6                          0x00002b50b8e8a460 __libc_start_main +
    245

    6    tmp2d75abj_                        0x000055d12bca7ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var res = 1\n    var base = n % p\n  \
    \  var exp = p - 2\n    while exp > 0 {\n        if exp % 2 == 1 {\n         \
    \   res = (res * base) % p\n        }\n        base = (base * base) % p\n    \
    \    exp /= 2\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpqmfpc15d/tmpqmfpc15d.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba814ff7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba814ceeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba814cee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba814ced7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqmfpc15d                        0x000055b8b74de24d <unavailable> + 4685

    5    libc.so.6                          0x00002ba8151e3460 __libc_start_main +
    245

    6    tmpqmfpc15d                        0x000055b8b74ddef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    // TODO: Implement me!\n    return 0\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp7ge04xnq/tmp7ge04xnq.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2459938c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b245962fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b245962f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b245962e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7ge04xnq                        0x00005654a4b1f1bd <unavailable> + 4541

    5    libc.so.6                          0x00002b2459b24460 __libc_start_main +
    245

    6    tmp7ge04xnq                        0x00005654a4b1ee69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    else if n % 2 == 0 {\n        let nmodp = modp(n: n / 2, p: p)\n        return\
    \ (nmodp * nmodp) % p\n    }\n    else {\n        return (modp(n: n - 1, p: p)\
    \ * n) % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp9f7a724z/tmp9f7a724z.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b50e68adc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b50e65a4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b50e65a4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b50e65a37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9f7a724z                        0x00005557aee052cd <unavailable> + 4813

    5    libc.so.6                          0x00002b50e6a99460 __libc_start_main +
    245

    6    tmp9f7a724z                        0x00005557aee04ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n % p == 0 {\n        return 0\n  \
    \  }\n    else if n < p {\n        return n\n    }\n    else {\n        let t\
    \ = n / p\n        let s = n - t * p\n        return s\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpem89tmnh/tmpem89tmnh.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba40a9f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba40a6e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba40a6e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba40a6e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpem89tmnh                        0x00005643404862cd <unavailable> + 4813

    5    libc.so.6                          0x00002ba40abdd460 __libc_start_main +
    245

    6    tmpem89tmnh                        0x0000564340485ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    var result = modp(n: n / 2, p: p)\n    result = (result * result) % p\n \
    \   if n % 2 == 1 {\n        result = (result * 2) % p\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tvar r\
    \ = 1\n\tvar m = n\n\twhile m > 0 {\n\t\tif m % 2 == 1 {\n\t\t\tr = (r * r) %\
    \ p\n\t\t}\n\t\tm = m / 2\n\t}\n\treturn r\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmptl2xc7l4/tmptl2xc7l4.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8420b7cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8420873b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8420873988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84208727b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptl2xc7l4                        0x000055864de9c24d <unavailable> + 4685

    5    libc.so.6                          0x00002b8420d68460 __libc_start_main +
    245

    6    tmptl2xc7l4                        0x000055864de9bef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return ((1<<n) % p)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp3oy1s6b1/tmp3oy1s6b1.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b58745bec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b58742b5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b58742b5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b58742b47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3oy1s6b1                        0x0000562b7b1612cd <unavailable> + 4813

    5    libc.so.6                          0x00002b58747aa460 __libc_start_main +
    245

    6    tmp3oy1s6b1                        0x0000562b7b160ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    } else\
    \ if n % 2 == 0 {\n        let y = modp(n: n / 2, p: p)\n        return (y * y)\
    \ % p\n    } else {\n        return (n % p * modp(n: n - 1, p: p)) % p\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpdm4_litm/tmpdm4_litm.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b42bb7f3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42bb4eab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b42bb4ea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42bb4e97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdm4_litm                        0x000055af94da62cd <unavailable> + 4813

    5    libc.so.6                          0x00002b42bb9df460 __libc_start_main +
    245

    6    tmpdm4_litm                        0x000055af94da5ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var pow = n\n    var res = 1\n    while\
    \ pow > 0 {\n        if pow & 1 == 1 {\n            res = (res * n) % p\n    \
    \    }\n        n = (n * n) % p\n        pow = pow >> 1\n    }\n    return res\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpp05f9j6f.swift:20:9: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n        n = (n * n) % p\n        ^\n"
  stdout: ''
  timestamp: 1660014426
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  var result = 1\n  for _ in 0..<n {\n   \
    \ result = (result * 2) % p\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var a = 1\n    while n\
    \ > 0 {\n        if n & 1 == 1 {\n            a = (a * n) % p\n        }\n   \
    \     n = n >> 1\n    }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpxvj0irwn/tmpxvj0irwn.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b058718dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0586e84b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0586e84988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0586e837b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxvj0irwn                        0x0000561fa65892cd <unavailable> + 4813

    5    libc.so.6                          0x00002b0587379460 __libc_start_main +
    245

    6    tmpxvj0irwn                        0x0000561fa6588ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let r = modp(n: n, p: p, n: n)\n    return\
    \ r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_06cknjr.swift:14:33: error: extra argument 'n' in call\n    let\
    \ r = modp(n: n, p: p, n: n)\n                ~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    } else\
    \ if n == 1 {\n        return n % p\n    } else {\n        var a = modp(n: n -\
    \ 1, p: p)\n        a = a * n\n        a = a % p\n        return a\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpd7pcw1xq/tmpd7pcw1xq.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac255edec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac255bd5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac255bd5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac255bd47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd7pcw1xq                        0x000055a5c5a3424d <unavailable> + 4685

    5    libc.so.6                          0x00002ac2560ca460 __libc_start_main +
    245

    6    tmpd7pcw1xq                        0x000055a5c5a33ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return p - modp(n:\
    \ abs(n), p: p)\n    }\n    if n == 0 {\n        return 1\n    }\n    if n ==\
    \ 1 {\n        return n\n    }\n    if n % 2 == 0 {\n        return modp(n: n/2,\
    \ p: p) * modp(n: n/2, p: p) % p\n    }\n    else {\n        return modp(n: n/2,\
    \ p: p) * modp(n: n/2, p: p) * 2 % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpi9oyxj56/tmpi9oyxj56.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ade8bf6fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ade8bc66b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ade8bc66988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ade8bc657b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi9oyxj56                        0x000056287fdea33d <unavailable> + 4925

    5    libc.so.6                          0x00002ade8c15b460 __libc_start_main +
    245

    6    tmpi9oyxj56                        0x000056287fde9fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    else if n == 1 {\n        return n % p\n    }\n    else {\n        let result\
    \ = modp(n: n/2, p: p)\n        if n % 2 == 0 {\n            return (result *\
    \ result) % p\n        }\n        else {\n            return (result * result\
    \ * n) % p\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpx3h8xcjz/tmpx3h8xcjz.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb57b9fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb57896b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeb57896988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeb578957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx3h8xcjz                        0x000056141cf452cd <unavailable> + 4813

    5    libc.so.6                          0x00002aeb57d8b460 __libc_start_main +
    245

    6    tmpx3h8xcjz                        0x000056141cf44ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    } else\
    \ if n == 1 {\n        return 2 % p\n    } else {\n        let prev = modp(n:\
    \ n - 1, p: p)\n        return (prev * 2) % p\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014426
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    // \u0420\u0435\u043A\u0443\u0440\u0441\
    \u0438\u0432\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442 \u0441\
    \u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0435\u0434\u043B\u0435\u043D\u043D\
    \u044B\u0439\n    // \u0432 \u043F\u0435\u0440\u0432\u043E\u043C \u0432\u0430\u0440\
    \u0438\u0430\u043D\u0442\u0435 \u043F\u0435\u0440\u0435\u043F\u043E\u043B\u043D\
    \u0435\u043D\u0438\u0435 \u0441\u0442\u0435\u043A\u0430 \u0431\u044B\u043B\u043E\
    \ \u043D\u0430 \u043F\u0435\u0440\u0432\u043E\u043C \u0442\u0435\u0441\u0442\u0435\
    \ - \u043F\u0440\u0438 \u0432\u044B\u0447\u0438\u0441\u043B\u0435\u043D\u0438\u0438\
    \ \u0434\u0432\u043E\u0439\u043A\u0438 \u0432 \u0441\u0442\u0435\u043F\u0435\u043D\
    \u0438 65536\n    // \u0432\u043E \u0432\u0442\u043E\u0440\u043E\u043C \u043F\u0435\
    \u0440\u0435\u043F\u043E\u043B\u043D\u0435\u043D\u0438\u0435 \u0441\u0442\u0435\
    \u043A\u0430 \u043F\u0440\u043E\u0438\u0441\u0445\u043E\u0434\u0438\u0442 \u043D\
    \u0430 \u0432\u0442\u043E\u0440\u043E\u043C \u0442\u0435\u0441\u0442\u0435\n \
    \   // \u043A \u0442\u043E\u043C\u0443 \u0436\u0435 \u0432\u0440\u0435\u043C\u044F\
    \ \u0432\u044B\u043F\u043E\u043B\u043D\u0435\u043D\u0438\u044F \u0441\u043B\u0438\
    \u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435\n    //if\
    \ n == 0 {\n    //    return 1\n    //}\n    //if n % 2 == 0 {\n    //    return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    //} else {\n    //    return\
    \ 2 * modp(n: n - 1, p: p) % p\n    //}\n    \n    var res = 1\n    var cur =\
    \ 2\n    var pow = n\n    while pow > 0 {\n        if pow % 2 == 1 {\n       \
    \     res = (res * cur) % p\n        }\n        cur = (cur * cur) % p\n      \
    \  pow /= 2\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014426
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    var res = 1\n    for _ in 0..<n {\n        res = (res * 2) % p\n    }\n \
    \   return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var r = 1\n    var i = 1\n    var x =\
    \ n\n    let modp = p\n    while i <= n {\n        if (x & 1) == 1 {\n       \
    \     r = (r * i) % modp\n        }\n        x = x >> 1\n        i = (i * 2) %\
    \ modp\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmptwlpl4v3/tmptwlpl4v3.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5fd837bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5fd8072b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5fd8072988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5fd80717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptwlpl4v3                        0x00005616ce53924d <unavailable> + 4685

    5    libc.so.6                          0x00002b5fd8567460 __libc_start_main +
    245

    6    tmptwlpl4v3                        0x00005616ce538ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return 1 << n % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp56tbwsej/tmp56tbwsej.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0566ddfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0566ad6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0566ad6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0566ad57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp56tbwsej                        0x0000564b898802cd <unavailable> + 4813

    5    libc.so.6                          0x00002b0566fcb460 __libc_start_main +
    245

    6    tmp56tbwsej                        0x0000564b8987fef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var res = 1\n    for _ in 1...n {\n  \
    \      res = res * 2 % p\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b9a0a39ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9a0a095561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9a0a095286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9a0a09513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9a0a094bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpri9q1jy0                        0x0000556a9722a75d <unavailable> + 5981

    6    tmpri9q1jy0                        0x0000556a9722a3cf <unavailable> + 5071

    7    libc.so.6                          0x00002b9a0a58a460 __libc_start_main +
    245

    8    tmpri9q1jy0                        0x0000556a97229fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = n\n    for _ in 1..<n {\n\
    \        result = (result * n) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpj_lxq3dv/tmpj_lxq3dv.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afe9a189c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afe99e80b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afe99e80988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afe99e7f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj_lxq3dv                        0x000055e467c6233d <unavailable> + 4925

    5    libc.so.6                          0x00002afe9a375460 __libc_start_main +
    245

    6    tmpj_lxq3dv                        0x000055e467c61fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  let power = min(n, p - 1)\n  var result\
    \ = 1\n  for _ in 0..<power {\n    result = (result * 2) % p\n  }\n  return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp8tyttb30/tmp8tyttb30.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2d3c64ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2d3c345b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2d3c345988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2d3c3447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8tyttb30                        0x0000557eb8b9a44d <unavailable> + 5197

    5    libc.so.6                          0x00002b2d3c83a460 __libc_start_main +
    245

    6    tmp8tyttb30                        0x0000557eb8b9a079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    // TODO: implementation\n    var a = 1\n\
    \    for _ in 0...n{\n        a = (a * 2) % p\n    }\n    return a\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp9hdm3o4p/tmp9hdm3o4p.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b42a3574c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42a326bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b42a326b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42a326a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9hdm3o4p                        0x0000557908b8633d <unavailable> + 4925

    5    libc.so.6                          0x00002b42a3760460 __libc_start_main +
    245

    6    tmp9hdm3o4p                        0x0000557908b85fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tguard n != 0 else { return 1 }\n\tguard\
    \ n % 2 == 0 else { return (pow(n, p) % p) }\n\tlet half = modp(n: n / 2, p: p)\n\
    \treturn (half * half) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpt354w2kb.swift:15:34: error: cannot find 'pow' in scope\n     \
    \   guard n % 2 == 0 else { return (pow(n, p) % p) }\n                       \
    \                 ^~~\n"
  stdout: ''
  timestamp: 1660014426
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    precondition(p > 0)\n    precondition(n\
    \ >= 0)\n    guard n > 0 else { return 1 }\n    return modp(n: (n-1)/2, p: p)\
    \ * modp(n: (n+1)/2, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014432
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    // precondition: p is prime\n    var res\
    \ = 1\n    var mul = n\n    var pow = p - 2\n    while pow > 0 {\n        if pow\
    \ & 1 == 1 {\n            res = (res * mul) % p\n        }\n        mul = (mul\
    \ * mul) % p\n        pow >>= 1\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpcd2wmiqh/tmpcd2wmiqh.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b88084e7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b88081deb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b88081de988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b88081dd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcd2wmiqh                        0x0000558ceaf2d24d <unavailable> + 4685

    5    libc.so.6                          0x00002b88086d3460 __libc_start_main +
    245

    6    tmpcd2wmiqh                        0x0000558ceaf2cef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let n1 = n % p\n    var r = 1\n    for\
    \ _ in 1...n1 {\n        r = (r * 2) % p\n    }\n    return r\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpeg6ysnow/tmpeg6ysnow.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b456b3c8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b456b0bfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b456b0bf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b456b0be7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeg6ysnow                        0x00005555cd9803bd <unavailable> + 5053

    5    libc.so.6                          0x00002b456b5b4460 __libc_start_main +
    245

    6    tmpeg6ysnow                        0x00005555cd97ffe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmphmcwevpr/tmphmcwevpr.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4467904c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44675fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44675fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44675fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmcwevpr                        0x00005640854c72cd <unavailable> + 4813

    5    libc.so.6                          0x00002b4467af0460 __libc_start_main +
    245

    6    tmphmcwevpr                        0x00005640854c6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014286
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  var power = n\n  var result = 1\n  while\
    \ power > 0 {\n    if power % 2 == 1 {\n      result = (result * n) % p\n    }\n\
    \    power /= 2\n    n = (n * n) % p\n  }\n  return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmptrkoac6t.swift:21:5: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n    n = (n * n) % p\n    ^\n"
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return (1..<n).reduce(1) { (result, _)\
    \ in\n        return (result * 2) % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpj7j9yfp5/tmpj7j9yfp5.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b179e154c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b179de4bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b179de4b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b179de4a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj7j9yfp5                        0x000055cedd71738d <unavailable> + 5005

    5    libc.so.6                          0x00002b179e340460 __libc_start_main +
    245

    6    tmpj7j9yfp5                        0x000055cedd717039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  return Int(pow(Double(n), Double(p - 2)))\
    \ % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpvj6za7c9.swift:14:14: error: cannot find 'pow' in scope\n  return\
    \ Int(pow(Double(n), Double(p - 2))) % p\n             ^~~\n"
  stdout: ''
  timestamp: 1660014426
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var prod = 1\n    for _ in 0..<n {\n \
    \       prod = (prod * 2) % p\n    }\n    return prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014426
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  // Only compute n % p if n is large\n  if\
    \ n >= p {\n    return Int(BigUInt(n) % BigUInt(p))\n  }\n  // BigInt.modPow is\
    \ too slow (probably due to a bug)\n  var res = 1\n  for _ in 0..<n {\n    res\
    \ = (res * 2) % p\n  }\n  return res\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpjm7z51ho.swift:16:16: error: cannot find 'BigUInt' in scope\n \
    \   return Int(BigUInt(n) % BigUInt(p))\n               ^~~~~~~\n/tmp/tmpjm7z51ho.swift:16:29:\
    \ error: cannot find 'BigUInt' in scope\n    return Int(BigUInt(n) % BigUInt(p))\n\
    \                            ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014426
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    precondition(n >= 0, \"n >= 0\")\n   \
    \ precondition(p > 0, \"p > 0\")\n    if n == 0 {\n        return 1\n    }\n \
    \   if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p: p)\
    \ % p\n    }\n    return 2 * modp(n: n - 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014426
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  var result = 1\n  for _ in 0..<n {\n   \
    \ result = (result * 2) % p\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  precondition(p > 0)\n  precondition(n >=\
    \ 0)\n  var x = 1\n  var m = n\n  while m > 0 {\n    if m % 2 == 1 {\n      x\
    \ = (x * x) % p\n    }\n    m = m / 2\n  }\n  return x\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp46qff98l/tmp46qff98l.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab12a393c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab12a08ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab12a08a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab12a0897b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp46qff98l                        0x0000561f95cc524d <unavailable> + 4685

    5    libc.so.6                          0x00002ab12a57f460 __libc_start_main +
    245

    6    tmp46qff98l                        0x0000561f95cc4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\treturn Int(pow(Double(n), Double(p - 2)))\
    \ % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp2c9fv1iy.swift:14:13: error: cannot find 'pow' in scope\n     \
    \   return Int(pow(Double(n), Double(p - 2))) % p\n                   ^~~\n"
  stdout: ''
  timestamp: 1660014426
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var a = 1\n    for _ in 0..<n {\n    \
    \    a = a * 2 % p\n    }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  let x = (n % p) + p\n  return x % p\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpdu9ul0uy/tmpdu9ul0uy.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2c6b06ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2c6ad61b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2c6ad61988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2c6ad607b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdu9ul0uy                        0x0000558a6159a2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b2c6b256460 __libc_start_main +
    245

    6    tmpdu9ul0uy                        0x0000558a61599ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var r = 1\n    var n = n\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            r = (r * (n % p)) % p\n        }\n\
    \        n /= 2\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpxkhzu0iz/tmpxkhzu0iz.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9a961f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9a95ee9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9a95ee9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9a95ee87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxkhzu0iz                        0x000055fe61b792cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9a963de460 __libc_start_main +
    245

    6    tmpxkhzu0iz                        0x000055fe61b78ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014426
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var d = p, s = 0, t = 1\n    while (n\
    \ > 0) {\n        let (q, r) = divide(n, d)\n        (n, d) = (d, r)\n       \
    \ (s, t) = (t, s-q*t)\n    }\n    if (d > 1) {\n        return 0\n    }\n    if\
    \ (s < 0) {\n        s += p\n    }\n    return s\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0fdlys3s.swift:16:22: error: cannot find 'divide' in scope\n  \
    \      let (q, r) = divide(n, d)\n                     ^~~~~~\n/tmp/tmp0fdlys3s.swift:17:10:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n        (n, d) = (d,\
    \ r)\n         ^\n"
  stdout: ''
  timestamp: 1660014426
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let y = modp(n / 2, p: p)\n        return (y * y)\
    \ % p\n    }\n    else {\n        return (modp(n - 1, p: p) * n) % p\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpezr_i97z.swift:18:21: error: missing argument label 'n:' in call\n\
    \        let y = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmpezr_i97z.swift:19:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (y * y) % p\n              \
    \    ^\n/tmp/tmpezr_i97z.swift:22:21: error: missing argument label 'n:' in call\n\
    \        return (modp(n - 1, p: p) * n) % p\n                    ^\n         \
    \            n: \n"
  stdout: ''
  timestamp: 1660014426
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return n == 0 ? 1\
    \ : 0\n    }\n    if n < 0 {\n        return modp(n: n + p, p: p)\n    }\n   \
    \ if n == 0 {\n        return 1\n    }\n    if n == 1 {\n        return 0\n  \
    \  }\n    if n % 2 == 0 {\n        return modp(n: (n / 2) * (n / 2), p: p)\n \
    \   }\n    return modp(n: (n / 2) * (n / 2), p: p) * 2\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpvj5aefwa/tmpvj5aefwa.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b04deb74c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b04de86bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b04de86b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b04de86a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvj5aefwa                        0x00005602d9a1d24d <unavailable> + 4685

    5    libc.so.6                          0x00002b04ded60460 __libc_start_main +
    245

    6    tmpvj5aefwa                        0x00005602d9a1cef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let r: Int\n    if n == 0 {\n        r\
    \ = 1\n    } else if n == 1 {\n        r = 0\n    } else {\n        let a = modp(n:\
    \ n - 1, p: p)\n        let b = modp(n: n - 2, p: p)\n        r = (a + b) % p\n\
    \    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpltcyycds/tmpltcyycds.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b094f78dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b094f484b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b094f484988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b094f4837b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpltcyycds                        0x000056134226d24d <unavailable> + 4685

    5    libc.so.6                          0x00002b094f979460 __libc_start_main +
    245

    6    tmpltcyycds                        0x000056134226cef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014427
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if p == 1 {\n        return 0\n    }\n\
    \    var out = 1\n    for _ in 0..<n {\n        out = (out * 2) % p\n    }\n \
    \   return out\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    } else\
    \ if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p: p)\
    \ % p\n    } else {\n        return n * modp(n: n - 1, p: p) % p\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp8dyv8ody/tmp8dyv8ody.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2a75ccdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2a759c4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2a759c4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2a759c37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8dyv8ody                        0x0000563b796e42cd <unavailable> + 4813

    5    libc.so.6                          0x00002b2a75eb9460 __libc_start_main +
    245

    6    tmp8dyv8ody                        0x0000563b796e3ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var r = 1\n    var x = n\n    var y =\
    \ p\n    while y > 0 {\n        if y & 1 > 0 {\n            r = (r * x) % p\n\
    \        }\n        y = y >> 1\n        x = (x * x) % p\n    }\n    return r\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpxdtk_jh4/tmpxdtk_jh4.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b33c4e60c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b33c4b57b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b33c4b57988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b33c4b567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxdtk_jh4                        0x000055b4b33842cd <unavailable> + 4813

    5    libc.so.6                          0x00002b33c504c460 __libc_start_main +
    245

    6    tmpxdtk_jh4                        0x000055b4b3383ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let b = modp(n: n / 2, p: p)\n        return (b\
    \ * b) % p\n    }\n    return (n % p) * modp(n: n - 1, p: p) % p\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpeh38ok9r/tmpeh38ok9r.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb78062c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb77d59b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeb77d59988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeb77d587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeh38ok9r                        0x00005618ed19b2cd <unavailable> + 4813

    5    libc.so.6                          0x00002aeb7824e460 __libc_start_main +
    245

    6    tmpeh38ok9r                        0x00005618ed19aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014427
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  var n = n\n  var result = 1\n  for _ in\
    \ 0..<n {\n    result = (result * 2) % p\n  }\n  return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return n % p\n    }\n    var ret = modp(n: n/2, p: p)\n\
    \    ret = (ret * ret) % p\n    if n % 2 == 1 {\n        ret = (ret * 2) % p\n\
    \    }\n    return ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpvfnqoi1r/tmpvfnqoi1r.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad5e5003c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad5e4cfab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad5e4cfa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad5e4cf97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvfnqoi1r                        0x0000560aa8e6e24d <unavailable> + 4685

    5    libc.so.6                          0x00002ad5e51ef460 __libc_start_main +
    245

    6    tmpvfnqoi1r                        0x0000560aa8e6def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var result = 1\n    while\
    \ n > 0 {\n        if n & 1 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        n = n >> 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpe4jzi5ce/tmpe4jzi5ce.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8c3363fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8c33336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8c33336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8c333357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe4jzi5ce                        0x00005635f429d2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b8c3382b460 __libc_start_main +
    245

    6    tmpe4jzi5ce                        0x00005635f429cef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return Int(pow(Double(n), Double(p - 2)))\
    \ % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_46iy3yt.swift:14:16: error: cannot find 'pow' in scope\n    return\
    \ Int(pow(Double(n), Double(p - 2))) % p\n               ^~~\n"
  stdout: ''
  timestamp: 1660014427
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let k = mod(n, p)\n    let d = p - 1\n\
    \    return mod(k, d)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpl1yda5k8.swift:14:13: error: cannot find 'mod' in scope\n    let\
    \ k = mod(n, p)\n            ^~~\n/tmp/tmpl1yda5k8.swift:16:12: error: cannot\
    \ find 'mod' in scope\n    return mod(k, d)\n           ^~~\n"
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 == 1 {\n\
    \            result = (result * (2 % p)) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp8gwquh8_/tmp8gwquh8_.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7f6dd16c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7f6da0db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7f6da0d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7f6da0c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8gwquh8_                        0x000055c4cfe2924d <unavailable> + 4685

    5    libc.so.6                          0x00002b7f6df02460 __libc_start_main +
    245

    6    tmp8gwquh8_                        0x000055c4cfe28ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014427
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return square(n: modp(n: n / 2, p: p)) % p\n   \
    \ } else {\n        return (n % p) * modp(n: n - 1, p: p) % p\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmprgz7grtb.swift:18:16: error: cannot find 'square' in scope\n  \
    \      return square(n: modp(n: n / 2, p: p)) % p\n               ^~~~~~\n"
  stdout: ''
  timestamp: 1660014427
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(n: p -\
    \ (-n % p), p: p)\n    }\n    if n == 0 {\n        return 1\n    }\n    if n %\
    \ 2 == 0 {\n        return ((modp(n: n / 2, p: p) % p) * (modp(n: n / 2, p: p)\
    \ % p)) % p\n    }\n    return ((modp(n: n / 2, p: p) % p) * (modp(n: n / 2, p:\
    \ p) % p) * 2) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let nlz = n.leadingZeroBitCount\n    var\
    \ _n = n << nlz\n    var res = 1\n    var p_prod = p\n    var i = 1\n    while\
    \ _n > 0 {\n        if _n & 1 != 0 {\n            res = (res * p_prod) % p\n \
    \       }\n        p_prod = (p_prod * p_prod) % p\n        _n >>= 1\n        i\
    \ += 1\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpt3uu170z/tmpt3uu170z.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b41eeb6fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b41ee866b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b41ee866988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b41ee8657b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt3uu170z                        0x000055b23961024d <unavailable> + 4685

    5    libc.so.6                          0x00002b41eed5b460 __libc_start_main +
    245

    6    tmpt3uu170z                        0x000055b23960fef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var (r, a) = (1, n % p)\n    var b = n\n\
    \    while b > 0 {\n        if b % 2 == 1 {\n            r = (r * a) % p\n   \
    \     }\n        a = (a * a) % p\n        b /= 2\n    }\n    return r\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpkzc4oh9p/tmpkzc4oh9p.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adee5495c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adee518cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adee518c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adee518b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkzc4oh9p                        0x0000560c8d89a24d <unavailable> + 4685

    5    libc.so.6                          0x00002adee5681460 __libc_start_main +
    245

    6    tmpkzc4oh9p                        0x0000560c8d899ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    // Did you know that a % b is the same\
    \ as a - ((a / b) * b)?\n    // var a = n % p;\n    // while a < 0 {\n    // \
    \    a += p;\n    // }\n    // return a;\n    return n % p;\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpbuvagzhc/tmpbuvagzhc.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9262cafc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b92629a6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b92629a6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92629a57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbuvagzhc                        0x000055d1235202cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9262e9b460 __libc_start_main +
    245

    6    tmpbuvagzhc                        0x000055d12351fef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014427
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var out = 1\n    for _ in 0..<n {\n  \
    \      out = (out * 2) % p\n    }\n    return out\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014427
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var t = n\n    while\
    \ t > 0 {\n        if t % 2 == 1 {\n            result = (result * n) % p\n  \
    \      }\n        t /= 2\n        n = (n * n) % p\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpw8wbualj.swift:21:9: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n        n = (n * n) % p\n        ^\n"
  stdout: ''
  timestamp: 1660014427
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    } else\
    \ if n%2 == 0 {\n        return modp(n: n/2, p: p)**2 % p\n    } else {\n    \
    \    return modp(n: n-1, p: p) * modp(n: 1, p: p) % p\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpkul1b6cl.swift:17:34: error: cannot find operator '**' in scope\n\
    \        return modp(n: n/2, p: p)**2 % p\n                                 ^~\n"
  stdout: ''
  timestamp: 1660014427
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  return Int(pow(Double(n), Double(p - 2)))\
    \ % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpvj6za7c9.swift:14:14: error: cannot find 'pow' in scope\n  return\
    \ Int(pow(Double(n), Double(p - 2))) % p\n             ^~~\n"
  stdout: ''
  timestamp: 1660014426
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if p == 0 {\n        return 1\n    }\n\
    \    else if n == 0 {\n        return 1\n    }\n    else if n == 1 {\n       \
    \ return n\n    }\n    else if n == 2 {\n        return (n % p)\n    }\n    else\
    \ {\n        var pow : Int = 1\n        for _ in 0..<n {\n            pow = (pow\
    \ * 2) % p\n        }\n        return pow\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014427
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return powmod(n: 2, p: n, m: p)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpnwa7jj9v.swift:14:12: error: cannot find 'powmod' in scope\n  \
    \  return powmod(n: 2, p: n, m: p)\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660014427
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n < 0 {\n        return modp(n: -n,\
    \ p: p)\n    }\n    if n == 0 {\n        return 1\n    }\n    var x = 1\n    for\
    \ _ in 0..<n {\n        x = (x * 2) % p\n    }\n    return x\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var k = n\n    var r = 1\n    while k\
    \ > 0 {\n        if k % 2 == 1 {\n            r = (r * 2) % p\n        }\n   \
    \     k = k / 2\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmptnx51cim/tmptnx51cim.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2bae2e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2badfd8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2badfd8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2badfd77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptnx51cim                        0x0000560b845ba24d <unavailable> + 4685

    5    libc.so.6                          0x00002b2bae4cd460 __libc_start_main +
    245

    6    tmptnx51cim                        0x0000560b845b9ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var r = 1\n    var n = n\n    var p =\
    \ p\n    while n > 0 {\n        if n & 1 != 0 {\n            r = (r * n) % p\n\
    \        }\n        n >>= 1\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpy7jamid_/tmpy7jamid_.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba265742c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba265439b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba265439988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba2654387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy7jamid_                        0x000056384048c2cd <unavailable> + 4813

    5    libc.so.6                          0x00002ba26592e460 __libc_start_main +
    245

    6    tmpy7jamid_                        0x000056384048bef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    } else\
    \ if n == 1 {\n        return n % p\n    } else {\n        var result = 1\n  \
    \      var power = n\n        while power > 0 {\n            result = (result\
    \ * power) % p\n            power /= 2\n        }\n        return result\n   \
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpryze_fpu/tmpryze_fpu.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af10c6cbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af10c3c2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af10c3c2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af10c3c17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpryze_fpu                        0x000056277b0162cd <unavailable> + 4813

    5    libc.so.6                          0x00002af10c8b7460 __libc_start_main +
    245

    6    tmpryze_fpu                        0x000056277b015ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014427
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  var r = 1\n  var b = n\n  while b > 0 {\n\
    \    if b % 2 == 1 {\n      r = (r * n) % p\n    }\n    b = b / 2\n    n = (n\
    \ * n) % p\n  }\n  return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpvd420rcl.swift:21:5: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n    n = (n * n) % p\n    ^\n"
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return 1\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmptwvj08n3/tmptwvj08n3.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3242177c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3241e6eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3241e6e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3241e6d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptwvj08n3                        0x000055e4cb5ac1bd <unavailable> + 4541

    5    libc.so.6                          0x00002b3242363460 __libc_start_main +
    245

    6    tmptwvj08n3                        0x000055e4cb5abe69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    } else\
    \ if n == 1 {\n        return n % p\n    } else {\n        var i = 1\n       \
    \ var m = modp(n: n / 2, p: p)\n        var q = (m * m) % p\n        if n % 2\
    \ == 1 {\n            q = (q * modp(n: n - 1, p: p)) % p\n        }\n        return\
    \ q\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmptipb90xc/tmptipb90xc.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7443c6dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7443964b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7443964988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74439637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptipb90xc                        0x000055ea668a424d <unavailable> + 4685

    5    libc.so.6                          0x00002b7443e59460 __libc_start_main +
    245

    6    tmptipb90xc                        0x000055ea668a3ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014427
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let a = pow(2, Double(n))\n    let b =\
    \ pow(2, Double(p))\n    let c = Int(Double(a).truncatingRemainder(dividingBy:\
    \ b))\n    return c\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpcrxpm3_3.swift:14:13: error: cannot find 'pow' in scope\n    let\
    \ a = pow(2, Double(n))\n            ^~~\n/tmp/tmpcrxpm3_3.swift:15:13: error:\
    \ cannot find 'pow' in scope\n    let b = pow(2, Double(p))\n            ^~~\n"
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n % p == 0 {\n        return 0\n  \
    \  }\n    var result = 1\n    for _ in 0..<n {\n        result = (result * 2)\
    \ % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpsynvx7sq/tmpsynvx7sq.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b24e031cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b24e0013b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b24e0013988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b24e00127b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsynvx7sq                        0x0000556cf3b3e43c <unavailable> + 5180

    5    libc.so.6                          0x00002b24e0508460 __libc_start_main +
    245

    6    tmpsynvx7sq                        0x0000556cf3b3dfe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014427
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    } else\
    \ if n == 1 {\n        return 2 % p\n    } else {\n        var ret = modp(n: n\
    \ / 2, p: p)\n        ret = (ret * ret) % p\n        if n % 2 == 1 {\n       \
    \     ret = (ret * 2) % p\n        }\n        return ret\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014427
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return Int(pow(Double(n), Double(p - 2)))\
    \ % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_46iy3yt.swift:14:16: error: cannot find 'pow' in scope\n    return\
    \ Int(pow(Double(n), Double(p - 2))) % p\n               ^~~\n"
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    else if n % 2 == 0 {\n        let t = modp(n: n / 2, p: p)\n        return\
    \ (t * t) % p\n    }\n    else {\n        return (n * modp(n: n - 1, p: p)) %\
    \ p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpsxh9cig3/tmpsxh9cig3.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad48a0dfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad489dd6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad489dd6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad489dd57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsxh9cig3                        0x000055d1c08e12cd <unavailable> + 4813

    5    libc.so.6                          0x00002ad48a2cb460 __libc_start_main +
    245

    6    tmpsxh9cig3                        0x000055d1c08e0ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014427
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var res = 1\n    for _ in 0..<n {\n  \
    \      res = (res * 2) % p\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    var base = n % p\n\
    \    var exponent = n\n    while exponent > 0 {\n        if exponent % 2 == 1\
    \ {\n            result = (result * base) % p\n        }\n        exponent >>=\
    \ 1\n        base = (base * base) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp_2i8y7kj/tmp_2i8y7kj.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af5f0f0ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af5f0c05b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af5f0c05988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af5f0c047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_2i8y7kj                        0x000055c47ef1d24d <unavailable> + 4685

    5    libc.so.6                          0x00002af5f10fa460 __libc_start_main +
    245

    6    tmp_2i8y7kj                        0x000055c47ef1cef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let y = modp(n: n / 2, p: p)\n        return (y\
    \ * y) % p\n    }\n    else {\n        return (n * modp(n: n - 1, p: p)) % p\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpjwoxt_1r/tmpjwoxt_1r.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeaa1437c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeaa112eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeaa112e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeaa112d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjwoxt_1r                        0x000055aad634b2cd <unavailable> + 4813

    5    libc.so.6                          0x00002aeaa1623460 __libc_start_main +
    245

    6    tmpjwoxt_1r                        0x000055aad634aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014427
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    var res = modp(n: n / 2, p: p)\n    res = (res * res) % p\n    if n % 2 ==\
    \ 1 {\n        res = (res * 2) % p\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    // Decompose n\n    var r = 0, k = n\n\
    \    while k > 0 {\n        let t = k & -k\n        k ^= t\n        r = (r + t)\
    \ % p\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpmu5u9cc8/tmpmu5u9cc8.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7b80d31c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7b80a28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7b80a28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7b80a277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmu5u9cc8                        0x000055ea14eca2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b7b80f1d460 __libc_start_main +
    245

    6    tmpmu5u9cc8                        0x000055ea14ec9ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    } else\
    \ if n == 1 {\n        return n % p\n    } else {\n        var res = 1\n     \
    \   let m = n % p\n        for _ in 1..<m {\n            res = (res * 2) % p\n\
    \        }\n        return res\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpsgbul51s/tmpsgbul51s.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3724072c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3723d69b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3723d69988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3723d687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsgbul51s                        0x00005622bc15633d <unavailable> + 4925

    5    libc.so.6                          0x00002b372425e460 __libc_start_main +
    245

    6    tmpsgbul51s                        0x00005622bc155fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014427
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var sum = 1\n    var product = 2\n   \
    \ var nCopy = n\n    while nCopy > 0 {\n        if nCopy & 1 == 1 {\n        \
    \    sum = (sum * product) % p\n        }\n        product = (product * product)\
    \ % p\n        nCopy = nCopy >> 1\n    }\n    return sum\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014427
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var d: Double = 1\n    for _ in 0..<n\
    \ {\n        d = (d * 2) % Double(p)\n    }\n    return Int(d)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpfqecndbt.swift:16:21: error: '%' is unavailable: For floating point\
    \ numbers use truncatingRemainder instead\n        d = (d * 2) % Double(p)\n \
    \                   ^\nSwift.%:2:13: note: '%' has been explicitly marked unavailable\
    \ here\npublic func % <T>(lhs: T, rhs: T) -> T where T : BinaryFloatingPoint\n\
    \            ^\n"
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if p == 1 {\n        return 0\n    }\n\
    \    var result = 1\n    var base = n % p\n    var exp = n\n    while exp > 0\
    \ {\n        if exp % 2 == 1 {\n            result = (result * base) % p\n   \
    \     }\n        exp /= 2\n        base = (base * base) % p\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpw1a1b44_/tmpw1a1b44_.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b23b2fb8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b23b2cafb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b23b2caf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b23b2cae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw1a1b44_                        0x0000555befd2c24d <unavailable> + 4685

    5    libc.so.6                          0x00002b23b31a4460 __libc_start_main +
    245

    6    tmpw1a1b44_                        0x0000555befd2bef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  var d = 1\n  var k = 0\n  var m = n\n  while\
    \ m > 0 {\n    if m & 1 == 1 {\n      d = (d * d) % p\n      k += 1\n    }\n \
    \   m >>= 1\n  }\n  return d\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp9wxa3x76/tmp9wxa3x76.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b78002eec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b77fffe5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b77fffe5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b77fffe47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9wxa3x76                        0x0000563cf1da724d <unavailable> + 4685

    5    libc.so.6                          0x00002b78004da460 __libc_start_main +
    245

    6    tmp9wxa3x76                        0x0000563cf1da6ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var res = 1\n    var n = n\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            res = (res * res) % p\n      \
    \  }\n        n /= 2\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpnup8j5ho/tmpnup8j5ho.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afa56e66c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa56b5db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afa56b5d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afa56b5c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnup8j5ho                        0x0000558d5561a24d <unavailable> + 4685

    5    libc.so.6                          0x00002afa57052460 __libc_start_main +
    245

    6    tmpnup8j5ho                        0x0000558d55619ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n <= 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return 0\n    }\n    if n == 2 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return (modp(n: n / 2, p: p) * modp(n: n\
    \ / 2, p: p) + 1) % p\n    }\n    return (modp(n: n / 2, p: p) * modp(n: n / 2,\
    \ p: p) + modp(n: n / 2 + 1, p: p) * modp(n: n / 2 + 1, p: p) + 1) % p\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpur_kcm60/tmpur_kcm60.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6ee175fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6ee1456b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6ee1456988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6ee14557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpur_kcm60                        0x000056535000224d <unavailable> + 4685

    5    libc.so.6                          0x00002b6ee194b460 __libc_start_main +
    245

    6    tmpur_kcm60                        0x0000565350001ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014427
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    var modp = modp(n: n >> 1, p: p)\n    modp = (modp * modp) % p\n    if n\
    \ & 1 == 1 {\n        modp = (modp * 2) % p\n    }\n    return modp\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014428
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    let half = n/2\n    let halfmod = modp(n: half, p: p)\n    if n % 2 == 0\
    \ {\n        return (halfmod * halfmod) % p\n    } else {\n        return (halfmod\
    \ * halfmod * 2) % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014427
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    guard n > 0 else { return 1 }\n    var\
    \ s = n\n    var r = 1\n    while s > 0 {\n        if s % 2 == 1 {\n         \
    \   r = (r * n) % p\n        }\n        n = (n * n) % p\n        s /= 2\n    }\n\
    \    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp1bm0pi6s.swift:21:9: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n        n = (n * n) % p\n        ^\n"
  stdout: ''
  timestamp: 1660014427
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  if n == 0 {\n    return 1\n  } else if n\
    \ % 2 == 0 {\n    let x = modp(n: n / 2, p: p)\n    return (x * x) % p\n  } else\
    \ {\n    return (n * modp(n: n - 1, p: p)) % p\n  }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpkm_ogapa/tmpkm_ogapa.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aea6fe80c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aea6fb77b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aea6fb77988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aea6fb767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkm_ogapa                        0x00005644967ca2cd <unavailable> + 4813

    5    libc.so.6                          0x00002aea7006c460 __libc_start_main +
    245

    6    tmpkm_ogapa                        0x00005644967c9ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014427
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let binary: [Int] = toBinary(n: n)\n \
    \   var a = 1\n    for _ in 0..<binary.count {\n        a = (a * a) % p\n    \
    \    if binary[binary.count - 1] == 1 {\n            a = (a * 2) % p\n       \
    \ }\n    }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpps8yvq_p.swift:14:25: error: cannot find 'toBinary' in scope\n\
    \    let binary: [Int] = toBinary(n: n)\n                        ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014427
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    var rem = 1\n    var pow = n\n    while pow != 0 {\n        if pow & 1 ==\
    \ 1 {\n            rem = (rem * n) % p\n        }\n        pow = pow >> 1\n  \
    \      n = (n * n) % p\n    }\n    return rem\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpizkd03tj.swift:24:9: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n        n = (n * n) % p\n        ^\n"
  stdout: ''
  timestamp: 1660014427
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var c = Int(ceil(Double(n) / Double(p)))\n\
    \    while (p * c < n) {\n        c += 1\n    }\n    return n - p * c\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpjhe10ut2.swift:14:17: error: cannot find 'ceil' in scope\n    var\
    \ c = Int(ceil(Double(n) / Double(p)))\n                ^~~~\n"
  stdout: ''
  timestamp: 1660014427
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    precondition(n >= 0)\n    precondition(p\
    \ > 0)\n    var result = 1\n    for _ in 0..<n {\n        result = (result * 2)\
    \ % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014428
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tvar (\n\t\tr = 1\n\t\td = n\n\t)\n\twhile\
    \ d > 0 {\n\t\tif d & 1 != 0 {\n\t\t\tr = (r * n) % p\n\t\t}\n\t\td >>= 1\n\t\t\
    n = (n * n) % p\n\t}\n\treturn r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpcm61jnrr.swift:15:5: error: expected ',' separator\n          \
    \      r = 1\n                  ^\n                 ,\n/tmp/tmpcm61jnrr.swift:15:5:\
    \ error: expected pattern\n                r = 1\n                  ^\n/tmp/tmpcm61jnrr.swift:15:3:\
    \ error: type annotation missing in pattern\n                r = 1\n         \
    \       ^\n/tmp/tmpcm61jnrr.swift:18:8: error: cannot find 'd' in scope\n    \
    \    while d > 0 {\n              ^\n/tmp/tmpcm61jnrr.swift:19:6: error: cannot\
    \ find 'd' in scope\n                if d & 1 != 0 {\n                   ^\n/tmp/tmpcm61jnrr.swift:22:3:\
    \ error: cannot find 'd' in scope\n                d >>= 1\n                ^\n\
    /tmp/tmpcm61jnrr.swift:22:5: error: type of expression is ambiguous without more\
    \ context\n                d >>= 1\n                ~~^~~~~\n/tmp/tmpcm61jnrr.swift:23:3:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n                n =\
    \ (n * n) % p\n                ^\n"
  stdout: ''
  timestamp: 1660014427
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var pow = n\n    var result = 1\n    while\
    \ pow > 0 {\n        if pow % 2 == 1 {\n            result = (result * n) % p\n\
    \        }\n        n = (n * n) % p\n        pow /= 2\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqw4j11f0.swift:20:9: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n        n = (n * n) % p\n        ^\n"
  stdout: ''
  timestamp: 1660014427
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var res = 1\n    if n == 0 {\n       \
    \ return res\n    }\n    else if n == 1 {\n        return 2\n    }\n    else {\n\
    \        for _ in 0..<n {\n            res = (res * 2) % p\n        }\n      \
    \  return res\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014428
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var res = 1\n    var i = n\n    while\
    \ i > 0 {\n        let q = i / p\n        let r = i - q * p\n        let s = res\
    \ * r\n        let t = s / p\n        res = s - t * p\n        i = q\n    }\n\
    \    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmph366q30e/tmph366q30e.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8392ad5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b83927ccb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b83927cc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b83927cb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph366q30e                        0x000055dc3718c2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b8392cc1460 __libc_start_main +
    245

    6    tmph366q30e                        0x000055dc3718bef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014428
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014287
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    } else\
    \ if n % 2 == 0 {\n        let res = modp(n: n / 2, p: p)\n        return res\
    \ * res % p\n    } else {\n        return (n % p) * modp(n: n - 1, p: p) % p\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmphauevn3u/tmphauevn3u.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b37b5729c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b37b5420b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b37b5420988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b37b541f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphauevn3u                        0x000055904459f2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b37b5915460 __libc_start_main +
    245

    6    tmphauevn3u                        0x000055904459eef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014428
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var res = 1\n    for _ in 0..<n {\n  \
    \      res = (res * 2) % p\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014427
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var x = 1\n    for _ in 0..<n {\n    \
    \    x = x * 2 % p\n    }\n    return x\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014428
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if p == 1 {\n        return 0\n    }\n\
    \    var result = 1\n    for _ in 0..<n {\n        result = (result * 2) % p\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014428
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    // PRECONDITION: n >= 0 and p > 0\n  \
    \  if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        let t =\
    \ modp(n: n / 2, p: p)\n        return (t * t) % p\n    }\n    return (modp(n:\
    \ n - 1, p: p) * p) % n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmptgixa55g/tmptgixa55g.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8edb333c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8edb02ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8edb02a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8edb0297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptgixa55g                        0x0000559275ee524d <unavailable> + 4685

    5    libc.so.6                          0x00002b8edb51f460 __libc_start_main +
    245

    6    tmptgixa55g                        0x0000559275ee4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014428
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tlet result = powmod(2, n, p)\n\treturn result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0kw40olc.swift:14:15: error: cannot find 'powmod' in scope\n  \
    \      let result = powmod(2, n, p)\n                     ^~~~~~\n"
  stdout: ''
  timestamp: 1660014428
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    precondition(n >= 0)\n    precondition(p\
    \ > 0)\n    if p == 1 {\n        return 0\n    }\n    var r = 1\n    var nn =\
    \ n\n    while nn != 0 {\n        if nn & 1 != 0 {\n            r = (r * n) %\
    \ p\n        }\n        nn >>= 1\n        n = (n * n) % p\n    }\n    return r\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpz6h06umf.swift:26:9: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n        n = (n * n) % p\n        ^\n"
  stdout: ''
  timestamp: 1660014428
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if p == 1 {\n        return 0\n    }\n\
    \    if n == 0 {\n        return 1\n    }\n    var b = 1\n    var np = p\n   \
    \ var nn = n\n    while nn > 0 {\n        if nn % 2 == 1 {\n            b = (b\
    \ * np) % p\n        }\n        np = (np * np) % p\n        nn /= 2\n    }\n \
    \   return b\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpwgrg3fkb/tmpwgrg3fkb.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6e40c53c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6e4094ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6e4094a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6e409497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwgrg3fkb                        0x00005653dae5924d <unavailable> + 4685

    5    libc.so.6                          0x00002b6e40e3f460 __libc_start_main +
    245

    6    tmpwgrg3fkb                        0x00005653dae58ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014428
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var nn = n\n    var result = 1\n    while\
    \ nn > 0 {\n        if nn & 1 == 1 {\n            result = (result * n) % p\n\
    \        }\n        nn = nn >> 1\n        n = (n * n) % p\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpok0f_0tx.swift:21:9: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n        n = (n * n) % p\n        ^\n"
  stdout: ''
  timestamp: 1660014428
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var num: Int = 1\n    var i: Int = 0\n\
    \    while i < n {\n        num = (num * 2) % p\n        i += 1\n    }\n    return\
    \ num\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014428
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  precondition(p > 0, \"modp: only positive\
    \ p supported\")\n  if p == 1 { return 0 }\n  var b = 1\n  var e = n\n  while\
    \ e > 0 {\n    if e & 1 == 1 {\n      b = b * n % p\n    }\n    e >>= 1\n    n\
    \ = n * n % p\n  }\n  return b\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6_u1gfmu.swift:23:5: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n    n = n * n % p\n    ^\n"
  stdout: ''
  timestamp: 1660014428
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let nn = Int(floor(log(Double(n)) / log(2.0)))\n\
    \    var result = 1\n    var a = 2\n    for i in 0...nn {\n        if n & (1 <<\
    \ i) != 0 {\n            result = (result * a) % p\n        }\n        a = (a\
    \ * a) % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpzzm4c1tw.swift:14:18: error: cannot find 'floor' in scope\n   \
    \ let nn = Int(floor(log(Double(n)) / log(2.0)))\n                 ^~~~~\n/tmp/tmpzzm4c1tw.swift:14:24:\
    \ error: cannot find 'log' in scope\n    let nn = Int(floor(log(Double(n)) / log(2.0)))\n\
    \                       ^~~\n/tmp/tmpzzm4c1tw.swift:14:41: error: cannot find\
    \ 'log' in scope\n    let nn = Int(floor(log(Double(n)) / log(2.0)))\n       \
    \                                 ^~~\n"
  stdout: ''
  timestamp: 1660014428
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return pow(2, n) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp936pmckl.swift:14:12: error: cannot find 'pow' in scope\n    return\
    \ pow(2, n) % p\n           ^~~\n"
  stdout: ''
  timestamp: 1660014428
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let (quotient, remainder) = Int.divMod(dividend:\
    \ n, divisor: p, truncatingRemainder: true)\n    return Int.minimum(p - remainder,\
    \ remainder)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpyfxips8w.swift:14:37: error: type 'Int' has no member 'divMod'\n\
    \    let (quotient, remainder) = Int.divMod(dividend: n, divisor: p, truncatingRemainder:\
    \ true)\n                                ~~~ ^~~~~~\n/tmp/tmpyfxips8w.swift:15:16:\
    \ error: type 'Int' has no member 'minimum'\n    return Int.minimum(p - remainder,\
    \ remainder)\n           ~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014428
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var res = 1\n    for _ in 1...n {\n  \
    \      res = (res * 2) % p\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b13e033cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13e0033561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b13e0033286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b13e003313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b13e0032bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpjntbww2y                        0x000055f264b1f75d <unavailable> + 5981

    6    tmpjntbww2y                        0x000055f264b1f3cf <unavailable> + 5071

    7    libc.so.6                          0x00002b13e0528460 __libc_start_main +
    245

    8    tmpjntbww2y                        0x000055f264b1efe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014428
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    precondition(p >= 1)\n    precondition(n\
    \ >= 0)\n    var result = 1\n    var power = n\n    while power > 0 {\n      \
    \  if power % 2 == 1 {\n            result = (result * n) % p\n        }\n   \
    \     n = (n * n) % p\n        power = power / 2\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_0tnpgex.swift:22:9: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n        n = (n * n) % p\n        ^\n"
  stdout: ''
  timestamp: 1660014428
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n\tif p <= 0 {\n\t\treturn 0\n\t}\n\tvar result\
    \ = 1\n\tvar base = n % p\n\tvar exponent = n\n\twhile exponent > 0 {\n\t\tif\
    \ exponent % 2 == 1 {\n\t\t\tresult = (result * base) % p\n\t\t}\n\t\texponent\
    \ = exponent >> 1\n\t\tbase = (base * base) % p\n\t}\n\treturn result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpcf5kwsdy/tmpcf5kwsdy.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aef16aacc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aef167a3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aef167a3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aef167a27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcf5kwsdy                        0x0000563436b1424d <unavailable> + 4685

    5    libc.so.6                          0x00002aef16c98460 __libc_start_main +
    245

    6    tmpcf5kwsdy                        0x0000563436b13ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014428
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    // YOUR CODE HERE\n    if n == 0 {\n \
    \       return 1\n    } else {\n        var temp = n\n        var num = p\n  \
    \      var ans = 1\n        while temp > 0 {\n            if temp % 2 == 1 {\n\
    \                ans = (ans * num) % p\n            }\n            num = (num\
    \ * num) % p\n            temp = temp / 2\n        }\n        return ans\n   \
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpbwfzmt1x/tmpbwfzmt1x.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad86e4bfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad86e1b6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad86e1b6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad86e1b57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbwfzmt1x                        0x0000562db268c24d <unavailable> + 4685

    5    libc.so.6                          0x00002ad86e6ab460 __libc_start_main +
    245

    6    tmpbwfzmt1x                        0x0000562db268bef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014428
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var n = n\n    var prod = 1\n    let p\
    \ = p\n    while n > 0 {\n        if n % 2 == 1 {\n            prod = (prod *\
    \ p) % modulo\n        }\n        n = n / 2\n    }\n    return prod\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6nns9fbl.swift:19:33: error: cannot find 'modulo' in scope\n  \
    \          prod = (prod * p) % modulo\n                                ^~~~~~\n"
  stdout: ''
  timestamp: 1660014428
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return n * modp(n: n - 1, p: p) % p\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpeyv_3yk_/tmpeyv_3yk_.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b02db1bfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b02daeb6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b02daeb6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b02daeb57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeyv_3yk_                        0x000055f172d912cd <unavailable> + 4813

    5    libc.so.6                          0x00002b02db3ab460 __libc_start_main +
    245

    6    tmpeyv_3yk_                        0x000055f172d90ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014428
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  // Implementation detail of the algorithm.\n\
    \  func b(n: Int, p: Int) -> Int {\n    if n == 0 {\n      return 1\n    }\n \
    \   if n == 1 {\n      return 2\n    }\n    if n.isMultiple(of: 2) {\n      return\
    \ b(n: n/2, p: p).square() % p\n    }\n    return (2 * b(n: n-1, p: p)) % p\n\
    \  }\n  return b(n: n, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp2z4xlnb_.swift:23:30: error: value of type 'Int' has no member\
    \ 'square'\n      return b(n: n/2, p: p).square() % p\n             ~~~~~~~~~~~~~~~\
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014428
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    else if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2,\
    \ p: p) % p\n    }\n    else {\n        return modp(n: n - 1, p: p) * modp(n:\
    \ 2, p: p) % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014433
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    return (1 << n) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp9g_572bg/tmp9g_572bg.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3f85b13c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3f8580ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3f8580a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3f858097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9g_572bg                        0x0000557daa2e92cd <unavailable> + 4813

    5    libc.so.6                          0x00002b3f85cff460 __libc_start_main +
    245

    6    tmp9g_572bg                        0x0000557daa2e8ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014428
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var c = 1\n    var i = 0\n    let cp =\
    \ p\n    while i < n {\n        c = (c * cp) % p\n        i += 1\n    }\n    return\
    \ c\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpujr4rov2/tmpujr4rov2.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b3c24ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b3bf41b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3b3bf41988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3b3bf407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpujr4rov2                        0x000056015742f24d <unavailable> + 4685

    5    libc.so.6                          0x00002b3b3c436460 __libc_start_main +
    245

    6    tmpujr4rov2                        0x000056015742eef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014428
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var x = 1\n    var n = n\n    var p =\
    \ p\n    while n > 0 {\n        if n % 2 == 1 {\n            x = (x * n) % p\n\
    \        }\n        n = n >> 1\n        p = (p * p) % 100\n    }\n    return x\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpo01npzfa/tmpo01npzfa.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002add0d455c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002add0d14cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002add0d14c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002add0d14b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo01npzfa                        0x000055c8806312cd <unavailable> + 4813

    5    libc.so.6                          0x00002add0d641460 __libc_start_main +
    245

    6    tmpo01npzfa                        0x000055c880630ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014428
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  var temp = 1\n  for _ in 0..<n {\n    temp\
    \ = (temp * 2) % p\n  }\n  return temp\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014428
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return (modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p)) % p\n    } else {\n        return (modp(n: n / 2, p: p) * modp(n: n / 2,\
    \ p: p) * 2) % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014428
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    let comp = BigInt(p)\n    return BigInt(n).modPow(2,\
    \ modulus: comp).description.trimZeros()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpzr48s1xr.swift:14:16: error: cannot find 'BigInt' in scope\n  \
    \  let comp = BigInt(p)\n               ^~~~~~\n/tmp/tmpzr48s1xr.swift:15:12:\
    \ error: cannot find 'BigInt' in scope\n    return BigInt(n).modPow(2, modulus:\
    \ comp).description.trimZeros()\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660014428
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        let c = modp(n: n / 2, p: p)\n        return (c\
    \ * c) % p\n    } else {\n        return (modp(n: n - 1, p: p) * modp(n: n, p:\
    \ p)) % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014433
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n  assert(p > 0)\n  var result = 1\n  for _\
    \ in 0..<n {\n    result = (result * 2) % p\n  }\n  return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014428
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return n % p\n    }\n    let half = modp(n: n / 2, p:\
    \ p)\n    let halfP = (half * half) % p\n    if n % 2 == 0 {\n        return halfP\n\
    \    } else {\n        return (halfP * n) % p\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp2rcltylf/tmp2rcltylf.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7783ad5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b77837ccb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b77837cc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b77837cb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2rcltylf                        0x00005623e49a22cd <unavailable> + 4813

    5    libc.so.6                          0x00002b7783cc1460 __libc_start_main +
    245

    6    tmp2rcltylf                        0x00005623e49a1ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014428
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(n: 3,\
    \ p: 5)\n/// 3\n/// >>> modp(n: 1101, p: 101)\n/// 2\n/// >>> modp(n: 0, p: 101)\n\
    /// 1\n/// >>> modp(n: 3, p: 11)\n/// 8\n/// >>> modp(n: 100, p: 101)\n/// 1\n\
    func modp(n: Int, p: Int) -> Int {\n    var total = 1\n    for _ in 0..<n {\n\
    \        total = total * 2 % p\n    }\n    return total\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014428
