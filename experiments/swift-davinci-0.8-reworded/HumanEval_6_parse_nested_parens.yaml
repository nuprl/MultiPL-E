name: HumanEval_6_parse_nested_parens
language: swift
prompt: "\n/// Input to this function is a string represented multiple groups for\
  \ nested parentheses separated by spaces.\n/// For each of the group, output the\
  \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
  \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(paren_string:\
  \ \"(()()) ((())) () ((())()())\")\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string:\
  \ String) -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()())\
  \ ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
  \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
  \ \"(()(())((())))\") == [4])"
completions: ["    var result: [Int] = []\n    let input = paren_string.characters.split\
    \ { $0 == \" \" }.map(String.init)\n    for item in input {\n        result.append(get_max_nested_parens(item))\n\
    \    }\n    return result", "    var max_nesting = [Int]()\n    var local_max_nesting\
    \ = 0\n    var paren_stack = [Int]()\n    for paren in paren_string {\n      \
    \  if paren == \"(\" {\n            paren_stack.append(1)\n            local_max_nesting\
    \ += 1\n        } else if paren == \")\" {\n            paren_stack.popLast()\n\
    \            local_max_nesting -= 1\n        } else if paren == \" \" {\n    \
    \        if !paren_stack.isEmpty {\n                print(\"Error: unbalanced\
    \ parens\")\n                return []\n            }\n            max_nesting.append(local_max_nesting)\n\
    \            local_max_nesting = 0\n        }\n    }\n    if !paren_stack.isEmpty\
    \ {\n        print(\"Error: unbalanced parens\")\n        return []\n    }\n \
    \   return max_nesting", "    var ans: [Int] = []\n    let paren_string_ar = paren_string.split(separator:\
    \ \" \")\n    var stack = Stack<Character>()\n    for c in paren_string_ar {\n\
    \        var count = 0\n        for i in c {\n            if i == \"(\" {\n  \
    \              stack.push(i)\n                count += 1\n            } else if\
    \ i == \")\" {\n                stack.pop()\n                count -= 1\n    \
    \        }\n        }\n        ans.append(count)\n    }\n    return ans", "  return\
    \ paren_string.split(separator: \" \").map {\n    var stack = [Int]()\n    var\
    \ max_depth = 0\n    for char in $0 {\n      if char == \"(\" {\n        stack.append(1)\n\
    \        max_depth = max(max_depth, stack.count)\n      } else if stack.popLast()\
    \ == nil {\n        return 0\n      }\n    }\n    return max_depth\n  }", "  \
    \  var paren_res = [Int]()\n    let groups = paren_string.split(separator: \"\
    \ \")\n    for group in groups {\n        var count = 0\n        var max = 0\n\
    \        for char in group {\n            if char == \"(\" {\n               \
    \ count += 1\n            } else if char == \")\" {\n                count -=\
    \ 1\n            }\n            if count > max {\n                max = count\n\
    \            }\n        }\n        paren_res.append(max)\n    }\n    return paren_res",
  '    return []', "    let paren_groups = paren_string.split(separator: \" \")\n\
    \    var max_nesting_levels = [Int]()\n    for group in paren_groups {\n     \
    \   var current_level = 0\n        var max_level = 0\n        for char in group\
    \ {\n            if char == \"(\" {\n                current_level += 1\n    \
    \        } else if char == \")\" {\n                current_level -= 1\n     \
    \       }\n            if current_level > max_level {\n                max_level\
    \ = current_level\n            }\n        }\n        max_nesting_levels.append(max_level)\n\
    \    }\n    return max_nesting_levels", "    // convert string to array of characters\n\
    \    let paren_characters = Array(paren_string)\n    var open_parens = 0\n   \
    \ var paren_levels = [Int]()\n    var paren_level = 0\n    var paren_level_arr\
    \ = [Int]()\n    var i = 0\n    while i < paren_characters.count {\n        //\
    \ if an open paren is found\n        if paren_characters[i] == \"(\" {\n     \
    \       // increase the number of open parens\n            open_parens += 1\n\
    \            // if this is the first open paren for this group\n            if\
    \ paren_level == 0 {\n                // start a new paren level array\n     \
    \           paren_level_arr = [Int]()\n            }\n            // update the\
    \ paren level\n            paren_level += 1\n            // add this paren level\
    \ to the paren level array\n            paren_level_arr.append(paren_level)\n\
    \        }\n        // if a closed paren is found\n        else if paren_characters[i]\
    \ == \")\" {\n            // decrease the number of open parens\n            open_parens\
    \ -= 1\n            // if all the parens are closed, then the group is done\n\
    \            if open_parens == 0 {\n                // add the group's paren levels\
    \ to the overall paren levels\n                paren_levels.append(contentsOf:\
    \ paren_level_arr)\n                // add a 1 to the overall paren levels to\
    \ signify the end of the group\n                paren_levels.append(1)\n     \
    \           // reset the paren level\n                paren_level = 0\n      \
    \      }\n            // update the paren level\n            paren_level -= 1\n\
    \        }\n        // if a space is found\n        else if paren_characters[i]\
    \ == \" \" {\n            // if the current paren level is not 0\n           \
    \ if paren_level != 0 {\n                // add this paren level to the paren\
    \ level array\n                paren_level_arr.append(paren_level)\n         \
    \   }\n        }\n        i += 1\n    }\n    // remove the last value which is\
    \ the end of the group\n    paren", "    // Start with an array to hold all the\
    \ groups\n    var groups = [String]()\n    // Then split the string by spaces\n\
    \    for group in paren_string.split(separator: \" \") {\n        groups.append(String(group))\n\
    \    }\n    var level_array = [Int]()\n    // Now that we have an array of individual\
    \ groups of parentheses,\n    // we can loop through them and count their levels\
    \ of nesting\n    for group in groups {\n        // Each group will have its own\
    \ array to hold the levels\n        var level_array_temp = [Int]()\n        var\
    \ level = 0\n        // Loop through each character in the group and increment\n\
    \        // or decrement the level accordingly\n        for char in group {\n\
    \            switch char {\n            case \"(\":\n                level +=\
    \ 1\n            case \")\":\n                level -= 1\n            default:\n\
    \                continue\n            }\n            level_array_temp.append(level)\n\
    \        }\n        // We have the array of levels, find the maximum value\n \
    \       if let max_level = level_array_temp.max() {\n            level_array.append(max_level)\n\
    \        }\n    }\n    return level_array", "    var max_nested_parens: [Int]\
    \ = []\n    var level: Int = 0\n    var max_level: Int = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            level += 1\n            if level\
    \ > max_level {\n                max_level = level\n            }\n        } else\
    \ if char == \")\" {\n            level -= 1\n        } else if char == \" \"\
    \ {\n            max_nested_parens.append(max_level)\n            max_level =\
    \ 0\n            level = 0\n        }\n    }\n    max_nested_parens.append(max_level)\n\
    \    return max_nested_parens", "    var stack = Stack<Character>()\n    var current_level\
    \ = 0\n    var max_levels = [Int]()\n    var temp_level = 0\n    for character\
    \ in paren_string {\n        if character == \"(\" {\n            stack.push(character)\n\
    \            current_level += 1\n        } else if character == \")\" {\n    \
    \        stack.pop()\n            temp_level = current_level\n            current_level\
    \ -= 1\n        } else if character == \" \" {\n            max_levels.append(temp_level)\n\
    \        }\n    }\n    return max_levels", "    return paren_string.split(separator:\
    \ \" \").map {\n        var paren_stack = [Character]()\n        var max_nesting\
    \ = 0\n        var curr_nesting = 0\n        for char in $0 {\n            if\
    \ char == \"(\" {\n                curr_nesting += 1\n                max_nesting\
    \ = max(max_nesting, curr_nesting)\n            } else if char == \")\" {\n  \
    \              curr_nesting -= 1\n            }\n        }\n        return max_nesting\n\
    \    }", "    let groups = paren_string.components(separatedBy: \" \")\n    var\
    \ result: [Int] = []\n    for group in groups {\n        var max_depth = 0\n \
    \       var curr_depth = 0\n        for char in group {\n            if char ==\
    \ \"(\" {\n                curr_depth += 1\n                if curr_depth > max_depth\
    \ {\n                    max_depth = curr_depth\n                }\n         \
    \   } else if char == \")\" {\n                curr_depth -= 1\n            }\n\
    \        }\n        result.append(max_depth)\n    }\n    return result", "   \
    \ \n    // 1. Parse parenthesis string into individual strings for each group\n\
    \    let paren_groups = paren_string.components(separatedBy: \" \")\n    \n  \
    \  // 2. Evaluate each paren group for max level of nesting\n    var result =\
    \ [Int]()\n    for paren_group in paren_groups {\n        result.append( max_nested_level(paren_group:\
    \ paren_group) )\n    }\n    \n    return result", "    let split_strings = paren_string.split(separator:\
    \ \" \")\n    var max_nesting_array = [Int]()\n    for curr_paren_string in split_strings\
    \ {\n        var count = 0\n        var max_count = 0\n        for curr_char in\
    \ curr_paren_string {\n            if curr_char == \"(\" {\n                count\
    \ += 1\n            } else if curr_char == \")\" {\n                count -= 1\n\
    \            }\n            if count > max_count {\n                max_count\
    \ = count\n            }\n        }\n        max_nesting_array.append(max_count)\n\
    \    }\n    return max_nesting_array", "    var depth = 0\n    var max_depth =\
    \ 0\n    var result = [Int]()\n    for c in paren_string {\n        if c == \"\
    (\" {\n            depth += 1\n            max_depth = max(max_depth, depth)\n\
    \        } else if c == \")\" {\n            depth -= 1\n        } else if c ==\
    \ \" \" {\n            if depth == 0 {\n                result.append(max_depth)\n\
    \                max_depth = 0\n            }\n        }\n    }\n    result.append(max_depth)\n\
    \    return result", "    return paren_string.components(separatedBy: \" \").map\
    \ { (paren) -> Int in\n        var depth = 0\n        var max_depth = 0\n    \
    \    for c in paren {\n            if c == \"(\" {\n                depth += 1\n\
    \            } else if c == \")\" {\n                depth -= 1\n            }\n\
    \            max_depth = max(max_depth, depth)\n        }\n        return max_depth\n\
    \    }", "    var paren_list = [Int]()\n    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    groups.forEach({\n        var level = 0\n        var max_level =\
    \ 0\n        for char in $0 {\n            if char == \"(\" {\n              \
    \  level += 1\n            } else if char == \")\" {\n                level -=\
    \ 1\n            }\n            if level > max_level {\n                max_level\
    \ = level\n            }\n        }\n        paren_list.append(max_level)\n  \
    \  })\n    return paren_list", "    var max_nesting = [Int]()\n    let groups\
    \ = paren_string.split(separator: \" \")\n    for group in groups {\n        var\
    \ nesting = 0\n        var max_nest = 0\n        for paren in group {\n      \
    \      if paren == \"(\" {\n                nesting += 1\n            } else if\
    \ paren == \")\" {\n                nesting -= 1\n            }\n            if\
    \ nesting > max_nest {\n                max_nest = nesting\n            }\n  \
    \      }\n        max_nesting.append(max_nest)\n    }\n    return max_nesting",
  "    let paren_string_arr = paren_string.split(separator: \" \")\n    var max_depth_arr\
    \ = [Int]()\n    for paren_string in paren_string_arr {\n        var left_paren_count\
    \ = 0\n        var max_depth = 0\n        for paren in paren_string {\n      \
    \      if paren == \"(\" {\n                left_paren_count += 1\n          \
    \      if left_paren_count > max_depth {\n                    max_depth = left_paren_count\n\
    \                }\n            } else if paren == \")\" {\n                left_paren_count\
    \ -= 1\n            }\n        }\n        max_depth_arr.append(max_depth)\n  \
    \  }\n    return max_depth_arr", '  return []', "    var results = [Int]()\n \
    \   let groups = paren_string.components(separatedBy: \" \")\n    for group in\
    \ groups {\n        results.append(calculate_nested_parens(paren_string: group))\n\
    \    }\n    return results", "    var max_paren_depth = [Int]()\n    let paren_groups\
    \ = paren_string.components(separatedBy: \" \")\n    for paren_group in paren_groups\
    \ {\n        max_paren_depth.append(max_paren_depth_in_paren_group(paren_group:\
    \ paren_group))\n    }\n    return max_paren_depth", "    // We count the open\
    \ parentheses and then subtract the number of closed parentheses.\n    // The\
    \ number of closed parentheses will always be smaller or equal to the number of\
    \ open parentheses.\n    // This subtraction tells us the number of unmatched\
    \ open parentheses.\n    // The maximum of this value will tell us the maximum\
    \ level of nesting.\n    let open_parens = \"(\"\n    let closed_parens = \")\"\
    \n    var results = [Int]()\n    for group in paren_string.split(separator: \"\
    \ \") {\n        var open_paren_count = 0\n        var close_paren_count = 0\n\
    \        for char in group {\n            if open_parens.contains(char) {\n  \
    \              open_paren_count += 1\n            } else if closed_parens.contains(char)\
    \ {\n                close_paren_count += 1\n            }\n        }\n      \
    \  results.append(open_paren_count - close_paren_count)\n    }\n    return results",
  '  return []', "    var paren_depth = [[Int]]()\n    var paren_count = [Int]()\n\
    \    var paren_max_depth = [Int]()\n    var inside_paren = 0\n    var paren_buffer\
    \ = [Int]()\n    for c in paren_string {\n        switch c {\n        case \"\
    (\":\n            inside_paren += 1\n            paren_buffer.append(inside_paren)\n\
    \        case \")\":\n            inside_paren -= 1\n            paren_buffer.append(inside_paren)\n\
    \        case \" \":\n            paren_depth.append(paren_buffer)\n         \
    \   paren_count.append(paren_buffer.count)\n            paren_max_depth.append(paren_buffer.max()!)\n\
    \            paren_buffer = [Int]()\n        default:\n            fatalError(\"\
    Invalid character\")\n        }\n    }\n    print(paren_depth)\n    print(paren_count)\n\
    \    print(paren_max_depth)\n    return paren_max_depth", "    var stack = [Int]()\n\
    \    var output = [Int]()\n    var max_count = 0\n    for c in paren_string {\n\
    \        if c == \"(\" {\n            stack.append(c.asciiValue!)\n          \
    \  max_count += 1\n        } else if c == \")\" {\n            stack.removeLast()\n\
    \            max_count -= 1\n        } else if c == \" \" {\n            output.append(max_count)\n\
    \            max_count = 0\n        }\n    }\n    output.append(max_count)\n \
    \   return output", "    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    return paren_groups.map { group in\n        return group.reduce(0)\
    \ { max($0, $1 == \"(\" ? $0 + 1 : $0 - 1) }\n    }", "    var max_nested_parens\
    \ = [Int]()\n    for group in paren_string.split(separator: \" \") {\n       \
    \ var paren_stack = Stack<Character>()\n        var nested_parens = 0\n      \
    \  for c in group {\n            if c == \"(\" {\n                paren_stack.push(c)\n\
    \                nested_parens += 1\n            } else if c == \")\" {\n    \
    \            _ = paren_stack.pop()\n            }\n        }\n        max_nested_parens.append(nested_parens)\n\
    \    }\n    return max_nested_parens", "    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    var parsed_parens: [Int] = []\n    for paren_group in paren_groups\
    \ {\n        parsed_parens.append(parse_parens(paren_group: paren_group))\n  \
    \  }\n    return parsed_parens", "    var open_paren_count: [Int] = []\n    var\
    \ max_count = 0\n    var char_index = 0\n    for c in paren_string {\n       \
    \ if c == \"(\" {\n            max_count += 1\n        } else if c == \")\" {\n\
    \            max_count -= 1\n        } else if c == \" \" {\n            open_paren_count.append(max_count)\n\
    \            max_count = 0\n        }\n        char_index += 1\n    }\n    open_paren_count.append(max_count)\n\
    \    return open_paren_count", '    return []', "    var stack = Array<Int>()\n\
    \    var max_nesting = 0\n    var result = Array<Int>()\n    var char_array =\
    \ Array(paren_string)\n    for i in 0..<char_array.count {\n        if char_array[i]\
    \ == \"(\" {\n            stack.append(1)\n            max_nesting += 1\n    \
    \    } else if char_array[i] == \")\" {\n            max_nesting -= 1\n      \
    \      stack.removeLast()\n        } else if char_array[i] == \" \" {\n      \
    \      result.append(max_nesting)\n            max_nesting = 0\n        }\n  \
    \  }\n    result.append(max_nesting)\n    return result", "    // Initialize result\
    \ array, and an array of characters representing the input string\n    var nesting_array:\
    \ [Int] = []\n    let paren_array = Array(paren_string)\n    \n    // Iterate\
    \ through the input array of characters\n    for (index, char) in paren_array.enumerated()\
    \ {\n        // Only process (, ignore all other characters\n        if char ==\
    \ \"(\" {\n            // Initialize a count at 1 to track the current level of\
    \ nesting\n            var count = 1\n            // Keep looping until the closing\
    \ parenthesis for this group is found\n            for i in index+1..<paren_array.count\
    \ {\n                // If a nested opening parenthesis is found, increment the\
    \ count of nesting level\n                if paren_array[i] == \"(\" {\n     \
    \               count += 1\n                }\n                // If a closing\
    \ parenthesis is found, decrement the count of nesting level\n               \
    \ if paren_array[i] == \")\" {\n                    count -= 1\n             \
    \   }\n                // If the count reaches 0 after decrementing, then we reached\
    \ the end of the current group.\n                // Append the value of count\
    \ to the result array, then break out of the loop.\n                if count ==\
    \ 0 {\n                    nesting_array.append(index)\n                    break\n\
    \                }\n            }\n        }\n    }\n    return nesting_array",
  "    let groups = paren_string.split(separator: \" \")\n    var result: [Int] =\
    \ []\n    for group in groups {\n        var curr_max_level = 0\n        var curr_level\
    \ = 0\n        for char in group {\n            if char == \"(\" {\n         \
    \       curr_level += 1\n                if curr_level > curr_max_level {\n  \
    \                  curr_max_level = curr_level\n                }\n          \
    \  } else if char == \")\" {\n                curr_level -= 1\n            }\n\
    \        }\n        result.append(curr_max_level)\n    }\n    return result",
  "    let paren_strs = paren_string.split(separator: \" \")\n    var max_nesting\
    \ = [Int]()\n    for paren_str in paren_strs {\n        var max_level = 0\n  \
    \      var current_level = 0\n        for char in paren_str {\n            if\
    \ char == \"(\" {\n                current_level += 1\n            } else if char\
    \ == \")\" {\n                current_level -= 1\n            }\n            if\
    \ current_level > max_level {\n                max_level = current_level\n   \
    \         }\n        }\n        max_nesting.append(max_level)\n    }\n    return\
    \ max_nesting", "    return paren_string.components(separatedBy: \" \").map {\
    \ return $0.characters.reduce(0) { count, c in\n        if c == \"(\" {\n    \
    \        return count + 1\n        } else if c == \")\" {\n            return\
    \ count - 1\n        } else {\n            return count\n        }\n    } }",
  "    let paren_strings = paren_string.components(separatedBy: \" \")\n    var paren_array:\
    \ [Int] = []\n    for paren_string in paren_strings {\n        var paren_count\
    \ = 0\n        var current_max = 0\n        for char in paren_string {\n     \
    \       if char == \"(\" {\n                paren_count += 1\n            } else\
    \ if char == \")\" {\n                paren_count -= 1\n            }\n      \
    \      if paren_count > current_max {\n                current_max = paren_count\n\
    \            }\n        }\n        paren_array.append(current_max)\n    }\n  \
    \  return paren_array", "    // matches the string in paren_string that has one\
    \ or more nested parentheses\n    let pattern = \"\\\\(\\\\(+.*?\\\\)\\\\)\"\n\
    \    let regex = try! NSRegularExpression(pattern: pattern, options: [])\n   \
    \ let range = NSRange(paren_string.startIndex..., in: paren_string)\n    let matches\
    \ = regex.matches(in: paren_string, options: [], range: range)\n    var paren_groups\
    \ = [Int]()\n    for match in matches {\n        let paren_group = paren_string[Range(match.range,\
    \ in: paren_string)!]\n        paren_groups.append(paren_group.filter { $0 ==\
    \ \"(\" }.count)\n    }\n    return paren_groups", "    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    return paren_groups.map(max_nested_parens)", "    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    var result = [Int]()\n    for group in groups {\n        var stack\
    \ = [Character]()\n        var max_depth = 0\n        var depth = 0\n        for\
    \ char in group {\n            if char == \"(\" {\n                stack.append(char)\n\
    \                depth += 1\n                if depth > max_depth {\n        \
    \            max_depth = depth\n                }\n            } else if char\
    \ == \")\" {\n                stack.popLast()\n                depth -= 1\n  \
    \          }\n        }\n        result.append(max_depth)\n    }\n    return result",
  "  var indexes: [Int] = []\n  var paren_counter: Int = 0\n  var paren_depth: Int\
    \ = 0\n  for c in paren_string {\n    if c == \"(\" {\n      paren_counter +=\
    \ 1\n      if paren_counter > paren_depth {\n        paren_depth = paren_counter\n\
    \      }\n    } else if c == \")\" {\n      paren_counter -= 1\n    } else if\
    \ c == \" \" {\n      indexes.append(paren_depth)\n      paren_depth = 0\n   \
    \   paren_counter = 0\n    }\n  }\n  indexes.append(paren_depth)\n  return indexes",
  "    let groups = paren_string.components(separatedBy: \" \")\n    var paren_depth\
    \ = [Int]()\n    for group in groups {\n        let chars = Array(group)\n   \
    \     var stack = [Int]()\n        var max_depth = 0\n        for c in chars {\n\
    \            if c == \"(\" {\n                stack.append(1)\n              \
    \  max_depth = max(max_depth, stack.count)\n            } else if c == \")\" {\n\
    \                stack.removeLast()\n            }\n        }\n        paren_depth.append(max_depth)\n\
    \    }\n    return paren_depth", "    var stack: [Int] = []\n    var output: [Int]\
    \ = []\n    var level = 0\n    var i = 0\n    var j = 0\n    while i < paren_string.count\
    \ {\n        if paren_string[i] == \"(\" {\n            level += 1\n         \
    \   stack.append(level)\n        } else if paren_string[i] == \")\" {\n      \
    \      stack.popLast()\n        } else if paren_string[i] == \" \" {\n       \
    \     output.append(stack.max() ?? 0)\n            stack = []\n            level\
    \ = 0\n        }\n        i += 1\n    }\n    return output", "    // your code\
    \ here\n    var result: [Int] = []\n    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in groups {\n        var stack: [Character] = []\n   \
    \     var inner_count = 0\n        var max_count = 0\n        for char in group\
    \ {\n            if char == \"(\" {\n                stack.append(char)\n    \
    \            inner_count += 1\n                if inner_count > max_count {\n\
    \                    max_count = inner_count\n                }\n            }\
    \ else if char == \")\" {\n                if stack.count > 0 {\n            \
    \        stack.removeLast()\n                    inner_count -= 1\n          \
    \      }\n            }\n        }\n        result.append(max_count)\n    }\n\
    \    return result", "    var output: [Int] = []\n    let input = paren_string.split(separator:\
    \ \" \")\n    for paren in input {\n        var count = 0\n        var max_count\
    \ = 0\n        for char in paren {\n            if char == \"(\" {\n         \
    \       count += 1\n            } else if char == \")\" {\n                count\
    \ -= 1\n            }\n            if count > max_count {\n                max_count\
    \ = count\n            }\n        }\n        output.append(max_count)\n    }\n\
    \    return output", "    var paren_levels: [Int] = []\n    let paren_groups =\
    \ paren_string.components(separatedBy: \" \")\n    for group in paren_groups {\n\
    \        var group_max = 0\n        var group_curr = 0\n        for ch in group\
    \ {\n            if ch == \"(\" {\n                group_curr += 1\n         \
    \   } else if ch == \")\" {\n                group_curr -= 1\n            }\n\
    \            if group_curr > group_max {\n                group_max = group_curr\n\
    \            }\n        }\n        paren_levels.append(group_max)\n    }\n   \
    \ return paren_levels", "    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    var max_depth = [Int]()\n    for paren_group in paren_groups {\n\
    \        var current_depth = 0\n        var max_current_depth = 0\n        for\
    \ c in paren_group {\n            if c == \"(\" {\n                current_depth\
    \ += 1\n            } else if c == \")\" {\n                current_depth -= 1\n\
    \            }\n            if current_depth > max_current_depth {\n         \
    \       max_current_depth = current_depth\n            }\n        }\n        max_depth.append(max_current_depth)\n\
    \    }\n    return max_depth", "    // TODO: Implement\n    return []", "    var\
    \ level = 0\n    var max_level = 0\n    var count = [Int]()\n    for ch in paren_string\
    \ {\n        if ch == \"(\" {\n            level += 1\n            max_level =\
    \ max(max_level, level)\n        } else if ch == \")\" {\n            level -=\
    \ 1\n        } else if ch == \" \" {\n            count.append(max_level)\n  \
    \          max_level = 0\n            level = 0\n        }\n    }\n    count.append(max_level)\n\
    \    return count", "    let groups = paren_string.components(separatedBy: \"\
    \ \")\n    var result = [Int]()\n    for group in groups {\n        if let deepest_nesting\
    \ = deepest_nesting_parens(paren_string: group) {\n            result.append(deepest_nesting)\n\
    \        }\n    }\n    return result", "    var max_nested_parens = [Int]()\n\
    \    for group in paren_string.split(separator: \" \") {\n        max_nested_parens.append(find_max_nested_parens(group))\n\
    \    }\n    return max_nested_parens", "    return paren_string.components(separatedBy:\
    \ \" \").map({ (parens) -> Int in\n        var count = 0\n        var max = 0\n\
    \        for char in parens {\n            if char == \"(\" {\n              \
    \  count += 1\n            } else if char == \")\" {\n                count -=\
    \ 1\n            }\n            if count > max {\n                max = count\n\
    \            }\n        }\n        return max\n    })", "    // This function\
    \ should return a list with all values for the maximal depth in each group, in\
    \ the same order.\n    return []", "    var result: [Int] = []\n    let groups\
    \ = paren_string.components(separatedBy: \" \")\n    for group in groups {\n \
    \       result.append(parse_nested_parens_helper(paren_string: group))\n    }\n\
    \    return result", "    let groups = paren_string.split(separator: \" \")\n\
    \    var result = [Int]()\n    for group in groups {\n        var count = 0\n\
    \        var max_count = 0\n        for character in group {\n            if character\
    \ == \"(\" {\n                count += 1\n            } else if character == \"\
    )\" {\n                count -= 1\n            }\n            if count > max_count\
    \ {\n                max_count = count\n            }\n        }\n        result.append(max_count)\n\
    \    }\n    return result", '    return', "  var stack = Stack<Int>()\n  var num_parens\
    \ = 0\n  var paren_group = [Int]()\n  paren_string.forEach {\n    switch $0 {\n\
    \    case \"(\":\n      num_parens += 1\n    case \")\":\n      num_parens -=\
    \ 1\n    case \" \":\n      paren_group.append(num_parens)\n      num_parens =\
    \ 0\n    default:\n      break\n    }\n  }\n  return paren_group", "    var results\
    \ = [Int]()\n    let separated = paren_string.components(separatedBy: \" \")\n\
    \    for str in separated {\n        var depth = 0\n        var maxDepth = 0\n\
    \        for c in str {\n            if c == \"(\" {\n                depth +=\
    \ 1\n            } else if c == \")\" {\n                depth -= 1\n        \
    \    }\n            if depth > maxDepth {\n                maxDepth = depth\n\
    \            }\n        }\n        results.append(maxDepth)\n    }\n    return\
    \ results", "    var max_depth = 0\n    var depth = 0\n    var depth_buffer =\
    \ [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n      \
    \      depth += 1\n            max_depth = max(max_depth, depth)\n        } else\
    \ if char == \")\" {\n            depth -= 1\n        } else if char == \" \"\
    \ {\n            depth_buffer.append(max_depth)\n            max_depth = 0\n \
    \           depth = 0\n        }\n    }\n    return depth_buffer", "    let paren_groups\
    \ = paren_string.split(separator: \" \")\n    var deepest_nesting = [Int]()\n\
    \    for paren_group in paren_groups {\n        deepest_nesting.append(deepest_paren_level(paren_group:\
    \ paren_group))\n    }\n    return deepest_nesting", "    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    return groups.map { parse_single_group(paren_string: $0) }", " \
    \   let paren_groups = paren_string.split(separator: \" \")\n    var levels =\
    \ [Int]()\n    for group in paren_groups {\n        var level_count = 0\n    \
    \    var highest_count = 0\n        for paren in group {\n            if paren\
    \ == \"(\" {\n                level_count += 1\n            } else if paren ==\
    \ \")\" {\n                level_count -= 1\n            }\n            if level_count\
    \ > highest_count {\n                highest_count = level_count\n           \
    \ }\n        }\n        levels.append(highest_count)\n    }\n    return levels",
  "    var results = [Int]()\n    let strings = paren_string.split(separator: \" \"\
    )\n    for string in strings {\n        let result = parse_nested_parens(string:\
    \ String(string))\n        results.append(result)\n    }\n    return results",
  "    var stack = Stack<Int>()\n    stack.push(0)\n\n    var max_depth = 0\n    for\
    \ c in paren_string {\n        if c == \"(\" {\n            stack.push(stack.peek()!\
    \ + 1)\n            max_depth = max(max_depth, stack.peek()!)\n        } else\
    \ if c == \")\" {\n            stack.pop()\n        }\n    }\n\n    return stack.stack",
  "    \n    var res: [Int] = []\n    var paren_stack: [Character] = []\n    var counter:\
    \ Int = 0\n    for paren in paren_string {\n        if paren == \"(\" {\n    \
    \        paren_stack.append(paren)\n            counter += 1\n        } else if\
    \ paren == \")\" {\n            if paren_stack.last == \"(\" {\n             \
    \   paren_stack.removeLast()\n                counter -= 1\n            } else\
    \ {\n                res.append(counter)\n                counter = 0\n      \
    \      }\n        }\n    }\n    if counter > 0 {\n        res.append(counter)\n\
    \    }\n    return res", "    var max_nesting = [Int]()\n    let groups = paren_string.split(separator:\
    \ \" \")\n    for group in groups {\n        max_nesting.append(parse_group(group:\
    \ group))\n    }\n    return max_nesting", "    var group_levels = [Int]()\n \
    \   var group_level = 0\n    var group_parens = 0\n    var in_parens = false\n\
    \    for c in paren_string {\n        if c == \"(\" {\n            group_parens\
    \ += 1\n            in_parens = true\n        } else if c == \")\" {\n       \
    \     group_parens -= 1\n            in_parens = false\n        } else if c ==\
    \ \" \" && !in_parens {\n            group_levels.append(group_level)\n      \
    \      group_level = 0\n        } else if c == \" \" && in_parens {\n        \
    \    if group_parens > group_level {\n                group_level = group_parens\n\
    \            }\n        }\n    }\n    if in_parens {\n        group_levels.append(group_level)\n\
    \    }\n    return group_levels", "    var max_levels = [Int]()\n    var group_level\
    \ = 0\n    var current_max = 0\n    var char_iter = paren_string.makeIterator()\n\
    \    while let char = char_iter.next() {\n        switch char {\n        case\
    \ \"(\":\n            group_level += 1\n            if group_level > current_max\
    \ {\n                current_max = group_level\n            }\n        case \"\
    )\":\n            group_level -= 1\n        case \" \":\n            max_levels.append(current_max)\n\
    \            current_max = 0\n            group_level = 0\n        default:\n\
    \            print(\"Unexpected char in paren string.\")\n        }\n    }\n \
    \   return max_levels", "    var current_level = 0\n    var max_level = 0\n  \
    \  var levels: [Int] = []\n    var depth_counter = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            depth_counter += 1\n            current_level\
    \ += 1\n            if current_level > max_level {\n                max_level\
    \ = current_level\n            }\n        } else if char == \")\" {\n        \
    \    depth_counter -= 1\n            current_level -= 1\n        } else if char\
    \ == \" \" {\n            // add current max_level and reset\n            levels.append(max_level)\n\
    \            max_level = 0\n            current_level = 0\n        }\n    }\n\
    \    levels.append(max_level)\n    assert(depth_counter == 0, \"Mismatched depth_counter\"\
    )\n    return levels", "    let groups = paren_string.split(separator: \" \")\n\
    \    return groups.map { group in\n        let group_copy = group\n        var\
    \ maximum_depth = 0\n        var counter = 0\n        for paren in group_copy\
    \ {\n            if paren == \"(\" {\n                counter += 1\n         \
    \   } else if paren == \")\" {\n                counter -= 1\n            }\n\
    \            maximum_depth = max(maximum_depth, counter)\n        }\n        return\
    \ maximum_depth\n    }", "  let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n  var result = [Int]()\n  for group in paren_groups {\n    result.append(find_max_nesting(paren_group:\
    \ group))\n  }\n  return result", "    return paren_string.split(separator: \"\
    \ \").map {\n        val in\n        parse_nested_parens(string: String(val))\n\
    \    }", "    var nested_parens = [Int]()\n    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in groups {\n        var level = 0\n        var max =\
    \ 0\n        for char in group {\n            if char == \"(\" {\n           \
    \     level += 1\n            } else if char == \")\" {\n                level\
    \ -= 1\n            }\n            if level > max {\n                max = level\n\
    \            }\n        }\n        nested_parens.append(max)\n    }\n    return\
    \ nested_parens", '    return paren_string.components(separatedBy: " ").map {
    $0.count_nested_parens() }', "    var curr_max = 0\n    var curr_count = 0\n \
    \   var result = [Int]()\n    for c in paren_string {\n        if c == \"(\" {\n\
    \            curr_count += 1\n            curr_max = max(curr_max, curr_count)\n\
    \        } else if c == \")\" {\n            curr_count -= 1\n        } else if\
    \ c == \" \" {\n            result.append(curr_max)\n            curr_max = 0\n\
    \            curr_count = 0\n        }\n    }\n    result.append(curr_max)\n \
    \   return result", "  var max_level = 0\n  var current_level = 0\n  var max_level_list\
    \ = [Int]()\n  let paren_array = paren_string.map { String($0) }\n  for paren\
    \ in paren_array {\n    if paren == \"(\" {\n      current_level += 1\n      if\
    \ current_level > max_level {\n        max_level = current_level\n      }\n  \
    \  } else if paren == \")\" {\n      if current_level > 0 {\n        current_level\
    \ -= 1\n      }\n    } else if paren == \" \" {\n      max_level_list.append(max_level)\n\
    \      max_level = 0\n      current_level = 0\n    }\n  }\n  max_level_list.append(max_level)\n\
    \  return max_level_list", "    var paren_string = paren_string\n    var result:\
    \ [Int] = []\n    while !paren_string.isEmpty {\n        var parent_count = 0\n\
    \        var temp = 0\n        var current_string = \"\"\n        for c in paren_string\
    \ {\n            current_string.append(c)\n            if c == \"(\" {\n     \
    \           temp += 1\n            } else if c == \")\" {\n                temp\
    \ -= 1\n            }\n            if temp > parent_count {\n                parent_count\
    \ = temp\n            }\n            if temp == 0 {\n                break\n \
    \           }\n        }\n        paren_string.removeFirst(current_string.count)\n\
    \        result.append(parent_count)\n    }\n    return result", "    var levels:\
    \ [Int] = []\n    let paren_groups = paren_string.split(separator: \" \")\n  \
    \  for paren_group in paren_groups {\n        var nested_level = 0\n        var\
    \ nesting_level = 0\n        for char in paren_group {\n            if char ==\
    \ \"(\" {\n                nesting_level += 1\n            } else if char == \"\
    )\" {\n                nesting_level -= 1\n            }\n            if nesting_level\
    \ > nested_level {\n                nested_level = nesting_level\n           \
    \ }\n        }\n        levels.append(nested_level)\n    }\n    return levels",
  "    let groups = paren_string.split(separator: \" \")\n    var output = [Int]()\n\
    \    for parens in groups {\n        var parentheses = \"\"\n        for paren\
    \ in parens {\n            parentheses.append(paren)\n            if paren ==\
    \ \")\" {\n                let num_of_parens = ParenCounter().number_of_parens(string:\
    \ parentheses)\n                output.append(num_of_parens)\n               \
    \ parentheses = \"\"\n            }\n        }\n    }\n    return output", " \
    \   var indices: [Int] = []\n    for group in paren_string.split(separator: \"\
    \ \") {\n        var level = 0\n        var max_level = 0\n        for char in\
    \ group {\n            if char == \"(\" {\n                level += 1\n      \
    \      } else if char == \")\" {\n                level -= 1\n            }\n\
    \            if level > max_level {\n                max_level = level\n     \
    \       }\n        }\n        indices.append(max_level)\n    }\n    return indices",
  "  let paren_groups = paren_string.split(separator: \" \")\n  var result: [Int]\
    \ = []\n  for group in paren_groups {\n    var open_parens = 0\n    var max_open_parens\
    \ = 0\n    for c in group {\n      if c == \"(\" {\n        open_parens += 1\n\
    \        if open_parens > max_open_parens {\n          max_open_parens = open_parens\n\
    \        }\n      } else if c == \")\" {\n        open_parens -= 1\n      }\n\
    \    }\n    result.append(max_open_parens)\n  }\n  return result", "    \n   \
    \ var list_of_depths = [Int]()\n    let list_of_paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    \n    for group in list_of_paren_groups {\n        var stack = [Character]()\n\
    \        var max_depth = 0\n        var curr_depth = 0\n        \n        for\
    \ char in group {\n            if char == \"(\" {\n                stack.append(char)\n\
    \                curr_depth += 1\n            } else if char == \")\" {\n    \
    \            if !stack.isEmpty {\n                    stack.removeLast()\n   \
    \                 curr_depth -= 1\n                }\n            }\n        \
    \    \n            if curr_depth > max_depth {\n                max_depth = curr_depth\n\
    \            }\n        }\n        \n        list_of_depths.append(max_depth)\n\
    \    }\n    \n    return list_of_depths", "    var parent_levels = [Int]()\n \
    \   var paren_stack = Stack<String>()\n    let tokens = paren_string.components(separatedBy:\
    \ \" \")\n    var paren_level = 0\n    for token in tokens {\n        for char\
    \ in token {\n            if char == \"(\" {\n                paren_stack.push(element:\
    \ String(char))\n                paren_level += 1\n            } else if char\
    \ == \")\" {\n                if paren_stack.peek() == \"(\" {\n             \
    \       paren_stack.pop()\n                    parent_levels.append(paren_level)\n\
    \                    paren_level = 0\n                }\n            }\n     \
    \   }\n    }\n    return parent_levels", "    var result: [Int] = []\n    let\
    \ groups = paren_string.split(separator: \" \")\n    for group in groups {\n \
    \       var open_paren_count = 0\n        var max_open_paren_count = 0\n     \
    \   for char in group {\n            if char == \"(\" {\n                open_paren_count\
    \ += 1\n                if open_paren_count > max_open_paren_count {\n       \
    \             max_open_paren_count = open_paren_count\n                }\n   \
    \         } else if char == \")\" {\n                open_paren_count -= 1\n \
    \           }\n        }\n        result.append(max_open_paren_count)\n    }\n\
    \    return result", '    return paren_string.split(separator: " ").map(|s| parse_nested_parens_group(paren_string:
    s))', "    var level = 0\n    var result = [Int]()\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            level += 1\n        } else if char\
    \ == \")\" {\n            result.append(level)\n            level -= 1\n     \
    \   }\n    }\n    return result", "    var result: [Int] = []\n    let groups\
    \ = paren_string.components(separatedBy: \" \")\n    for group in groups {\n \
    \       var max = 0\n        var curr = 0\n        for c in group {\n        \
    \    if c == \"(\" {\n                curr += 1\n            } else if c == \"\
    )\" {\n                curr -= 1\n            }\n            if curr > max {\n\
    \                max = curr\n            }\n        }\n        result.append(max)\n\
    \    }\n    return result", "    let paren_groups = paren_string.split(separator:\
    \ \" \")\n    var paren_depth = [Int]()\n    for paren_group in paren_groups {\n\
    \        paren_depth.append(depth_of_nested_parens(paren_group: paren_group))\n\
    \    }\n    return paren_depth", "    var paren_stack = Stack<Character>()\n \
    \   var max_depth = 0\n    var curr_depth = 0\n    var max_depths = [Int]()\n\
    \    for char in paren_string {\n        switch char {\n        case \"(\":\n\
    \            curr_depth += 1\n            paren_stack.push(char)\n        case\
    \ \")\":\n            paren_stack.pop()\n            if curr_depth > max_depth\
    \ {\n                max_depth = curr_depth\n            }\n            curr_depth\
    \ -= 1\n        case \" \":\n            if paren_stack.isEmpty() {\n        \
    \        max_depths.append(max_depth)\n                max_depth = 0\n       \
    \         curr_depth = 0\n            }\n        default:\n            break\n\
    \        }\n    }\n    max_depths.append(max_depth)\n    return max_depths", " \
    \   var levels = [Int]()\n    var level = 0\n    var i = 0\n    while i < paren_string.count\
    \ {\n        let index = paren_string.index(paren_string.startIndex, offsetBy:\
    \ i)\n        if paren_string[index] == \"(\" {\n            level += 1\n    \
    \    } else if paren_string[index] == \")\" {\n            level -= 1\n      \
    \  } else if paren_string[index] == \" \" {\n            levels.append(level)\n\
    \            level = 0\n        }\n        i += 1\n    }\n    return levels",
  "    // collect nested parentheses into a list\n    let open_paren: Character =\
    \ \"(\"\n    let close_paren: Character = \")\"\n    var current_level = 0\n \
    \   var max_level = 0\n    var nested_parens: [Int] = []\n    for char in paren_string\
    \ {\n        if char == open_paren {\n            current_level += 1\n       \
    \     if current_level > max_level {\n                max_level = current_level\n\
    \            }\n        } else if char == close_paren {\n            nested_parens.append(max_level)\n\
    \            current_level -= 1\n        }\n    }\n    return nested_parens",
  "    let groups = paren_string.components(separatedBy: \" \")\n    return groups.map\
    \ {\n        // The nested parentheses can only be in the format of \"(()...())\"\
    \ or \"(())...((()))\"\n        // Find the level of nesting with the smallest\
    \ number of closing parentheses.\n        let (_, min_close_paren) = $0.reduce((0,\
    \ Int.max)) { (curr_max, ch) in\n            if ch == \"(\" {\n              \
    \  return (curr_max.0 + 1, curr_max.1)\n            } else {\n               \
    \ return (curr_max.0 - 1, min(curr_max.1, curr_max.0 - 1))\n            }\n  \
    \      }\n        return min_close_paren\n    }", "    var acc = [Int]()\n   \
    \ for group in paren_string.split(separator: \" \") {\n        acc.append(parse_nested_parens_inner(group:\
    \ group))\n    }\n    return acc", "  let nested_parens = paren_string.components(separatedBy:\
    \ \" \")\n  var results = [Int]()\n  for parens in nested_parens {\n    results.append(parse_nested_parens_helper(parens:\
    \ parens))\n  }\n  return results", "    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    var n_levels: [Int] = []\n    for group in groups {\n        n_levels.append(parse_paren_group(paren_string:\
    \ group))\n    }\n    return n_levels", "  let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n  var paren_counts = [Int]()\n  for paren_group in paren_groups {\n\
    \    if paren_group.isEmpty {\n      paren_counts.append(0)\n      continue\n\
    \    }\n    var count = 0\n    var max_count = 0\n    for char in paren_group\
    \ {\n      if char == \"(\" {\n        count += 1\n      } else if char == \"\
    )\" {\n        count -= 1\n      }\n      if count > max_count {\n        max_count\
    \ = count\n      }\n    }\n    paren_counts.append(max_count)\n  }\n  return paren_counts",
  "    let paren_groups = paren_string.components(separatedBy: \" \")\n    var max_depths\
    \ = [Int]()\n    for group in paren_groups {\n        var group_counter = 0\n\
    \        var group_max = 0\n        for paren in group {\n            if paren\
    \ == \"(\" {\n                group_counter += 1\n            } else if paren\
    \ == \")\" {\n                group_counter -= 1\n            }\n            if\
    \ group_counter > group_max {\n                group_max = group_counter\n   \
    \         }\n        }\n        max_depths.append(group_max)\n    }\n    return\
    \ max_depths", "    var levels = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        levels.append(parse_nested_parens_single(paren_string:\
    \ paren_group))\n    }\n    return levels", "    var result = [Int]()\n    let\
    \ groups = paren_string.split(separator: \" \")\n    for group in groups {\n \
    \       var max_depth = 0\n        var current_depth = 0\n        for c in group\
    \ {\n            if c == \"(\" {\n                current_depth += 1\n       \
    \     } else if c == \")\" {\n                if current_depth > max_depth {\n\
    \                    max_depth = current_depth\n                }\n          \
    \      current_depth -= 1\n            }\n        }\n        result.append(max_depth)\n\
    \    }\n    return result", "    var array = [Int]()\n    var stack = [Character]()\n\
    \    var depth = 0\n    var paren_string = paren_string\n    while !paren_string.isEmpty\
    \ {\n        var char = paren_string.removeFirst()\n        if char == \"(\" {\n\
    \            stack.append(char)\n            depth += 1\n        } else if char\
    \ == \")\" {\n            stack.removeLast()\n            if stack.isEmpty {\n\
    \                array.append(depth)\n                depth = 0\n            }\n\
    \        }\n    }\n    return array", "    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    var result = [Int]()\n    for group in groups {\n        let (_,\
    \ result_value) = parse_group(paren_string: group)\n        result.append(result_value)\n\
    \    }\n    return result", "    var levels = [Int]()\n    var max = 0\n    var\
    \ level = 0\n    for character in paren_string {\n        if character == \"(\"\
    \ {\n            level += 1\n            if level > max {\n                max\
    \ = level\n            }\n        } else if character == \")\" {\n           \
    \ level -= 1\n        } else if character == \" \" {\n            levels.append(max)\n\
    \            max = 0\n            level = 0\n        }\n    }\n    levels.append(max)\n\
    \    return levels", "    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    return paren_groups.map { (group) -> Int in\n        var level =\
    \ 0\n        var max_level = 0\n        for char in group {\n            if char\
    \ == \"(\" {\n                level += 1\n            } else if char == \")\"\
    \ {\n                level -= 1\n            }\n            max_level = max(max_level,\
    \ level)\n        }\n        return max_level\n    }", "    // TODO:\n    var\
    \ max_level = 0\n    var level = 0\n    var result = [Int]()\n    var prev = \"\
    \"\n    for paren in paren_string {\n        if paren == \"(\" {\n           \
    \ level += 1\n            if level > max_level {\n                max_level =\
    \ level\n            }\n        } else if paren == \")\" {\n            level\
    \ -= 1\n        } else if paren == \" \" {\n            if prev == \")\" {\n \
    \               result.append(max_level)\n                max_level = 0\n    \
    \            level = 0\n            }\n        }\n        prev = String(paren)\n\
    \    }\n    if level == 0 {\n        result.append(max_level)\n    }\n    return\
    \ result", "    let components = paren_string.components(separatedBy: \" \")\n\
    \    var paren_counts = [Int]()\n    for paren in components {\n        paren_counts.append(count_nested_parens(paren:\
    \ paren))\n    }\n    return paren_counts", "    var output = [Int]()\n    let\
    \ groups = paren_string.components(separatedBy: \" \")\n    for group in groups\
    \ {\n        var parens = [String]()\n        var chars = [Character](group)\n\
    \        for i in 0..<chars.count {\n            if chars[i] == \"(\" {\n    \
    \            parens.append(\"(\")\n            } else if chars[i] == \")\" {\n\
    \                parens.removeLast()\n            }\n        }\n        output.append(parens.count)\n\
    \    }\n    return output", "    // TODO: Write your code here\n    var res: [Int]\
    \ = []\n    let stringArr = paren_string.split(separator: \" \")\n    stringArr.forEach\
    \ { (paren) in\n        var count = 0\n        var max = 0\n        paren.forEach\
    \ { (char) in\n            if char == \"(\" {\n                count += 1\n  \
    \          } else {\n                count -= 1\n            }\n            max\
    \ = max > count ? max : count\n        }\n        res.append(max)\n    }\n   \
    \ return res", "    var result: [Int] = []\n    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in groups {\n        result.append(nested_parens(group:\
    \ group))\n    }\n    return result", "    // TODO: Implement me!\n    return\
    \ []", '    return paren_string.components(separatedBy: " ").map { return level_of_nesting(paren_string:
    $0) }', "    let paren_groups = paren_string.split(separator: \" \")\n    return\
    \ paren_groups.map { Int(parse_nested_parens_for_group(group: String($0))) }",
  "  var char_array = Array(paren_string)\n  var max_stack: [Int] = []\n  var max_level\
    \ = 0\n  var current_level = 0\n  for char in char_array {\n    if char == \"\
    (\" {\n      current_level += 1\n      if current_level > max_level {\n      \
    \  max_level = current_level\n      }\n    } else if char == \")\" {\n      current_level\
    \ -= 1\n      if current_level == 0 {\n        max_stack.append(max_level)\n \
    \       max_level = 0\n      }\n    }\n  }\n  return max_stack", "    var result\
    \ = [Int]()\n    let groups = paren_string.components(separatedBy: \" \")\n  \
    \  for group in groups {\n        result.append(parse_nested_parens_for_group(group:\
    \ group))\n    }\n    return result", "    var start_parens = 0\n    var depth\
    \ = 0\n    var max_depths = [Int]()\n    for char in paren_string {\n        if\
    \ char == \"(\" {\n            start_parens += 1\n            depth += 1\n   \
    \     } else if char == \")\" {\n            depth -= 1\n            if depth\
    \ == 0 {\n                max_depths.append(start_parens)\n                start_parens\
    \ = 0\n            }\n        } else if char == \" \" {\n            if depth\
    \ != 0 {\n                fatalError(\"ERROR: Unbalanced parentheses, or malformed\
    \ input.\")\n            }\n        }\n    }\n    return max_depths", "    let\
    \ groups = paren_string.components(separatedBy: \" \")\n    var results = [Int]()\n\
    \    for group in groups {\n        results.append(parsing(string: group))\n \
    \   }\n    return results", "    // Split the string into groups of parentheses\n\
    \    let groups = paren_string.components(separatedBy: \" \")\n    var result\
    \ = [Int]()\n    // Count the deepest level of nesting for each group\n    for\
    \ group in groups {\n        var counter = 0\n        var max = 0\n        for\
    \ character in group {\n            if character == \"(\" {\n                counter\
    \ += 1\n            } else if character == \")\" {\n                counter -=\
    \ 1\n            }\n            max = max > counter ? max : counter\n        }\n\
    \        result.append(max)\n    }\n    return result", '    return paren_string.components(separatedBy:
    " ").map({ parse_parens($0) })', '    return [""]', "    var paren_array = paren_string.components(separatedBy:\
    \ \" \")\n    var result = [Int]()\n    for i in 0..<paren_array.count {\n   \
    \     var stack = Stack<Character>()\n        for j in 0..<paren_array[i].count\
    \ {\n            let char = paren_array[i][j]\n            if char == \"(\" {\n\
    \                stack.push(char)\n            } else if char == \")\" {\n   \
    \             stack.pop()\n            }\n        }\n        result.append(stack.count)\n\
    \    }\n    return result", "    // This function parses the string to find the\
    \ nested parentheses, and return\n    // the max nesting level\n    //\n    //\
    \ Input: \"(()()) ((())) () ((())()())\",\n    // Output: [2, 3, 1, 3]\n    let\
    \ parenthesis_list = paren_string.components(separatedBy: \" \")\n    var max_nested\
    \ = [Int]()\n    for str in parenthesis_list {\n        var count = 0\n      \
    \  var max_count = 0\n        for char in str {\n            if char == \"(\"\
    \ {\n                count += 1\n            } else if char == \")\" {\n     \
    \           count -= 1\n            }\n            if count > max_count {\n  \
    \              max_count = count\n            }\n        }\n        max_nested.append(max_count)\n\
    \    }\n    return max_nested", "    var paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    var max_nesting_levels = [Int]()\n    for i in 0..<paren_groups.count\
    \ {\n        var temp_nesting_level = 0\n        var max_nesting_level = 0\n \
    \       for j in 0..<paren_groups[i].count {\n            let current_char = paren_groups[i][j]\n\
    \            if current_char == \"(\" {\n                temp_nesting_level +=\
    \ 1\n            } else if current_char == \")\" {\n                temp_nesting_level\
    \ -= 1\n            }\n            if temp_nesting_level > max_nesting_level {\n\
    \                max_nesting_level = temp_nesting_level\n            }\n     \
    \   }\n        max_nesting_levels.append(max_nesting_level)\n    }\n    return\
    \ max_nesting_levels", "    return paren_string.components(separatedBy: \" \"\
    ).map { paren_string in\n        if let number = Int(paren_string) {\n       \
    \     return number\n        } else {\n            return paren_string.reduce((level:\
    \ 0, max_level: 0), { (acc, char) -> (Int, Int) in\n                if char ==\
    \ \"(\" {\n                    return (acc.level + 1, max(acc.max_level, acc.level\
    \ + 1))\n                } else {\n                    return (acc.level - 1,\
    \ acc.max_level)\n                }\n            }).max_level\n        }\n   \
    \ }", "    let paren_list = paren_string.components(separatedBy: \" \")\n    var\
    \ paren_level_list = [Int]()\n    for paren in paren_list {\n        paren_level_list.append(determine_nested_paren_level(paren:\
    \ paren))\n    }\n    return paren_level_list", "    let paren_groups = paren_string.split(separator:\
    \ \" \")\n    var output: [Int] = []\n    for paren_group in paren_groups {\n\
    \        output.append(parse_nested_parens_single_group(paren_group: paren_group))\n\
    \    }\n    return output", "    let groups = paren_string.split(separator: \"\
    \ \")\n    var max_levels: [Int] = []\n    for group in groups {\n        max_levels.append(get_max_nesting_level(group:\
    \ group))\n    }\n    return max_levels", "    var stack: [Int] = []\n    var\
    \ max_level: Int = 0\n    var level: Int = 0\n    var result: [Int] = []\n   \
    \ for char in paren_string {\n        switch char {\n        case \"(\":\n   \
    \         level += 1\n            max_level = max(max_level, level)\n        \
    \    stack.append(max_level)\n        case \")\":\n            stack.popLast()\n\
    \            level -= 1\n        case \" \":\n            result.append(max_level)\n\
    \            max_level = 0\n        default:\n            break\n        }\n \
    \   }\n    result.append(max_level)\n    return result", "    var output = [Int]()\n\
    \    let groups = paren_string.components(separatedBy: \" \")\n    for group in\
    \ groups {\n        if group.isEmpty {\n            output.append(0)\n       \
    \     continue\n        }\n        var max_depth = 0\n        var curr_depth =\
    \ 0\n        for char in group {\n            if char == \"(\" {\n           \
    \     curr_depth += 1\n                if curr_depth > max_depth {\n         \
    \           max_depth = curr_depth\n                }\n            } else if char\
    \ == \")\" {\n                curr_depth -= 1\n            }\n        }\n    \
    \    output.append(max_depth)\n    }\n    return output", "    var nest_levels\
    \ = [Int]()\n    var nest_count = 0\n    var nest_max = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            nest_count += 1\n            if nest_count\
    \ > nest_max {\n                nest_max = nest_count\n            }\n       \
    \ } else if char == \")\" {\n            nest_count -= 1\n        } else if char\
    \ == \" \" {\n            nest_levels.append(nest_max)\n            nest_max =\
    \ 0\n            nest_count = 0\n        }\n    }\n    return nest_levels", " \
    \   let groups = paren_string.components(separatedBy: \" \")\n    var parse_results\
    \ = [Int]()\n    for group in groups {\n        parse_results.append(parse_nested_parens_group(group:\
    \ group))\n    }\n    return parse_results", "    let split_groups = paren_string.split(separator:\
    \ \" \")\n    var ret = [Int]()\n    for (index, char) in split_groups.enumerated()\
    \ {\n        print(\"Char: \\(char)\")\n        var max_level = 0\n        var\
    \ curr_level = 0\n        for (_, paren) in char.enumerated() {\n            if\
    \ paren == \"(\" {\n                curr_level += 1\n                if curr_level\
    \ > max_level {\n                    max_level = curr_level\n                }\n\
    \            } else if paren == \")\" {\n                curr_level -= 1\n   \
    \         }\n        }\n        ret.append(max_level)\n    }\n    return ret",
  "    func get_deepest_level(group: String) -> Int {\n        var current_level =\
    \ 0\n        var max_level = 0\n        for char in group {\n            if char\
    \ == \"(\" {\n                current_level += 1\n                if current_level\
    \ > max_level {\n                    max_level = current_level\n             \
    \   }\n            } else if char == \")\" {\n                current_level -=\
    \ 1\n            }\n        }\n        return max_level\n    }\n    var groups\
    \ = paren_string.split(separator: \" \")\n    var result = [Int]()\n    for group\
    \ in groups {\n        result.append(get_deepest_level(group: String(group)))\n\
    \    }\n    return result", "    var output = [Int]()\n    for paren_group in\
    \ paren_string.split(separator: \" \") {\n        // state variables\n       \
    \ var isNested = false\n        var open_paren_count = 0\n        var max_depth\
    \ = 0\n        for c in paren_group {\n            if c == \"(\" {\n         \
    \       isNested = true\n                open_paren_count += 1\n             \
    \   max_depth = max(max_depth, open_paren_count)\n            } else if c == \"\
    )\" {\n                open_paren_count -= 1\n            }\n        }\n     \
    \   if isNested {\n            output.append(max_depth)\n        } else {\n  \
    \          output.append(0)\n        }\n    }\n    return output", "    var result\
    \ = [Int]()\n    var current_result = 0\n    var current_char_index = paren_string.startIndex\n\
    \    while current_char_index < paren_string.endIndex {\n        let current_char\
    \ = paren_string[current_char_index]\n        if current_char == \"(\" {\n   \
    \         current_result += 1\n        } else if current_char == \")\" {\n   \
    \         current_result -= 1\n        } else if current_char == \" \" {\n   \
    \         result.append(current_result)\n            current_result = 0\n    \
    \    }\n        current_char_index = paren_string.index(after: current_char_index)\n\
    \    }\n    result.append(current_result)\n    return result", "    var output\
    \ = [Int]()\n    var current_parens_level = 0\n    var max_parens_level = 0\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            current_parens_level\
    \ += 1\n            if current_parens_level > max_parens_level {\n           \
    \     max_parens_level = current_parens_level\n            }\n        } else if\
    \ char == \")\" {\n            current_parens_level -= 1\n        } else if char\
    \ == \" \" {\n            output.append(max_parens_level)\n            max_parens_level\
    \ = 0\n            current_parens_level = 0\n        }\n    }\n    output.append(max_parens_level)\n\
    \    return output", "    var parsed_list = [Int]()\n    let tokens = paren_string.split(separator:\
    \ \" \")\n    for token in tokens {\n        var max_depth = 0\n        var current_depth\
    \ = 0\n        for char in token {\n            if char == \"(\" {\n         \
    \       current_depth += 1\n                if current_depth > max_depth {\n \
    \                   max_depth = current_depth\n                }\n           \
    \ } else if char == \")\" {\n                current_depth -= 1\n            }\n\
    \        }\n        parsed_list.append(max_depth)\n    }\n    return parsed_list",
  "    let groups = paren_string.split(separator: \" \")\n    var max_depth_by_group\
    \ = [Int]()\n    var max_depth = 0\n    var current_depth = 0\n    for group in\
    \ groups {\n        max_depth = 0\n        current_depth = 0\n        for paren\
    \ in group {\n            if paren == \"(\" {\n                current_depth +=\
    \ 1\n            } else if paren == \")\" {\n                current_depth -=\
    \ 1\n            }\n            if current_depth > max_depth {\n             \
    \   max_depth = current_depth\n            }\n        }\n        max_depth_by_group.append(max_depth)\n\
    \    }\n    return max_depth_by_group", "    var max_depth = [Int]()\n    let\
    \ paren_groups = paren_string.components(separatedBy: \" \")\n    for group in\
    \ paren_groups {\n        var current_count = 0\n        var maximum_count = 0\n\
    \        for i in group.characters {\n            if i == \"(\" {\n          \
    \      current_count += 1\n            } else if i == \")\" {\n              \
    \  if current_count > maximum_count {\n                    maximum_count = current_count\n\
    \                }\n                current_count -= 1\n            }\n      \
    \  }\n        max_depth.append(maximum_count)\n    }\n    return max_depth", " \
    \   var group_depth = [Int]()\n    var group_string = \"\"\n    let paren_string_vec\
    \ = paren_string.split(separator: \" \")\n    for s in paren_string_vec {\n  \
    \      var depth = 0\n        var prev_depth = 0\n        for c in s {\n     \
    \       if c == \"(\" {\n                depth += 1\n            } else if c ==\
    \ \")\" {\n                depth -= 1\n            }\n            prev_depth =\
    \ max(prev_depth, depth)\n        }\n        group_depth.append(prev_depth)\n\
    \    }\n    return group_depth", "    let paren_groups = paren_string.split(separator:\
    \ \" \")\n    var depth_arr = [Int]()\n    for paren_group in paren_groups {\n\
    \        var depth = 0\n        var max_depth = 0\n        for paren in paren_group\
    \ {\n            if paren == \"(\" {\n                depth += 1\n           \
    \ } else if paren == \")\" {\n                depth -= 1\n            }\n    \
    \        if depth > max_depth {\n                max_depth = depth\n         \
    \   }\n        }\n        depth_arr.append(max_depth)\n    }\n    return depth_arr",
  "    var nested_parens: [Int] = []\n    var count: Int = 0\n    var tmp_count: Int\
    \ = 0\n    for ch in paren_string {\n        if ch == \"(\" {\n            count\
    \ += 1\n            tmp_count += 1\n        } else if ch == \")\" {\n        \
    \    count -= 1\n            tmp_count -= 1\n        } else if ch == \" \" {\n\
    \            if tmp_count > 0 {\n                nested_parens.append(tmp_count)\n\
    \            }\n            tmp_count = 0\n        }\n    }\n    return nested_parens",
  "    let paren_groups = paren_string.split(separator: \" \")\n    var paren_level_counters\
    \ = [Int]()\n    for group in paren_groups {\n        paren_level_counters.append(parse_nested_parens_helper(paren_str:\
    \ String(group)))\n    }\n    return paren_level_counters", '    return paren_string.components(separatedBy:
    " ").map { compute_nested_parens($0) }', "    var stack = [Int]()\n    var max_depth\
    \ = 0\n    var paren_levels = [Int]()\n    var paren_count = 0\n    for (index,\
    \ paren) in paren_string.enumerated() {\n        if paren == \"(\" {\n       \
    \     paren_count += 1\n            stack.append(paren_count)\n            max_depth\
    \ = max(max_depth, paren_count)\n        } else if paren == \")\" {\n        \
    \    let removed_paren = stack.removeLast()\n            if removed_paren == paren_count\
    \ {\n                paren_levels.append(paren_count)\n                paren_count\
    \ = 0\n            }\n        } else if index == paren_string.count - 1 {\n  \
    \          paren_levels.append(max_depth)\n        }\n    }\n    return paren_levels",
  '    return parse_parens(paren_string: paren_string, open_paren: "(", close_paren:
    ")")', "    var paren_items = paren_string.components(separatedBy: \" \")\n  \
    \  return paren_items.map { parse_single_nested_parens(paren_string: $0) }", " \
    \   return paren_string.components(separatedBy: \" \").map { (parens) -> Int in\n\
    \        var stack = Stack<Character>()\n        var max_depth = 0\n        var\
    \ current_depth = 0\n        for char in parens {\n            if char == \"(\"\
    \ {\n                current_depth += 1\n                max_depth = max(max_depth,\
    \ current_depth)\n            } else if char == \")\" {\n                current_depth\
    \ -= 1\n            }\n        }\n        return max_depth\n    }", "  var stack:\
    \ [Int] = []\n  var count: Int = 0\n  var result: [Int] = []\n  let chars = paren_string.characters\n\
    \  for char in chars {\n    if char == \"(\" {\n      stack.append(1)\n      count\
    \ += 1\n    } else if char == \")\" {\n      stack.removeLast()\n      count -=\
    \ 1\n    } else if char == \" \" {\n      result.append(count)\n      count =\
    \ 0\n    }\n  }\n  return result", "    var parsed_nested_parens: [Int] = []\n\
    \    // Your code here\n    return parsed_nested_parens", "    let groups = paren_string.split(separator:\
    \ \" \")\n    return groups.map { group in\n        var level = 0\n        var\
    \ max_level = 0\n        for c in group {\n            if c == \"(\" {\n     \
    \           level += 1\n            } else if c == \")\" {\n                level\
    \ -= 1\n            }\n            max_level = max(max_level, level)\n       \
    \ }\n        return max_level\n    }", "    let groups = paren_string.split(separator:\
    \ \" \")\n    var nested_levels = [Int]()\n    for group in groups {\n       \
    \ nested_levels.append(get_deepest_nested_level(group))\n    }\n    return nested_levels",
  "    return paren_string.components(separatedBy: \" \").map { paren_string in\n\
    \        var depth = 0\n        var max_depth = 0\n        for i in paren_string\
    \ {\n            if i == \"(\" {\n                depth += 1\n            } else\
    \ if i == \")\" {\n                depth -= 1\n            }\n            max_depth\
    \ = max(max_depth, depth)\n        }\n        return max_depth\n    }", "    let\
    \ paren_groups = paren_string.components(separatedBy: \" \")\n    var paren_level\
    \ = [Int]()\n    for paren in paren_groups {\n        var open_count = 0\n   \
    \     var level = 0\n        for char in paren {\n            if char == \"(\"\
    \ {\n                open_count += 1\n                level = max(level, open_count)\n\
    \            } else if char == \")\" {\n                open_count -= 1\n    \
    \        }\n        }\n        paren_level.append(level)\n    }\n    return paren_level",
  "    /// Converts a string representation of an expression to a vector of parenthesized\
    \ groups.\n    /// e.g. \"(()()) ((())) () ((())()())\" -> [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n    func get_paren_groups(paren_string: String) ->\
    \ [String] {\n        var paren_groups: [String] = []\n        var paren_string\
    \ = paren_string.replacingOccurrences(of: \" \", with: \"\")\n        while paren_string.count\
    \ > 0 {\n            if let idx = paren_string.firstIndex(of: \")\") {\n     \
    \           let right_substr = paren_string[...idx]\n                paren_string\
    \ = String(paren_string[idx...])\n                paren_string.removeFirst()\n\
    \                if let idx = right_substr.lastIndex(of: \"(\") {\n          \
    \          let left_substr = right_substr[...idx]\n                    paren_groups.append(String(left_substr))\n\
    \                }\n            }\n        }\n        return paren_groups\n  \
    \  }\n    \n    /// Calculates the level of nesting for a string containing a\
    \ single group of nested parentheses.\n    /// e.g. \"(()())\" -> 3\n    func\
    \ get_nested_parens_level(paren_group: String) -> Int {\n        var level: Int\
    \ = 0\n        var max_level: Int = 0\n        for char in paren_group {\n   \
    \         if char == \"(\" {\n                level += 1\n            } else if\
    \ char == \")\" {\n                if level > max_level {\n                  \
    \  max_level = level\n                }\n                level -= 1\n        \
    \    }\n        }\n        return max_level\n    }\n    \n    let paren_groups\
    \ = get_paren_groups(paren_string: paren_string)\n    var nested_parens_levels:\
    \ [Int] = []\n    for paren_group in paren_groups {\n        nested_parens_levels.append(get_nested_parens_level(paren_group:\
    \ paren_group))\n    }\n    return nested_parens_levels", "    let paren_string_array\
    \ = paren_string.split(separator: \" \")\n    var maximum_nested_levels = [Int]()\n\
    \    for paren_group in paren_string_array {\n        maximum_nested_levels.append(calculate_max_nested_paren_level(paren_group:\
    \ paren_group))\n    }\n    return maximum_nested_levels", "    var pairs = [(Int,\
    \ Int)]()\n    var paren_vec = [Character]()\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            paren_vec.append(char)\n        } else\
    \ if char == \")\" {\n            if paren_vec.count > 0 {\n                paren_vec.removeLast()\n\
    \                pairs.append((paren_vec.count, paren_vec.count + 1))\n      \
    \      }\n        }\n    }\n    var result = [Int]()\n    for pair in pairs {\n\
    \        result.append(pair.1 - pair.0)\n    }\n    return result", '    return
    paren_string.components(separatedBy: " ").map(paren_to_level_of_nesting)', " \
    \ let length = paren_string.count\n  var output = [Int]()\n  var index = 0\n \
    \ while index < length {\n    var stack = Stack<Character>()\n    var depth =\
    \ 0\n    var local_index = index\n    while local_index < length {\n      let\
    \ char = paren_string[paren_string.index(paren_string.startIndex, offsetBy: local_index)]\n\
    \      if char == \"(\" {\n        stack.push(item: char)\n        depth += 1\n\
    \      } else if char == \")\" {\n        stack.pop()\n        depth -= 1\n  \
    \    } else if char == \" \" {\n        if stack.isEmpty() {\n          index\
    \ = local_index + 1\n          break\n        }\n      }\n      local_index +=\
    \ 1\n    }\n    output.append(depth)\n  }\n  return output", "    \n    var max_depth_of_parens\
    \ = [Int]()\n    var temp_depth_of_parens = 0\n    var current_depth_of_parens\
    \ = 0\n    \n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_depth_of_parens += 1\n        } else if char == \")\" {\n   \
    \         current_depth_of_parens -= 1\n        } else if char == \" \" {\n  \
    \          temp_depth_of_parens = max(temp_depth_of_parens, current_depth_of_parens)\n\
    \            current_depth_of_parens = 0\n        }\n    }\n    \n    max_depth_of_parens.append(temp_depth_of_parens)\n\
    \    \n    return max_depth_of_parens", "    let paren_string_components = paren_string.components(separatedBy:\
    \ \" \")\n    var paren_string_array = [String]()\n    for str in paren_string_components\
    \ {\n        if str != \"\" {\n            paren_string_array.append(str)\n  \
    \      }\n    }\n    var levels_array = [Int]()\n    for paren_str in paren_string_array\
    \ {\n        levels_array.append(get_nested_parens_level(paren_str: paren_str))\n\
    \    }\n    return levels_array", "    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    var max_nesting_levels = [Int]()\n    for group in groups {\n  \
    \      var max_level = 0\n        var nesting_level = 0\n        for paren in\
    \ group {\n            if paren == \"(\" {\n                nesting_level += 1\n\
    \            } else if paren == \")\" {\n                nesting_level -= 1\n\
    \            }\n            if nesting_level > max_level {\n                max_level\
    \ = nesting_level\n            }\n        }\n        max_nesting_levels.append(max_level)\n\
    \    }\n    return max_nesting_levels", "    let group_strings = paren_string.split(separator:\
    \ \" \")\n    var max_levels = [Int]()\n    var level = 0\n    for group_string\
    \ in group_strings {\n        var l = 0\n        for c in group_string {\n   \
    \         if c == \"(\" {\n                l += 1\n            } else if c ==\
    \ \")\" {\n                l -= 1\n            }\n        }\n        max_levels.append(level)\n\
    \        level = l\n    }\n    return max_levels", "    var stack: [Character]\
    \ = []\n    var open_paren_count = 0\n    var results: [Int] = []\n    for char\
    \ in paren_string {\n        if char == \"(\" {\n            stack.append(char)\n\
    \            open_paren_count += 1\n        } else if char == \")\" {\n      \
    \      open_paren_count -= 1\n            stack.popLast()\n        } else if char\
    \ == \" \" && open_paren_count == 0 {\n            results.append(stack.count)\n\
    \        }\n    }\n    return results", "    var paren_groups = paren_string.split(separator:\
    \ \" \")\n    var max_nesting_levels = [Int]()\n    for group in paren_groups\
    \ {\n        let level = find_max_nesting_level(paren_string: String(group))\n\
    \        max_nesting_levels.append(level)\n    }\n    return max_nesting_levels",
  "    let paren_groups = paren_string.split(separator: \" \")\n    var results =\
    \ [Int]()\n    for group in paren_groups {\n        results.append(parse_nested_parens_helper(paren_group:\
    \ group))\n    }\n    return results", "    var max_nesting = [Int]()\n    for\
    \ paren in paren_string.split(separator: \" \") {\n        var count = 0\n   \
    \     var max_count = 0\n        for char in paren {\n            if char == \"\
    (\" {\n                count += 1\n            } else if char == \")\" {\n   \
    \             count -= 1\n            }\n            if count > max_count {\n\
    \                max_count = count\n            }\n        }\n        max_nesting.append(max_count)\n\
    \    }\n    return max_nesting", "    var current_max = 0\n    var max_values\
    \ = [Int]()\n    var paren_stack = [Character]()\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.append(char)\n      \
    \      current_max += 1\n        } else if char == \")\" {\n            paren_stack.popLast()\n\
    \            current_max -= 1\n        } else if char == \" \" {\n           \
    \ max_values.append(current_max)\n            current_max = 0\n        }\n   \
    \ }\n    return max_values", "    let groups = paren_string.split(separator: \"\
    \ \")\n    var parsed = [Int]()\n    for group in groups {\n        parsed.append(max_nesting_parens(group:\
    \ String(group)))\n    }\n    return parsed", "    // TODO: Implement parse_nested_parens\n\
    \    var groups = paren_string.components(separatedBy: \" \")\n    var answers\
    \ = [Int]()\n    var stack: Stack<Character> = Stack<Character>()\n    for i in\
    \ 0..<groups.count {\n        stack.clear()\n        var count = 0\n        var\
    \ max = 0\n        for x in groups[i] {\n            if x == \"(\" {\n       \
    \         stack.push(x)\n                count += 1\n                if count\
    \ > max {\n                    max = count\n                }\n            } else\
    \ if x == \")\" {\n                if let value = stack.pop() {\n            \
    \        if value == \"(\" {\n                        count -= 1\n           \
    \         }\n                }\n            }\n        }\n        answers.append(max)\n\
    \    }\n    return answers", "    var paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    var depths = [Int]()\n    for group in paren_groups {\n        depths.append(deepest_level_of_nesting(group:\
    \ group))\n    }\n    return depths", "    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    return groups.map { $0.parse_nested_parens() }", "    let groups\
    \ = paren_string.components(separatedBy: \" \")\n    return groups.map { group\
    \ in\n        count_nested_parens(paren_string: group)\n    }", "    var count_list\
    \ = [Int]()\n    var stack = Stack<Character>()\n    var temp_count = 0\n    for\
    \ c in paren_string {\n        if c == \"(\" {\n            stack.push(c)\n  \
    \          temp_count += 1\n        } else if c == \")\" {\n            stack.pop()\n\
    \            temp_count -= 1\n        } else if c == \" \" {\n            count_list.append(temp_count)\n\
    \            temp_count = 0\n        }\n    }\n    return count_list", "    let\
    \ groups = paren_string.split(separator: \" \")\n    var res = [Int]()\n    for\
    \ group in groups {\n        var current_max = 0\n        var n_in_paren = 0\n\
    \        for c in group {\n            if c == \"(\" {\n                n_in_paren\
    \ += 1\n                current_max = max(current_max, n_in_paren)\n         \
    \   } else if c == \")\" {\n                n_in_paren -= 1\n            }\n \
    \       }\n        res.append(current_max)\n    }\n    return res", "    var paren_stack\
    \ = Stack<Character>()\n    var level_stack = Stack<Int>()\n    var level = 0\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            level\
    \ += 1\n            paren_stack.push(element: char)\n            level_stack.push(element:\
    \ level)\n        } else if char == \")\" {\n            level -= 1\n        \
    \    paren_stack.pop()\n            level_stack.pop()\n        }\n    }\n    return\
    \ level_stack.array", '    return paren_string.components(separatedBy: " ").map
    { $0.count_nested_parens() }', "    var depth = 0\n    var res = [Int]()\n   \
    \ var max_depth = 0\n    for c in paren_string {\n        if c == \"(\" {\n  \
    \          depth += 1\n            max_depth = max(max_depth, depth)\n       \
    \ } else if c == \")\" {\n            depth -= 1\n        } else if c == \" \"\
    \ {\n            res.append(max_depth)\n            max_depth = 0\n          \
    \  depth = 0\n        }\n    }\n    return res", "    let groups = paren_string.split(separator:\
    \ \" \")\n    var result: [Int] = []\n    for group in groups {\n        result.append(get_max_nesting_level(paren_string:\
    \ String(group)))\n    }\n    return result", "    var paren_levels = [Int]()\n\
    \    let group_strings = paren_string.split(separator: \" \")\n    for i in 0..<group_strings.count\
    \ {\n        var curr_max = 0\n        var curr_level = 0\n        let chars =\
    \ group_strings[i].characters\n        for c in chars {\n            if c == \"\
    (\" {\n                curr_level += 1\n                if curr_level > curr_max\
    \ {\n                    curr_max = curr_level\n                }\n          \
    \  } else if c == \")\" {\n                curr_level -= 1\n            }\n  \
    \      }\n        paren_levels.append(curr_max)\n    }\n    return paren_levels",
  "    \n    let groups = paren_string.split(separator: \" \")\n    var results: [Int]\
    \ = []\n    \n    for group in groups {\n        var max_stack = 0\n        var\
    \ current_stack = 0\n        \n        for letter in group {\n            if letter\
    \ == \"(\" {\n                current_stack += 1\n                if current_stack\
    \ > max_stack {\n                    max_stack = current_stack\n             \
    \   }\n            } else if letter == \")\" {\n                current_stack\
    \ -= 1\n            }\n        }\n        results.append(max_stack)\n    }\n \
    \   return results", '    return paren_string.split(separator: " ").map(max_depth_of_paren)',
  "    return paren_string.components(separatedBy: \" \").map({group -> Int in\n \
    \       return deepest_nesting_parens(paren_string: group)\n    })", "    let\
    \ paren_groups = paren_string.components(separatedBy: \" \")\n    var max_nested_levels\
    \ = [Int]()\n    for paren_group in paren_groups {\n        max_nested_levels.append(get_nested_parens_count(paren_string:\
    \ paren_group))\n    }\n    return max_nested_levels", "    var paren_stack =\
    \ [Character]()\n    var max_paren_level = 0\n    var current_paren_level = 0\n\
    \    var paren_level_list = [Int]()\n    for char in paren_string {\n        switch\
    \ char {\n        case \"(\":\n            paren_stack.append(char)\n        \
    \    current_paren_level += 1\n            if current_paren_level > max_paren_level\
    \ {\n                max_paren_level = current_paren_level\n            }\n  \
    \      case \")\":\n            if paren_stack.count == 0 {\n                //\
    \ Closing a paren without an opening paren: invalid\n                return []\n\
    \            }\n            if current_paren_level > 0 {\n                current_paren_level\
    \ -= 1\n            }\n            paren_stack.removeLast()\n        case \" \"\
    :\n            if paren_stack.count == 0 {\n                // Closing all open\
    \ parens before space: valid\n                paren_level_list.append(max_paren_level)\n\
    \                max_paren_level = 0\n                current_paren_level = 0\n\
    \            } else {\n                // Closing some parens before space: invalid\n\
    \                return []\n            }\n        default:\n            // Only\
    \ allowed chars are ( and )\n            return []\n        }\n    }\n    // Closing\
    \ all open parens before string end: valid\n    if paren_stack.count == 0 {\n\
    \        paren_level_list.append(max_paren_level)\n    }\n    return paren_level_list",
  "  let paren_groups = paren_string.split(separator: \" \")\n  var nested_parens:\
    \ [Int] = []\n  for paren_group in paren_groups {\n    let paren_counts = paren_group.split(separator:\
    \ \"(\")\n    let left_paren_count = paren_counts.count - 1\n    let closing_paren_count\
    \ = paren_counts.last?.count ?? 0\n    let open_paren_count = left_paren_count\
    \ - closing_paren_count\n    nested_parens.append(open_paren_count)\n  }\n  return\
    \ nested_parens", '    return paren_string.components(separatedBy: " ").map({
    get_max_nesting($0) })', '    return [2, 3, 1, 3]', "    let paren_list = paren_string.components(separatedBy:\
    \ \" \")\n    var max_depth = 0\n    var depth = 0\n    var curr_paren_list: [Int]\
    \ = []\n    for paren in paren_list {\n        for curr_paren in paren {\n   \
    \         switch curr_paren {\n            case \"(\":\n                depth\
    \ += 1\n            case \")\":\n                depth -= 1\n            default:\n\
    \                continue\n            }\n        }\n        if depth > max_depth\
    \ {\n            max_depth = depth\n        }\n        curr_paren_list.append(max_depth)\n\
    \        depth = 0\n    }\n    return curr_paren_list", "    return paren_string.components(separatedBy:\
    \ \" \").map {\n        var opened = 0\n        var max_opened = 0\n        for\
    \ c in $0 {\n            if c == \"(\" {\n                opened += 1\n      \
    \          max_opened = max(max_opened, opened)\n            } else if c == \"\
    )\" {\n                opened -= 1\n            }\n        }\n        return max_opened\n\
    \    }", "    return paren_string.split(separator: \" \").map { (paren_string)\
    \ -> Int in\n        var stack = Stack<Character>()\n        var max_depth = 0\n\
    \        var current_depth = 0\n        for paren in paren_string {\n        \
    \    if paren == \"(\" {\n                current_depth += 1\n               \
    \ max_depth = max(max_depth, current_depth)\n            } else if paren == \"\
    )\" {\n                current_depth -= 1\n            }\n        }\n        return\
    \ max_depth\n    }", "    var max_level_per_grp: [Int] = []\n    var level: Int\
    \ = 0\n    var grp_idx: Int = 0\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            level += 1\n        } else if char == \")\" {\n    \
    \        level -= 1\n        } else if char == \" \" {\n            max_level_per_grp.append(level)\n\
    \            level = 0\n            grp_idx += 1\n        }\n    }\n    max_level_per_grp.append(level)\n\
    \    return max_level_per_grp", "    var res: [Int] = []\n    for char in paren_string.characters\
    \ {\n        if char == \"(\" {\n            res.append(0)\n        } else if\
    \ char == \")\" {\n            res[res.count - 1] += 1\n        } else if char\
    \ == \" \" {\n            continue\n        } else {\n            print(\"Unexpected\
    \ character in the string\")\n        }\n    }\n    return res", "    \n    //\
    \ use a stack to keep track of parenthesis\n    var stack: [String] = []\n   \
    \ var result: [Int] = []\n    var current_max: Int = 0\n    \n    // loop through\
    \ each character in the string\n    for char in paren_string {\n        \n   \
    \     // if the character is a opening parenthesis\n        if char == \"(\" {\n\
    \            \n            // add it to the stack\n            stack.append(String(char))\n\
    \            \n            // and update the current_max\n            current_max\
    \ += 1\n            \n        } else if char == \")\" {\n            \n      \
    \      // once we reach a closing parenthesis, remove the last element in the\
    \ stack and update the current_max\n            stack.removeLast()\n         \
    \   current_max -= 1\n            \n            // if there is no more elements\
    \ in the stack,\n            // we have reached the last parenthesis of a group\n\
    \            if stack.isEmpty {\n                \n                // append the\
    \ current_max to the result and reset it\n                result.append(current_max)\n\
    \                current_max = 0\n            }\n        }\n    }\n    \n    return\
    \ result", "    let paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    return paren_groups.map({ paren_group in\n        var max_nesting_level\
    \ = 0\n        var curr_nesting_level = 0\n        for char in paren_group {\n\
    \            if char == \"(\" {\n                curr_nesting_level += 1\n   \
    \         } else if char == \")\" {\n                curr_nesting_level -= 1\n\
    \            }\n            max_nesting_level = max(max_nesting_level, curr_nesting_level)\n\
    \        }\n        return max_nesting_level\n    })", "    var result = [Int]()\n\
    \    let split = paren_string.split(separator: \" \")\n    for s in split {\n\
    \        result.append(parse_nested_parens_in_string(s: String(s)))\n    }\n \
    \   return result", "    let groups = paren_string.split(separator: \" \")\n \
    \   var result = [Int]()\n    for group in groups {\n        var max_nesting =\
    \ 0\n        var current_nesting = 0\n        for paren in group {\n         \
    \   if paren == \"(\" {\n                current_nesting += 1\n            } else\
    \ if paren == \")\" {\n                current_nesting -= 1\n            }\n \
    \           if current_nesting > max_nesting {\n                max_nesting =\
    \ current_nesting\n            }\n        }\n        result.append(max_nesting)\n\
    \    }\n    return result", "    var output = [Int]()\n    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in groups {\n        var stack = [Character]()\n     \
    \   var maxDepth = 0\n        var currentDepth = 0\n        for char in group\
    \ {\n            if char == \"(\" {\n                stack.append(char)\n    \
    \            currentDepth += 1\n                if currentDepth > maxDepth {\n\
    \                    maxDepth = currentDepth\n                }\n            }\
    \ else if char == \")\" {\n                _ = stack.popLast()\n             \
    \   currentDepth -= 1\n            }\n        }\n        output.append(maxDepth)\n\
    \    }\n    return output", "    \n    let words = paren_string.split(separator:\
    \ \" \")\n    var nested_group = [Int]()\n    \n    for word in words {\n    \
    \    var stack = [Character]()\n        var max_nested = 0\n        var current_nested\
    \ = 0\n        \n        for char in word {\n            if char == \"(\" {\n\
    \                stack.append(char)\n                current_nested += 1\n   \
    \             if current_nested > max_nested {\n                    max_nested\
    \ = current_nested\n                }\n            } else if char == \")\" {\n\
    \                stack.popLast()\n                current_nested -= 1\n      \
    \      }\n        }\n        nested_group.append(max_nested)\n    }\n    return\
    \ nested_group", "    var result = [Int]()\n    for paren in paren_string.components(separatedBy:\
    \ \" \") {\n        result.append(parse_nested_parens(paren: paren))\n    }\n\
    \    return result", "    var stack: [Character] = []\n    var count: Int = 0\n\
    \    var result: [Int] = []\n    var maxCount: Int = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            stack.append(char)\n            count\
    \ += 1\n        } else if char == \")\" {\n            stack.removeLast()\n  \
    \          count -= 1\n        } else if char == \" \" {\n            result.append(count)\n\
    \            count = 0\n        }\n    }\n    if result.count > 0 {\n        maxCount\
    \ = result.max()!\n    }\n    return result"]
stop_tokens:
- "\n}"
